var y_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, g0 = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
 */
(function(s, l) {
  (function(a, m) {
    s.exports = m();
  })(y_, function() {
    var a = {}, m = {};
    function y(g, o, k) {
      if (m[g] = k, g === "index") {
        var D = "var sharedModule = {}; (" + m.shared + ")(sharedModule); (" + m.worker + ")(sharedModule);", L = {};
        return m.shared(L), m.index(a, L), typeof window < "u" && a.setWorkerUrl(window.URL.createObjectURL(new Blob([D], { type: "text/javascript" }))), a;
      }
    }
    y("shared", ["exports"], function(g) {
      function o(i, t, n, c) {
        return new (n || (n = Promise))(function(f, v) {
          function x(M) {
            try {
              T(c.next(M));
            } catch (R) {
              v(R);
            }
          }
          function E(M) {
            try {
              T(c.throw(M));
            } catch (R) {
              v(R);
            }
          }
          function T(M) {
            var R;
            M.done ? f(M.value) : (R = M.value, R instanceof n ? R : new n(function(U) {
              U(R);
            })).then(x, E);
          }
          T((c = c.apply(i, t || [])).next());
        });
      }
      function k(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var D = L;
      function L(i, t) {
        this.x = i, this.y = t;
      }
      L.prototype = { clone: function() {
        return new L(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, t) {
        return this.clone()._rotateAround(i, t);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var t = i.x - this.x, n = i.y - this.y;
        return t * t + n * n;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, t) {
        return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t);
      }, _matMult: function(i) {
        var t = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var t = Math.cos(i), n = Math.sin(i), c = n * this.x + t * this.y;
        return this.x = t * this.x - n * this.y, this.y = c, this;
      }, _rotateAround: function(i, t) {
        var n = Math.cos(i), c = Math.sin(i), f = t.y + c * (this.x - t.x) + n * (this.y - t.y);
        return this.x = t.x + n * (this.x - t.x) - c * (this.y - t.y), this.y = f, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, L.convert = function(i) {
        return i instanceof L ? i : Array.isArray(i) ? new L(i[0], i[1]) : i;
      };
      var j = k(D), O = z;
      function z(i, t, n, c) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (c - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = c;
      }
      z.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, c = 0; c < 8; c++) {
          var f = this.sampleCurveX(n) - i;
          if (Math.abs(f) < t) return n;
          var v = this.sampleCurveDerivativeX(n);
          if (Math.abs(v) < 1e-6) break;
          n -= f / v;
        }
        var x = 0, E = 1;
        for (n = i, c = 0; c < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - i) < t)); c++) i > f ? x = n : E = n, n = 0.5 * (E - x) + x;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var pe = k(O);
      let oe, ae;
      function Q() {
        return oe == null && (oe = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), oe;
      }
      function fe() {
        if (ae == null && (ae = !1, Q())) {
          const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (t) {
            for (let c = 0; c < 5 * 5; c++) {
              const f = 4 * c;
              t.fillStyle = `rgb(${f},${f + 1},${f + 2})`, t.fillRect(c % 5, Math.floor(c / 5), 1, 1);
            }
            const n = t.getImageData(0, 0, 5, 5).data;
            for (let c = 0; c < 5 * 5 * 4; c++) if (c % 4 != 3 && n[c] !== c) {
              ae = !0;
              break;
            }
          }
        }
        return ae || !1;
      }
      function Ce(i, t, n, c) {
        const f = new pe(i, t, n, c);
        return (v) => f.solve(v);
      }
      const ze = Ce(0.25, 0.1, 0.25, 1);
      function je(i, t, n) {
        return Math.min(n, Math.max(t, i));
      }
      function Qe(i, t, n) {
        const c = n - t, f = ((i - t) % c + c) % c + t;
        return f === t ? n : f;
      }
      function ke(i, ...t) {
        for (const n of t) for (const c in n) i[c] = n[c];
        return i;
      }
      let Ae = 1;
      function me(i, t, n) {
        const c = {};
        for (const f in i) c[f] = t.call(this, i[f], f, i);
        return c;
      }
      function ve(i, t, n) {
        const c = {};
        for (const f in i) t.call(this, i[f], f, i) && (c[f] = i[f]);
        return c;
      }
      function X(i) {
        return Array.isArray(i) ? i.map(X) : typeof i == "object" && i ? me(i, X) : i;
      }
      const re = {};
      function xe(i) {
        re[i] || (typeof console < "u" && console.warn(i), re[i] = !0);
      }
      function ye(i, t, n) {
        return (n.y - i.y) * (t.x - i.x) > (t.y - i.y) * (n.x - i.x);
      }
      function Ve(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let He = null;
      function Ze(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const qe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function Je(i, t, n, c, f) {
        return o(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const v = new VideoFrame(i, { timestamp: 0 });
          try {
            const x = v == null ? void 0 : v.format;
            if (!x || !x.startsWith("BGR") && !x.startsWith("RGB")) throw new Error(`Unrecognized format ${x}`);
            const E = x.startsWith("BGR"), T = new Uint8ClampedArray(c * f * 4);
            if (yield v.copyTo(T, function(M, R, U, H, J) {
              const ne = 4 * Math.max(-R, 0), he = (Math.max(0, U) - U) * H * 4 + ne, Se = 4 * H, Pe = Math.max(0, R), Xe = Math.max(0, U);
              return { rect: { x: Pe, y: Xe, width: Math.min(M.width, R + H) - Pe, height: Math.min(M.height, U + J) - Xe }, layout: [{ offset: he, stride: Se }] };
            }(i, t, n, c, f)), E) for (let M = 0; M < T.length; M += 4) {
              const R = T[M];
              T[M] = T[M + 2], T[M + 2] = R;
            }
            return T;
          } finally {
            v.close();
          }
        });
      }
      let et, st;
      const ee = "AbortError";
      function _e() {
        return new Error(ee);
      }
      const be = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Te(i) {
        return be.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const Oe = "global-dispatcher";
      class $e extends Error {
        constructor(t, n, c, f) {
          super(`AJAXError: ${n} (${t}): ${c}`), this.status = t, this.statusText = n, this.url = c, this.body = f;
        }
      }
      const Ue = () => Ve(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ke = function(i, t) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const c = Te(i.url);
          if (c) return c(i, t);
          if (Ve(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: Oe }, t);
        }
        if (!(/^file:/.test(n = i.url) || /^file:/.test(Ue()) && !/^\w+:/.test(n))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(c, f) {
            return o(this, void 0, void 0, function* () {
              const v = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, cache: c.cache, referrer: Ue(), signal: f.signal });
              c.type !== "json" || v.headers.has("Accept") || v.headers.set("Accept", "application/json");
              const x = yield fetch(v);
              if (!x.ok) {
                const M = yield x.blob();
                throw new $e(x.status, x.statusText, c.url, M);
              }
              let E;
              E = c.type === "arrayBuffer" || c.type === "image" ? x.arrayBuffer() : c.type === "json" ? x.json() : x.text();
              const T = yield E;
              if (f.signal.aborted) throw _e();
              return { data: T, cacheControl: x.headers.get("Cache-Control"), expires: x.headers.get("Expires") };
            });
          }(i, t);
          if (Ve(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: Oe }, t);
        }
        var n;
        return function(c, f) {
          return new Promise((v, x) => {
            var E;
            const T = new XMLHttpRequest();
            T.open(c.method || "GET", c.url, !0), c.type !== "arrayBuffer" && c.type !== "image" || (T.responseType = "arraybuffer");
            for (const M in c.headers) T.setRequestHeader(M, c.headers[M]);
            c.type === "json" && (T.responseType = "text", !((E = c.headers) === null || E === void 0) && E.Accept || T.setRequestHeader("Accept", "application/json")), T.withCredentials = c.credentials === "include", T.onerror = () => {
              x(new Error(T.statusText));
            }, T.onload = () => {
              if (!f.signal.aborted) if ((T.status >= 200 && T.status < 300 || T.status === 0) && T.response !== null) {
                let M = T.response;
                if (c.type === "json") try {
                  M = JSON.parse(T.response);
                } catch (R) {
                  return void x(R);
                }
                v({ data: M, cacheControl: T.getResponseHeader("Cache-Control"), expires: T.getResponseHeader("Expires") });
              } else {
                const M = new Blob([T.response], { type: T.getResponseHeader("Content-Type") });
                x(new $e(T.status, T.statusText, c.url, M));
              }
            }, f.signal.addEventListener("abort", () => {
              T.abort(), x(_e());
            }), T.send(c.body);
          });
        }(i, t);
      };
      function nt(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const t = new URL(i), n = window.location;
        return t.protocol === n.protocol && t.host === n.host;
      }
      function ot(i, t, n) {
        n[i] && n[i].indexOf(t) !== -1 || (n[i] = n[i] || [], n[i].push(t));
      }
      function vt(i, t, n) {
        if (n && n[i]) {
          const c = n[i].indexOf(t);
          c !== -1 && n[i].splice(c, 1);
        }
      }
      class mt {
        constructor(t, n = {}) {
          ke(this, n), this.type = t;
        }
      }
      class Pt extends mt {
        constructor(t, n = {}) {
          super("error", ke({ error: t }, n));
        }
      }
      class rt {
        on(t, n) {
          return this._listeners = this._listeners || {}, ot(t, n, this._listeners), this;
        }
        off(t, n) {
          return vt(t, n, this._listeners), vt(t, n, this._oneTimeListeners), this;
        }
        once(t, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ot(t, n, this._oneTimeListeners), this) : new Promise((c) => this.once(t, c));
        }
        fire(t, n) {
          typeof t == "string" && (t = new mt(t, n || {}));
          const c = t.type;
          if (this.listens(c)) {
            t.target = this;
            const f = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
            for (const E of f) E.call(this, t);
            const v = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
            for (const E of v) vt(c, E, this._oneTimeListeners), E.call(this, t);
            const x = this._eventedParent;
            x && (ke(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), x.fire(t));
          } else t instanceof Pt && console.error(t.error);
          return this;
        }
        listens(t) {
          return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
        }
        setEventedParent(t, n) {
          return this._eventedParent = t, this._eventedParentData = n, this;
        }
      }
      var Y = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const Kt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Rt(i, t) {
        const n = {};
        for (const c in i) c !== "ref" && (n[c] = i[c]);
        return Kt.forEach((c) => {
          c in t && (n[c] = t[c]);
        }), n;
      }
      function lt(i, t) {
        if (Array.isArray(i)) {
          if (!Array.isArray(t) || i.length !== t.length) return !1;
          for (let n = 0; n < i.length; n++) if (!lt(i[n], t[n])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && t !== null) {
          if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
          for (const n in i) if (!lt(i[n], t[n])) return !1;
          return !0;
        }
        return i === t;
      }
      function xt(i, t) {
        i.push(t);
      }
      function At(i, t, n) {
        xt(n, { command: "addSource", args: [i, t[i]] });
      }
      function Et(i, t, n) {
        xt(t, { command: "removeSource", args: [i] }), n[i] = !0;
      }
      function jt(i, t, n, c) {
        Et(i, n, c), At(i, t, n);
      }
      function ni(i, t, n) {
        let c;
        for (c in i[n]) if (Object.prototype.hasOwnProperty.call(i[n], c) && c !== "data" && !lt(i[n][c], t[n][c])) return !1;
        for (c in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], c) && c !== "data" && !lt(i[n][c], t[n][c])) return !1;
        return !0;
      }
      function ii(i, t, n, c, f, v) {
        i = i || {}, t = t || {};
        for (const x in i) Object.prototype.hasOwnProperty.call(i, x) && (lt(i[x], t[x]) || n.push({ command: v, args: [c, x, t[x], f] }));
        for (const x in t) Object.prototype.hasOwnProperty.call(t, x) && !Object.prototype.hasOwnProperty.call(i, x) && (lt(i[x], t[x]) || n.push({ command: v, args: [c, x, t[x], f] }));
      }
      function yi(i) {
        return i.id;
      }
      function xi(i, t) {
        return i[t.id] = t, i;
      }
      class pt {
        constructor(t, n, c, f) {
          this.message = (t ? `${t}: ` : "") + c, f && (this.identifier = f), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function Jt(i, ...t) {
        for (const n of t) for (const c in n) i[c] = n[c];
        return i;
      }
      class si extends Error {
        constructor(t, n) {
          super(n), this.message = n, this.key = t;
        }
      }
      class It {
        constructor(t, n = []) {
          this.parent = t, this.bindings = {};
          for (const [c, f] of n) this.bindings[c] = f;
        }
        concat(t) {
          return new It(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || !!this.parent && this.parent.has(t);
        }
      }
      const Zi = { kind: "null" }, ft = { kind: "number" }, ri = { kind: "string" }, Lt = { kind: "boolean" }, Si = { kind: "color" }, Gi = { kind: "object" }, zt = { kind: "value" }, cr = { kind: "collator" }, Ni = { kind: "formatted" }, ie = { kind: "padding" }, ue = { kind: "resolvedImage" }, $ = { kind: "variableAnchorOffsetCollection" };
      function B(i, t) {
        return { kind: "array", itemType: i, N: t };
      }
      function q(i) {
        if (i.kind === "array") {
          const t = q(i.itemType);
          return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`;
        }
        return i.kind;
      }
      const te = [Zi, ft, ri, Lt, Si, Ni, Gi, B(zt), ie, ue, $];
      function ge(i, t) {
        if (t.kind === "error") return null;
        if (i.kind === "array") {
          if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ge(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null;
        } else {
          if (i.kind === t.kind) return null;
          if (i.kind === "value") {
            for (const n of te) if (!ge(n, t)) return null;
          }
        }
        return `Expected ${q(i)} but found ${q(t)} instead.`;
      }
      function Me(i, t) {
        return t.some((n) => n.kind === i.kind);
      }
      function Fe(i, t) {
        return t.some((n) => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i);
      }
      function Ne(i, t) {
        return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind;
      }
      const De = 0.96422, tt = 0.82521, ut = 4 / 29, We = 6 / 29, gt = 3 * We * We, Mt = We * We * We, $t = Math.PI / 180, Qt = 180 / Math.PI;
      function ei(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function pi([i, t, n, c]) {
        let f, v;
        const x = Wi((0.2225045 * (i = fi(i)) + 0.7168786 * (t = fi(t)) + 0.0606169 * (n = fi(n))) / 1);
        i === t && t === n ? f = v = x : (f = Wi((0.4360747 * i + 0.3850649 * t + 0.1430804 * n) / De), v = Wi((0.0139322 * i + 0.0971045 * t + 0.7141733 * n) / tt));
        const E = 116 * x - 16;
        return [E < 0 ? 0 : E, 500 * (f - x), 200 * (x - v), c];
      }
      function fi(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Wi(i) {
        return i > Mt ? Math.pow(i, 1 / 3) : i / gt + ut;
      }
      function Oi([i, t, n, c]) {
        let f = (i + 16) / 116, v = isNaN(t) ? f : f + t / 500, x = isNaN(n) ? f : f - n / 200;
        return f = 1 * Bi(f), v = De * Bi(v), x = tt * Bi(x), [mi(3.1338561 * v - 1.6168667 * f - 0.4906146 * x), mi(-0.9787684 * v + 1.9161415 * f + 0.033454 * x), mi(0.0719453 * v - 0.2289914 * f + 1.4052427 * x), c];
      }
      function mi(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function Bi(i) {
        return i > We ? i * i * i : gt * (i - ut);
      }
      function Hi(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function gr(i, t) {
        return br(t ? i / 100 : i, 0, 1);
      }
      function br(i, t, n) {
        return Math.min(Math.max(t, i), n);
      }
      function Pr(i) {
        return !i.some(Number.isNaN);
      }
      const Vs = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class ji {
        constructor(t, n, c, f = 1, v = !0) {
          this.r = t, this.g = n, this.b = c, this.a = f, v || (this.r *= f, this.g *= f, this.b *= f, f || this.overwriteGetter("rgb", [t, n, c, f]));
        }
        static parse(t) {
          if (t instanceof ji) return t;
          if (typeof t != "string") return;
          const n = function(c) {
            if ((c = c.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const f = Vs[c];
            if (f) {
              const [x, E, T] = f;
              return [x / 255, E / 255, T / 255, 1];
            }
            if (c.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(c)) {
              const x = c.length < 6 ? 1 : 2;
              let E = 1;
              return [Hi(c.slice(E, E += x)), Hi(c.slice(E, E += x)), Hi(c.slice(E, E += x)), Hi(c.slice(E, E + x) || "ff")];
            }
            if (c.startsWith("rgb")) {
              const x = c.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (x) {
                const [E, T, M, R, U, H, J, ne, he, Se, Pe, Xe] = x, Be = [R || " ", J || " ", Se].join("");
                if (Be === "  " || Be === "  /" || Be === ",," || Be === ",,,") {
                  const Ge = [M, H, he].join(""), at = Ge === "%%%" ? 100 : Ge === "" ? 255 : 0;
                  if (at) {
                    const Ct = [br(+T / at, 0, 1), br(+U / at, 0, 1), br(+ne / at, 0, 1), Pe ? gr(+Pe, Xe) : 1];
                    if (Pr(Ct)) return Ct;
                  }
                }
                return;
              }
            }
            const v = c.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (v) {
              const [x, E, T, M, R, U, H, J, ne] = v, he = [T || " ", R || " ", H].join("");
              if (he === "  " || he === "  /" || he === ",," || he === ",,,") {
                const Se = [+E, br(+M, 0, 100), br(+U, 0, 100), J ? gr(+J, ne) : 1];
                if (Pr(Se)) return function([Pe, Xe, Be, Ge]) {
                  function at(Ct) {
                    const Bt = (Ct + Pe / 30) % 12, hi = Xe * Math.min(Be, 1 - Be);
                    return Be - hi * Math.max(-1, Math.min(Bt - 3, 9 - Bt, 1));
                  }
                  return Pe = ei(Pe), Xe /= 100, Be /= 100, [at(0), at(8), at(4), Ge];
                }(Se);
              }
            }
          }(t);
          return n ? new ji(...n, !1) : void 0;
        }
        get rgb() {
          const { r: t, g: n, b: c, a: f } = this, v = f || 1 / 0;
          return this.overwriteGetter("rgb", [t / v, n / v, c / v, f]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t) {
            const [n, c, f, v] = pi(t), x = Math.sqrt(c * c + f * f);
            return [Math.round(1e4 * x) ? ei(Math.atan2(f, c) * Qt) : NaN, x, n, v];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", pi(this.rgb));
        }
        overwriteGetter(t, n) {
          return Object.defineProperty(this, t, { value: n }), n;
        }
        toString() {
          const [t, n, c, f] = this.rgb;
          return `rgba(${[t, n, c].map((v) => Math.round(255 * v)).join(",")},${f})`;
        }
      }
      ji.black = new ji(0, 0, 0, 1), ji.white = new ji(1, 1, 1, 1), ji.transparent = new ji(0, 0, 0, 0), ji.red = new ji(1, 0, 0, 1);
      class Yo {
        constructor(t, n, c) {
          this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = c, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t, n) {
          return this.collator.compare(t, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class ca {
        constructor(t, n, c, f, v) {
          this.text = t, this.image = n, this.scale = c, this.fontStack = f, this.textColor = v;
        }
      }
      class Wr {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new Wr([new ca(t, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
        }
        static factory(t) {
          return t instanceof Wr ? t : Wr.fromString(t);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
        }
      }
      class on {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof on) return t;
          if (typeof t == "number") return new on([t, t, t, t]);
          if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
            for (const n of t) if (typeof n != "number") return;
            switch (t.length) {
              case 1:
                t = [t[0], t[0], t[0], t[0]];
                break;
              case 2:
                t = [t[0], t[1], t[0], t[1]];
                break;
              case 3:
                t = [t[0], t[1], t[2], t[1]];
            }
            return new on(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Jo = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class gn {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof gn) return t;
          if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
            for (let n = 0; n < t.length; n += 2) {
              const c = t[n], f = t[n + 1];
              if (typeof c != "string" || !Jo.has(c) || !Array.isArray(f) || f.length !== 2 || typeof f[0] != "number" || typeof f[1] != "number") return;
            }
            return new gn(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Xr {
        constructor(t) {
          this.name = t.name, this.available = t.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t) {
          return t ? new Xr({ name: t, available: !1 }) : null;
        }
      }
      function ha(i, t, n, c) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? c === void 0 || typeof c == "number" && c >= 0 && c <= 1 ? null : `Invalid rgba value [${[i, t, n, c].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof c == "number" ? [i, t, n, c] : [i, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function On(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof ji || i instanceof Yo || i instanceof Wr || i instanceof on || i instanceof gn || i instanceof Xr) return !0;
        if (Array.isArray(i)) {
          for (const t of i) if (!On(t)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const t in i) if (!On(i[t])) return !1;
          return !0;
        }
        return !1;
      }
      function xr(i) {
        if (i === null) return Zi;
        if (typeof i == "string") return ri;
        if (typeof i == "boolean") return Lt;
        if (typeof i == "number") return ft;
        if (i instanceof ji) return Si;
        if (i instanceof Yo) return cr;
        if (i instanceof Wr) return Ni;
        if (i instanceof on) return ie;
        if (i instanceof gn) return $;
        if (i instanceof Xr) return ue;
        if (Array.isArray(i)) {
          const t = i.length;
          let n;
          for (const c of i) {
            const f = xr(c);
            if (n) {
              if (n === f) continue;
              n = zt;
              break;
            }
            n = f;
          }
          return B(n || zt, t);
        }
        return Gi;
      }
      function rr(i) {
        const t = typeof i;
        return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof ji || i instanceof Wr || i instanceof on || i instanceof gn || i instanceof Xr ? i.toString() : JSON.stringify(i);
      }
      class _n {
        constructor(t, n) {
          this.type = t, this.value = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (!On(t[1])) return n.error("invalid value");
          const c = t[1];
          let f = xr(c);
          const v = n.expectedType;
          return f.kind !== "array" || f.N !== 0 || !v || v.kind !== "array" || typeof v.N == "number" && v.N !== 0 || (f = v), new _n(f, c);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class hr {
        constructor(t) {
          this.name = "ExpressionEvaluationError", this.message = t;
        }
        toJSON() {
          return this.message;
        }
      }
      const Na = { string: ri, number: ft, boolean: Lt, object: Gi };
      class ln {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          let c, f = 1;
          const v = t[0];
          if (v === "array") {
            let E, T;
            if (t.length > 2) {
              const M = t[1];
              if (typeof M != "string" || !(M in Na) || M === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              E = Na[M], f++;
            } else E = zt;
            if (t.length > 3) {
              if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
              T = t[2], f++;
            }
            c = B(E, T);
          } else {
            if (!Na[v]) throw new Error(`Types doesn't contain name = ${v}`);
            c = Na[v];
          }
          const x = [];
          for (; f < t.length; f++) {
            const E = n.parse(t[f], f, zt);
            if (!E) return null;
            x.push(E);
          }
          return new ln(c, x);
        }
        evaluate(t) {
          for (let n = 0; n < this.args.length; n++) {
            const c = this.args[n].evaluate(t);
            if (!ge(this.type, xr(c))) return c;
            if (n === this.args.length - 1) throw new hr(`Expected value to be of type ${q(this.type)}, but found ${q(xr(c))} instead.`);
          }
          throw new Error();
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const Ko = { "to-boolean": Lt, "to-color": Si, "to-number": ft, "to-string": ri };
      class Sr {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const c = t[0];
          if (!Ko[c]) throw new Error(`Can't parse ${c} as it is not part of the known types`);
          if ((c === "to-boolean" || c === "to-string") && t.length !== 2) return n.error("Expected one argument.");
          const f = Ko[c], v = [];
          for (let x = 1; x < t.length; x++) {
            const E = n.parse(t[x], x, zt);
            if (!E) return null;
            v.push(E);
          }
          return new Sr(f, v);
        }
        evaluate(t) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(t);
            case "color": {
              let n, c;
              for (const f of this.args) {
                if (n = f.evaluate(t), c = null, n instanceof ji) return n;
                if (typeof n == "string") {
                  const v = t.parseColor(n);
                  if (v) return v;
                } else if (Array.isArray(n) && (c = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : ha(n[0], n[1], n[2], n[3]), !c)) return new ji(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
              }
              throw new hr(c || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "padding": {
              let n;
              for (const c of this.args) {
                n = c.evaluate(t);
                const f = on.parse(n);
                if (f) return f;
              }
              throw new hr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let n;
              for (const c of this.args) {
                n = c.evaluate(t);
                const f = gn.parse(n);
                if (f) return f;
              }
              throw new hr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "number": {
              let n = null;
              for (const c of this.args) {
                if (n = c.evaluate(t), n === null) return 0;
                const f = Number(n);
                if (!isNaN(f)) return f;
              }
              throw new hr(`Could not convert ${JSON.stringify(n)} to number.`);
            }
            case "formatted":
              return Wr.fromString(rr(this.args[0].evaluate(t)));
            case "resolvedImage":
              return Xr.fromString(rr(this.args[0].evaluate(t)));
            default:
              return rr(this.args[0].evaluate(t));
          }
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const no = ["Unknown", "Point", "LineString", "Polygon"];
      class jr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? no[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t) {
          let n = this._parseColorCache[t];
          return n || (n = this._parseColorCache[t] = ji.parse(t)), n;
        }
      }
      class as {
        constructor(t, n, c = [], f, v = new It(), x = []) {
          this.registry = t, this.path = c, this.key = c.map((E) => `[${E}]`).join(""), this.scope = v, this.errors = x, this.expectedType = f, this._isConstant = n;
        }
        parse(t, n, c, f, v = {}) {
          return n ? this.concat(n, c, f)._parse(t, v) : this._parse(t, v);
        }
        _parse(t, n) {
          function c(f, v, x) {
            return x === "assert" ? new ln(v, [f]) : x === "coerce" ? new Sr(v, [f]) : f;
          }
          if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
            if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const f = t[0];
            if (typeof f != "string") return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const v = this.registry[f];
            if (v) {
              let x = v.parse(t, this);
              if (!x) return null;
              if (this.expectedType) {
                const E = this.expectedType, T = x.type;
                if (E.kind !== "string" && E.kind !== "number" && E.kind !== "boolean" && E.kind !== "object" && E.kind !== "array" || T.kind !== "value") if (E.kind !== "color" && E.kind !== "formatted" && E.kind !== "resolvedImage" || T.kind !== "value" && T.kind !== "string") if (E.kind !== "padding" || T.kind !== "value" && T.kind !== "number" && T.kind !== "array") if (E.kind !== "variableAnchorOffsetCollection" || T.kind !== "value" && T.kind !== "array") {
                  if (this.checkSubtype(E, T)) return null;
                } else x = c(x, E, n.typeAnnotation || "coerce");
                else x = c(x, E, n.typeAnnotation || "coerce");
                else x = c(x, E, n.typeAnnotation || "coerce");
                else x = c(x, E, n.typeAnnotation || "assert");
              }
              if (!(x instanceof _n) && x.type.kind !== "resolvedImage" && this._isConstant(x)) {
                const E = new jr();
                try {
                  x = new _n(x.type, x.evaluate(E));
                } catch (T) {
                  return this.error(T.message), null;
                }
              }
              return x;
            }
            return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
        }
        concat(t, n, c) {
          const f = typeof t == "number" ? this.path.concat(t) : this.path, v = c ? this.scope.concat(c) : this.scope;
          return new as(this.registry, this._isConstant, f, n || null, v, this.errors);
        }
        error(t, ...n) {
          const c = `${this.key}${n.map((f) => `[${f}]`).join("")}`;
          this.errors.push(new si(c, t));
        }
        checkSubtype(t, n) {
          const c = ge(t, n);
          return c && this.error(c), c;
        }
      }
      class os {
        constructor(t, n) {
          this.type = n.type, this.bindings = [].concat(t), this.result = n;
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const n of this.bindings) t(n[1]);
          t(this.result);
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
          const c = [];
          for (let v = 1; v < t.length - 1; v += 2) {
            const x = t[v];
            if (typeof x != "string") return n.error(`Expected string, but found ${typeof x} instead.`, v);
            if (/[^a-zA-Z0-9_]/.test(x)) return n.error("Variable names must contain only alphanumeric characters or '_'.", v);
            const E = n.parse(t[v + 1], v + 1);
            if (!E) return null;
            c.push([x, E]);
          }
          const f = n.parse(t[t.length - 1], t.length - 1, n.expectedType, c);
          return f ? new os(c, f) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Ri {
        constructor(t, n) {
          this.type = n.type, this.name = t, this.boundExpression = n;
        }
        static parse(t, n) {
          if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
          const c = t[1];
          return n.scope.has(c) ? new Ri(c, n.scope.get(c)) : n.error(`Unknown variable "${c}". Make sure "${c}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class so {
        constructor(t, n, c) {
          this.type = t, this.index = n, this.input = c;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const c = n.parse(t[1], 1, ft), f = n.parse(t[2], 2, B(n.expectedType || zt));
          return c && f ? new so(f.type.itemType, c, f) : null;
        }
        evaluate(t) {
          const n = this.index.evaluate(t), c = this.input.evaluate(t);
          if (n < 0) throw new hr(`Array index out of bounds: ${n} < 0.`);
          if (n >= c.length) throw new hr(`Array index out of bounds: ${n} > ${c.length - 1}.`);
          if (n !== Math.floor(n)) throw new hr(`Array index must be an integer, but found ${n} instead.`);
          return c[n];
        }
        eachChild(t) {
          t(this.index), t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Qo {
        constructor(t, n) {
          this.type = Lt, this.needle = t, this.haystack = n;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const c = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, zt);
          return c && f ? Me(c.type, [Lt, ri, ft, Zi, zt]) ? new Qo(c, f) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${q(c.type)} instead`) : null;
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), c = this.haystack.evaluate(t);
          if (!c) return !1;
          if (!Fe(n, ["boolean", "string", "number", "null"])) throw new hr(`Expected first argument to be of type boolean, string, number or null, but found ${q(xr(n))} instead.`);
          if (!Fe(c, ["string", "array"])) throw new hr(`Expected second argument to be of type array or string, but found ${q(xr(c))} instead.`);
          return c.indexOf(n) >= 0;
        }
        eachChild(t) {
          t(this.needle), t(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class $s {
        constructor(t, n, c) {
          this.type = ft, this.needle = t, this.haystack = n, this.fromIndex = c;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const c = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, zt);
          if (!c || !f) return null;
          if (!Me(c.type, [Lt, ri, ft, Zi, zt])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${q(c.type)} instead`);
          if (t.length === 4) {
            const v = n.parse(t[3], 3, ft);
            return v ? new $s(c, f, v) : null;
          }
          return new $s(c, f);
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), c = this.haystack.evaluate(t);
          if (!Fe(n, ["boolean", "string", "number", "null"])) throw new hr(`Expected first argument to be of type boolean, string, number or null, but found ${q(xr(n))} instead.`);
          let f;
          if (this.fromIndex && (f = this.fromIndex.evaluate(t)), Fe(c, ["string"])) {
            const v = c.indexOf(n, f);
            return v === -1 ? -1 : [...c.slice(0, v)].length;
          }
          if (Fe(c, ["array"])) return c.indexOf(n, f);
          throw new hr(`Expected second argument to be of type array or string, but found ${q(xr(c))} instead.`);
        }
        eachChild(t) {
          t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class el {
        constructor(t, n, c, f, v, x) {
          this.inputType = t, this.type = n, this.input = c, this.cases = f, this.outputs = v, this.otherwise = x;
        }
        static parse(t, n) {
          if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
          let c, f;
          n.expectedType && n.expectedType.kind !== "value" && (f = n.expectedType);
          const v = {}, x = [];
          for (let M = 2; M < t.length - 1; M += 2) {
            let R = t[M];
            const U = t[M + 1];
            Array.isArray(R) || (R = [R]);
            const H = n.concat(M);
            if (R.length === 0) return H.error("Expected at least one branch label.");
            for (const ne of R) {
              if (typeof ne != "number" && typeof ne != "string") return H.error("Branch labels must be numbers or strings.");
              if (typeof ne == "number" && Math.abs(ne) > Number.MAX_SAFE_INTEGER) return H.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof ne == "number" && Math.floor(ne) !== ne) return H.error("Numeric branch labels must be integer values.");
              if (c) {
                if (H.checkSubtype(c, xr(ne))) return null;
              } else c = xr(ne);
              if (v[String(ne)] !== void 0) return H.error("Branch labels must be unique.");
              v[String(ne)] = x.length;
            }
            const J = n.parse(U, M, f);
            if (!J) return null;
            f = f || J.type, x.push(J);
          }
          const E = n.parse(t[1], 1, zt);
          if (!E) return null;
          const T = n.parse(t[t.length - 1], t.length - 1, f);
          return T ? E.type.kind !== "value" && n.concat(1).checkSubtype(c, E.type) ? null : new el(c, f, E, v, x, T) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          return (xr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
        }
        eachChild(t) {
          t(this.input), this.outputs.forEach(t), t(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class da {
        constructor(t, n, c) {
          this.type = t, this.branches = n, this.otherwise = c;
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
          let c;
          n.expectedType && n.expectedType.kind !== "value" && (c = n.expectedType);
          const f = [];
          for (let x = 1; x < t.length - 1; x += 2) {
            const E = n.parse(t[x], x, Lt);
            if (!E) return null;
            const T = n.parse(t[x + 1], x + 1, c);
            if (!T) return null;
            f.push([E, T]), c = c || T.type;
          }
          const v = n.parse(t[t.length - 1], t.length - 1, c);
          if (!v) return null;
          if (!c) throw new Error("Can't infer output type");
          return new da(c, f, v);
        }
        evaluate(t) {
          for (const [n, c] of this.branches) if (n.evaluate(t)) return c.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [n, c] of this.branches) t(n), t(c);
          t(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class za {
        constructor(t, n, c, f) {
          this.type = t, this.input = n, this.beginIndex = c, this.endIndex = f;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const c = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, ft);
          if (!c || !f) return null;
          if (!Me(c.type, [B(zt), ri, zt])) return n.error(`Expected first argument to be of type array or string, but found ${q(c.type)} instead`);
          if (t.length === 4) {
            const v = n.parse(t[3], 3, ft);
            return v ? new za(c.type, c, f, v) : null;
          }
          return new za(c.type, c, f);
        }
        evaluate(t) {
          const n = this.input.evaluate(t), c = this.beginIndex.evaluate(t);
          let f;
          if (this.endIndex && (f = this.endIndex.evaluate(t)), Fe(n, ["string"])) return [...n].slice(c, f).join("");
          if (Fe(n, ["array"])) return n.slice(c, f);
          throw new hr(`Expected first argument to be of type array or string, but found ${q(xr(n))} instead.`);
        }
        eachChild(t) {
          t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function ao(i, t) {
        const n = i.length - 1;
        let c, f, v = 0, x = n, E = 0;
        for (; v <= x; ) if (E = Math.floor((v + x) / 2), c = i[E], f = i[E + 1], c <= t) {
          if (E === n || t < f) return E;
          v = E + 1;
        } else {
          if (!(c > t)) throw new hr("Input is not a number.");
          x = E - 1;
        }
        return 0;
      }
      class pa {
        constructor(t, n, c) {
          this.type = t, this.input = n, this.labels = [], this.outputs = [];
          for (const [f, v] of c) this.labels.push(f), this.outputs.push(v);
        }
        static parse(t, n) {
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          const c = n.parse(t[1], 1, ft);
          if (!c) return null;
          const f = [];
          let v = null;
          n.expectedType && n.expectedType.kind !== "value" && (v = n.expectedType);
          for (let x = 1; x < t.length; x += 2) {
            const E = x === 1 ? -1 / 0 : t[x], T = t[x + 1], M = x, R = x + 1;
            if (typeof E != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
            if (f.length && f[f.length - 1][0] >= E) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
            const U = n.parse(T, R, v);
            if (!U) return null;
            v = v || U.type, f.push([E, U]);
          }
          return new pa(v, c, f);
        }
        evaluate(t) {
          const n = this.labels, c = this.outputs;
          if (n.length === 1) return c[0].evaluate(t);
          const f = this.input.evaluate(t);
          if (f <= n[0]) return c[0].evaluate(t);
          const v = n.length;
          return f >= n[v - 1] ? c[v - 1].evaluate(t) : c[ao(n, f)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function As(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var oo = Fa;
      function Fa(i, t, n, c) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (c - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = c;
      }
      Fa.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, c = 0; c < 8; c++) {
          var f = this.sampleCurveX(n) - i;
          if (Math.abs(f) < t) return n;
          var v = this.sampleCurveDerivativeX(n);
          if (Math.abs(v) < 1e-6) break;
          n -= f / v;
        }
        var x = 0, E = 1;
        for (n = i, c = 0; c < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - i) < t)); c++) i > f ? x = n : E = n, n = 0.5 * (E - x) + x;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var Il = As(oo);
      function wr(i, t, n) {
        return i + n * (t - i);
      }
      function Ba(i, t, n) {
        return i.map((c, f) => wr(c, t[f], n));
      }
      const qr = { number: wr, color: function(i, t, n, c = "rgb") {
        switch (c) {
          case "rgb": {
            const [f, v, x, E] = Ba(i.rgb, t.rgb, n);
            return new ji(f, v, x, E, !1);
          }
          case "hcl": {
            const [f, v, x, E] = i.hcl, [T, M, R, U] = t.hcl;
            let H, J;
            if (isNaN(f) || isNaN(T)) isNaN(f) ? isNaN(T) ? H = NaN : (H = T, x !== 1 && x !== 0 || (J = M)) : (H = f, R !== 1 && R !== 0 || (J = v));
            else {
              let Xe = T - f;
              T > f && Xe > 180 ? Xe -= 360 : T < f && f - T > 180 && (Xe += 360), H = f + n * Xe;
            }
            const [ne, he, Se, Pe] = function([Xe, Be, Ge, at]) {
              return Xe = isNaN(Xe) ? 0 : Xe * $t, Oi([Ge, Math.cos(Xe) * Be, Math.sin(Xe) * Be, at]);
            }([H, J ?? wr(v, M, n), wr(x, R, n), wr(E, U, n)]);
            return new ji(ne, he, Se, Pe, !1);
          }
          case "lab": {
            const [f, v, x, E] = Oi(Ba(i.lab, t.lab, n));
            return new ji(f, v, x, E, !1);
          }
        }
      }, array: Ba, padding: function(i, t, n) {
        return new on(Ba(i.values, t.values, n));
      }, variableAnchorOffsetCollection: function(i, t, n) {
        const c = i.values, f = t.values;
        if (c.length !== f.length) throw new hr(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${t.toString()}`);
        const v = [];
        for (let x = 0; x < c.length; x += 2) {
          if (c[x] !== f[x]) throw new hr(`Cannot interpolate values containing mismatched anchors. from[${x}]: ${c[x]}, to[${x}]: ${f[x]}`);
          v.push(c[x]);
          const [E, T] = c[x + 1], [M, R] = f[x + 1];
          v.push([wr(E, M, n), wr(T, R, n)]);
        }
        return new gn(v);
      } };
      class ai {
        constructor(t, n, c, f, v) {
          this.type = t, this.operator = n, this.interpolation = c, this.input = f, this.labels = [], this.outputs = [];
          for (const [x, E] of v) this.labels.push(x), this.outputs.push(E);
        }
        static interpolationFactor(t, n, c, f) {
          let v = 0;
          if (t.name === "exponential") v = lo(n, t.base, c, f);
          else if (t.name === "linear") v = lo(n, 1, c, f);
          else if (t.name === "cubic-bezier") {
            const x = t.controlPoints;
            v = new Il(x[0], x[1], x[2], x[3]).solve(lo(n, 1, c, f));
          }
          return v;
        }
        static parse(t, n) {
          let [c, f, v, ...x] = t;
          if (!Array.isArray(f) || f.length === 0) return n.error("Expected an interpolation type expression.", 1);
          if (f[0] === "linear") f = { name: "linear" };
          else if (f[0] === "exponential") {
            const M = f[1];
            if (typeof M != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            f = { name: "exponential", base: M };
          } else {
            if (f[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
            {
              const M = f.slice(1);
              if (M.length !== 4 || M.some((R) => typeof R != "number" || R < 0 || R > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              f = { name: "cubic-bezier", controlPoints: M };
            }
          }
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          if (v = n.parse(v, 2, ft), !v) return null;
          const E = [];
          let T = null;
          c === "interpolate-hcl" || c === "interpolate-lab" ? T = Si : n.expectedType && n.expectedType.kind !== "value" && (T = n.expectedType);
          for (let M = 0; M < x.length; M += 2) {
            const R = x[M], U = x[M + 1], H = M + 3, J = M + 4;
            if (typeof R != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', H);
            if (E.length && E[E.length - 1][0] >= R) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', H);
            const ne = n.parse(U, J, T);
            if (!ne) return null;
            T = T || ne.type, E.push([R, ne]);
          }
          return Ne(T, ft) || Ne(T, Si) || Ne(T, ie) || Ne(T, $) || Ne(T, B(ft)) ? new ai(T, c, f, v, E) : n.error(`Type ${q(T)} is not interpolatable.`);
        }
        evaluate(t) {
          const n = this.labels, c = this.outputs;
          if (n.length === 1) return c[0].evaluate(t);
          const f = this.input.evaluate(t);
          if (f <= n[0]) return c[0].evaluate(t);
          const v = n.length;
          if (f >= n[v - 1]) return c[v - 1].evaluate(t);
          const x = ao(n, f), E = ai.interpolationFactor(this.interpolation, f, n[x], n[x + 1]), T = c[x].evaluate(t), M = c[x + 1].evaluate(t);
          switch (this.operator) {
            case "interpolate":
              return qr[this.type.kind](T, M, E);
            case "interpolate-hcl":
              return qr.color(T, M, E, "hcl");
            case "interpolate-lab":
              return qr.color(T, M, E, "lab");
          }
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function lo(i, t, n, c) {
        const f = c - n, v = i - n;
        return f === 0 ? 0 : t === 1 ? v / f : (Math.pow(t, v) - 1) / (Math.pow(t, f) - 1);
      }
      class uo {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expectected at least one argument.");
          let c = null;
          const f = n.expectedType;
          f && f.kind !== "value" && (c = f);
          const v = [];
          for (const E of t.slice(1)) {
            const T = n.parse(E, 1 + v.length, c, void 0, { typeAnnotation: "omit" });
            if (!T) return null;
            c = c || T.type, v.push(T);
          }
          if (!c) throw new Error("No output type");
          const x = f && v.some((E) => ge(f, E.type));
          return new uo(x ? zt : c, v);
        }
        evaluate(t) {
          let n, c = null, f = 0;
          for (const v of this.args) if (f++, c = v.evaluate(t), c && c instanceof Xr && !c.available && (n || (n = c.name), c = null, f === this.args.length && (c = n)), c !== null) break;
          return c;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function Tn(i, t) {
        return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
      }
      function tl(i, t, n, c) {
        return c.compare(t, n) === 0;
      }
      function Zs(i, t, n) {
        const c = i !== "==" && i !== "!=";
        return class _0 {
          constructor(v, x, E) {
            this.type = Lt, this.lhs = v, this.rhs = x, this.collator = E, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
          }
          static parse(v, x) {
            if (v.length !== 3 && v.length !== 4) return x.error("Expected two or three arguments.");
            const E = v[0];
            let T = x.parse(v[1], 1, zt);
            if (!T) return null;
            if (!Tn(E, T.type)) return x.concat(1).error(`"${E}" comparisons are not supported for type '${q(T.type)}'.`);
            let M = x.parse(v[2], 2, zt);
            if (!M) return null;
            if (!Tn(E, M.type)) return x.concat(2).error(`"${E}" comparisons are not supported for type '${q(M.type)}'.`);
            if (T.type.kind !== M.type.kind && T.type.kind !== "value" && M.type.kind !== "value") return x.error(`Cannot compare types '${q(T.type)}' and '${q(M.type)}'.`);
            c && (T.type.kind === "value" && M.type.kind !== "value" ? T = new ln(M.type, [T]) : T.type.kind !== "value" && M.type.kind === "value" && (M = new ln(T.type, [M])));
            let R = null;
            if (v.length === 4) {
              if (T.type.kind !== "string" && M.type.kind !== "string" && T.type.kind !== "value" && M.type.kind !== "value") return x.error("Cannot use collator to compare non-string types.");
              if (R = x.parse(v[3], 3, cr), !R) return null;
            }
            return new _0(T, M, R);
          }
          evaluate(v) {
            const x = this.lhs.evaluate(v), E = this.rhs.evaluate(v);
            if (c && this.hasUntypedArgument) {
              const T = xr(x), M = xr(E);
              if (T.kind !== M.kind || T.kind !== "string" && T.kind !== "number") throw new hr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${T.kind}, ${M.kind}) instead.`);
            }
            if (this.collator && !c && this.hasUntypedArgument) {
              const T = xr(x), M = xr(E);
              if (T.kind !== "string" || M.kind !== "string") return t(v, x, E);
            }
            return this.collator ? n(v, x, E, this.collator.evaluate(v)) : t(v, x, E);
          }
          eachChild(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const co = Zs("==", function(i, t, n) {
        return t === n;
      }, tl), ho = Zs("!=", function(i, t, n) {
        return t !== n;
      }, function(i, t, n, c) {
        return !tl(0, t, n, c);
      }), Pl = Zs("<", function(i, t, n) {
        return t < n;
      }, function(i, t, n, c) {
        return c.compare(t, n) < 0;
      }), au = Zs(">", function(i, t, n) {
        return t > n;
      }, function(i, t, n, c) {
        return c.compare(t, n) > 0;
      }), ou = Zs("<=", function(i, t, n) {
        return t <= n;
      }, function(i, t, n, c) {
        return c.compare(t, n) <= 0;
      }), po = Zs(">=", function(i, t, n) {
        return t >= n;
      }, function(i, t, n, c) {
        return c.compare(t, n) >= 0;
      });
      class ls {
        constructor(t, n, c) {
          this.type = cr, this.locale = c, this.caseSensitive = t, this.diacriticSensitive = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected one argument.");
          const c = t[1];
          if (typeof c != "object" || Array.isArray(c)) return n.error("Collator options argument must be an object.");
          const f = n.parse(c["case-sensitive"] !== void 0 && c["case-sensitive"], 1, Lt);
          if (!f) return null;
          const v = n.parse(c["diacritic-sensitive"] !== void 0 && c["diacritic-sensitive"], 1, Lt);
          if (!v) return null;
          let x = null;
          return c.locale && (x = n.parse(c.locale, 1, ri), !x) ? null : new ls(f, v, x);
        }
        evaluate(t) {
          return new Yo(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
        }
        eachChild(t) {
          t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ss {
        constructor(t, n, c, f, v) {
          this.type = ri, this.number = t, this.locale = n, this.currency = c, this.minFractionDigits = f, this.maxFractionDigits = v;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error("Expected two arguments.");
          const c = n.parse(t[1], 1, ft);
          if (!c) return null;
          const f = t[2];
          if (typeof f != "object" || Array.isArray(f)) return n.error("NumberFormat options argument must be an object.");
          let v = null;
          if (f.locale && (v = n.parse(f.locale, 1, ri), !v)) return null;
          let x = null;
          if (f.currency && (x = n.parse(f.currency, 1, ri), !x)) return null;
          let E = null;
          if (f["min-fraction-digits"] && (E = n.parse(f["min-fraction-digits"], 1, ft), !E)) return null;
          let T = null;
          return f["max-fraction-digits"] && (T = n.parse(f["max-fraction-digits"], 1, ft), !T) ? null : new Ss(c, v, x, E, T);
        }
        evaluate(t) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
        }
        eachChild(t) {
          t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class fo {
        constructor(t) {
          this.type = Ni, this.sections = t;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const c = t[1];
          if (!Array.isArray(c) && typeof c == "object") return n.error("First argument must be an image or text section.");
          const f = [];
          let v = !1;
          for (let x = 1; x <= t.length - 1; ++x) {
            const E = t[x];
            if (v && typeof E == "object" && !Array.isArray(E)) {
              v = !1;
              let T = null;
              if (E["font-scale"] && (T = n.parse(E["font-scale"], 1, ft), !T)) return null;
              let M = null;
              if (E["text-font"] && (M = n.parse(E["text-font"], 1, B(ri)), !M)) return null;
              let R = null;
              if (E["text-color"] && (R = n.parse(E["text-color"], 1, Si), !R)) return null;
              const U = f[f.length - 1];
              U.scale = T, U.font = M, U.textColor = R;
            } else {
              const T = n.parse(t[x], 1, zt);
              if (!T) return null;
              const M = T.type.kind;
              if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              v = !0, f.push({ content: T, scale: null, font: null, textColor: null });
            }
          }
          return new fo(f);
        }
        evaluate(t) {
          return new Wr(this.sections.map((n) => {
            const c = n.content.evaluate(t);
            return xr(c) === ue ? new ca("", c, null, null, null) : new ca(rr(c), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null);
          }));
        }
        eachChild(t) {
          for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Gs {
        constructor(t) {
          this.type = ue, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected two arguments.");
          const c = n.parse(t[1], 1, ri);
          return c ? new Gs(c) : n.error("No image name provided.");
        }
        evaluate(t) {
          const n = this.input.evaluate(t), c = Xr.fromString(n);
          return c && t.availableImages && (c.available = t.availableImages.indexOf(n) > -1), c;
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ra {
        constructor(t) {
          this.type = ft, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
          const c = n.parse(t[1], 1);
          return c ? c.type.kind !== "array" && c.type.kind !== "string" && c.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${q(c.type)} instead.`) : new Ra(c) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          if (typeof n == "string") return [...n].length;
          if (Array.isArray(n)) return n.length;
          throw new hr(`Expected value to be of type string or array, but found ${q(xr(n))} instead.`);
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const un = 8192;
      function Ll(i, t) {
        const n = (180 + i[0]) / 360, c = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, f = Math.pow(2, t.z);
        return [Math.round(n * f * un), Math.round(c * f * un)];
      }
      function mo(i, t) {
        const n = Math.pow(2, t.z);
        return [(f = (i[0] / un + t.x) / n, 360 * f - 180), (c = (i[1] / un + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90)];
        var c, f;
      }
      function Es(i, t) {
        i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1]);
      }
      function us(i, t) {
        return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3]);
      }
      function Di(i, t, n) {
        const c = i[0] - t[0], f = i[1] - t[1], v = i[0] - n[0], x = i[1] - n[1];
        return c * x - v * f == 0 && c * v <= 0 && f * x <= 0;
      }
      function cs(i, t, n, c) {
        return (f = [c[0] - n[0], c[1] - n[1]])[0] * (v = [t[0] - i[0], t[1] - i[1]])[1] - f[1] * v[0] != 0 && !(!Ml(i, t, n, c) || !Ml(n, c, i, t));
        var f, v;
      }
      function lu(i, t, n) {
        for (const c of n) for (let f = 0; f < c.length - 1; ++f) if (cs(i, t, c[f], c[f + 1])) return !0;
        return !1;
      }
      function kn(i, t, n = !1) {
        let c = !1;
        for (const E of t) for (let T = 0; T < E.length - 1; T++) {
          if (Di(i, E[T], E[T + 1])) return n;
          (v = E[T])[1] > (f = i)[1] != (x = E[T + 1])[1] > f[1] && f[0] < (x[0] - v[0]) * (f[1] - v[1]) / (x[1] - v[1]) + v[0] && (c = !c);
        }
        var f, v, x;
        return c;
      }
      function hs(i, t) {
        for (const n of t) if (kn(i, n)) return !0;
        return !1;
      }
      function go(i, t) {
        for (const n of i) if (!kn(n, t)) return !1;
        for (let n = 0; n < i.length - 1; ++n) if (lu(i[n], i[n + 1], t)) return !1;
        return !0;
      }
      function Oa(i, t) {
        for (const n of t) if (go(i, n)) return !0;
        return !1;
      }
      function Ml(i, t, n, c) {
        const f = c[0] - n[0], v = c[1] - n[1], x = (i[0] - n[0]) * v - f * (i[1] - n[1]), E = (t[0] - n[0]) * v - f * (t[1] - n[1]);
        return x > 0 && E < 0 || x < 0 && E > 0;
      }
      function fa(i, t, n) {
        const c = [];
        for (let f = 0; f < i.length; f++) {
          const v = [];
          for (let x = 0; x < i[f].length; x++) {
            const E = Ll(i[f][x], n);
            Es(t, E), v.push(E);
          }
          c.push(v);
        }
        return c;
      }
      function Nl(i, t, n) {
        const c = [];
        for (let f = 0; f < i.length; f++) {
          const v = fa(i[f], t, n);
          c.push(v);
        }
        return c;
      }
      function _o(i, t, n, c) {
        if (i[0] < n[0] || i[0] > n[2]) {
          const f = 0.5 * c;
          let v = i[0] - n[0] > f ? -c : n[0] - i[0] > f ? c : 0;
          v === 0 && (v = i[0] - n[2] > f ? -c : n[2] - i[0] > f ? c : 0), i[0] += v;
        }
        Es(t, i);
      }
      function yo(i, t, n, c) {
        const f = Math.pow(2, c.z) * un, v = [c.x * un, c.y * un], x = [];
        for (const E of i) for (const T of E) {
          const M = [T.x + v[0], T.y + v[1]];
          _o(M, t, n, f), x.push(M);
        }
        return x;
      }
      function il(i, t, n, c) {
        const f = Math.pow(2, c.z) * un, v = [c.x * un, c.y * un], x = [];
        for (const T of i) {
          const M = [];
          for (const R of T) {
            const U = [R.x + v[0], R.y + v[1]];
            Es(t, U), M.push(U);
          }
          x.push(M);
        }
        if (t[2] - t[0] <= f / 2) {
          (E = t)[0] = E[1] = 1 / 0, E[2] = E[3] = -1 / 0;
          for (const T of x) for (const M of T) _o(M, t, n, f);
        }
        var E;
        return x;
      }
      class jn {
        constructor(t, n) {
          this.type = Lt, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (On(t[1])) {
            const c = t[1];
            if (c.type === "FeatureCollection") {
              const f = [];
              for (const v of c.features) {
                const { type: x, coordinates: E } = v.geometry;
                x === "Polygon" && f.push(E), x === "MultiPolygon" && f.push(...E);
              }
              if (f.length) return new jn(c, { type: "MultiPolygon", coordinates: f });
            } else if (c.type === "Feature") {
              const f = c.geometry.type;
              if (f === "Polygon" || f === "MultiPolygon") return new jn(c, c.geometry);
            } else if (c.type === "Polygon" || c.type === "MultiPolygon") return new jn(c, c);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, c) {
              const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = n.canonicalID();
              if (c.type === "Polygon") {
                const E = fa(c.coordinates, v, x), T = yo(n.geometry(), f, v, x);
                if (!us(f, v)) return !1;
                for (const M of T) if (!kn(M, E)) return !1;
              }
              if (c.type === "MultiPolygon") {
                const E = Nl(c.coordinates, v, x), T = yo(n.geometry(), f, v, x);
                if (!us(f, v)) return !1;
                for (const M of T) if (!hs(M, E)) return !1;
              }
              return !0;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, c) {
              const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = n.canonicalID();
              if (c.type === "Polygon") {
                const E = fa(c.coordinates, v, x), T = il(n.geometry(), f, v, x);
                if (!us(f, v)) return !1;
                for (const M of T) if (!go(M, E)) return !1;
              }
              if (c.type === "MultiPolygon") {
                const E = Nl(c.coordinates, v, x), T = il(n.geometry(), f, v, x);
                if (!us(f, v)) return !1;
                for (const M of T) if (!Oa(M, E)) return !1;
              }
              return !0;
            }(t, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let vo = class {
        constructor(i = [], t = (n, c) => n < c ? -1 : n > c ? 1 : 0) {
          if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(i) {
          this.data.push(i), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], t = this.data.pop();
          return --this.length > 0 && (this.data[0] = t, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: t, compare: n } = this, c = t[i];
          for (; i > 0; ) {
            const f = i - 1 >> 1, v = t[f];
            if (n(c, v) >= 0) break;
            t[i] = v, i = f;
          }
          t[i] = c;
        }
        _down(i) {
          const { data: t, compare: n } = this, c = this.length >> 1, f = t[i];
          for (; i < c; ) {
            let v = 1 + (i << 1);
            const x = v + 1;
            if (x < this.length && n(t[x], t[v]) < 0 && (v = x), n(t[v], f) >= 0) break;
            t[i] = t[v], i = v;
          }
          t[i] = f;
        }
      };
      function rl(i, t, n, c, f) {
        nl(i, t, n, c || i.length - 1, f || bo);
      }
      function nl(i, t, n, c, f) {
        for (; c > n; ) {
          if (c - n > 600) {
            var v = c - n + 1, x = t - n + 1, E = Math.log(v), T = 0.5 * Math.exp(2 * E / 3), M = 0.5 * Math.sqrt(E * T * (v - T) / v) * (x - v / 2 < 0 ? -1 : 1);
            nl(i, t, Math.max(n, Math.floor(t - x * T / v + M)), Math.min(c, Math.floor(t + (v - x) * T / v + M)), f);
          }
          var R = i[t], U = n, H = c;
          for (ja(i, n, t), f(i[c], R) > 0 && ja(i, n, c); U < H; ) {
            for (ja(i, U, H), U++, H--; f(i[U], R) < 0; ) U++;
            for (; f(i[H], R) > 0; ) H--;
          }
          f(i[n], R) === 0 ? ja(i, n, H) : ja(i, ++H, c), H <= t && (n = H + 1), t <= H && (c = H - 1);
        }
      }
      function ja(i, t, n) {
        var c = i[t];
        i[t] = i[n], i[n] = c;
      }
      function bo(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function Cs(i, t) {
        if (i.length <= 1) return [i];
        const n = [];
        let c, f;
        for (const v of i) {
          const x = ma(v);
          x !== 0 && (v.area = Math.abs(x), f === void 0 && (f = x < 0), f === x < 0 ? (c && n.push(c), c = [v]) : c.push(v));
        }
        if (c && n.push(c), t > 1) for (let v = 0; v < n.length; v++) n[v].length <= t || (rl(n[v], t, 1, n[v].length - 1, sl), n[v] = n[v].slice(0, t));
        return n;
      }
      function sl(i, t) {
        return t.area - i.area;
      }
      function ma(i) {
        let t = 0;
        for (let n, c, f = 0, v = i.length, x = v - 1; f < v; x = f++) n = i[f], c = i[x], t += (c.x - n.x) * (n.y + c.y);
        return t;
      }
      const xo = 1 / 298.257223563, I = xo * (2 - xo), K = Math.PI / 180;
      class Ee {
        constructor(t) {
          const n = 6378.137 * K * 1e3, c = Math.cos(t * K), f = 1 / (1 - I * (1 - c * c)), v = Math.sqrt(f);
          this.kx = n * v * c, this.ky = n * v * f * (1 - I);
        }
        distance(t, n) {
          const c = this.wrap(t[0] - n[0]) * this.kx, f = (t[1] - n[1]) * this.ky;
          return Math.sqrt(c * c + f * f);
        }
        pointOnLine(t, n) {
          let c, f, v, x, E = 1 / 0;
          for (let T = 0; T < t.length - 1; T++) {
            let M = t[T][0], R = t[T][1], U = this.wrap(t[T + 1][0] - M) * this.kx, H = (t[T + 1][1] - R) * this.ky, J = 0;
            U === 0 && H === 0 || (J = (this.wrap(n[0] - M) * this.kx * U + (n[1] - R) * this.ky * H) / (U * U + H * H), J > 1 ? (M = t[T + 1][0], R = t[T + 1][1]) : J > 0 && (M += U / this.kx * J, R += H / this.ky * J)), U = this.wrap(n[0] - M) * this.kx, H = (n[1] - R) * this.ky;
            const ne = U * U + H * H;
            ne < E && (E = ne, c = M, f = R, v = T, x = J);
          }
          return { point: [c, f], index: v, t: Math.max(0, Math.min(1, x)) };
        }
        wrap(t) {
          for (; t < -180; ) t += 360;
          for (; t > 180; ) t -= 360;
          return t;
        }
      }
      function Re(i, t) {
        return t[0] - i[0];
      }
      function Ye(i) {
        return i[1] - i[0] + 1;
      }
      function ct(i, t) {
        return i[1] >= i[0] && i[1] < t;
      }
      function Dt(i, t) {
        if (i[0] > i[1]) return [null, null];
        const n = Ye(i);
        if (t) {
          if (n === 2) return [i, null];
          const f = Math.floor(n / 2);
          return [[i[0], i[0] + f], [i[0] + f, i[1]]];
        }
        if (n === 1) return [i, null];
        const c = Math.floor(n / 2) - 1;
        return [[i[0], i[0] + c], [i[0] + c + 1, i[1]]];
      }
      function Ut(i, t) {
        if (!ct(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let c = t[0]; c <= t[1]; ++c) Es(n, i[c]);
        return n;
      }
      function ui(i) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const n of i) for (const c of n) Es(t, c);
        return t;
      }
      function bi(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function Ci(i, t, n) {
        if (!bi(i) || !bi(t)) return NaN;
        let c = 0, f = 0;
        return i[2] < t[0] && (c = t[0] - i[2]), i[0] > t[2] && (c = i[0] - t[2]), i[1] > t[3] && (f = i[1] - t[3]), i[3] < t[1] && (f = t[1] - i[3]), n.distance([0, 0], [c, f]);
      }
      function Ii(i, t, n) {
        const c = n.pointOnLine(t, i);
        return n.distance(i, c.point);
      }
      function nr(i, t, n, c, f) {
        const v = Math.min(Ii(i, [n, c], f), Ii(t, [n, c], f)), x = Math.min(Ii(n, [i, t], f), Ii(c, [i, t], f));
        return Math.min(v, x);
      }
      function Er(i, t, n, c, f) {
        if (!ct(t, i.length) || !ct(c, n.length)) return 1 / 0;
        let v = 1 / 0;
        for (let x = t[0]; x < t[1]; ++x) {
          const E = i[x], T = i[x + 1];
          for (let M = c[0]; M < c[1]; ++M) {
            const R = n[M], U = n[M + 1];
            if (cs(E, T, R, U)) return 0;
            v = Math.min(v, nr(E, T, R, U, f));
          }
        }
        return v;
      }
      function Ti(i, t, n, c, f) {
        if (!ct(t, i.length) || !ct(c, n.length)) return NaN;
        let v = 1 / 0;
        for (let x = t[0]; x <= t[1]; ++x) for (let E = c[0]; E <= c[1]; ++E) if (v = Math.min(v, f.distance(i[x], n[E])), v === 0) return v;
        return v;
      }
      function Yr(i, t, n) {
        if (kn(i, t, !0)) return 0;
        let c = 1 / 0;
        for (const f of t) {
          const v = f[0], x = f[f.length - 1];
          if (v !== x && (c = Math.min(c, Ii(i, [x, v], n)), c === 0)) return c;
          const E = n.pointOnLine(f, i);
          if (c = Math.min(c, n.distance(i, E.point)), c === 0) return c;
        }
        return c;
      }
      function oi(i, t, n, c) {
        if (!ct(t, i.length)) return NaN;
        for (let v = t[0]; v <= t[1]; ++v) if (kn(i[v], n, !0)) return 0;
        let f = 1 / 0;
        for (let v = t[0]; v < t[1]; ++v) {
          const x = i[v], E = i[v + 1];
          for (const T of n) for (let M = 0, R = T.length, U = R - 1; M < R; U = M++) {
            const H = T[U], J = T[M];
            if (cs(x, E, H, J)) return 0;
            f = Math.min(f, nr(x, E, H, J, c));
          }
        }
        return f;
      }
      function yn(i, t) {
        for (const n of i) for (const c of n) if (kn(c, t, !0)) return !0;
        return !1;
      }
      function Mi(i, t, n, c = 1 / 0) {
        const f = ui(i), v = ui(t);
        if (c !== 1 / 0 && Ci(f, v, n) >= c) return c;
        if (us(f, v)) {
          if (yn(i, t)) return 0;
        } else if (yn(t, i)) return 0;
        let x = 1 / 0;
        for (const E of i) for (let T = 0, M = E.length, R = M - 1; T < M; R = T++) {
          const U = E[R], H = E[T];
          for (const J of t) for (let ne = 0, he = J.length, Se = he - 1; ne < he; Se = ne++) {
            const Pe = J[Se], Xe = J[ne];
            if (cs(U, H, Pe, Xe)) return 0;
            x = Math.min(x, nr(U, H, Pe, Xe, n));
          }
        }
        return x;
      }
      function zi(i, t, n, c, f, v) {
        if (!v) return;
        const x = Ci(Ut(c, v), f, n);
        x < t && i.push([x, v, [0, 0]]);
      }
      function Ts(i, t, n, c, f, v, x) {
        if (!v || !x) return;
        const E = Ci(Ut(c, v), Ut(f, x), n);
        E < t && i.push([E, v, x]);
      }
      function Hs(i, t, n, c, f = 1 / 0) {
        let v = Math.min(c.distance(i[0], n[0][0]), f);
        if (v === 0) return v;
        const x = new vo([[0, [0, i.length - 1], [0, 0]]], Re), E = ui(n);
        for (; x.length > 0; ) {
          const T = x.pop();
          if (T[0] >= v) continue;
          const M = T[1], R = t ? 50 : 100;
          if (Ye(M) <= R) {
            if (!ct(M, i.length)) return NaN;
            if (t) {
              const U = oi(i, M, n, c);
              if (isNaN(U) || U === 0) return U;
              v = Math.min(v, U);
            } else for (let U = M[0]; U <= M[1]; ++U) {
              const H = Yr(i[U], n, c);
              if (v = Math.min(v, H), v === 0) return 0;
            }
          } else {
            const U = Dt(M, t);
            zi(x, v, c, i, E, U[0]), zi(x, v, c, i, E, U[1]);
          }
        }
        return v;
      }
      function Ws(i, t, n, c, f, v = 1 / 0) {
        let x = Math.min(v, f.distance(i[0], n[0]));
        if (x === 0) return x;
        const E = new vo([[0, [0, i.length - 1], [0, n.length - 1]]], Re);
        for (; E.length > 0; ) {
          const T = E.pop();
          if (T[0] >= x) continue;
          const M = T[1], R = T[2], U = t ? 50 : 100, H = c ? 50 : 100;
          if (Ye(M) <= U && Ye(R) <= H) {
            if (!ct(M, i.length) && ct(R, n.length)) return NaN;
            let J;
            if (t && c) J = Er(i, M, n, R, f), x = Math.min(x, J);
            else if (t && !c) {
              const ne = i.slice(M[0], M[1] + 1);
              for (let he = R[0]; he <= R[1]; ++he) if (J = Ii(n[he], ne, f), x = Math.min(x, J), x === 0) return x;
            } else if (!t && c) {
              const ne = n.slice(R[0], R[1] + 1);
              for (let he = M[0]; he <= M[1]; ++he) if (J = Ii(i[he], ne, f), x = Math.min(x, J), x === 0) return x;
            } else J = Ti(i, M, n, R, f), x = Math.min(x, J);
          } else {
            const J = Dt(M, t), ne = Dt(R, c);
            Ts(E, x, f, i, n, J[0], ne[0]), Ts(E, x, f, i, n, J[0], ne[1]), Ts(E, x, f, i, n, J[1], ne[0]), Ts(E, x, f, i, n, J[1], ne[1]);
          }
        }
        return x;
      }
      function ga(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : i.type === "MultiLineString" ? i.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : i.type === "MultiPoint" ? i.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [i];
      }
      class ds {
        constructor(t, n) {
          this.type = ft, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (On(t[1])) {
            const c = t[1];
            if (c.type === "FeatureCollection") return new ds(c, c.features.map((f) => ga(f.geometry)).flat());
            if (c.type === "Feature") return new ds(c, ga(c.geometry));
            if ("type" in c && "coordinates" in c) return new ds(c, ga(c));
          }
          return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, c) {
              const f = n.geometry(), v = f.flat().map((T) => mo([T.x, T.y], n.canonical));
              if (f.length === 0) return NaN;
              const x = new Ee(v[0][1]);
              let E = 1 / 0;
              for (const T of c) {
                switch (T.type) {
                  case "Point":
                    E = Math.min(E, Ws(v, !1, [T.coordinates], !1, x, E));
                    break;
                  case "LineString":
                    E = Math.min(E, Ws(v, !1, T.coordinates, !0, x, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Hs(v, !1, T.coordinates, x, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, c) {
              const f = n.geometry(), v = f.flat().map((T) => mo([T.x, T.y], n.canonical));
              if (f.length === 0) return NaN;
              const x = new Ee(v[0][1]);
              let E = 1 / 0;
              for (const T of c) {
                switch (T.type) {
                  case "Point":
                    E = Math.min(E, Ws(v, !0, [T.coordinates], !1, x, E));
                    break;
                  case "LineString":
                    E = Math.min(E, Ws(v, !0, T.coordinates, !0, x, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Hs(v, !0, T.coordinates, x, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
            if (t.geometryType() === "Polygon") return function(n, c) {
              const f = n.geometry();
              if (f.length === 0 || f[0].length === 0) return NaN;
              const v = Cs(f, 0).map((T) => T.map((M) => M.map((R) => mo([R.x, R.y], n.canonical)))), x = new Ee(v[0][0][0][1]);
              let E = 1 / 0;
              for (const T of c) for (const M of v) {
                switch (T.type) {
                  case "Point":
                    E = Math.min(E, Hs([T.coordinates], !1, M, x, E));
                    break;
                  case "LineString":
                    E = Math.min(E, Hs(T.coordinates, !0, M, x, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Mi(M, T.coordinates, x, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const ks = { "==": co, "!=": ho, ">": au, "<": Pl, ">=": po, "<=": ou, array: ln, at: so, boolean: ln, case: da, coalesce: uo, collator: ls, format: fo, image: Gs, in: Qo, "index-of": $s, interpolate: ai, "interpolate-hcl": ai, "interpolate-lab": ai, length: Ra, let: os, literal: _n, match: el, number: ln, "number-format": Ss, object: ln, slice: za, step: pa, string: ln, "to-boolean": Sr, "to-color": Sr, "to-number": Sr, "to-string": Sr, var: Ri, within: jn, distance: ds };
      class Ur {
        constructor(t, n, c, f) {
          this.name = t, this.type = n, this._evaluate = c, this.args = f;
        }
        evaluate(t) {
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        static parse(t, n) {
          const c = t[0], f = Ur.definitions[c];
          if (!f) return n.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const v = Array.isArray(f) ? f[0] : f.type, x = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads, E = x.filter(([M]) => !Array.isArray(M) || M.length === t.length - 1);
          let T = null;
          for (const [M, R] of E) {
            T = new as(n.registry, Xs, n.path, null, n.scope);
            const U = [];
            let H = !1;
            for (let J = 1; J < t.length; J++) {
              const ne = t[J], he = Array.isArray(M) ? M[J - 1] : M.type, Se = T.parse(ne, 1 + U.length, he);
              if (!Se) {
                H = !0;
                break;
              }
              U.push(Se);
            }
            if (!H) if (Array.isArray(M) && M.length !== U.length) T.error(`Expected ${M.length} arguments, but found ${U.length} instead.`);
            else {
              for (let J = 0; J < U.length; J++) {
                const ne = Array.isArray(M) ? M[J] : M.type, he = U[J];
                T.concat(J + 1).checkSubtype(ne, he.type);
              }
              if (T.errors.length === 0) return new Ur(c, v, R, U);
            }
          }
          if (E.length === 1) n.errors.push(...T.errors);
          else {
            const M = (E.length ? E : x).map(([U]) => {
              return H = U, Array.isArray(H) ? `(${H.map(q).join(", ")})` : `(${q(H.type)}...)`;
              var H;
            }).join(" | "), R = [];
            for (let U = 1; U < t.length; U++) {
              const H = n.parse(t[U], 1 + R.length);
              if (!H) return null;
              R.push(q(H.type));
            }
            n.error(`Expected arguments of type ${M}, but found (${R.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t, n) {
          Ur.definitions = n;
          for (const c in n) t[c] = Ur;
        }
      }
      function Jr(i, [t, n, c, f]) {
        t = t.evaluate(i), n = n.evaluate(i), c = c.evaluate(i);
        const v = f ? f.evaluate(i) : 1, x = ha(t, n, c, v);
        if (x) throw new hr(x);
        return new ji(t / 255, n / 255, c / 255, v, !1);
      }
      function _a(i, t) {
        return i in t;
      }
      function ya(i, t) {
        const n = t[i];
        return n === void 0 ? null : n;
      }
      function qn(i) {
        return { type: i };
      }
      function Xs(i) {
        if (i instanceof Ri) return Xs(i.boundExpression);
        if (i instanceof Ur && i.name === "error" || i instanceof ls || i instanceof jn || i instanceof ds) return !1;
        const t = i instanceof Sr || i instanceof ln;
        let n = !0;
        return i.eachChild((c) => {
          n = t ? n && Xs(c) : n && c instanceof _n;
        }), !!n && Fr(i) && Ys(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function Fr(i) {
        if (i instanceof Ur && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof jn || i instanceof ds) return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !Fr(n) && (t = !1);
        }), t;
      }
      function va(i) {
        if (i instanceof Ur && i.name === "feature-state") return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !va(n) && (t = !1);
        }), t;
      }
      function Ys(i, t) {
        if (i instanceof Ur && t.indexOf(i.name) >= 0) return !1;
        let n = !0;
        return i.eachChild((c) => {
          n && !Ys(c, t) && (n = !1);
        }), n;
      }
      function qa(i) {
        return { result: "success", value: i };
      }
      function Kr(i) {
        return { result: "error", value: i };
      }
      function Ds(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function zl(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function al(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function ki(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function cn(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function ps(i) {
        return i;
      }
      function Js(i, t) {
        const n = t.type === "color", c = i.stops && typeof i.stops[0][0] == "object", f = c || !(c || i.property !== void 0), v = i.type || (al(t) ? "exponential" : "interval");
        if (n || t.type === "padding") {
          const R = n ? ji.parse : on.parse;
          (i = Jt({}, i)).stops && (i.stops = i.stops.map((U) => [U[0], R(U[1])])), i.default = R(i.default ? i.default : t.default);
        }
        if (i.colorSpace && (x = i.colorSpace) !== "rgb" && x !== "hcl" && x !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var x;
        let E, T, M;
        if (v === "exponential") E = Un;
        else if (v === "interval") E = Ks;
        else if (v === "categorical") {
          E = Is, T = /* @__PURE__ */ Object.create(null);
          for (const R of i.stops) T[R[0]] = R[1];
          M = typeof i.stops[0][0];
        } else {
          if (v !== "identity") throw new Error(`Unknown function type "${v}"`);
          E = Ua;
        }
        if (c) {
          const R = {}, U = [];
          for (let ne = 0; ne < i.stops.length; ne++) {
            const he = i.stops[ne], Se = he[0].zoom;
            R[Se] === void 0 && (R[Se] = { zoom: Se, type: i.type, property: i.property, default: i.default, stops: [] }, U.push(Se)), R[Se].stops.push([he[0].value, he[1]]);
          }
          const H = [];
          for (const ne of U) H.push([R[ne].zoom, Js(R[ne], t)]);
          const J = { name: "linear" };
          return { kind: "composite", interpolationType: J, interpolationFactor: ai.interpolationFactor.bind(void 0, J), zoomStops: H.map((ne) => ne[0]), evaluate: ({ zoom: ne }, he) => Un({ stops: H, base: i.base }, t, ne).evaluate(ne, he) };
        }
        if (f) {
          const R = v === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: R, interpolationFactor: ai.interpolationFactor.bind(void 0, R), zoomStops: i.stops.map((U) => U[0]), evaluate: ({ zoom: U }) => E(i, t, U, T, M) };
        }
        return { kind: "source", evaluate(R, U) {
          const H = U && U.properties ? U.properties[i.property] : void 0;
          return H === void 0 ? hn(i.default, t.default) : E(i, t, H, T, M);
        } };
      }
      function hn(i, t, n) {
        return i !== void 0 ? i : t !== void 0 ? t : n !== void 0 ? n : void 0;
      }
      function Is(i, t, n, c, f) {
        return hn(typeof n === f ? c[n] : void 0, i.default, t.default);
      }
      function Ks(i, t, n) {
        if (ki(n) !== "number") return hn(i.default, t.default);
        const c = i.stops.length;
        if (c === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[c - 1][0]) return i.stops[c - 1][1];
        const f = ao(i.stops.map((v) => v[0]), n);
        return i.stops[f][1];
      }
      function Un(i, t, n) {
        const c = i.base !== void 0 ? i.base : 1;
        if (ki(n) !== "number") return hn(i.default, t.default);
        const f = i.stops.length;
        if (f === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[f - 1][0]) return i.stops[f - 1][1];
        const v = ao(i.stops.map((R) => R[0]), n), x = function(R, U, H, J) {
          const ne = J - H, he = R - H;
          return ne === 0 ? 0 : U === 1 ? he / ne : (Math.pow(U, he) - 1) / (Math.pow(U, ne) - 1);
        }(n, c, i.stops[v][0], i.stops[v + 1][0]), E = i.stops[v][1], T = i.stops[v + 1][1], M = qr[t.type] || ps;
        return typeof E.evaluate == "function" ? { evaluate(...R) {
          const U = E.evaluate.apply(void 0, R), H = T.evaluate.apply(void 0, R);
          if (U !== void 0 && H !== void 0) return M(U, H, x, i.colorSpace);
        } } : M(E, T, x, i.colorSpace);
      }
      function Ua(i, t, n) {
        switch (t.type) {
          case "color":
            n = ji.parse(n);
            break;
          case "formatted":
            n = Wr.fromString(n.toString());
            break;
          case "resolvedImage":
            n = Xr.fromString(n.toString());
            break;
          case "padding":
            n = on.parse(n);
            break;
          default:
            ki(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
        }
        return hn(n, i.default, t.default);
      }
      Ur.register(ks, { error: [{ kind: "error" }, [ri], (i, [t]) => {
        throw new hr(t.evaluate(i));
      }], typeof: [ri, [zt], (i, [t]) => q(xr(t.evaluate(i)))], "to-rgba": [B(ft, 4), [Si], (i, [t]) => {
        const [n, c, f, v] = t.evaluate(i).rgb;
        return [255 * n, 255 * c, 255 * f, v];
      }], rgb: [Si, [ft, ft, ft], Jr], rgba: [Si, [ft, ft, ft, ft], Jr], has: { type: Lt, overloads: [[[ri], (i, [t]) => _a(t.evaluate(i), i.properties())], [[ri, Gi], (i, [t, n]) => _a(t.evaluate(i), n.evaluate(i))]] }, get: { type: zt, overloads: [[[ri], (i, [t]) => ya(t.evaluate(i), i.properties())], [[ri, Gi], (i, [t, n]) => ya(t.evaluate(i), n.evaluate(i))]] }, "feature-state": [zt, [ri], (i, [t]) => ya(t.evaluate(i), i.featureState || {})], properties: [Gi, [], (i) => i.properties()], "geometry-type": [ri, [], (i) => i.geometryType()], id: [zt, [], (i) => i.id()], zoom: [ft, [], (i) => i.globals.zoom], "heatmap-density": [ft, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [ft, [], (i) => i.globals.lineProgress || 0], accumulated: [zt, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [ft, qn(ft), (i, t) => {
        let n = 0;
        for (const c of t) n += c.evaluate(i);
        return n;
      }], "*": [ft, qn(ft), (i, t) => {
        let n = 1;
        for (const c of t) n *= c.evaluate(i);
        return n;
      }], "-": { type: ft, overloads: [[[ft, ft], (i, [t, n]) => t.evaluate(i) - n.evaluate(i)], [[ft], (i, [t]) => -t.evaluate(i)]] }, "/": [ft, [ft, ft], (i, [t, n]) => t.evaluate(i) / n.evaluate(i)], "%": [ft, [ft, ft], (i, [t, n]) => t.evaluate(i) % n.evaluate(i)], ln2: [ft, [], () => Math.LN2], pi: [ft, [], () => Math.PI], e: [ft, [], () => Math.E], "^": [ft, [ft, ft], (i, [t, n]) => Math.pow(t.evaluate(i), n.evaluate(i))], sqrt: [ft, [ft], (i, [t]) => Math.sqrt(t.evaluate(i))], log10: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10], ln: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i))], log2: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2], sin: [ft, [ft], (i, [t]) => Math.sin(t.evaluate(i))], cos: [ft, [ft], (i, [t]) => Math.cos(t.evaluate(i))], tan: [ft, [ft], (i, [t]) => Math.tan(t.evaluate(i))], asin: [ft, [ft], (i, [t]) => Math.asin(t.evaluate(i))], acos: [ft, [ft], (i, [t]) => Math.acos(t.evaluate(i))], atan: [ft, [ft], (i, [t]) => Math.atan(t.evaluate(i))], min: [ft, qn(ft), (i, t) => Math.min(...t.map((n) => n.evaluate(i)))], max: [ft, qn(ft), (i, t) => Math.max(...t.map((n) => n.evaluate(i)))], abs: [ft, [ft], (i, [t]) => Math.abs(t.evaluate(i))], round: [ft, [ft], (i, [t]) => {
        const n = t.evaluate(i);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [ft, [ft], (i, [t]) => Math.floor(t.evaluate(i))], ceil: [ft, [ft], (i, [t]) => Math.ceil(t.evaluate(i))], "filter-==": [Lt, [ri, zt], (i, [t, n]) => i.properties()[t.value] === n.value], "filter-id-==": [Lt, [zt], (i, [t]) => i.id() === t.value], "filter-type-==": [Lt, [ri], (i, [t]) => i.geometryType() === t.value], "filter-<": [Lt, [ri, zt], (i, [t, n]) => {
        const c = i.properties()[t.value], f = n.value;
        return typeof c == typeof f && c < f;
      }], "filter-id-<": [Lt, [zt], (i, [t]) => {
        const n = i.id(), c = t.value;
        return typeof n == typeof c && n < c;
      }], "filter->": [Lt, [ri, zt], (i, [t, n]) => {
        const c = i.properties()[t.value], f = n.value;
        return typeof c == typeof f && c > f;
      }], "filter-id->": [Lt, [zt], (i, [t]) => {
        const n = i.id(), c = t.value;
        return typeof n == typeof c && n > c;
      }], "filter-<=": [Lt, [ri, zt], (i, [t, n]) => {
        const c = i.properties()[t.value], f = n.value;
        return typeof c == typeof f && c <= f;
      }], "filter-id-<=": [Lt, [zt], (i, [t]) => {
        const n = i.id(), c = t.value;
        return typeof n == typeof c && n <= c;
      }], "filter->=": [Lt, [ri, zt], (i, [t, n]) => {
        const c = i.properties()[t.value], f = n.value;
        return typeof c == typeof f && c >= f;
      }], "filter-id->=": [Lt, [zt], (i, [t]) => {
        const n = i.id(), c = t.value;
        return typeof n == typeof c && n >= c;
      }], "filter-has": [Lt, [zt], (i, [t]) => t.value in i.properties()], "filter-has-id": [Lt, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [Lt, [B(ri)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [Lt, [B(zt)], (i, [t]) => t.value.indexOf(i.id()) >= 0], "filter-in-small": [Lt, [ri, B(zt)], (i, [t, n]) => n.value.indexOf(i.properties()[t.value]) >= 0], "filter-in-large": [Lt, [ri, B(zt)], (i, [t, n]) => function(c, f, v, x) {
        for (; v <= x; ) {
          const E = v + x >> 1;
          if (f[E] === c) return !0;
          f[E] > c ? x = E - 1 : v = E + 1;
        }
        return !1;
      }(i.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: Lt, overloads: [[[Lt, Lt], (i, [t, n]) => t.evaluate(i) && n.evaluate(i)], [qn(Lt), (i, t) => {
        for (const n of t) if (!n.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: Lt, overloads: [[[Lt, Lt], (i, [t, n]) => t.evaluate(i) || n.evaluate(i)], [qn(Lt), (i, t) => {
        for (const n of t) if (n.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [Lt, [Lt], (i, [t]) => !t.evaluate(i)], "is-supported-script": [Lt, [ri], (i, [t]) => {
        const n = i.globals && i.globals.isSupportedScript;
        return !n || n(t.evaluate(i));
      }], upcase: [ri, [ri], (i, [t]) => t.evaluate(i).toUpperCase()], downcase: [ri, [ri], (i, [t]) => t.evaluate(i).toLowerCase()], concat: [ri, qn(zt), (i, t) => t.map((n) => rr(n.evaluate(i))).join("")], "resolved-locale": [ri, [cr], (i, [t]) => t.evaluate(i).resolvedLocale()] });
      class ba {
        constructor(t, n) {
          var c;
          this.expression = t, this._warningHistory = {}, this._evaluator = new jr(), this._defaultValue = n ? (c = n).type === "color" && cn(c.default) ? new ji(0, 0, 0, 0) : c.type === "color" ? ji.parse(c.default) || null : c.type === "padding" ? on.parse(c.default) || null : c.type === "variableAnchorOffsetCollection" ? gn.parse(c.default) || null : c.default === void 0 ? null : c.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
        }
        evaluateWithoutErrorHandling(t, n, c, f, v, x) {
          return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = c, this._evaluator.canonical = f, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = x, this.expression.evaluate(this._evaluator);
        }
        evaluate(t, n, c, f, v, x) {
          this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = c || null, this._evaluator.canonical = f, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = x || null;
          try {
            const E = this.expression.evaluate(this._evaluator);
            if (E == null || typeof E == "number" && E != E) return this._defaultValue;
            if (this._enumValues && !(E in this._enumValues)) throw new hr(`Expected value to be one of ${Object.keys(this._enumValues).map((T) => JSON.stringify(T)).join(", ")}, but found ${JSON.stringify(E)} instead.`);
            return E;
          } catch (E) {
            return this._warningHistory[E.message] || (this._warningHistory[E.message] = !0, typeof console < "u" && console.warn(E.message)), this._defaultValue;
          }
        }
      }
      function fs(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in ks;
      }
      function Qr(i, t) {
        const n = new as(ks, Xs, [], t ? function(f) {
          const v = { color: Si, string: ri, number: ft, enum: ri, boolean: Lt, formatted: Ni, padding: ie, resolvedImage: ue, variableAnchorOffsetCollection: $ };
          return f.type === "array" ? B(v[f.value] || zt, f.length) : v[f.type];
        }(t) : void 0), c = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return c ? qa(new ba(c, t)) : Kr(n.errors);
      }
      class vn {
        constructor(t, n) {
          this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !va(n.expression);
        }
        evaluateWithoutErrorHandling(t, n, c, f, v, x) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, c, f, v, x);
        }
        evaluate(t, n, c, f, v, x) {
          return this._styleExpression.evaluate(t, n, c, f, v, x);
        }
      }
      class Vn {
        constructor(t, n, c, f) {
          this.kind = t, this.zoomStops = c, this._styleExpression = n, this.isStateDependent = t !== "camera" && !va(n.expression), this.interpolationType = f;
        }
        evaluateWithoutErrorHandling(t, n, c, f, v, x) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, c, f, v, x);
        }
        evaluate(t, n, c, f, v, x) {
          return this._styleExpression.evaluate(t, n, c, f, v, x);
        }
        interpolationFactor(t, n, c) {
          return this.interpolationType ? ai.interpolationFactor(this.interpolationType, t, n, c) : 0;
        }
      }
      function xa(i, t) {
        const n = Qr(i, t);
        if (n.result === "error") return n;
        const c = n.value.expression, f = Fr(c);
        if (!f && !Ds(t)) return Kr([new si("", "data expressions not supported")]);
        const v = Ys(c, ["zoom"]);
        if (!v && !zl(t)) return Kr([new si("", "zoom expressions not supported")]);
        const x = Zn(c);
        return x || v ? x instanceof si ? Kr([x]) : x instanceof ai && !al(t) ? Kr([new si("", '"interpolate" expressions cannot be used with this property')]) : qa(x ? new Vn(f ? "camera" : "composite", n.value, x.labels, x instanceof ai ? x.interpolation : void 0) : new vn(f ? "constant" : "source", n.value)) : Kr([new si("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class $n {
        constructor(t, n) {
          this._parameters = t, this._specification = n, Jt(this, Js(this._parameters, this._specification));
        }
        static deserialize(t) {
          return new $n(t._parameters, t._specification);
        }
        static serialize(t) {
          return { _parameters: t._parameters, _specification: t._specification };
        }
      }
      function Zn(i) {
        let t = null;
        if (i instanceof os) t = Zn(i.result);
        else if (i instanceof uo) {
          for (const n of i.args) if (t = Zn(n), t) break;
        } else (i instanceof pa || i instanceof ai) && i.input instanceof Ur && i.input.name === "zoom" && (t = i);
        return t instanceof si || i.eachChild((n) => {
          const c = Zn(n);
          c instanceof si ? t = c : !t && c ? t = new si("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && c && t !== c && (t = new si("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), t;
      }
      function wa(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const t of i.slice(1)) if (!wa(t) && typeof t != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const dn = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function ms(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        wa(i) || (i = dr(i));
        const t = Qr(i, dn);
        if (t.result === "error") throw new Error(t.value.map((n) => `${n.key}: ${n.message}`).join(", "));
        return { filter: (n, c, f) => t.value.evaluate(n, c, {}, f), needGeometry: Yi(i) };
      }
      function tr(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function Yi(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let t = 1; t < i.length; t++) if (Yi(i[t])) return !0;
        return !1;
      }
      function dr(i) {
        if (!i) return !0;
        const t = i[0];
        return i.length <= 1 ? t !== "any" : t === "==" ? Cr(i[1], i[2], "==") : t === "!=" ? Tr(Cr(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Cr(i[1], i[2], t) : t === "any" ? (n = i.slice(1), ["any"].concat(n.map(dr))) : t === "all" ? ["all"].concat(i.slice(1).map(dr)) : t === "none" ? ["all"].concat(i.slice(1).map(dr).map(Tr)) : t === "in" ? Dn(i[1], i.slice(2)) : t === "!in" ? Tr(Dn(i[1], i.slice(2))) : t === "has" ? Gn(i[1]) : t !== "!has" || Tr(Gn(i[1]));
        var n;
      }
      function Cr(i, t, n) {
        switch (i) {
          case "$type":
            return [`filter-type-${n}`, t];
          case "$id":
            return [`filter-id-${n}`, t];
          default:
            return [`filter-${n}`, i, t];
        }
      }
      function Dn(i, t) {
        if (t.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", t]];
          case "$id":
            return ["filter-id-in", ["literal", t]];
          default:
            return t.length > 200 && !t.some((n) => typeof n != typeof t[0]) ? ["filter-in-large", i, ["literal", t.sort(tr)]] : ["filter-in-small", i, ["literal", t]];
        }
      }
      function Gn(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function Tr(i) {
        return ["!", i];
      }
      function Ps(i) {
        const t = typeof i;
        if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let f = "[";
          for (const v of i) f += `${Ps(v)},`;
          return `${f}]`;
        }
        const n = Object.keys(i).sort();
        let c = "{";
        for (let f = 0; f < n.length; f++) c += `${JSON.stringify(n[f])}:${Ps(i[n[f]])},`;
        return `${c}}`;
      }
      function uu(i) {
        let t = "";
        for (const n of Kt) t += `/${Ps(i[n])}`;
        return t;
      }
      function cu(i) {
        const t = i.value;
        return t ? [new pt(i.key, t, "constants have been deprecated as of v8")] : [];
      }
      function _r(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function Hn(i) {
        if (Array.isArray(i)) return i.map(Hn);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const t = {};
          for (const n in i) t[n] = Hn(i[n]);
          return t;
        }
        return _r(i);
      }
      function bn(i) {
        const t = i.key, n = i.value, c = i.valueSpec || {}, f = i.objectElementValidators || {}, v = i.style, x = i.styleSpec, E = i.validateSpec;
        let T = [];
        const M = ki(n);
        if (M !== "object") return [new pt(t, n, `object expected, ${M} found`)];
        for (const R in n) {
          const U = R.split(".")[0], H = c[U] || c["*"];
          let J;
          if (f[U]) J = f[U];
          else if (c[U]) J = E;
          else if (f["*"]) J = f["*"];
          else {
            if (!c["*"]) {
              T.push(new pt(t, n[R], `unknown property "${R}"`));
              continue;
            }
            J = E;
          }
          T = T.concat(J({ key: (t && `${t}.`) + R, value: n[R], valueSpec: H, style: v, styleSpec: x, object: n, objectKey: R, validateSpec: E }, n));
        }
        for (const R in c) f[R] || c[R].required && c[R].default === void 0 && n[R] === void 0 && T.push(new pt(t, n, `missing required property "${R}"`));
        return T;
      }
      function wo(i) {
        const t = i.value, n = i.valueSpec, c = i.style, f = i.styleSpec, v = i.key, x = i.arrayElementValidator || i.validateSpec;
        if (ki(t) !== "array") return [new pt(v, t, `array expected, ${ki(t)} found`)];
        if (n.length && t.length !== n.length) return [new pt(v, t, `array length ${n.length} expected, length ${t.length} found`)];
        if (n["min-length"] && t.length < n["min-length"]) return [new pt(v, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
        let E = { type: n.value, values: n.values };
        f.$version < 7 && (E.function = n.function), ki(n.value) === "object" && (E = n.value);
        let T = [];
        for (let M = 0; M < t.length; M++) T = T.concat(x({ array: t, arrayIndex: M, value: t[M], valueSpec: E, validateSpec: i.validateSpec, style: c, styleSpec: f, key: `${v}[${M}]` }));
        return T;
      }
      function ol(i) {
        const t = i.key, n = i.value, c = i.valueSpec;
        let f = ki(n);
        return f === "number" && n != n && (f = "NaN"), f !== "number" ? [new pt(t, n, `number expected, ${f} found`)] : "minimum" in c && n < c.minimum ? [new pt(t, n, `${n} is less than the minimum value ${c.minimum}`)] : "maximum" in c && n > c.maximum ? [new pt(t, n, `${n} is greater than the maximum value ${c.maximum}`)] : [];
      }
      function Va(i) {
        const t = i.valueSpec, n = _r(i.value.type);
        let c, f, v, x = {};
        const E = n !== "categorical" && i.value.property === void 0, T = !E, M = ki(i.value.stops) === "array" && ki(i.value.stops[0]) === "array" && ki(i.value.stops[0][0]) === "object", R = bn({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(J) {
          if (n === "identity") return [new pt(J.key, J.value, 'identity function may not have a "stops" property')];
          let ne = [];
          const he = J.value;
          return ne = ne.concat(wo({ key: J.key, value: he, valueSpec: J.valueSpec, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec, arrayElementValidator: U })), ki(he) === "array" && he.length === 0 && ne.push(new pt(J.key, he, "array must have at least one stop")), ne;
        }, default: function(J) {
          return J.validateSpec({ key: J.key, value: J.value, valueSpec: t, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec });
        } } });
        return n === "identity" && E && R.push(new pt(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || R.push(new pt(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !al(i.valueSpec) && R.push(new pt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (T && !Ds(i.valueSpec) ? R.push(new pt(i.key, i.value, "property functions not supported")) : E && !zl(i.valueSpec) && R.push(new pt(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !M || i.value.property !== void 0 || R.push(new pt(i.key, i.value, '"property" property is required')), R;
        function U(J) {
          let ne = [];
          const he = J.value, Se = J.key;
          if (ki(he) !== "array") return [new pt(Se, he, `array expected, ${ki(he)} found`)];
          if (he.length !== 2) return [new pt(Se, he, `array length 2 expected, length ${he.length} found`)];
          if (M) {
            if (ki(he[0]) !== "object") return [new pt(Se, he, `object expected, ${ki(he[0])} found`)];
            if (he[0].zoom === void 0) return [new pt(Se, he, "object stop key must have zoom")];
            if (he[0].value === void 0) return [new pt(Se, he, "object stop key must have value")];
            if (v && v > _r(he[0].zoom)) return [new pt(Se, he[0].zoom, "stop zoom values must appear in ascending order")];
            _r(he[0].zoom) !== v && (v = _r(he[0].zoom), f = void 0, x = {}), ne = ne.concat(bn({ key: `${Se}[0]`, value: he[0], valueSpec: { zoom: {} }, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { zoom: ol, value: H } }));
          } else ne = ne.concat(H({ key: `${Se}[0]`, value: he[0], valueSpec: {}, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec }, he));
          return fs(Hn(he[1])) ? ne.concat([new pt(`${Se}[1]`, he[1], "expressions are not allowed in function stops.")]) : ne.concat(J.validateSpec({ key: `${Se}[1]`, value: he[1], valueSpec: t, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec }));
        }
        function H(J, ne) {
          const he = ki(J.value), Se = _r(J.value), Pe = J.value !== null ? J.value : ne;
          if (c) {
            if (he !== c) return [new pt(J.key, Pe, `${he} stop domain type must match previous stop domain type ${c}`)];
          } else c = he;
          if (he !== "number" && he !== "string" && he !== "boolean") return [new pt(J.key, Pe, "stop domain value must be a number, string, or boolean")];
          if (he !== "number" && n !== "categorical") {
            let Xe = `number expected, ${he} found`;
            return Ds(t) && n === void 0 && (Xe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new pt(J.key, Pe, Xe)];
          }
          return n !== "categorical" || he !== "number" || isFinite(Se) && Math.floor(Se) === Se ? n !== "categorical" && he === "number" && f !== void 0 && Se < f ? [new pt(J.key, Pe, "stop domain values must appear in ascending order")] : (f = Se, n === "categorical" && Se in x ? [new pt(J.key, Pe, "stop domain values must be unique")] : (x[Se] = !0, [])) : [new pt(J.key, Pe, `integer expected, found ${Se}`)];
        }
      }
      function Br(i) {
        const t = (i.expressionContext === "property" ? xa : Qr)(Hn(i.value), i.valueSpec);
        if (t.result === "error") return t.value.map((c) => new pt(`${i.key}${c.key}`, i.value, c.message));
        const n = t.value.expression || t.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new pt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !va(n)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !va(n)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!Ys(n, ["zoom", "feature-state"])) return [new pt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !Fr(n)) return [new pt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Lr(i) {
        const t = i.key, n = i.value, c = i.valueSpec, f = [];
        return Array.isArray(c.values) ? c.values.indexOf(_r(n)) === -1 && f.push(new pt(t, n, `expected one of [${c.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(c.values).indexOf(_r(n)) === -1 && f.push(new pt(t, n, `expected one of [${Object.keys(c.values).join(", ")}], ${JSON.stringify(n)} found`)), f;
      }
      function Ao(i) {
        return wa(Hn(i.value)) ? Br(Jt({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : $a(i);
      }
      function $a(i) {
        const t = i.value, n = i.key;
        if (ki(t) !== "array") return [new pt(n, t, `array expected, ${ki(t)} found`)];
        const c = i.styleSpec;
        let f, v = [];
        if (t.length < 1) return [new pt(n, t, "filter array must have at least 1 element")];
        switch (v = v.concat(Lr({ key: `${n}[0]`, value: t[0], valueSpec: c.filter_operator, style: i.style, styleSpec: i.styleSpec })), _r(t[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 && _r(t[1]) === "$type" && v.push(new pt(n, t, `"$type" cannot be use with operator "${t[0]}"`));
          case "==":
          case "!=":
            t.length !== 3 && v.push(new pt(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t.length >= 2 && (f = ki(t[1]), f !== "string" && v.push(new pt(`${n}[1]`, t[1], `string expected, ${f} found`)));
            for (let x = 2; x < t.length; x++) f = ki(t[x]), _r(t[1]) === "$type" ? v = v.concat(Lr({ key: `${n}[${x}]`, value: t[x], valueSpec: c.geometry_type, style: i.style, styleSpec: i.styleSpec })) : f !== "string" && f !== "number" && f !== "boolean" && v.push(new pt(`${n}[${x}]`, t[x], `string, number, or boolean expected, ${f} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let x = 1; x < t.length; x++) v = v.concat($a({ key: `${n}[${x}]`, value: t[x], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            f = ki(t[1]), t.length !== 2 ? v.push(new pt(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : f !== "string" && v.push(new pt(`${n}[1]`, t[1], `string expected, ${f} found`));
        }
        return v;
      }
      function Fl(i, t) {
        const n = i.key, c = i.validateSpec, f = i.style, v = i.styleSpec, x = i.value, E = i.objectKey, T = v[`${t}_${i.layerType}`];
        if (!T) return [];
        const M = E.match(/^(.*)-transition$/);
        if (t === "paint" && M && T[M[1]] && T[M[1]].transition) return c({ key: n, value: x, valueSpec: v.transition, style: f, styleSpec: v });
        const R = i.valueSpec || T[E];
        if (!R) return [new pt(n, x, `unknown property "${E}"`)];
        let U;
        if (ki(x) === "string" && Ds(R) && !R.tokens && (U = /^{([^}]+)}$/.exec(x))) return [new pt(n, x, `"${E}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(U[1])} }\`.`)];
        const H = [];
        return i.layerType === "symbol" && (E === "text-field" && f && !f.glyphs && H.push(new pt(n, x, 'use of "text-field" requires a style "glyphs" property')), E === "text-font" && cn(Hn(x)) && _r(x.type) === "identity" && H.push(new pt(n, x, '"text-font" does not support identity functions'))), H.concat(c({ key: i.key, value: x, valueSpec: R, style: f, styleSpec: v, expressionContext: "property", propertyType: t, propertyKey: E }));
      }
      function Za(i) {
        return Fl(i, "paint");
      }
      function So(i) {
        return Fl(i, "layout");
      }
      function ll(i) {
        let t = [];
        const n = i.value, c = i.key, f = i.style, v = i.styleSpec;
        n.type || n.ref || t.push(new pt(c, n, 'either "type" or "ref" is required'));
        let x = _r(n.type);
        const E = _r(n.ref);
        if (n.id) {
          const T = _r(n.id);
          for (let M = 0; M < i.arrayIndex; M++) {
            const R = f.layers[M];
            _r(R.id) === T && t.push(new pt(c, n.id, `duplicate layer id "${n.id}", previously used at line ${R.id.__line__}`));
          }
        }
        if ("ref" in n) {
          let T;
          ["type", "source", "source-layer", "filter", "layout"].forEach((M) => {
            M in n && t.push(new pt(c, n[M], `"${M}" is prohibited for ref layers`));
          }), f.layers.forEach((M) => {
            _r(M.id) === E && (T = M);
          }), T ? T.ref ? t.push(new pt(c, n.ref, "ref cannot reference another ref layer")) : x = _r(T.type) : t.push(new pt(c, n.ref, `ref layer "${E}" not found`));
        } else if (x !== "background") if (n.source) {
          const T = f.sources && f.sources[n.source], M = T && _r(T.type);
          T ? M === "vector" && x === "raster" ? t.push(new pt(c, n.source, `layer "${n.id}" requires a raster source`)) : M !== "raster-dem" && x === "hillshade" ? t.push(new pt(c, n.source, `layer "${n.id}" requires a raster-dem source`)) : M === "raster" && x !== "raster" ? t.push(new pt(c, n.source, `layer "${n.id}" requires a vector source`)) : M !== "vector" || n["source-layer"] ? M === "raster-dem" && x !== "hillshade" ? t.push(new pt(c, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : x !== "line" || !n.paint || !n.paint["line-gradient"] || M === "geojson" && T.lineMetrics || t.push(new pt(c, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new pt(c, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new pt(c, n.source, `source "${n.source}" not found`));
        } else t.push(new pt(c, n, 'missing required property "source"'));
        return t = t.concat(bn({ key: c, value: n, valueSpec: v.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${c}.type`, value: n.type, valueSpec: v.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: n, objectKey: "type" }), filter: Ao, layout: (T) => bn({ layer: n, key: T.key, value: T.value, style: T.style, styleSpec: T.styleSpec, validateSpec: T.validateSpec, objectElementValidators: { "*": (M) => So(Jt({ layerType: x }, M)) } }), paint: (T) => bn({ layer: n, key: T.key, value: T.value, style: T.style, styleSpec: T.styleSpec, validateSpec: T.validateSpec, objectElementValidators: { "*": (M) => Za(Jt({ layerType: x }, M)) } }) } })), t;
      }
      function Aa(i) {
        const t = i.value, n = i.key, c = ki(t);
        return c !== "string" ? [new pt(n, t, `string expected, ${c} found`)] : [];
      }
      const Eo = { promoteId: function({ key: i, value: t }) {
        if (ki(t) === "string") return Aa({ key: i, value: t });
        {
          const n = [];
          for (const c in t) n.push(...Aa({ key: `${i}.${c}`, value: t[c] }));
          return n;
        }
      } };
      function Ga(i) {
        const t = i.value, n = i.key, c = i.styleSpec, f = i.style, v = i.validateSpec;
        if (!t.type) return [new pt(n, t, '"type" is required')];
        const x = _r(t.type);
        let E;
        switch (x) {
          case "vector":
          case "raster":
            return E = bn({ key: n, value: t, valueSpec: c[`source_${x.replace("-", "_")}`], style: i.style, styleSpec: c, objectElementValidators: Eo, validateSpec: v }), E;
          case "raster-dem":
            return E = function(T) {
              var M;
              const R = (M = T.sourceName) !== null && M !== void 0 ? M : "", U = T.value, H = T.styleSpec, J = H.source_raster_dem, ne = T.style;
              let he = [];
              const Se = ki(U);
              if (U === void 0) return he;
              if (Se !== "object") return he.push(new pt("source_raster_dem", U, `object expected, ${Se} found`)), he;
              const Pe = _r(U.encoding) === "custom", Xe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Be = T.value.encoding ? `"${T.value.encoding}"` : "Default";
              for (const Ge in U) !Pe && Xe.includes(Ge) ? he.push(new pt(Ge, U[Ge], `In "${R}": "${Ge}" is only valid when "encoding" is set to "custom". ${Be} encoding found`)) : J[Ge] ? he = he.concat(T.validateSpec({ key: Ge, value: U[Ge], valueSpec: J[Ge], validateSpec: T.validateSpec, style: ne, styleSpec: H })) : he.push(new pt(Ge, U[Ge], `unknown property "${Ge}"`));
              return he;
            }({ sourceName: n, value: t, style: i.style, styleSpec: c, validateSpec: v }), E;
          case "geojson":
            if (E = bn({ key: n, value: t, valueSpec: c.source_geojson, style: f, styleSpec: c, validateSpec: v, objectElementValidators: Eo }), t.cluster) for (const T in t.clusterProperties) {
              const [M, R] = t.clusterProperties[T], U = typeof M == "string" ? [M, ["accumulated"], ["get", T]] : M;
              E.push(...Br({ key: `${n}.${T}.map`, value: R, validateSpec: v, expressionContext: "cluster-map" })), E.push(...Br({ key: `${n}.${T}.reduce`, value: U, validateSpec: v, expressionContext: "cluster-reduce" }));
            }
            return E;
          case "video":
            return bn({ key: n, value: t, valueSpec: c.source_video, style: f, validateSpec: v, styleSpec: c });
          case "image":
            return bn({ key: n, value: t, valueSpec: c.source_image, style: f, validateSpec: v, styleSpec: c });
          case "canvas":
            return [new pt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Lr({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: f, validateSpec: v, styleSpec: c });
        }
      }
      function Co(i) {
        const t = i.value, n = i.styleSpec, c = n.light, f = i.style;
        let v = [];
        const x = ki(t);
        if (t === void 0) return v;
        if (x !== "object") return v = v.concat([new pt("light", t, `object expected, ${x} found`)]), v;
        for (const E in t) {
          const T = E.match(/^(.*)-transition$/);
          v = v.concat(T && c[T[1]] && c[T[1]].transition ? i.validateSpec({ key: E, value: t[E], valueSpec: n.transition, validateSpec: i.validateSpec, style: f, styleSpec: n }) : c[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        }
        return v;
      }
      function ul(i) {
        const t = i.value, n = i.styleSpec, c = n.sky, f = i.style, v = ki(t);
        if (t === void 0) return [];
        if (v !== "object") return [new pt("sky", t, `object expected, ${v} found`)];
        let x = [];
        for (const E in t) x = x.concat(c[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: c[E], style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return x;
      }
      function hu(i) {
        const t = i.value, n = i.styleSpec, c = n.terrain, f = i.style;
        let v = [];
        const x = ki(t);
        if (t === void 0) return v;
        if (x !== "object") return v = v.concat([new pt("terrain", t, `object expected, ${x} found`)]), v;
        for (const E in t) v = v.concat(c[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return v;
      }
      function du(i) {
        let t = [];
        const n = i.value, c = i.key;
        if (Array.isArray(n)) {
          const f = [], v = [];
          for (const x in n) n[x].id && f.includes(n[x].id) && t.push(new pt(c, n, `all the sprites' ids must be unique, but ${n[x].id} is duplicated`)), f.push(n[x].id), n[x].url && v.includes(n[x].url) && t.push(new pt(c, n, `all the sprites' URLs must be unique, but ${n[x].url} is duplicated`)), v.push(n[x].url), t = t.concat(bn({ key: `${c}[${x}]`, value: n[x], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return t;
        }
        return Aa({ key: c, value: n });
      }
      const cl = { "*": () => [], array: wo, boolean: function(i) {
        const t = i.value, n = i.key, c = ki(t);
        return c !== "boolean" ? [new pt(n, t, `boolean expected, ${c} found`)] : [];
      }, number: ol, color: function(i) {
        const t = i.key, n = i.value, c = ki(n);
        return c !== "string" ? [new pt(t, n, `color expected, ${c} found`)] : ji.parse(String(n)) ? [] : [new pt(t, n, `color expected, "${n}" found`)];
      }, constants: cu, enum: Lr, filter: Ao, function: Va, layer: ll, object: bn, source: Ga, light: Co, sky: ul, terrain: hu, projection: function(i) {
        const t = i.value, n = i.styleSpec, c = n.projection, f = i.style, v = ki(t);
        if (t === void 0) return [];
        if (v !== "object") return [new pt("projection", t, `object expected, ${v} found`)];
        let x = [];
        for (const E in t) x = x.concat(c[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: c[E], style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return x;
      }, string: Aa, formatted: function(i) {
        return Aa(i).length === 0 ? [] : Br(i);
      }, resolvedImage: function(i) {
        return Aa(i).length === 0 ? [] : Br(i);
      }, padding: function(i) {
        const t = i.key, n = i.value;
        if (ki(n) === "array") {
          if (n.length < 1 || n.length > 4) return [new pt(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
          const c = { type: "number" };
          let f = [];
          for (let v = 0; v < n.length; v++) f = f.concat(i.validateSpec({ key: `${t}[${v}]`, value: n[v], validateSpec: i.validateSpec, valueSpec: c }));
          return f;
        }
        return ol({ key: t, value: n, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const t = i.key, n = i.value, c = ki(n), f = i.styleSpec;
        if (c !== "array" || n.length < 1 || n.length % 2 != 0) return [new pt(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let v = [];
        for (let x = 0; x < n.length; x += 2) v = v.concat(Lr({ key: `${t}[${x}]`, value: n[x], valueSpec: f.layout_symbol["text-anchor"] })), v = v.concat(wo({ key: `${t}[${x + 1}]`, value: n[x + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: f }));
        return v;
      }, sprite: du };
      function To(i) {
        const t = i.value, n = i.valueSpec, c = i.styleSpec;
        return i.validateSpec = To, n.expression && cn(_r(t)) ? Va(i) : n.expression && fs(Hn(t)) ? Br(i) : n.type && cl[n.type] ? cl[n.type](i) : bn(Jt({}, i, { valueSpec: n.type ? c[n.type] : n }));
      }
      function qu(i) {
        const t = i.value, n = i.key, c = Aa(i);
        return c.length || (t.indexOf("{fontstack}") === -1 && c.push(new pt(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && c.push(new pt(n, t, '"glyphs" url must include a "{range}" token'))), c;
      }
      function Wn(i, t = Y) {
        let n = [];
        return n = n.concat(To({ key: "", value: i, valueSpec: t.$root, styleSpec: t, style: i, validateSpec: To, objectElementValidators: { glyphs: qu, "*": () => [] } })), i.constants && (n = n.concat(cu({ key: "constants", value: i.constants, style: i, styleSpec: t, validateSpec: To }))), pu(n);
      }
      function Ls(i) {
        return function(t) {
          return i({ ...t, validateSpec: To });
        };
      }
      function pu(i) {
        return [].concat(i).sort((t, n) => t.line - n.line);
      }
      function In(i) {
        return function(...t) {
          return pu(i.apply(this, t));
        };
      }
      Wn.source = In(Ls(Ga)), Wn.sprite = In(Ls(du)), Wn.glyphs = In(Ls(qu)), Wn.light = In(Ls(Co)), Wn.sky = In(Ls(ul)), Wn.terrain = In(Ls(hu)), Wn.layer = In(Ls(ll)), Wn.filter = In(Ls(Ao)), Wn.paintProperty = In(Ls(Za)), Wn.layoutProperty = In(Ls(So));
      const Qs = Wn, hl = Qs.light, Dc = Qs.sky, Uu = Qs.paintProperty, fu = Qs.layoutProperty;
      function mu(i, t) {
        let n = !1;
        if (t && t.length) for (const c of t) i.fire(new Pt(new Error(c.message))), n = !0;
        return n;
      }
      class ko {
        constructor(t, n, c) {
          const f = this.cells = [];
          if (t instanceof ArrayBuffer) {
            this.arrayBuffer = t;
            const x = new Int32Array(this.arrayBuffer);
            t = x[0], this.d = (n = x[1]) + 2 * (c = x[2]);
            for (let T = 0; T < this.d * this.d; T++) {
              const M = x[3 + T], R = x[3 + T + 1];
              f.push(M === R ? null : x.subarray(M, R));
            }
            const E = x[3 + f.length + 1];
            this.keys = x.subarray(x[3 + f.length], E), this.bboxes = x.subarray(E), this.insert = this._insertReadonly;
          } else {
            this.d = n + 2 * c;
            for (let x = 0; x < this.d * this.d; x++) f.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = n, this.extent = t, this.padding = c, this.scale = n / t, this.uid = 0;
          const v = c / n * t;
          this.min = -v, this.max = t + v;
        }
        insert(t, n, c, f, v) {
          this._forEachCell(n, c, f, v, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(c), this.bboxes.push(f), this.bboxes.push(v);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t, n, c, f, v, x) {
          this.cells[v].push(x);
        }
        query(t, n, c, f, v) {
          const x = this.min, E = this.max;
          if (t <= x && n <= x && E <= c && E <= f && !v) return Array.prototype.slice.call(this.keys);
          {
            const T = [];
            return this._forEachCell(t, n, c, f, this._queryCell, T, {}, v), T;
          }
        }
        _queryCell(t, n, c, f, v, x, E, T) {
          const M = this.cells[v];
          if (M !== null) {
            const R = this.keys, U = this.bboxes;
            for (let H = 0; H < M.length; H++) {
              const J = M[H];
              if (E[J] === void 0) {
                const ne = 4 * J;
                (T ? T(U[ne + 0], U[ne + 1], U[ne + 2], U[ne + 3]) : t <= U[ne + 2] && n <= U[ne + 3] && c >= U[ne + 0] && f >= U[ne + 1]) ? (E[J] = !0, x.push(R[J])) : E[J] = !1;
              }
            }
          }
        }
        _forEachCell(t, n, c, f, v, x, E, T) {
          const M = this._convertToCellCoord(t), R = this._convertToCellCoord(n), U = this._convertToCellCoord(c), H = this._convertToCellCoord(f);
          for (let J = M; J <= U; J++) for (let ne = R; ne <= H; ne++) {
            const he = this.d * ne + J;
            if ((!T || T(this._convertFromCellCoord(J), this._convertFromCellCoord(ne), this._convertFromCellCoord(J + 1), this._convertFromCellCoord(ne + 1))) && v.call(this, t, n, c, f, he, x, E, T)) return;
          }
        }
        _convertFromCellCoord(t) {
          return (t - this.padding) / this.scale;
        }
        _convertToCellCoord(t) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t = this.cells, n = 3 + this.cells.length + 1 + 1;
          let c = 0;
          for (let x = 0; x < this.cells.length; x++) c += this.cells[x].length;
          const f = new Int32Array(n + c + this.keys.length + this.bboxes.length);
          f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
          let v = n;
          for (let x = 0; x < t.length; x++) {
            const E = t[x];
            f[3 + x] = v, f.set(E, v), v += E.length;
          }
          return f[3 + t.length] = v, f.set(this.keys, v), v += this.keys.length, f[3 + t.length + 1] = v, f.set(this.bboxes, v), v += this.bboxes.length, f.buffer;
        }
        static serialize(t, n) {
          const c = t.toArrayBuffer();
          return n && n.push(c), { buffer: c };
        }
        static deserialize(t) {
          return new ko(t.buffer);
        }
      }
      const Xn = {};
      function Ot(i, t, n = {}) {
        if (Xn[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(t, "_classRegistryKey", { value: i, writeable: !1 }), Xn[i] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
      }
      Ot("Object", Object), Ot("TransferableGridIndex", ko), Ot("Color", ji), Ot("Error", Error), Ot("AJAXError", $e), Ot("ResolvedImage", Xr), Ot("StylePropertyFunction", $n), Ot("StyleExpression", ba, { omit: ["_evaluator"] }), Ot("ZoomDependentExpression", Vn), Ot("ZoomConstantExpression", vn), Ot("CompoundExpression", Ur, { omit: ["_evaluate"] });
      for (const i in ks) ks[i]._classRegistryKey || Ot(`Expression_${i}`, ks[i]);
      function gs(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function Pn(i) {
        return i.$name || i.constructor._classRegistryKey;
      }
      function Ms(i) {
        return !function(t) {
          if (t === null || typeof t != "object") return !1;
          const n = Pn(t);
          return !(!n || n === "Object");
        }(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || gs(i) || Ze(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
      }
      function Do(i, t) {
        if (Ms(i)) return (gs(i) || Ze(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const v = [];
          for (const x of i) v.push(Do(x, t));
          return v;
        }
        if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
        const n = Pn(i);
        if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
        if (!Xn[n]) throw new Error(`${n} is not registered.`);
        const { klass: c } = Xn[n], f = c.serialize ? c.serialize(i, t) : {};
        if (c.serialize) {
          if (t && f === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const v in i) {
            if (!i.hasOwnProperty(v) || Xn[n].omit.indexOf(v) >= 0) continue;
            const x = i[v];
            f[v] = Xn[n].shallow.indexOf(v) >= 0 ? x : Do(x, t);
          }
          i instanceof Error && (f.message = i.message);
        }
        if (f.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return n !== "Object" && (f.$name = n), f;
      }
      function Ha(i) {
        if (Ms(i)) return i;
        if (Array.isArray(i)) return i.map(Ha);
        if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
        const t = Pn(i) || "Object";
        if (!Xn[t]) throw new Error(`can't deserialize unregistered class ${t}`);
        const { klass: n } = Xn[t];
        if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
        if (n.deserialize) return n.deserialize(i);
        const c = Object.create(n.prototype);
        for (const f of Object.keys(i)) {
          if (f === "$name") continue;
          const v = i[f];
          c[f] = Xn[t].shallow.indexOf(f) >= 0 ? v : Ha(v);
        }
        return c;
      }
      class Ns {
        constructor() {
          this.first = !0;
        }
        update(t, n) {
          const c = Math.floor(t);
          return this.first ? (this.first = !1, this.lastIntegerZoom = c, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = c, !0) : (this.lastFloorZoom > c ? (this.lastIntegerZoom = c + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < c && (this.lastIntegerZoom = c, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = c, !0));
        }
      }
      const vi = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, Khmer: (i) => i >= 6016 && i <= 6143, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Katakana: (i) => i >= 12448 && i <= 12543, Kanbun: (i) => i >= 12688 && i <= 12703, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "Private Use Area": (i) => i >= 57344 && i <= 63743, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function gu(i) {
        for (const t of i) if (yu(t.charCodeAt(0))) return !0;
        return !1;
      }
      function Ic(i) {
        for (const t of i) if (!Wa(t.charCodeAt(0))) return !1;
        return !0;
      }
      function Bl(i) {
        const t = i.map((n) => {
          try {
            return new RegExp(`\\p{sc=${n}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((n) => n);
        return new RegExp(t.join("|"), "u");
      }
      const Vu = Bl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Wa(i) {
        return !Vu.test(String.fromCodePoint(i));
      }
      const _u = Bl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function yu(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(vi["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || vi["CJK Compatibility"](i) || vi["CJK Strokes"](i) || !(!vi["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || vi["Enclosed CJK Letters and Months"](i) || vi["Ideographic Description Characters"](i) || vi.Kanbun(i) || vi.Katakana(i) && i !== 12540 || !(!vi["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!vi["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || vi["Vertical Forms"](i) || vi["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || _u.test(String.fromCodePoint(i)))));
      }
      function dl(i) {
        return !(yu(i) || function(t) {
          return !!(vi["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || vi["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || vi["Letterlike Symbols"](t) || vi["Number Forms"](t) || vi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || vi["Control Pictures"](t) && t !== 9251 || vi["Optical Character Recognition"](t) || vi["Enclosed Alphanumerics"](t) || vi["Geometric Shapes"](t) || vi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || vi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || vi["CJK Symbols and Punctuation"](t) || vi.Katakana(t) || vi["Private Use Area"](t) || vi["CJK Compatibility Forms"](t) || vi["Small Form Variants"](t) || vi["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
        }(i));
      }
      const Rl = Bl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Xa(i) {
        return Rl.test(String.fromCodePoint(i));
      }
      function vu(i, t) {
        return !(!t && Xa(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || vi.Khmer(i));
      }
      function $u(i) {
        for (const t of i) if (Xa(t.charCodeAt(0))) return !0;
        return !1;
      }
      const Ln = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class Ji {
        constructor(t, n) {
          this.zoom = t, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ns(), this.transition = {});
        }
        isSupportedScript(t) {
          return function(n, c) {
            for (const f of n) if (!vu(f.charCodeAt(0), c)) return !1;
            return !0;
          }(t, Ln.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t = this.zoom, n = t - Math.floor(t), c = this.crossFadingFactor();
          return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * c } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - c) * n };
        }
      }
      class Io {
        constructor(t, n) {
          this.property = t, this.value = n, this.expression = function(c, f) {
            if (cn(c)) return new $n(c, f);
            if (fs(c)) {
              const v = xa(c, f);
              if (v.result === "error") throw new Error(v.value.map((x) => `${x.key}: ${x.message}`).join(", "));
              return v.value;
            }
            {
              let v = c;
              return f.type === "color" && typeof c == "string" ? v = ji.parse(c) : f.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(c) && (v = gn.parse(c)) : v = on.parse(c), { kind: "constant", evaluate: () => v };
            }
          }(n === void 0 ? t.specification.default : n, t.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t, n, c) {
          return this.property.possiblyEvaluate(this, t, n, c);
        }
      }
      class Ol {
        constructor(t) {
          this.property = t, this.value = new Io(t, void 0);
        }
        transitioned(t, n) {
          return new Zu(this.property, this.value, n, ke({}, t.transition, this.transition), t.now);
        }
        untransitioned() {
          return new Zu(this.property, this.value, null, {}, 0);
        }
      }
      class jl {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
        }
        getValue(t) {
          return X(this._values[t].value.value);
        }
        setValue(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Ol(this._values[t].property)), this._values[t].value = new Io(this._values[t].property, n === null ? void 0 : X(n));
        }
        getTransition(t) {
          return X(this._values[t].transition);
        }
        setTransition(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Ol(this._values[t].property)), this._values[t].transition = X(n) || void 0;
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const c = this.getValue(n);
            c !== void 0 && (t[n] = c);
            const f = this.getTransition(n);
            f !== void 0 && (t[`${n}-transition`] = f);
          }
          return t;
        }
        transitioned(t, n) {
          const c = new pl(this._properties);
          for (const f of Object.keys(this._values)) c._values[f] = this._values[f].transitioned(t, n._values[f]);
          return c;
        }
        untransitioned() {
          const t = new pl(this._properties);
          for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
          return t;
        }
      }
      class Zu {
        constructor(t, n, c, f, v) {
          this.property = t, this.value = n, this.begin = v + f.delay || 0, this.end = this.begin + f.duration || 0, t.specification.transition && (f.delay || f.duration) && (this.prior = c);
        }
        possiblyEvaluate(t, n, c) {
          const f = t.now || 0, v = this.value.possiblyEvaluate(t, n, c), x = this.prior;
          if (x) {
            if (f > this.end) return this.prior = null, v;
            if (this.value.isDataDriven()) return this.prior = null, v;
            if (f < this.begin) return x.possiblyEvaluate(t, n, c);
            {
              const E = (f - this.begin) / (this.end - this.begin);
              return this.property.interpolate(x.possiblyEvaluate(t, n, c), v, function(T) {
                if (T <= 0) return 0;
                if (T >= 1) return 1;
                const M = T * T, R = M * T;
                return 4 * (T < 0.5 ? R : 3 * (T - M) + R - 0.75);
              }(E));
            }
          }
          return v;
        }
      }
      class pl {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t, n, c) {
          const f = new Sa(this._properties);
          for (const v of Object.keys(this._values)) f._values[v] = this._values[v].possiblyEvaluate(t, n, c);
          return f;
        }
        hasTransition() {
          for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class fl {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPropertyValues);
        }
        hasValue(t) {
          return this._values[t].value !== void 0;
        }
        getValue(t) {
          return X(this._values[t].value);
        }
        setValue(t, n) {
          this._values[t] = new Io(this._values[t].property, n === null ? void 0 : X(n));
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const c = this.getValue(n);
            c !== void 0 && (t[n] = c);
          }
          return t;
        }
        possiblyEvaluate(t, n, c) {
          const f = new Sa(this._properties);
          for (const v of Object.keys(this._values)) f._values[v] = this._values[v].possiblyEvaluate(t, n, c);
          return f;
        }
      }
      class _s {
        constructor(t, n, c) {
          this.property = t, this.value = n, this.parameters = c;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t) {
          return this.value.kind === "constant" ? this.value.value : t;
        }
        evaluate(t, n, c, f) {
          return this.property.evaluate(this.value, this.parameters, t, n, c, f);
        }
      }
      class Sa {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
        }
        get(t) {
          return this._values[t];
        }
      }
      class Gt {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n) {
          if (t.isDataDriven()) throw new Error("Value should not be data driven");
          return t.expression.evaluate(n);
        }
        interpolate(t, n, c) {
          const f = qr[this.specification.type];
          return f ? f(t, n, c) : t;
        }
      }
      class li {
        constructor(t, n) {
          this.specification = t, this.overrides = n;
        }
        possiblyEvaluate(t, n, c, f) {
          return new _s(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, c, f) } : t.expression, n);
        }
        interpolate(t, n, c) {
          if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
          if (t.value.value === void 0 || n.value.value === void 0) return new _s(this, { kind: "constant", value: void 0 }, t.parameters);
          const f = qr[this.specification.type];
          if (f) {
            const v = f(t.value.value, n.value.value, c);
            return new _s(this, { kind: "constant", value: v }, t.parameters);
          }
          return t;
        }
        evaluate(t, n, c, f, v, x) {
          return t.kind === "constant" ? t.value : t.evaluate(n, c, f, v, x);
        }
      }
      class ml extends li {
        possiblyEvaluate(t, n, c, f) {
          if (t.value === void 0) return new _s(this, { kind: "constant", value: void 0 }, n);
          if (t.expression.kind === "constant") {
            const v = t.expression.evaluate(n, null, {}, c, f), x = t.property.specification.type === "resolvedImage" && typeof v != "string" ? v.name : v, E = this._calculate(x, x, x, n);
            return new _s(this, { kind: "constant", value: E }, n);
          }
          if (t.expression.kind === "camera") {
            const v = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
            return new _s(this, { kind: "constant", value: v }, n);
          }
          return new _s(this, t.expression, n);
        }
        evaluate(t, n, c, f, v, x) {
          if (t.kind === "source") {
            const E = t.evaluate(n, c, f, v, x);
            return this._calculate(E, E, E, n);
          }
          return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, c, f), t.evaluate({ zoom: Math.floor(n.zoom) }, c, f), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, c, f), n) : t.value;
        }
        _calculate(t, n, c, f) {
          return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: c, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class b {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, c, f) {
          if (t.value !== void 0) {
            if (t.expression.kind === "constant") {
              const v = t.expression.evaluate(n, null, {}, c, f);
              return this._calculate(v, v, v, n);
            }
            return this._calculate(t.expression.evaluate(new Ji(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Ji(Math.floor(n.zoom), n)), t.expression.evaluate(new Ji(Math.floor(n.zoom + 1), n)), n);
          }
        }
        _calculate(t, n, c, f) {
          return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: c, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class S {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, c, f) {
          return !!t.expression.evaluate(n, null, {}, c, f);
        }
        interpolate() {
          return !1;
        }
      }
      class h {
        constructor(t) {
          this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const n in t) {
            const c = t[n];
            c.specification.overridable && this.overridableProperties.push(n);
            const f = this.defaultPropertyValues[n] = new Io(c, void 0), v = this.defaultTransitionablePropertyValues[n] = new Ol(c);
            this.defaultTransitioningPropertyValues[n] = v.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = f.possiblyEvaluate({});
          }
        }
      }
      Ot("DataDrivenProperty", li), Ot("DataConstantProperty", Gt), Ot("CrossFadedDataDrivenProperty", ml), Ot("CrossFadedProperty", b), Ot("ColorRampProperty", S);
      const e = "-transition";
      class r extends rt {
        constructor(t, n) {
          if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), n.layout && (this._unevaluatedLayout = new fl(n.layout)), n.paint)) {
            this._transitionablePaint = new jl(n.paint);
            for (const c in t.paint) this.setPaintProperty(c, t.paint[c], { validate: !1 });
            for (const c in t.layout) this.setLayoutProperty(c, t.layout[c], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Sa(n.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t) {
          return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
        }
        setLayoutProperty(t, n, c = {}) {
          n != null && this._validate(fu, `layers.${this.id}.layout.${t}`, t, n, c) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
        }
        getPaintProperty(t) {
          return t.endsWith(e) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, n, c = {}) {
          if (n != null && this._validate(Uu, `layers.${this.id}.paint.${t}`, t, n, c)) return !1;
          if (t.endsWith(e)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
          {
            const f = this._transitionablePaint._values[t], v = f.property.specification["property-type"] === "cross-faded-data-driven", x = f.value.isDataDriven(), E = f.value;
            this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
            const T = this._transitionablePaint._values[t].value;
            return T.isDataDriven() || x || v || this._handleOverridablePaintPropertyUpdate(t, E, T);
          }
        }
        _handleSpecialPaintPropertyUpdate(t) {
        }
        _handleOverridablePaintPropertyUpdate(t, n, c) {
          return !1;
        }
        isHidden(t) {
          return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, n) {
          t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
        }
        serialize() {
          const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), ve(t, (n, c) => !(n === void 0 || c === "layout" && !Object.keys(n).length || c === "paint" && !Object.keys(n).length));
        }
        _validate(t, n, c, f, v = {}) {
          return (!v || v.validate !== !1) && mu(this, t.call(Qs, { key: n, layerType: this.type, objectKey: c, value: f, styleSpec: Y, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const t in this.paint._values) {
            const n = this.paint.get(t);
            if (n instanceof _s && Ds(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const u = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class d {
        constructor(t, n) {
          this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class p {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(t, n) {
          return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
        }
        static deserialize(t) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          this.reserve(t), this.length = t;
        }
        reserve(t) {
          if (t > this.capacity) {
            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function w(i, t = 1) {
        let n = 0, c = 0;
        return { members: i.map((f) => {
          const v = u[f.type].BYTES_PER_ELEMENT, x = n = A(n, Math.max(t, v)), E = f.components || 1;
          return c = Math.max(c, v), n += v * E, { name: f.name, type: f.type, components: E, offset: x };
        }), size: A(n, Math.max(c, t)), alignment: t };
      }
      function A(i, t) {
        return Math.ceil(i / t) * t;
      }
      class C extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, t, n);
        }
        emplace(t, n, c) {
          const f = 2 * t;
          return this.int16[f + 0] = n, this.int16[f + 1] = c, t;
        }
      }
      C.prototype.bytesPerElement = 4, Ot("StructArrayLayout2i4", C);
      class P extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, c);
        }
        emplace(t, n, c, f) {
          const v = 3 * t;
          return this.int16[v + 0] = n, this.int16[v + 1] = c, this.int16[v + 2] = f, t;
        }
      }
      P.prototype.bytesPerElement = 6, Ot("StructArrayLayout3i6", P);
      class F extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, t, n, c, f);
        }
        emplace(t, n, c, f, v) {
          const x = 4 * t;
          return this.int16[x + 0] = n, this.int16[x + 1] = c, this.int16[x + 2] = f, this.int16[x + 3] = v, t;
        }
      }
      F.prototype.bytesPerElement = 8, Ot("StructArrayLayout4i8", F);
      class N extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, c, f, v, x);
        }
        emplace(t, n, c, f, v, x, E) {
          const T = 6 * t;
          return this.int16[T + 0] = n, this.int16[T + 1] = c, this.int16[T + 2] = f, this.int16[T + 3] = v, this.int16[T + 4] = x, this.int16[T + 5] = E, t;
        }
      }
      N.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i4i12", N);
      class Z extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, c, f, v, x);
        }
        emplace(t, n, c, f, v, x, E) {
          const T = 4 * t, M = 8 * t;
          return this.int16[T + 0] = n, this.int16[T + 1] = c, this.uint8[M + 4] = f, this.uint8[M + 5] = v, this.uint8[M + 6] = x, this.uint8[M + 7] = E, t;
        }
      }
      Z.prototype.bytesPerElement = 8, Ot("StructArrayLayout2i4ub8", Z);
      class G extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, t, n);
        }
        emplace(t, n, c) {
          const f = 2 * t;
          return this.float32[f + 0] = n, this.float32[f + 1] = c, t;
        }
      }
      G.prototype.bytesPerElement = 8, Ot("StructArrayLayout2f8", G);
      class V extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x, E, T, M, R) {
          const U = this.length;
          return this.resize(U + 1), this.emplace(U, t, n, c, f, v, x, E, T, M, R);
        }
        emplace(t, n, c, f, v, x, E, T, M, R, U) {
          const H = 10 * t;
          return this.uint16[H + 0] = n, this.uint16[H + 1] = c, this.uint16[H + 2] = f, this.uint16[H + 3] = v, this.uint16[H + 4] = x, this.uint16[H + 5] = E, this.uint16[H + 6] = T, this.uint16[H + 7] = M, this.uint16[H + 8] = R, this.uint16[H + 9] = U, t;
        }
      }
      V.prototype.bytesPerElement = 20, Ot("StructArrayLayout10ui20", V);
      class W extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x, E, T, M, R, U, H) {
          const J = this.length;
          return this.resize(J + 1), this.emplace(J, t, n, c, f, v, x, E, T, M, R, U, H);
        }
        emplace(t, n, c, f, v, x, E, T, M, R, U, H, J) {
          const ne = 12 * t;
          return this.int16[ne + 0] = n, this.int16[ne + 1] = c, this.int16[ne + 2] = f, this.int16[ne + 3] = v, this.uint16[ne + 4] = x, this.uint16[ne + 5] = E, this.uint16[ne + 6] = T, this.uint16[ne + 7] = M, this.int16[ne + 8] = R, this.int16[ne + 9] = U, this.int16[ne + 10] = H, this.int16[ne + 11] = J, t;
        }
      }
      W.prototype.bytesPerElement = 24, Ot("StructArrayLayout4i4ui4i24", W);
      class se extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, c);
        }
        emplace(t, n, c, f) {
          const v = 3 * t;
          return this.float32[v + 0] = n, this.float32[v + 1] = c, this.float32[v + 2] = f, t;
        }
      }
      se.prototype.bytesPerElement = 12, Ot("StructArrayLayout3f12", se);
      class le extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint32[1 * t + 0] = n, t;
        }
      }
      le.prototype.bytesPerElement = 4, Ot("StructArrayLayout1ul4", le);
      class de extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x, E, T, M) {
          const R = this.length;
          return this.resize(R + 1), this.emplace(R, t, n, c, f, v, x, E, T, M);
        }
        emplace(t, n, c, f, v, x, E, T, M, R) {
          const U = 10 * t, H = 5 * t;
          return this.int16[U + 0] = n, this.int16[U + 1] = c, this.int16[U + 2] = f, this.int16[U + 3] = v, this.int16[U + 4] = x, this.int16[U + 5] = E, this.uint32[H + 3] = T, this.uint16[U + 8] = M, this.uint16[U + 9] = R, t;
        }
      }
      de.prototype.bytesPerElement = 20, Ot("StructArrayLayout6i1ul2ui20", de);
      class ce extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, c, f, v, x);
        }
        emplace(t, n, c, f, v, x, E) {
          const T = 6 * t;
          return this.int16[T + 0] = n, this.int16[T + 1] = c, this.int16[T + 2] = f, this.int16[T + 3] = v, this.int16[T + 4] = x, this.int16[T + 5] = E, t;
        }
      }
      ce.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i2i2i12", ce);
      class we extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, t, n, c, f, v);
        }
        emplace(t, n, c, f, v, x) {
          const E = 4 * t, T = 8 * t;
          return this.float32[E + 0] = n, this.float32[E + 1] = c, this.float32[E + 2] = f, this.int16[T + 6] = v, this.int16[T + 7] = x, t;
        }
      }
      we.prototype.bytesPerElement = 16, Ot("StructArrayLayout2f1f2i16", we);
      class Le extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, c, f, v, x);
        }
        emplace(t, n, c, f, v, x, E) {
          const T = 16 * t, M = 4 * t, R = 8 * t;
          return this.uint8[T + 0] = n, this.uint8[T + 1] = c, this.float32[M + 1] = f, this.float32[M + 2] = v, this.int16[R + 6] = x, this.int16[R + 7] = E, t;
        }
      }
      Le.prototype.bytesPerElement = 16, Ot("StructArrayLayout2ub2f2i16", Le);
      class Ie extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, c);
        }
        emplace(t, n, c, f) {
          const v = 3 * t;
          return this.uint16[v + 0] = n, this.uint16[v + 1] = c, this.uint16[v + 2] = f, t;
        }
      }
      Ie.prototype.bytesPerElement = 6, Ot("StructArrayLayout3ui6", Ie);
      class it extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe) {
          const Xe = this.length;
          return this.resize(Xe + 1), this.emplace(Xe, t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe);
        }
        emplace(t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe, Xe) {
          const Be = 24 * t, Ge = 12 * t, at = 48 * t;
          return this.int16[Be + 0] = n, this.int16[Be + 1] = c, this.uint16[Be + 2] = f, this.uint16[Be + 3] = v, this.uint32[Ge + 2] = x, this.uint32[Ge + 3] = E, this.uint32[Ge + 4] = T, this.uint16[Be + 10] = M, this.uint16[Be + 11] = R, this.uint16[Be + 12] = U, this.float32[Ge + 7] = H, this.float32[Ge + 8] = J, this.uint8[at + 36] = ne, this.uint8[at + 37] = he, this.uint8[at + 38] = Se, this.uint32[Ge + 10] = Pe, this.int16[Be + 22] = Xe, t;
        }
      }
      it.prototype.bytesPerElement = 48, Ot("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", it);
      class ht extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, at, Ct, Bt, hi, Ft, Nt, Xt, Vt) {
          const qt = this.length;
          return this.resize(qt + 1), this.emplace(qt, t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, at, Ct, Bt, hi, Ft, Nt, Xt, Vt);
        }
        emplace(t, n, c, f, v, x, E, T, M, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, at, Ct, Bt, hi, Ft, Nt, Xt, Vt, qt) {
          const dt = 32 * t, Yt = 16 * t;
          return this.int16[dt + 0] = n, this.int16[dt + 1] = c, this.int16[dt + 2] = f, this.int16[dt + 3] = v, this.int16[dt + 4] = x, this.int16[dt + 5] = E, this.int16[dt + 6] = T, this.int16[dt + 7] = M, this.uint16[dt + 8] = R, this.uint16[dt + 9] = U, this.uint16[dt + 10] = H, this.uint16[dt + 11] = J, this.uint16[dt + 12] = ne, this.uint16[dt + 13] = he, this.uint16[dt + 14] = Se, this.uint16[dt + 15] = Pe, this.uint16[dt + 16] = Xe, this.uint16[dt + 17] = Be, this.uint16[dt + 18] = Ge, this.uint16[dt + 19] = at, this.uint16[dt + 20] = Ct, this.uint16[dt + 21] = Bt, this.uint16[dt + 22] = hi, this.uint32[Yt + 12] = Ft, this.float32[Yt + 13] = Nt, this.float32[Yt + 14] = Xt, this.uint16[dt + 30] = Vt, this.uint16[dt + 31] = qt, t;
        }
      }
      ht.prototype.bytesPerElement = 64, Ot("StructArrayLayout8i15ui1ul2f2ui64", ht);
      class _t extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.float32[1 * t + 0] = n, t;
        }
      }
      _t.prototype.bytesPerElement = 4, Ot("StructArrayLayout1f4", _t);
      class wt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, c);
        }
        emplace(t, n, c, f) {
          const v = 3 * t;
          return this.uint16[6 * t + 0] = n, this.float32[v + 1] = c, this.float32[v + 2] = f, t;
        }
      }
      wt.prototype.bytesPerElement = 12, Ot("StructArrayLayout1ui2f12", wt);
      class bt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, c);
        }
        emplace(t, n, c, f) {
          const v = 4 * t;
          return this.uint32[2 * t + 0] = n, this.uint16[v + 2] = c, this.uint16[v + 3] = f, t;
        }
      }
      bt.prototype.bytesPerElement = 8, Ot("StructArrayLayout1ul2ui8", bt);
      class yt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, t, n);
        }
        emplace(t, n, c) {
          const f = 2 * t;
          return this.uint16[f + 0] = n, this.uint16[f + 1] = c, t;
        }
      }
      yt.prototype.bytesPerElement = 4, Ot("StructArrayLayout2ui4", yt);
      class St extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint16[1 * t + 0] = n, t;
        }
      }
      St.prototype.bytesPerElement = 2, Ot("StructArrayLayout1ui2", St);
      class Zt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, c, f) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, t, n, c, f);
        }
        emplace(t, n, c, f, v) {
          const x = 4 * t;
          return this.float32[x + 0] = n, this.float32[x + 1] = c, this.float32[x + 2] = f, this.float32[x + 3] = v, t;
        }
      }
      Zt.prototype.bytesPerElement = 16, Ot("StructArrayLayout4f16", Zt);
      class Tt extends d {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new j(this.anchorPointX, this.anchorPointY);
        }
      }
      Tt.prototype.size = 20;
      class kt extends de {
        get(t) {
          return new Tt(this, t);
        }
      }
      Ot("CollisionBoxArray", kt);
      class Wt extends d {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 37] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 38] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 10] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Wt.prototype.size = 48;
      class di extends it {
        get(t) {
          return new Wt(this, t);
        }
      }
      Ot("PlacedSymbolArray", di);
      class ci extends d {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 12] = t;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      ci.prototype.size = 64;
      class gi extends ht {
        get(t) {
          return new ci(this, t);
        }
      }
      Ot("SymbolInstanceArray", gi);
      class Ei extends _t {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      Ot("GlyphOffsetArray", Ei);
      class qi extends P {
        getx(t) {
          return this.int16[3 * t + 0];
        }
        gety(t) {
          return this.int16[3 * t + 1];
        }
        gettileUnitDistanceFromAnchor(t) {
          return this.int16[3 * t + 2];
        }
      }
      Ot("SymbolLineVertexArray", qi);
      class sr extends d {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      sr.prototype.size = 12;
      class Fi extends wt {
        get(t) {
          return new sr(this, t);
        }
      }
      Ot("TextAnchorOffsetArray", Fi);
      class yr extends d {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      yr.prototype.size = 8;
      class Ui extends bt {
        get(t) {
          return new yr(this, t);
        }
      }
      Ot("FeatureIndexArray", Ui);
      class pr extends C {
      }
      class kr extends C {
      }
      class pn extends C {
      }
      class Mn extends N {
      }
      class ar extends Z {
      }
      class Ea extends G {
      }
      class Nn extends V {
      }
      class gl extends W {
      }
      class Po extends se {
      }
      class en extends le {
      }
      class fn extends ce {
      }
      class Rr extends Le {
      }
      class tn extends Ie {
      }
      class Ar extends yt {
      }
      const Vr = w([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: rn } = Vr;
      class Li {
        constructor(t = []) {
          this.segments = t;
        }
        prepareSegment(t, n, c, f) {
          let v = this.segments[this.segments.length - 1];
          return t > Li.MAX_VERTEX_ARRAY_LENGTH && xe(`Max vertices per segment is ${Li.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!v || v.vertexLength + t > Li.MAX_VERTEX_ARRAY_LENGTH || v.sortKey !== f) && (v = { vertexOffset: n.length, primitiveOffset: c.length, vertexLength: 0, primitiveLength: 0 }, f !== void 0 && (v.sortKey = f), this.segments.push(v)), v;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
        }
        static simpleSegment(t, n, c, f) {
          return new Li([{ vertexOffset: t, primitiveOffset: n, vertexLength: c, primitiveLength: f, vaos: {}, sortKey: 0 }]);
        }
      }
      function zs(i, t) {
        return 256 * (i = je(Math.floor(i), 0, 255)) + je(Math.floor(t), 0, 255);
      }
      Li.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ot("SegmentVector", Li);
      const Ca = w([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var ea = { exports: {} }, Lo = { exports: {} };
      Lo.exports = function(i, t) {
        var n, c, f, v, x, E, T, M;
        for (c = i.length - (n = 3 & i.length), f = t, x = 3432918353, E = 461845907, M = 0; M < c; ) T = 255 & i.charCodeAt(M) | (255 & i.charCodeAt(++M)) << 8 | (255 & i.charCodeAt(++M)) << 16 | (255 & i.charCodeAt(++M)) << 24, ++M, f = 27492 + (65535 & (v = 5 * (65535 & (f = (f ^= T = (65535 & (T = (T = (65535 & T) * x + (((T >>> 16) * x & 65535) << 16) & 4294967295) << 15 | T >>> 17)) * E + (((T >>> 16) * E & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
        switch (T = 0, n) {
          case 3:
            T ^= (255 & i.charCodeAt(M + 2)) << 16;
          case 2:
            T ^= (255 & i.charCodeAt(M + 1)) << 8;
          case 1:
            f ^= T = (65535 & (T = (T = (65535 & (T ^= 255 & i.charCodeAt(M))) * x + (((T >>> 16) * x & 65535) << 16) & 4294967295) << 15 | T >>> 17)) * E + (((T >>> 16) * E & 65535) << 16) & 4294967295;
        }
        return f ^= i.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0;
      };
      var Pc = Lo.exports, Gu = { exports: {} };
      Gu.exports = function(i, t) {
        for (var n, c = i.length, f = t ^ c, v = 0; c >= 4; ) n = 1540483477 * (65535 & (n = 255 & i.charCodeAt(v) | (255 & i.charCodeAt(++v)) << 8 | (255 & i.charCodeAt(++v)) << 16 | (255 & i.charCodeAt(++v)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), c -= 4, ++v;
        switch (c) {
          case 3:
            f ^= (255 & i.charCodeAt(v + 2)) << 16;
          case 2:
            f ^= (255 & i.charCodeAt(v + 1)) << 8;
          case 1:
            f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(v))) + ((1540483477 * (f >>> 16) & 65535) << 16);
        }
        return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0;
      };
      var Fs = Pc, ta = Gu.exports;
      ea.exports = Fs, ea.exports.murmur3 = Fs, ea.exports.murmur2 = ta;
      var ql = k(ea.exports);
      class _l {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(t, n, c, f) {
          this.ids.push(Ul(t)), this.positions.push(n, c, f);
        }
        getPositions(t) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const n = Ul(t);
          let c = 0, f = this.ids.length - 1;
          for (; c < f; ) {
            const x = c + f >> 1;
            this.ids[x] >= n ? f = x : c = x + 1;
          }
          const v = [];
          for (; this.ids[c] === n; ) v.push({ index: this.positions[3 * c], start: this.positions[3 * c + 1], end: this.positions[3 * c + 2] }), c++;
          return v;
        }
        static serialize(t, n) {
          const c = new Float64Array(t.ids), f = new Uint32Array(t.positions);
          return yl(c, f, 0, c.length - 1), n && n.push(c.buffer, f.buffer), { ids: c, positions: f };
        }
        static deserialize(t) {
          const n = new _l();
          return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n;
        }
      }
      function Ul(i) {
        const t = +i;
        return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ql(String(i));
      }
      function yl(i, t, n, c) {
        for (; n < c; ) {
          const f = i[n + c >> 1];
          let v = n - 1, x = c + 1;
          for (; ; ) {
            do
              v++;
            while (i[v] < f);
            do
              x--;
            while (i[x] > f);
            if (v >= x) break;
            ia(i, v, x), ia(t, 3 * v, 3 * x), ia(t, 3 * v + 1, 3 * x + 1), ia(t, 3 * v + 2, 3 * x + 2);
          }
          x - n < c - x ? (yl(i, t, n, x), n = x + 1) : (yl(i, t, x + 1, c), c = x);
        }
      }
      function ia(i, t, n) {
        const c = i[t];
        i[t] = i[n], i[n] = c;
      }
      Ot("FeaturePositionMap", _l);
      class Mo {
        constructor(t, n) {
          this.gl = t.gl, this.location = n;
        }
      }
      class bu extends Mo {
        constructor(t, n) {
          super(t, n), this.current = 0;
        }
        set(t) {
          this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
        }
      }
      class xu extends Mo {
        constructor(t, n) {
          super(t, n), this.current = [0, 0, 0, 0];
        }
        set(t) {
          t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
        }
      }
      class Hu extends Mo {
        constructor(t, n) {
          super(t, n), this.current = ji.transparent;
        }
        set(t) {
          t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
        }
      }
      const wu = new Float32Array(16);
      function Wu(i) {
        return [zs(255 * i.r, 255 * i.g), zs(255 * i.b, 255 * i.a)];
      }
      class Au {
        constructor(t, n, c) {
          this.value = t, this.uniformNames = n.map((f) => `u_${f}`), this.type = c;
        }
        setUniform(t, n, c) {
          t.set(c.constantOr(this.value));
        }
        getBinding(t, n, c) {
          return this.type === "color" ? new Hu(t, n) : new bu(t, n);
        }
      }
      class Ya {
        constructor(t, n) {
          this.uniformNames = n.map((c) => `u_${c}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t, n) {
          this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
        }
        setUniform(t, n, c, f) {
          const v = f === "u_pattern_to" ? this.patternTo : f === "u_pattern_from" ? this.patternFrom : f === "u_pixel_ratio_to" ? this.pixelRatioTo : f === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          v && t.set(v);
        }
        getBinding(t, n, c) {
          return c.substr(0, 9) === "u_pattern" ? new xu(t, n) : new bu(t, n);
        }
      }
      class Ta {
        constructor(t, n, c, f) {
          this.expression = t, this.type = c, this.maxValue = 0, this.paintVertexAttributes = n.map((v) => ({ name: `a_${v}`, type: "Float32", components: c === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new f();
        }
        populatePaintArray(t, n, c, f, v) {
          const x = this.paintVertexArray.length, E = this.expression.evaluate(new Ji(0), n, {}, f, [], v);
          this.paintVertexArray.resize(t), this._setPaintValue(x, t, E);
        }
        updatePaintArray(t, n, c, f) {
          const v = this.expression.evaluate({ zoom: 0 }, c, f);
          this._setPaintValue(t, n, v);
        }
        _setPaintValue(t, n, c) {
          if (this.type === "color") {
            const f = Wu(c);
            for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, f[0], f[1]);
          } else {
            for (let f = t; f < n; f++) this.paintVertexArray.emplace(f, c);
            this.maxValue = Math.max(this.maxValue, Math.abs(c));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class ys {
        constructor(t, n, c, f, v, x) {
          this.expression = t, this.uniformNames = n.map((E) => `u_${E}_t`), this.type = c, this.useIntegerZoom = f, this.zoom = v, this.maxValue = 0, this.paintVertexAttributes = n.map((E) => ({ name: `a_${E}`, type: "Float32", components: c === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new x();
        }
        populatePaintArray(t, n, c, f, v) {
          const x = this.expression.evaluate(new Ji(this.zoom), n, {}, f, [], v), E = this.expression.evaluate(new Ji(this.zoom + 1), n, {}, f, [], v), T = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValue(T, t, x, E);
        }
        updatePaintArray(t, n, c, f) {
          const v = this.expression.evaluate({ zoom: this.zoom }, c, f), x = this.expression.evaluate({ zoom: this.zoom + 1 }, c, f);
          this._setPaintValue(t, n, v, x);
        }
        _setPaintValue(t, n, c, f) {
          if (this.type === "color") {
            const v = Wu(c), x = Wu(f);
            for (let E = t; E < n; E++) this.paintVertexArray.emplace(E, v[0], v[1], x[0], x[1]);
          } else {
            for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, c, f);
            this.maxValue = Math.max(this.maxValue, Math.abs(c), Math.abs(f));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, n) {
          const c = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, f = je(this.expression.interpolationFactor(c, this.zoom, this.zoom + 1), 0, 1);
          t.set(f);
        }
        getBinding(t, n, c) {
          return new bu(t, n);
        }
      }
      class zn {
        constructor(t, n, c, f, v, x) {
          this.expression = t, this.type = n, this.useIntegerZoom = c, this.zoom = f, this.layerId = x, this.zoomInPaintVertexArray = new v(), this.zoomOutPaintVertexArray = new v();
        }
        populatePaintArray(t, n, c) {
          const f = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(f, t, n.patterns && n.patterns[this.layerId], c);
        }
        updatePaintArray(t, n, c, f, v) {
          this._setPaintValues(t, n, c.patterns && c.patterns[this.layerId], v);
        }
        _setPaintValues(t, n, c, f) {
          if (!f || !c) return;
          const { min: v, mid: x, max: E } = c, T = f[v], M = f[x], R = f[E];
          if (T && M && R) for (let U = t; U < n; U++) this.zoomInPaintVertexArray.emplace(U, M.tl[0], M.tl[1], M.br[0], M.br[1], T.tl[0], T.tl[1], T.br[0], T.br[1], M.pixelRatio, T.pixelRatio), this.zoomOutPaintVertexArray.emplace(U, M.tl[0], M.tl[1], M.br[0], M.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], M.pixelRatio, R.pixelRatio);
        }
        upload(t) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Ca.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Ca.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Lc {
        constructor(t, n, c) {
          this.binders = {}, this._buffers = [];
          const f = [];
          for (const v in t.paint._values) {
            if (!c(v)) continue;
            const x = t.paint.get(v);
            if (!(x instanceof _s && Ds(x.property.specification))) continue;
            const E = Cd(v, t.type), T = x.value, M = x.property.specification.type, R = x.property.useIntegerZoom, U = x.property.specification["property-type"], H = U === "cross-faded" || U === "cross-faded-data-driven";
            if (T.kind === "constant") this.binders[v] = H ? new Ya(T.value, E) : new Au(T.value, E, M), f.push(`/u_${v}`);
            else if (T.kind === "source" || H) {
              const J = Mc(v, M, "source");
              this.binders[v] = H ? new zn(T, M, R, n, J, t.id) : new Ta(T, E, M, J), f.push(`/a_${v}`);
            } else {
              const J = Mc(v, M, "composite");
              this.binders[v] = new ys(T, E, M, R, n, J), f.push(`/z_${v}`);
            }
          }
          this.cacheKey = f.sort().join("");
        }
        getMaxValue(t) {
          const n = this.binders[t];
          return n instanceof Ta || n instanceof ys ? n.maxValue : 0;
        }
        populatePaintArrays(t, n, c, f, v) {
          for (const x in this.binders) {
            const E = this.binders[x];
            (E instanceof Ta || E instanceof ys || E instanceof zn) && E.populatePaintArray(t, n, c, f, v);
          }
        }
        setConstantPatternPositions(t, n) {
          for (const c in this.binders) {
            const f = this.binders[c];
            f instanceof Ya && f.setConstantPatternPositions(t, n);
          }
        }
        updatePaintArrays(t, n, c, f, v) {
          let x = !1;
          for (const E in t) {
            const T = n.getPositions(E);
            for (const M of T) {
              const R = c.feature(M.index);
              for (const U in this.binders) {
                const H = this.binders[U];
                if ((H instanceof Ta || H instanceof ys || H instanceof zn) && H.expression.isStateDependent === !0) {
                  const J = f.paint.get(U);
                  H.expression = J.value, H.updatePaintArray(M.start, M.end, R, t[E], v), x = !0;
                }
              }
            }
          }
          return x;
        }
        defines() {
          const t = [];
          for (const n in this.binders) {
            const c = this.binders[n];
            (c instanceof Au || c instanceof Ya) && t.push(...c.uniformNames.map((f) => `#define HAS_UNIFORM_${f}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const n in this.binders) {
            const c = this.binders[n];
            if (c instanceof Ta || c instanceof ys) for (let f = 0; f < c.paintVertexAttributes.length; f++) t.push(c.paintVertexAttributes[f].name);
            else if (c instanceof zn) for (let f = 0; f < Ca.members.length; f++) t.push(Ca.members[f].name);
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const n in this.binders) {
            const c = this.binders[n];
            if (c instanceof Au || c instanceof Ya || c instanceof ys) for (const f of c.uniformNames) t.push(f);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t, n) {
          const c = [];
          for (const f in this.binders) {
            const v = this.binders[f];
            if (v instanceof Au || v instanceof Ya || v instanceof ys) {
              for (const x of v.uniformNames) if (n[x]) {
                const E = v.getBinding(t, n[x], x);
                c.push({ name: x, property: f, binding: E });
              }
            }
          }
          return c;
        }
        setUniforms(t, n, c, f) {
          for (const { name: v, property: x, binding: E } of n) this.binders[x].setUniform(E, f, c.get(x), v);
        }
        updatePaintBuffers(t) {
          this._buffers = [];
          for (const n in this.binders) {
            const c = this.binders[n];
            if (t && c instanceof zn) {
              const f = t.fromScale === 2 ? c.zoomInPaintVertexBuffer : c.zoomOutPaintVertexBuffer;
              f && this._buffers.push(f);
            } else (c instanceof Ta || c instanceof ys) && c.paintVertexBuffer && this._buffers.push(c.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const n in this.binders) {
            const c = this.binders[n];
            (c instanceof Ta || c instanceof ys || c instanceof zn) && c.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const n = this.binders[t];
            (n instanceof Ta || n instanceof ys || n instanceof zn) && n.destroy();
          }
        }
      }
      class No {
        constructor(t, n, c = () => !0) {
          this.programConfigurations = {};
          for (const f of t) this.programConfigurations[f.id] = new Lc(f, n, c);
          this.needsUpload = !1, this._featureMap = new _l(), this._bufferOffset = 0;
        }
        populatePaintArrays(t, n, c, f, v, x) {
          for (const E in this.programConfigurations) this.programConfigurations[E].populatePaintArrays(t, n, f, v, x);
          n.id !== void 0 && this._featureMap.add(n.id, c, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
        }
        updatePaintArrays(t, n, c, f) {
          for (const v of c) this.needsUpload = this.programConfigurations[v.id].updatePaintArrays(t, this._featureMap, n, v, f) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
        }
      }
      function Cd(i, t) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${t}-`, "").replace(/-/g, "_")];
      }
      function Mc(i, t, n) {
        const c = { color: { source: G, composite: Zt }, number: { source: _t, composite: G } }, f = function(v) {
          return { "line-pattern": { source: Nn, composite: Nn }, "fill-pattern": { source: Nn, composite: Nn }, "fill-extrusion-pattern": { source: Nn, composite: Nn } }[v];
        }(i);
        return f && f[n] || c[t][n];
      }
      Ot("ConstantBinder", Au), Ot("CrossFadedConstantBinder", Ya), Ot("SourceExpressionBinder", Ta), Ot("CrossFadedCompositeBinder", zn), Ot("CompositeExpressionBinder", ys), Ot("ProgramConfiguration", Lc, { omit: ["_buffers"] }), Ot("ProgramConfigurationSet", No);
      const or = 8192, Nc = Math.pow(2, 14) - 1, zc = -Nc - 1;
      function vl(i) {
        const t = or / i.extent, n = i.loadGeometry();
        for (let c = 0; c < n.length; c++) {
          const f = n[c];
          for (let v = 0; v < f.length; v++) {
            const x = f[v], E = Math.round(x.x * t), T = Math.round(x.y * t);
            x.x = je(E, zc, Nc), x.y = je(T, zc, Nc), (E < x.x || E > x.x + 1 || T < x.y || T > x.y + 1) && xe("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return n;
      }
      function zo(i, t) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: t ? vl(i) : [] };
      }
      function Xu(i, t, n, c, f) {
        i.emplaceBack(2 * t + (c + 1) / 2, 2 * n + (f + 1) / 2);
      }
      class bl {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new kr(), this.indexArray = new tn(), this.segments = new Li(), this.programConfigurations = new No(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, c) {
          const f = this.layers[0], v = [];
          let x = null, E = !1;
          f.type === "circle" && (x = f.layout.get("circle-sort-key"), E = !x.isConstant());
          for (const { feature: T, id: M, index: R, sourceLayerIndex: U } of t) {
            const H = this.layers[0]._featureFilter.needGeometry, J = zo(T, H);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), J, c)) continue;
            const ne = E ? x.evaluate(J, {}, c) : void 0, he = { id: M, properties: T.properties, type: T.type, sourceLayerIndex: U, index: R, geometry: H ? J.geometry : vl(T), patterns: {}, sortKey: ne };
            v.push(he);
          }
          E && v.sort((T, M) => T.sortKey - M.sortKey);
          for (const T of v) {
            const { geometry: M, index: R, sourceLayerIndex: U } = T, H = t[R].feature;
            this.addFeature(T, M, R, c), n.featureIndex.insert(H, M, R, U, this.index);
          }
        }
        update(t, n, c) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, c);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, rn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t, n, c, f) {
          for (const v of n) for (const x of v) {
            const E = x.x, T = x.y;
            if (E < 0 || E >= or || T < 0 || T >= or) continue;
            const M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), R = M.vertexLength;
            Xu(this.layoutVertexArray, E, T, -1, -1), Xu(this.layoutVertexArray, E, T, 1, -1), Xu(this.layoutVertexArray, E, T, 1, 1), Xu(this.layoutVertexArray, E, T, -1, 1), this.indexArray.emplaceBack(R, R + 1, R + 2), this.indexArray.emplaceBack(R, R + 3, R + 2), M.vertexLength += 4, M.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, {}, f);
        }
      }
      function Yu(i, t) {
        for (let n = 0; n < i.length; n++) if (Bo(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (Bo(i, t[n])) return !0;
        return !!Da(i, t);
      }
      function Ju(i, t, n) {
        return !!Bo(i, t) || !!Su(t, i, n);
      }
      function ka(i, t) {
        if (i.length === 1) return kh(t, i[0]);
        for (let n = 0; n < t.length; n++) {
          const c = t[n];
          for (let f = 0; f < c.length; f++) if (Bo(i, c[f])) return !0;
        }
        for (let n = 0; n < i.length; n++) if (kh(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (Da(i, t[n])) return !0;
        return !1;
      }
      function Fo(i, t, n) {
        if (i.length > 1) {
          if (Da(i, t)) return !0;
          for (let c = 0; c < t.length; c++) if (Su(t[c], i, n)) return !0;
        }
        for (let c = 0; c < i.length; c++) if (Su(i[c], t, n)) return !0;
        return !1;
      }
      function Da(i, t) {
        if (i.length === 0 || t.length === 0) return !1;
        for (let n = 0; n < i.length - 1; n++) {
          const c = i[n], f = i[n + 1];
          for (let v = 0; v < t.length - 1; v++) if (Ku(c, f, t[v], t[v + 1])) return !0;
        }
        return !1;
      }
      function Ku(i, t, n, c) {
        return ye(i, n, c) !== ye(t, n, c) && ye(i, t, n) !== ye(i, t, c);
      }
      function Su(i, t, n) {
        const c = n * n;
        if (t.length === 1) return i.distSqr(t[0]) < c;
        for (let f = 1; f < t.length; f++) if (Fc(i, t[f - 1], t[f]) < c) return !0;
        return !1;
      }
      function Fc(i, t, n) {
        const c = t.distSqr(n);
        if (c === 0) return i.distSqr(t);
        const f = ((i.x - t.x) * (n.x - t.x) + (i.y - t.y) * (n.y - t.y)) / c;
        return i.distSqr(f < 0 ? t : f > 1 ? n : n.sub(t)._mult(f)._add(t));
      }
      function kh(i, t) {
        let n, c, f, v = !1;
        for (let x = 0; x < i.length; x++) {
          n = i[x];
          for (let E = 0, T = n.length - 1; E < n.length; T = E++) c = n[E], f = n[T], c.y > t.y != f.y > t.y && t.x < (f.x - c.x) * (t.y - c.y) / (f.y - c.y) + c.x && (v = !v);
        }
        return v;
      }
      function Bo(i, t) {
        let n = !1;
        for (let c = 0, f = i.length - 1; c < i.length; f = c++) {
          const v = i[c], x = i[f];
          v.y > t.y != x.y > t.y && t.x < (x.x - v.x) * (t.y - v.y) / (x.y - v.y) + v.x && (n = !n);
        }
        return n;
      }
      function Bc(i, t, n) {
        const c = n[0], f = n[2];
        if (i.x < c.x && t.x < c.x || i.x > f.x && t.x > f.x || i.y < c.y && t.y < c.y || i.y > f.y && t.y > f.y) return !1;
        const v = ye(i, t, n[0]);
        return v !== ye(i, t, n[1]) || v !== ye(i, t, n[2]) || v !== ye(i, t, n[3]);
      }
      function Rc(i, t, n) {
        const c = t.paint.get(i).value;
        return c.kind === "constant" ? c.value : n.programConfigurations.get(t.id).getMaxValue(i);
      }
      function Dh(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function Ih(i, t, n, c, f) {
        if (!t[0] && !t[1]) return i;
        const v = j.convert(t)._mult(f);
        n === "viewport" && v._rotate(-c);
        const x = [];
        for (let E = 0; E < i.length; E++) x.push(i[E].sub(v));
        return x;
      }
      let bf, xf;
      Ot("CircleBucket", bl, { omit: ["layers"] });
      var L1 = { get paint() {
        return xf = xf || new h({ "circle-radius": new li(Y.paint_circle["circle-radius"]), "circle-color": new li(Y.paint_circle["circle-color"]), "circle-blur": new li(Y.paint_circle["circle-blur"]), "circle-opacity": new li(Y.paint_circle["circle-opacity"]), "circle-translate": new Gt(Y.paint_circle["circle-translate"]), "circle-translate-anchor": new Gt(Y.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Gt(Y.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Gt(Y.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new li(Y.paint_circle["circle-stroke-width"]), "circle-stroke-color": new li(Y.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new li(Y.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return bf = bf || new h({ "circle-sort-key": new li(Y.layout_circle["circle-sort-key"]) });
      } }, Yn = 1e-6, Qu = typeof Float32Array < "u" ? Float32Array : Array;
      function Td(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function wf(i, t, n) {
        var c = t[0], f = t[1], v = t[2], x = t[3], E = t[4], T = t[5], M = t[6], R = t[7], U = t[8], H = t[9], J = t[10], ne = t[11], he = t[12], Se = t[13], Pe = t[14], Xe = t[15], Be = n[0], Ge = n[1], at = n[2], Ct = n[3];
        return i[0] = Be * c + Ge * E + at * U + Ct * he, i[1] = Be * f + Ge * T + at * H + Ct * Se, i[2] = Be * v + Ge * M + at * J + Ct * Pe, i[3] = Be * x + Ge * R + at * ne + Ct * Xe, i[4] = (Be = n[4]) * c + (Ge = n[5]) * E + (at = n[6]) * U + (Ct = n[7]) * he, i[5] = Be * f + Ge * T + at * H + Ct * Se, i[6] = Be * v + Ge * M + at * J + Ct * Pe, i[7] = Be * x + Ge * R + at * ne + Ct * Xe, i[8] = (Be = n[8]) * c + (Ge = n[9]) * E + (at = n[10]) * U + (Ct = n[11]) * he, i[9] = Be * f + Ge * T + at * H + Ct * Se, i[10] = Be * v + Ge * M + at * J + Ct * Pe, i[11] = Be * x + Ge * R + at * ne + Ct * Xe, i[12] = (Be = n[12]) * c + (Ge = n[13]) * E + (at = n[14]) * U + (Ct = n[15]) * he, i[13] = Be * f + Ge * T + at * H + Ct * Se, i[14] = Be * v + Ge * M + at * J + Ct * Pe, i[15] = Be * x + Ge * R + at * ne + Ct * Xe, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, t = arguments.length; t--; ) i += arguments[t] * arguments[t];
        return Math.sqrt(i);
      });
      var Oc, M1 = wf;
      function Ph(i, t, n) {
        var c = t[0], f = t[1], v = t[2], x = t[3];
        return i[0] = n[0] * c + n[4] * f + n[8] * v + n[12] * x, i[1] = n[1] * c + n[5] * f + n[9] * v + n[13] * x, i[2] = n[2] * c + n[6] * f + n[10] * v + n[14] * x, i[3] = n[3] * c + n[7] * f + n[11] * v + n[15] * x, i;
      }
      Oc = new Qu(4), Qu != Float32Array && (Oc[0] = 0, Oc[1] = 0, Oc[2] = 0, Oc[3] = 0);
      class N1 extends r {
        constructor(t) {
          super(t, L1);
        }
        createBucket(t) {
          return new bl(t);
        }
        queryRadius(t) {
          const n = t;
          return Rc("circle-radius", this, n) + Rc("circle-stroke-width", this, n) + Dh(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t, n, c, f, v, x, E, T) {
          const M = Ih(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), x.angle, E), R = this.paint.get("circle-radius").evaluate(n, c) + this.paint.get("circle-stroke-width").evaluate(n, c), U = this.paint.get("circle-pitch-alignment") === "map", H = U ? M : function(ne, he) {
            return ne.map((Se) => Af(Se, he));
          }(M, T), J = U ? R * E : R;
          for (const ne of f) for (const he of ne) {
            const Se = U ? he : Af(he, T);
            let Pe = J;
            const Xe = Ph([], [he.x, he.y, 0, 1], T);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Pe *= Xe[3] / x.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Pe *= x.cameraToCenterDistance / Xe[3]), Ju(H, Se, Pe)) return !0;
          }
          return !1;
        }
      }
      function Af(i, t) {
        const n = Ph([], [i.x, i.y, 0, 1], t);
        return new j(n[0] / n[3], n[1] / n[3]);
      }
      class Sf extends bl {
      }
      let Ef;
      Ot("HeatmapBucket", Sf, { omit: ["layers"] });
      var z1 = { get paint() {
        return Ef = Ef || new h({ "heatmap-radius": new li(Y.paint_heatmap["heatmap-radius"]), "heatmap-weight": new li(Y.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Gt(Y.paint_heatmap["heatmap-intensity"]), "heatmap-color": new S(Y.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Gt(Y.paint_heatmap["heatmap-opacity"]) });
      } };
      function kd(i, { width: t, height: n }, c, f) {
        if (f) {
          if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
          else if (f.length !== t * n * c) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${t * n * c}`);
        } else f = new Uint8Array(t * n * c);
        return i.width = t, i.height = n, i.data = f, i;
      }
      function Cf(i, { width: t, height: n }, c) {
        if (t === i.width && n === i.height) return;
        const f = kd({}, { width: t, height: n }, c);
        Dd(i, f, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, t), height: Math.min(i.height, n) }, c), i.width = t, i.height = n, i.data = f.data;
      }
      function Dd(i, t, n, c, f, v) {
        if (f.width === 0 || f.height === 0) return t;
        if (f.width > i.width || f.height > i.height || n.x > i.width - f.width || n.y > i.height - f.height) throw new RangeError("out of range source coordinates for image copy");
        if (f.width > t.width || f.height > t.height || c.x > t.width - f.width || c.y > t.height - f.height) throw new RangeError("out of range destination coordinates for image copy");
        const x = i.data, E = t.data;
        if (x === E) throw new Error("srcData equals dstData, so image is already copied");
        for (let T = 0; T < f.height; T++) {
          const M = ((n.y + T) * i.width + n.x) * v, R = ((c.y + T) * t.width + c.x) * v;
          for (let U = 0; U < f.width * v; U++) E[R + U] = x[M + U];
        }
        return t;
      }
      class jc {
        constructor(t, n) {
          kd(this, t, 1, n);
        }
        resize(t) {
          Cf(this, t, 1);
        }
        clone() {
          return new jc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, c, f, v) {
          Dd(t, n, c, f, v, 1);
        }
      }
      class ra {
        constructor(t, n) {
          kd(this, t, 4, n);
        }
        resize(t) {
          Cf(this, t, 4);
        }
        replace(t, n) {
          n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
        }
        clone() {
          return new ra({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, c, f, v) {
          Dd(t, n, c, f, v, 4);
        }
      }
      function Tf(i) {
        const t = {}, n = i.resolution || 256, c = i.clips ? i.clips.length : 1, f = i.image || new ra({ width: n, height: c });
        if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
        const v = (x, E, T) => {
          t[i.evaluationKey] = T;
          const M = i.expression.evaluate(t);
          f.data[x + E + 0] = Math.floor(255 * M.r / M.a), f.data[x + E + 1] = Math.floor(255 * M.g / M.a), f.data[x + E + 2] = Math.floor(255 * M.b / M.a), f.data[x + E + 3] = Math.floor(255 * M.a);
        };
        if (i.clips) for (let x = 0, E = 0; x < c; ++x, E += 4 * n) for (let T = 0, M = 0; T < n; T++, M += 4) {
          const R = T / (n - 1), { start: U, end: H } = i.clips[x];
          v(E, M, U * (1 - R) + H * R);
        }
        else for (let x = 0, E = 0; x < n; x++, E += 4) v(0, E, x / (n - 1));
        return f;
      }
      Ot("AlphaImage", jc), Ot("RGBAImage", ra);
      const Id = "big-fb";
      class F1 extends r {
        createBucket(t) {
          return new Sf(t);
        }
        constructor(t) {
          super(t, z1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Tf({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(Id) && this.heatmapFbos.delete(Id);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let kf;
      var B1 = { get paint() {
        return kf = kf || new h({ "hillshade-illumination-direction": new Gt(Y.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Gt(Y.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Gt(Y.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Gt(Y.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Gt(Y.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Gt(Y.paint_hillshade["hillshade-accent-color"]) });
      } };
      class R1 extends r {
        constructor(t) {
          super(t, B1);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const O1 = w([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: j1 } = O1;
      function Df(i, t, n = 2) {
        const c = t && t.length, f = c ? t[0] * n : i.length;
        let v = If(i, 0, f, n, !0);
        const x = [];
        if (!v || v.next === v.prev) return x;
        let E, T, M;
        if (c && (v = function(R, U, H, J) {
          const ne = [];
          for (let he = 0, Se = U.length; he < Se; he++) {
            const Pe = If(R, U[he] * J, he < Se - 1 ? U[he + 1] * J : R.length, J, !1);
            Pe === Pe.next && (Pe.steiner = !0), ne.push(W1(Pe));
          }
          ne.sort(Z1);
          for (let he = 0; he < ne.length; he++) H = G1(ne[he], H);
          return H;
        }(i, t, v, n)), i.length > 80 * n) {
          E = 1 / 0, T = 1 / 0;
          let R = -1 / 0, U = -1 / 0;
          for (let H = n; H < f; H += n) {
            const J = i[H], ne = i[H + 1];
            J < E && (E = J), ne < T && (T = ne), J > R && (R = J), ne > U && (U = ne);
          }
          M = Math.max(R - E, U - T), M = M !== 0 ? 32767 / M : 0;
        }
        return qc(v, x, n, E, T, M, 0), x;
      }
      function If(i, t, n, c, f) {
        let v;
        if (f === function(x, E, T, M) {
          let R = 0;
          for (let U = E, H = T - M; U < T; U += M) R += (x[H] - x[U]) * (x[U + 1] + x[H + 1]), H = U;
          return R;
        }(i, t, n, c) > 0) for (let x = t; x < n; x += c) v = Mf(x / c | 0, i[x], i[x + 1], v);
        else for (let x = n - c; x >= t; x -= c) v = Mf(x / c | 0, i[x], i[x + 1], v);
        return v && Lh(v, v.next) && (Vc(v), v = v.next), v;
      }
      function Eu(i, t) {
        if (!i) return i;
        t || (t = i);
        let n, c = i;
        do
          if (n = !1, c.steiner || !Lh(c, c.next) && zr(c.prev, c, c.next) !== 0) c = c.next;
          else {
            if (Vc(c), c = t = c.prev, c === c.next) break;
            n = !0;
          }
        while (n || c !== t);
        return t;
      }
      function qc(i, t, n, c, f, v, x) {
        if (!i) return;
        !x && v && function(T, M, R, U) {
          let H = T;
          do
            H.z === 0 && (H.z = Pd(H.x, H.y, M, R, U)), H.prevZ = H.prev, H.nextZ = H.next, H = H.next;
          while (H !== T);
          H.prevZ.nextZ = null, H.prevZ = null, function(J) {
            let ne, he = 1;
            do {
              let Se, Pe = J;
              J = null;
              let Xe = null;
              for (ne = 0; Pe; ) {
                ne++;
                let Be = Pe, Ge = 0;
                for (let Ct = 0; Ct < he && (Ge++, Be = Be.nextZ, Be); Ct++) ;
                let at = he;
                for (; Ge > 0 || at > 0 && Be; ) Ge !== 0 && (at === 0 || !Be || Pe.z <= Be.z) ? (Se = Pe, Pe = Pe.nextZ, Ge--) : (Se = Be, Be = Be.nextZ, at--), Xe ? Xe.nextZ = Se : J = Se, Se.prevZ = Xe, Xe = Se;
                Pe = Be;
              }
              Xe.nextZ = null, he *= 2;
            } while (ne > 1);
          }(H);
        }(i, c, f, v);
        let E = i;
        for (; i.prev !== i.next; ) {
          const T = i.prev, M = i.next;
          if (v ? U1(i, c, f, v) : q1(i)) t.push(T.i, i.i, M.i), Vc(i), i = M.next, E = M.next;
          else if ((i = M) === E) {
            x ? x === 1 ? qc(i = V1(Eu(i), t), t, n, c, f, v, 2) : x === 2 && $1(i, t, n, c, f, v) : qc(Eu(i), t, n, c, f, v, 1);
            break;
          }
        }
      }
      function q1(i) {
        const t = i.prev, n = i, c = i.next;
        if (zr(t, n, c) >= 0) return !1;
        const f = t.x, v = n.x, x = c.x, E = t.y, T = n.y, M = c.y, R = f < v ? f < x ? f : x : v < x ? v : x, U = E < T ? E < M ? E : M : T < M ? T : M, H = f > v ? f > x ? f : x : v > x ? v : x, J = E > T ? E > M ? E : M : T > M ? T : M;
        let ne = c.next;
        for (; ne !== t; ) {
          if (ne.x >= R && ne.x <= H && ne.y >= U && ne.y <= J && ec(f, E, v, T, x, M, ne.x, ne.y) && zr(ne.prev, ne, ne.next) >= 0) return !1;
          ne = ne.next;
        }
        return !0;
      }
      function U1(i, t, n, c) {
        const f = i.prev, v = i, x = i.next;
        if (zr(f, v, x) >= 0) return !1;
        const E = f.x, T = v.x, M = x.x, R = f.y, U = v.y, H = x.y, J = E < T ? E < M ? E : M : T < M ? T : M, ne = R < U ? R < H ? R : H : U < H ? U : H, he = E > T ? E > M ? E : M : T > M ? T : M, Se = R > U ? R > H ? R : H : U > H ? U : H, Pe = Pd(J, ne, t, n, c), Xe = Pd(he, Se, t, n, c);
        let Be = i.prevZ, Ge = i.nextZ;
        for (; Be && Be.z >= Pe && Ge && Ge.z <= Xe; ) {
          if (Be.x >= J && Be.x <= he && Be.y >= ne && Be.y <= Se && Be !== f && Be !== x && ec(E, R, T, U, M, H, Be.x, Be.y) && zr(Be.prev, Be, Be.next) >= 0 || (Be = Be.prevZ, Ge.x >= J && Ge.x <= he && Ge.y >= ne && Ge.y <= Se && Ge !== f && Ge !== x && ec(E, R, T, U, M, H, Ge.x, Ge.y) && zr(Ge.prev, Ge, Ge.next) >= 0)) return !1;
          Ge = Ge.nextZ;
        }
        for (; Be && Be.z >= Pe; ) {
          if (Be.x >= J && Be.x <= he && Be.y >= ne && Be.y <= Se && Be !== f && Be !== x && ec(E, R, T, U, M, H, Be.x, Be.y) && zr(Be.prev, Be, Be.next) >= 0) return !1;
          Be = Be.prevZ;
        }
        for (; Ge && Ge.z <= Xe; ) {
          if (Ge.x >= J && Ge.x <= he && Ge.y >= ne && Ge.y <= Se && Ge !== f && Ge !== x && ec(E, R, T, U, M, H, Ge.x, Ge.y) && zr(Ge.prev, Ge, Ge.next) >= 0) return !1;
          Ge = Ge.nextZ;
        }
        return !0;
      }
      function V1(i, t) {
        let n = i;
        do {
          const c = n.prev, f = n.next.next;
          !Lh(c, f) && Pf(c, n, n.next, f) && Uc(c, f) && Uc(f, c) && (t.push(c.i, n.i, f.i), Vc(n), Vc(n.next), n = i = f), n = n.next;
        } while (n !== i);
        return Eu(n);
      }
      function $1(i, t, n, c, f, v) {
        let x = i;
        do {
          let E = x.next.next;
          for (; E !== x.prev; ) {
            if (x.i !== E.i && X1(x, E)) {
              let T = Lf(x, E);
              return x = Eu(x, x.next), T = Eu(T, T.next), qc(x, t, n, c, f, v, 0), void qc(T, t, n, c, f, v, 0);
            }
            E = E.next;
          }
          x = x.next;
        } while (x !== i);
      }
      function Z1(i, t) {
        return i.x - t.x;
      }
      function G1(i, t) {
        const n = function(f, v) {
          let x = v;
          const E = f.x, T = f.y;
          let M, R = -1 / 0;
          do {
            if (T <= x.y && T >= x.next.y && x.next.y !== x.y) {
              const he = x.x + (T - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
              if (he <= E && he > R && (R = he, M = x.x < x.next.x ? x : x.next, he === E)) return M;
            }
            x = x.next;
          } while (x !== v);
          if (!M) return null;
          const U = M, H = M.x, J = M.y;
          let ne = 1 / 0;
          x = M;
          do {
            if (E >= x.x && x.x >= H && E !== x.x && ec(T < J ? E : R, T, H, J, T < J ? R : E, T, x.x, x.y)) {
              const he = Math.abs(T - x.y) / (E - x.x);
              Uc(x, f) && (he < ne || he === ne && (x.x > M.x || x.x === M.x && H1(M, x))) && (M = x, ne = he);
            }
            x = x.next;
          } while (x !== U);
          return M;
        }(i, t);
        if (!n) return t;
        const c = Lf(n, i);
        return Eu(c, c.next), Eu(n, n.next);
      }
      function H1(i, t) {
        return zr(i.prev, i, t.prev) < 0 && zr(t.next, i, i.next) < 0;
      }
      function Pd(i, t, n, c, f) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * f | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - c) * f | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
      }
      function W1(i) {
        let t = i, n = i;
        do
          (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
        while (t !== i);
        return n;
      }
      function ec(i, t, n, c, f, v, x, E) {
        return (f - x) * (t - E) >= (i - x) * (v - E) && (i - x) * (c - E) >= (n - x) * (t - E) && (n - x) * (v - E) >= (f - x) * (c - E);
      }
      function X1(i, t) {
        return i.next.i !== t.i && i.prev.i !== t.i && !function(n, c) {
          let f = n;
          do {
            if (f.i !== n.i && f.next.i !== n.i && f.i !== c.i && f.next.i !== c.i && Pf(f, f.next, n, c)) return !0;
            f = f.next;
          } while (f !== n);
          return !1;
        }(i, t) && (Uc(i, t) && Uc(t, i) && function(n, c) {
          let f = n, v = !1;
          const x = (n.x + c.x) / 2, E = (n.y + c.y) / 2;
          do
            f.y > E != f.next.y > E && f.next.y !== f.y && x < (f.next.x - f.x) * (E - f.y) / (f.next.y - f.y) + f.x && (v = !v), f = f.next;
          while (f !== n);
          return v;
        }(i, t) && (zr(i.prev, i, t.prev) || zr(i, t.prev, t)) || Lh(i, t) && zr(i.prev, i, i.next) > 0 && zr(t.prev, t, t.next) > 0);
      }
      function zr(i, t, n) {
        return (t.y - i.y) * (n.x - t.x) - (t.x - i.x) * (n.y - t.y);
      }
      function Lh(i, t) {
        return i.x === t.x && i.y === t.y;
      }
      function Pf(i, t, n, c) {
        const f = Nh(zr(i, t, n)), v = Nh(zr(i, t, c)), x = Nh(zr(n, c, i)), E = Nh(zr(n, c, t));
        return f !== v && x !== E || !(f !== 0 || !Mh(i, n, t)) || !(v !== 0 || !Mh(i, c, t)) || !(x !== 0 || !Mh(n, i, c)) || !(E !== 0 || !Mh(n, t, c));
      }
      function Mh(i, t, n) {
        return t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y);
      }
      function Nh(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function Uc(i, t) {
        return zr(i.prev, i, i.next) < 0 ? zr(i, t, i.next) >= 0 && zr(i, i.prev, t) >= 0 : zr(i, t, i.prev) < 0 || zr(i, i.next, t) < 0;
      }
      function Lf(i, t) {
        const n = Ld(i.i, i.x, i.y), c = Ld(t.i, t.x, t.y), f = i.next, v = t.prev;
        return i.next = t, t.prev = i, n.next = f, f.prev = n, c.next = n, n.prev = c, v.next = c, c.prev = v, c;
      }
      function Mf(i, t, n, c) {
        const f = Ld(i, t, n);
        return c ? (f.next = c.next, f.prev = c, c.next.prev = f, c.next = f) : (f.prev = f, f.next = f), f;
      }
      function Vc(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function Ld(i, t, n) {
        return { i, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function Md(i, t, n) {
        const c = n.patternDependencies;
        let f = !1;
        for (const v of t) {
          const x = v.paint.get(`${i}-pattern`);
          x.isConstant() || (f = !0);
          const E = x.constantOr(null);
          E && (f = !0, c[E.to] = !0, c[E.from] = !0);
        }
        return f;
      }
      function Nd(i, t, n, c, f) {
        const v = f.patternDependencies;
        for (const x of t) {
          const E = x.paint.get(`${i}-pattern`).value;
          if (E.kind !== "constant") {
            let T = E.evaluate({ zoom: c - 1 }, n, {}, f.availableImages), M = E.evaluate({ zoom: c }, n, {}, f.availableImages), R = E.evaluate({ zoom: c + 1 }, n, {}, f.availableImages);
            T = T && T.name ? T.name : T, M = M && M.name ? M.name : M, R = R && R.name ? R.name : R, v[T] = !0, v[M] = !0, v[R] = !0, n.patterns[x.id] = { min: T, mid: M, max: R };
          }
        }
        return n;
      }
      class zd {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new pn(), this.indexArray = new tn(), this.indexArray2 = new Ar(), this.programConfigurations = new No(t.layers, t.zoom), this.segments = new Li(), this.segments2 = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, c) {
          this.hasPattern = Md("fill", this.layers, n);
          const f = this.layers[0].layout.get("fill-sort-key"), v = !f.isConstant(), x = [];
          for (const { feature: E, id: T, index: M, sourceLayerIndex: R } of t) {
            const U = this.layers[0]._featureFilter.needGeometry, H = zo(E, U);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), H, c)) continue;
            const J = v ? f.evaluate(H, {}, c, n.availableImages) : void 0, ne = { id: T, properties: E.properties, type: E.type, sourceLayerIndex: R, index: M, geometry: U ? H.geometry : vl(E), patterns: {}, sortKey: J };
            x.push(ne);
          }
          v && x.sort((E, T) => E.sortKey - T.sortKey);
          for (const E of x) {
            const { geometry: T, index: M, sourceLayerIndex: R } = E;
            if (this.hasPattern) {
              const U = Nd("fill", this.layers, E, this.zoom, n);
              this.patternFeatures.push(U);
            } else this.addFeature(E, T, M, c, {});
            n.featureIndex.insert(t[M].feature, T, M, R, this.index);
          }
        }
        update(t, n, c) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, c);
        }
        addFeatures(t, n, c) {
          for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, n, c);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, j1), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t, n, c, f, v) {
          for (const x of Cs(n, 500)) {
            let E = 0;
            for (const J of x) E += J.length;
            const T = this.segments.prepareSegment(E, this.layoutVertexArray, this.indexArray), M = T.vertexLength, R = [], U = [];
            for (const J of x) {
              if (J.length === 0) continue;
              J !== x[0] && U.push(R.length / 2);
              const ne = this.segments2.prepareSegment(J.length, this.layoutVertexArray, this.indexArray2), he = ne.vertexLength;
              this.layoutVertexArray.emplaceBack(J[0].x, J[0].y), this.indexArray2.emplaceBack(he + J.length - 1, he), R.push(J[0].x), R.push(J[0].y);
              for (let Se = 1; Se < J.length; Se++) this.layoutVertexArray.emplaceBack(J[Se].x, J[Se].y), this.indexArray2.emplaceBack(he + Se - 1, he + Se), R.push(J[Se].x), R.push(J[Se].y);
              ne.vertexLength += J.length, ne.primitiveLength += J.length;
            }
            const H = Df(R, U);
            for (let J = 0; J < H.length; J += 3) this.indexArray.emplaceBack(M + H[J], M + H[J + 1], M + H[J + 2]);
            T.vertexLength += E, T.primitiveLength += H.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, v, f);
        }
      }
      let Nf, zf;
      Ot("FillBucket", zd, { omit: ["layers", "patternFeatures"] });
      var Y1 = { get paint() {
        return zf = zf || new h({ "fill-antialias": new Gt(Y.paint_fill["fill-antialias"]), "fill-opacity": new li(Y.paint_fill["fill-opacity"]), "fill-color": new li(Y.paint_fill["fill-color"]), "fill-outline-color": new li(Y.paint_fill["fill-outline-color"]), "fill-translate": new Gt(Y.paint_fill["fill-translate"]), "fill-translate-anchor": new Gt(Y.paint_fill["fill-translate-anchor"]), "fill-pattern": new ml(Y.paint_fill["fill-pattern"]) });
      }, get layout() {
        return Nf = Nf || new h({ "fill-sort-key": new li(Y.layout_fill["fill-sort-key"]) });
      } };
      class J1 extends r {
        constructor(t) {
          super(t, Y1);
        }
        recalculate(t, n) {
          super.recalculate(t, n);
          const c = this.paint._values["fill-outline-color"];
          c.value.kind === "constant" && c.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new zd(t);
        }
        queryRadius() {
          return Dh(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t, n, c, f, v, x, E) {
          return ka(Ih(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), x.angle, E), f);
        }
        isTileClipped() {
          return !0;
        }
      }
      const K1 = w([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Q1 = w([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: e2 } = K1;
      var Vl = {}, t2 = D, Ff = tc;
      function tc(i, t, n, c, f) {
        this.properties = {}, this.extent = n, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = c, this._values = f, i.readFields(i2, this, t);
      }
      function i2(i, t, n) {
        i == 1 ? t.id = n.readVarint() : i == 2 ? function(c, f) {
          for (var v = c.readVarint() + c.pos; c.pos < v; ) {
            var x = f._keys[c.readVarint()], E = f._values[c.readVarint()];
            f.properties[x] = E;
          }
        }(n, t) : i == 3 ? t.type = n.readVarint() : i == 4 && (t._geometry = n.pos);
      }
      function r2(i) {
        for (var t, n, c = 0, f = 0, v = i.length, x = v - 1; f < v; x = f++) c += ((n = i[x]).x - (t = i[f]).x) * (t.y + n.y);
        return c;
      }
      tc.types = ["Unknown", "Point", "LineString", "Polygon"], tc.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t, n = i.readVarint() + i.pos, c = 1, f = 0, v = 0, x = 0, E = []; i.pos < n; ) {
          if (f <= 0) {
            var T = i.readVarint();
            c = 7 & T, f = T >> 3;
          }
          if (f--, c === 1 || c === 2) v += i.readSVarint(), x += i.readSVarint(), c === 1 && (t && E.push(t), t = []), t.push(new t2(v, x));
          else {
            if (c !== 7) throw new Error("unknown command " + c);
            t && t.push(t[0].clone());
          }
        }
        return t && E.push(t), E;
      }, tc.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t = i.readVarint() + i.pos, n = 1, c = 0, f = 0, v = 0, x = 1 / 0, E = -1 / 0, T = 1 / 0, M = -1 / 0; i.pos < t; ) {
          if (c <= 0) {
            var R = i.readVarint();
            n = 7 & R, c = R >> 3;
          }
          if (c--, n === 1 || n === 2) (f += i.readSVarint()) < x && (x = f), f > E && (E = f), (v += i.readSVarint()) < T && (T = v), v > M && (M = v);
          else if (n !== 7) throw new Error("unknown command " + n);
        }
        return [x, T, E, M];
      }, tc.prototype.toGeoJSON = function(i, t, n) {
        var c, f, v = this.extent * Math.pow(2, n), x = this.extent * i, E = this.extent * t, T = this.loadGeometry(), M = tc.types[this.type];
        function R(J) {
          for (var ne = 0; ne < J.length; ne++) {
            var he = J[ne];
            J[ne] = [360 * (he.x + x) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (he.y + E) / v) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var U = [];
            for (c = 0; c < T.length; c++) U[c] = T[c][0];
            R(T = U);
            break;
          case 2:
            for (c = 0; c < T.length; c++) R(T[c]);
            break;
          case 3:
            for (T = function(J) {
              var ne = J.length;
              if (ne <= 1) return [J];
              for (var he, Se, Pe = [], Xe = 0; Xe < ne; Xe++) {
                var Be = r2(J[Xe]);
                Be !== 0 && (Se === void 0 && (Se = Be < 0), Se === Be < 0 ? (he && Pe.push(he), he = [J[Xe]]) : he.push(J[Xe]));
              }
              return he && Pe.push(he), Pe;
            }(T), c = 0; c < T.length; c++) for (f = 0; f < T[c].length; f++) R(T[c][f]);
        }
        T.length === 1 ? T = T[0] : M = "Multi" + M;
        var H = { type: "Feature", geometry: { type: M, coordinates: T }, properties: this.properties };
        return "id" in this && (H.id = this.id), H;
      };
      var n2 = Ff, Bf = Rf;
      function Rf(i, t) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(s2, this, t), this.length = this._features.length;
      }
      function s2(i, t, n) {
        i === 15 ? t.version = n.readVarint() : i === 1 ? t.name = n.readString() : i === 5 ? t.extent = n.readVarint() : i === 2 ? t._features.push(n.pos) : i === 3 ? t._keys.push(n.readString()) : i === 4 && t._values.push(function(c) {
          for (var f = null, v = c.readVarint() + c.pos; c.pos < v; ) {
            var x = c.readVarint() >> 3;
            f = x === 1 ? c.readString() : x === 2 ? c.readFloat() : x === 3 ? c.readDouble() : x === 4 ? c.readVarint64() : x === 5 ? c.readVarint() : x === 6 ? c.readSVarint() : x === 7 ? c.readBoolean() : null;
          }
          return f;
        }(n));
      }
      Rf.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var t = this._pbf.readVarint() + this._pbf.pos;
        return new n2(this._pbf, t, this.extent, this._keys, this._values);
      };
      var a2 = Bf;
      function o2(i, t, n) {
        if (i === 3) {
          var c = new a2(n, n.readVarint() + n.pos);
          c.length && (t[c.name] = c);
        }
      }
      Vl.VectorTile = function(i, t) {
        this.layers = i.readFields(o2, {}, t);
      }, Vl.VectorTileFeature = Ff, Vl.VectorTileLayer = Bf;
      const l2 = Vl.VectorTileFeature.types, Fd = Math.pow(2, 13);
      function $c(i, t, n, c, f, v, x, E) {
        i.emplaceBack(t, n, 2 * Math.floor(c * Fd) + x, f * Fd * 2, v * Fd * 2, Math.round(E));
      }
      class Bd {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Mn(), this.centroidVertexArray = new pr(), this.indexArray = new tn(), this.programConfigurations = new No(t.layers, t.zoom), this.segments = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, c) {
          this.features = [], this.hasPattern = Md("fill-extrusion", this.layers, n);
          for (const { feature: f, id: v, index: x, sourceLayerIndex: E } of t) {
            const T = this.layers[0]._featureFilter.needGeometry, M = zo(f, T);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), M, c)) continue;
            const R = { id: v, sourceLayerIndex: E, index: x, geometry: T ? M.geometry : vl(f), properties: f.properties, type: f.type, patterns: {} };
            this.hasPattern ? this.features.push(Nd("fill-extrusion", this.layers, R, this.zoom, n)) : this.addFeature(R, R.geometry, x, c, {}), n.featureIndex.insert(f, R.geometry, x, E, this.index, !0);
          }
        }
        addFeatures(t, n, c) {
          for (const f of this.features) {
            const { geometry: v } = f;
            this.addFeature(f, v, f.index, n, c);
          }
        }
        update(t, n, c) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, c);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, e2), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Q1.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t, n, c, f, v) {
          for (const x of Cs(n, 500)) {
            const E = { x: 0, y: 0, vertexCount: 0 };
            let T = 0;
            for (const ne of x) T += ne.length;
            let M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const ne of x) {
              if (ne.length === 0 || c2(ne)) continue;
              let he = 0;
              for (let Se = 0; Se < ne.length; Se++) {
                const Pe = ne[Se];
                if (Se >= 1) {
                  const Xe = ne[Se - 1];
                  if (!u2(Pe, Xe)) {
                    M.vertexLength + 4 > Li.MAX_VERTEX_ARRAY_LENGTH && (M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Be = Pe.sub(Xe)._perp()._unit(), Ge = Xe.dist(Pe);
                    he + Ge > 32768 && (he = 0), $c(this.layoutVertexArray, Pe.x, Pe.y, Be.x, Be.y, 0, 0, he), $c(this.layoutVertexArray, Pe.x, Pe.y, Be.x, Be.y, 0, 1, he), E.x += 2 * Pe.x, E.y += 2 * Pe.y, E.vertexCount += 2, he += Ge, $c(this.layoutVertexArray, Xe.x, Xe.y, Be.x, Be.y, 0, 0, he), $c(this.layoutVertexArray, Xe.x, Xe.y, Be.x, Be.y, 0, 1, he), E.x += 2 * Xe.x, E.y += 2 * Xe.y, E.vertexCount += 2;
                    const at = M.vertexLength;
                    this.indexArray.emplaceBack(at, at + 2, at + 1), this.indexArray.emplaceBack(at + 1, at + 2, at + 3), M.vertexLength += 4, M.primitiveLength += 2;
                  }
                }
              }
            }
            if (M.vertexLength + T > Li.MAX_VERTEX_ARRAY_LENGTH && (M = this.segments.prepareSegment(T, this.layoutVertexArray, this.indexArray)), l2[t.type] !== "Polygon") continue;
            const R = [], U = [], H = M.vertexLength;
            for (const ne of x) if (ne.length !== 0) {
              ne !== x[0] && U.push(R.length / 2);
              for (let he = 0; he < ne.length; he++) {
                const Se = ne[he];
                $c(this.layoutVertexArray, Se.x, Se.y, 0, 0, 1, 1, 0), E.x += Se.x, E.y += Se.y, E.vertexCount += 1, R.push(Se.x), R.push(Se.y);
              }
            }
            const J = Df(R, U);
            for (let ne = 0; ne < J.length; ne += 3) this.indexArray.emplaceBack(H + J[ne], H + J[ne + 2], H + J[ne + 1]);
            M.primitiveLength += J.length / 3, M.vertexLength += T;
            for (let ne = 0; ne < E.vertexCount; ne++) {
              const he = Math.floor(E.x / E.vertexCount), Se = Math.floor(E.y / E.vertexCount);
              this.centroidVertexArray.emplaceBack(he, Se);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, v, f);
        }
      }
      function u2(i, t) {
        return i.x === t.x && (i.x < 0 || i.x > or) || i.y === t.y && (i.y < 0 || i.y > or);
      }
      function c2(i) {
        return i.every((t) => t.x < 0) || i.every((t) => t.x > or) || i.every((t) => t.y < 0) || i.every((t) => t.y > or);
      }
      let Of;
      Ot("FillExtrusionBucket", Bd, { omit: ["layers", "features"] });
      var h2 = { get paint() {
        return Of = Of || new h({ "fill-extrusion-opacity": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new li(Y["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ml(Y["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new li(Y["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new li(Y["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class d2 extends r {
        constructor(t) {
          super(t, h2);
        }
        createBucket(t) {
          return new Bd(t);
        }
        queryRadius() {
          return Dh(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(t, n, c, f, v, x, E, T) {
          const M = Ih(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), x.angle, E), R = this.paint.get("fill-extrusion-height").evaluate(n, c), U = this.paint.get("fill-extrusion-base").evaluate(n, c), H = function(ne, he, Se, Pe) {
            const Xe = [];
            for (const Be of ne) {
              const Ge = [Be.x, Be.y, 0, 1];
              Ph(Ge, Ge, he), Xe.push(new j(Ge[0] / Ge[3], Ge[1] / Ge[3]));
            }
            return Xe;
          }(M, T), J = function(ne, he, Se, Pe) {
            const Xe = [], Be = [], Ge = Pe[8] * he, at = Pe[9] * he, Ct = Pe[10] * he, Bt = Pe[11] * he, hi = Pe[8] * Se, Ft = Pe[9] * Se, Nt = Pe[10] * Se, Xt = Pe[11] * Se;
            for (const Vt of ne) {
              const qt = [], dt = [];
              for (const Yt of Vt) {
                const Ht = Yt.x, _i = Yt.y, ir = Pe[0] * Ht + Pe[4] * _i + Pe[12], Qi = Pe[1] * Ht + Pe[5] * _i + Pe[13], nn = Pe[2] * Ht + Pe[6] * _i + Pe[14], Ia = Pe[3] * Ht + Pe[7] * _i + Pe[15], wn = nn + Ct, sn = Ia + Bt, Jn = ir + hi, Kn = Qi + Ft, Qn = nn + Nt, Mr = Ia + Xt, an = new j((ir + Ge) / sn, (Qi + at) / sn);
                an.z = wn / sn, qt.push(an);
                const Fn = new j(Jn / Mr, Kn / Mr);
                Fn.z = Qn / Mr, dt.push(Fn);
              }
              Xe.push(qt), Be.push(dt);
            }
            return [Xe, Be];
          }(f, U, R, T);
          return function(ne, he, Se) {
            let Pe = 1 / 0;
            ka(Se, he) && (Pe = jf(Se, he[0]));
            for (let Xe = 0; Xe < he.length; Xe++) {
              const Be = he[Xe], Ge = ne[Xe];
              for (let at = 0; at < Be.length - 1; at++) {
                const Ct = Be[at], Bt = [Ct, Be[at + 1], Ge[at + 1], Ge[at], Ct];
                Yu(Se, Bt) && (Pe = Math.min(Pe, jf(Se, Bt)));
              }
            }
            return Pe !== 1 / 0 && Pe;
          }(J[0], J[1], H);
        }
      }
      function Zc(i, t) {
        return i.x * t.x + i.y * t.y;
      }
      function jf(i, t) {
        if (i.length === 1) {
          let n = 0;
          const c = t[n++];
          let f;
          for (; !f || c.equals(f); ) if (f = t[n++], !f) return 1 / 0;
          for (; n < t.length; n++) {
            const v = t[n], x = i[0], E = f.sub(c), T = v.sub(c), M = x.sub(c), R = Zc(E, E), U = Zc(E, T), H = Zc(T, T), J = Zc(M, E), ne = Zc(M, T), he = R * H - U * U, Se = (H * J - U * ne) / he, Pe = (R * ne - U * J) / he, Xe = c.z * (1 - Se - Pe) + f.z * Se + v.z * Pe;
            if (isFinite(Xe)) return Xe;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const c of t) n = Math.min(n, c.z);
          return n;
        }
      }
      const p2 = w([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: f2 } = p2, m2 = w([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: g2 } = m2, _2 = Vl.VectorTileFeature.types, y2 = Math.cos(Math.PI / 180 * 37.5), qf = Math.pow(2, 14) / 0.5;
      class Rd {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new ar(), this.layoutVertexArray2 = new Ea(), this.indexArray = new tn(), this.programConfigurations = new No(t.layers, t.zoom), this.segments = new Li(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, c) {
          this.hasPattern = Md("line", this.layers, n);
          const f = this.layers[0].layout.get("line-sort-key"), v = !f.isConstant(), x = [];
          for (const { feature: E, id: T, index: M, sourceLayerIndex: R } of t) {
            const U = this.layers[0]._featureFilter.needGeometry, H = zo(E, U);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), H, c)) continue;
            const J = v ? f.evaluate(H, {}, c) : void 0, ne = { id: T, properties: E.properties, type: E.type, sourceLayerIndex: R, index: M, geometry: U ? H.geometry : vl(E), patterns: {}, sortKey: J };
            x.push(ne);
          }
          v && x.sort((E, T) => E.sortKey - T.sortKey);
          for (const E of x) {
            const { geometry: T, index: M, sourceLayerIndex: R } = E;
            if (this.hasPattern) {
              const U = Nd("line", this.layers, E, this.zoom, n);
              this.patternFeatures.push(U);
            } else this.addFeature(E, T, M, c, {});
            n.featureIndex.insert(t[M].feature, T, M, R, this.index);
          }
        }
        update(t, n, c) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, c);
        }
        addFeatures(t, n, c) {
          for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, n, c);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, g2)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, f2), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
        }
        addFeature(t, n, c, f, v) {
          const x = this.layers[0].layout, E = x.get("line-join").evaluate(t, {}), T = x.get("line-cap"), M = x.get("line-miter-limit"), R = x.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t);
          for (const U of n) this.addLine(U, t, E, T, M, R);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, v, f);
        }
        addLine(t, n, c, f, v, x) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Pe = 0; Pe < t.length - 1; Pe++) this.totalDistance += t[Pe].dist(t[Pe + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const E = _2[n.type] === "Polygon";
          let T = t.length;
          for (; T >= 2 && t[T - 1].equals(t[T - 2]); ) T--;
          let M = 0;
          for (; M < T - 1 && t[M].equals(t[M + 1]); ) M++;
          if (T < (E ? 3 : 2)) return;
          c === "bevel" && (v = 1.05);
          const R = this.overscaling <= 16 ? 15 * or / (512 * this.overscaling) : 0, U = this.segments.prepareSegment(10 * T, this.layoutVertexArray, this.indexArray);
          let H, J, ne, he, Se;
          this.e1 = this.e2 = -1, E && (H = t[T - 2], Se = t[M].sub(H)._unit()._perp());
          for (let Pe = M; Pe < T; Pe++) {
            if (ne = Pe === T - 1 ? E ? t[M + 1] : void 0 : t[Pe + 1], ne && t[Pe].equals(ne)) continue;
            Se && (he = Se), H && (J = H), H = t[Pe], Se = ne ? ne.sub(H)._unit()._perp() : he, he = he || Se;
            let Xe = he.add(Se);
            Xe.x === 0 && Xe.y === 0 || Xe._unit();
            const Be = he.x * Se.x + he.y * Se.y, Ge = Xe.x * Se.x + Xe.y * Se.y, at = Ge !== 0 ? 1 / Ge : 1 / 0, Ct = 2 * Math.sqrt(2 - 2 * Ge), Bt = Ge < y2 && J && ne, hi = he.x * Se.y - he.y * Se.x > 0;
            if (Bt && Pe > M) {
              const Xt = H.dist(J);
              if (Xt > 2 * R) {
                const Vt = H.sub(H.sub(J)._mult(R / Xt)._round());
                this.updateDistance(J, Vt), this.addCurrentVertex(Vt, he, 0, 0, U), J = Vt;
              }
            }
            const Ft = J && ne;
            let Nt = Ft ? c : E ? "butt" : f;
            if (Ft && Nt === "round" && (at < x ? Nt = "miter" : at <= 2 && (Nt = "fakeround")), Nt === "miter" && at > v && (Nt = "bevel"), Nt === "bevel" && (at > 2 && (Nt = "flipbevel"), at < v && (Nt = "miter")), J && this.updateDistance(J, H), Nt === "miter") Xe._mult(at), this.addCurrentVertex(H, Xe, 0, 0, U);
            else if (Nt === "flipbevel") {
              if (at > 100) Xe = Se.mult(-1);
              else {
                const Xt = at * he.add(Se).mag() / he.sub(Se).mag();
                Xe._perp()._mult(Xt * (hi ? -1 : 1));
              }
              this.addCurrentVertex(H, Xe, 0, 0, U), this.addCurrentVertex(H, Xe.mult(-1), 0, 0, U);
            } else if (Nt === "bevel" || Nt === "fakeround") {
              const Xt = -Math.sqrt(at * at - 1), Vt = hi ? Xt : 0, qt = hi ? 0 : Xt;
              if (J && this.addCurrentVertex(H, he, Vt, qt, U), Nt === "fakeround") {
                const dt = Math.round(180 * Ct / Math.PI / 20);
                for (let Yt = 1; Yt < dt; Yt++) {
                  let Ht = Yt / dt;
                  if (Ht !== 0.5) {
                    const ir = Ht - 0.5;
                    Ht += Ht * ir * (Ht - 1) * ((1.0904 + Be * (Be * (3.55645 - 1.43519 * Be) - 3.2452)) * ir * ir + (0.848013 + Be * (0.215638 * Be - 1.06021)));
                  }
                  const _i = Se.sub(he)._mult(Ht)._add(he)._unit()._mult(hi ? -1 : 1);
                  this.addHalfVertex(H, _i.x, _i.y, !1, hi, 0, U);
                }
              }
              ne && this.addCurrentVertex(H, Se, -Vt, -qt, U);
            } else if (Nt === "butt") this.addCurrentVertex(H, Xe, 0, 0, U);
            else if (Nt === "square") {
              const Xt = J ? 1 : -1;
              this.addCurrentVertex(H, Xe, Xt, Xt, U);
            } else Nt === "round" && (J && (this.addCurrentVertex(H, he, 0, 0, U), this.addCurrentVertex(H, he, 1, 1, U, !0)), ne && (this.addCurrentVertex(H, Se, -1, -1, U, !0), this.addCurrentVertex(H, Se, 0, 0, U)));
            if (Bt && Pe < T - 1) {
              const Xt = H.dist(ne);
              if (Xt > 2 * R) {
                const Vt = H.add(ne.sub(H)._mult(R / Xt)._round());
                this.updateDistance(H, Vt), this.addCurrentVertex(Vt, Se, 0, 0, U), H = Vt;
              }
            }
          }
        }
        addCurrentVertex(t, n, c, f, v, x = !1) {
          const E = n.y * f - n.x, T = -n.y - n.x * f;
          this.addHalfVertex(t, n.x + n.y * c, n.y - n.x * c, x, !1, c, v), this.addHalfVertex(t, E, T, x, !0, -f, v), this.distance > qf / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, c, f, v, x));
        }
        addHalfVertex({ x: t, y: n }, c, f, v, x, E, T) {
          const M = 0.5 * (this.lineClips ? this.scaledDistance * (qf - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t << 1) + (v ? 1 : 0), (n << 1) + (x ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * f) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & M) << 2, M >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const R = T.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, R), T.primitiveLength++), x ? this.e2 = R : this.e1 = R;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t, n) {
          this.distance += t.dist(n), this.updateScaledDistance();
        }
      }
      let Uf, Vf;
      Ot("LineBucket", Rd, { omit: ["layers", "patternFeatures"] });
      var $f = { get paint() {
        return Vf = Vf || new h({ "line-opacity": new li(Y.paint_line["line-opacity"]), "line-color": new li(Y.paint_line["line-color"]), "line-translate": new Gt(Y.paint_line["line-translate"]), "line-translate-anchor": new Gt(Y.paint_line["line-translate-anchor"]), "line-width": new li(Y.paint_line["line-width"]), "line-gap-width": new li(Y.paint_line["line-gap-width"]), "line-offset": new li(Y.paint_line["line-offset"]), "line-blur": new li(Y.paint_line["line-blur"]), "line-dasharray": new b(Y.paint_line["line-dasharray"]), "line-pattern": new ml(Y.paint_line["line-pattern"]), "line-gradient": new S(Y.paint_line["line-gradient"]) });
      }, get layout() {
        return Uf = Uf || new h({ "line-cap": new Gt(Y.layout_line["line-cap"]), "line-join": new li(Y.layout_line["line-join"]), "line-miter-limit": new Gt(Y.layout_line["line-miter-limit"]), "line-round-limit": new Gt(Y.layout_line["line-round-limit"]), "line-sort-key": new li(Y.layout_line["line-sort-key"]) });
      } };
      class v2 extends li {
        possiblyEvaluate(t, n) {
          return n = new Ji(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
        }
        evaluate(t, n, c, f) {
          return n = ke({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, c, f);
        }
      }
      let zh;
      class b2 extends r {
        constructor(t) {
          super(t, $f), this.gradientVersion = 0, zh || (zh = new v2($f.paint.properties["line-width"].specification), zh.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if (t === "line-gradient") {
            const n = this.gradientExpression();
            this.stepInterpolant = !!function(c) {
              return c._styleExpression !== void 0;
            }(n) && n._styleExpression.expression instanceof pa, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t, n) {
          super.recalculate(t, n), this.paint._values["line-floorwidth"] = zh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }
        createBucket(t) {
          return new Rd(t);
        }
        queryRadius(t) {
          const n = t, c = Zf(Rc("line-width", this, n), Rc("line-gap-width", this, n)), f = Rc("line-offset", this, n);
          return c / 2 + Math.abs(f) + Dh(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t, n, c, f, v, x, E) {
          const T = Ih(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), x.angle, E), M = E / 2 * Zf(this.paint.get("line-width").evaluate(n, c), this.paint.get("line-gap-width").evaluate(n, c)), R = this.paint.get("line-offset").evaluate(n, c);
          return R && (f = function(U, H) {
            const J = [];
            for (let ne = 0; ne < U.length; ne++) {
              const he = U[ne], Se = [];
              for (let Pe = 0; Pe < he.length; Pe++) {
                const Xe = he[Pe - 1], Be = he[Pe], Ge = he[Pe + 1], at = Pe === 0 ? new j(0, 0) : Be.sub(Xe)._unit()._perp(), Ct = Pe === he.length - 1 ? new j(0, 0) : Ge.sub(Be)._unit()._perp(), Bt = at._add(Ct)._unit(), hi = Bt.x * Ct.x + Bt.y * Ct.y;
                hi !== 0 && Bt._mult(1 / hi), Se.push(Bt._mult(H)._add(Be));
              }
              J.push(Se);
            }
            return J;
          }(f, R * E)), function(U, H, J) {
            for (let ne = 0; ne < H.length; ne++) {
              const he = H[ne];
              if (U.length >= 3) {
                for (let Se = 0; Se < he.length; Se++) if (Bo(U, he[Se])) return !0;
              }
              if (Fo(U, he, J)) return !0;
            }
            return !1;
          }(T, f, M);
        }
        isTileClipped() {
          return !0;
        }
      }
      function Zf(i, t) {
        return t > 0 ? t + 2 * i : i;
      }
      const x2 = w([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), w2 = w([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      w([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const A2 = w([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      w([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Gf = w([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), S2 = w([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function E2(i, t, n) {
        return i.sections.forEach((c) => {
          c.text = function(f, v, x) {
            const E = v.layout.get("text-transform").evaluate(x, {});
            return E === "uppercase" ? f = f.toLocaleUpperCase() : E === "lowercase" && (f = f.toLocaleLowerCase()), Ln.applyArabicShaping && (f = Ln.applyArabicShaping(f)), f;
          }(c.text, t, n);
        }), i;
      }
      w([{ name: "triangle", components: 3, type: "Uint16" }]), w([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), w([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), w([{ type: "Float32", name: "offsetX" }]), w([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), w([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Gc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var $r = 24, Hf = Ki, Wf = function(i, t, n, c, f) {
        var v, x, E = 8 * f - c - 1, T = (1 << E) - 1, M = T >> 1, R = -7, U = f - 1, H = -1, J = i[t + U];
        for (U += H, v = J & (1 << -R) - 1, J >>= -R, R += E; R > 0; v = 256 * v + i[t + U], U += H, R -= 8) ;
        for (x = v & (1 << -R) - 1, v >>= -R, R += c; R > 0; x = 256 * x + i[t + U], U += H, R -= 8) ;
        if (v === 0) v = 1 - M;
        else {
          if (v === T) return x ? NaN : 1 / 0 * (J ? -1 : 1);
          x += Math.pow(2, c), v -= M;
        }
        return (J ? -1 : 1) * x * Math.pow(2, v - c);
      }, Xf = function(i, t, n, c, f, v) {
        var x, E, T, M = 8 * v - f - 1, R = (1 << M) - 1, U = R >> 1, H = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, J = 0, ne = 1, he = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (E = isNaN(t) ? 1 : 0, x = R) : (x = Math.floor(Math.log(t) / Math.LN2), t * (T = Math.pow(2, -x)) < 1 && (x--, T *= 2), (t += x + U >= 1 ? H / T : H * Math.pow(2, 1 - U)) * T >= 2 && (x++, T /= 2), x + U >= R ? (E = 0, x = R) : x + U >= 1 ? (E = (t * T - 1) * Math.pow(2, f), x += U) : (E = t * Math.pow(2, U - 1) * Math.pow(2, f), x = 0)); f >= 8; i[n + J] = 255 & E, J += ne, E /= 256, f -= 8) ;
        for (x = x << f | E, M += f; M > 0; i[n + J] = 255 & x, J += ne, x /= 256, M -= 8) ;
        i[n + J - ne] |= 128 * he;
      };
      function Ki(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Ki.Varint = 0, Ki.Fixed64 = 1, Ki.Bytes = 2, Ki.Fixed32 = 5;
      var Od = 4294967296, Yf = 1 / Od, Jf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function xl(i) {
        return i.type === Ki.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function ic(i, t, n) {
        return n ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0);
      }
      function Kf(i, t, n) {
        var c = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
        n.realloc(c);
        for (var f = n.pos - 1; f >= i; f--) n.buf[f + c] = n.buf[f];
      }
      function C2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeVarint(i[n]);
      }
      function T2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSVarint(i[n]);
      }
      function k2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFloat(i[n]);
      }
      function D2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeDouble(i[n]);
      }
      function I2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeBoolean(i[n]);
      }
      function P2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed32(i[n]);
      }
      function L2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed32(i[n]);
      }
      function M2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed64(i[n]);
      }
      function N2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed64(i[n]);
      }
      function Fh(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + 16777216 * i[t + 3];
      }
      function rc(i, t, n) {
        i[n] = t, i[n + 1] = t >>> 8, i[n + 2] = t >>> 16, i[n + 3] = t >>> 24;
      }
      function Qf(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + (i[t + 3] << 24);
      }
      Ki.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, t, n) {
        for (n = n || this.length; this.pos < n; ) {
          var c = this.readVarint(), f = c >> 3, v = this.pos;
          this.type = 7 & c, i(f, t, this), this.pos === v && this.skip(c);
        }
        return t;
      }, readMessage: function(i, t) {
        return this.readFields(i, t, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = Fh(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = Qf(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = Fh(this.buf, this.pos) + Fh(this.buf, this.pos + 4) * Od;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = Fh(this.buf, this.pos) + Qf(this.buf, this.pos + 4) * Od;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = Wf(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = Wf(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var t, n, c = this.buf;
        return t = 127 & (n = c[this.pos++]), n < 128 ? t : (t |= (127 & (n = c[this.pos++])) << 7, n < 128 ? t : (t |= (127 & (n = c[this.pos++])) << 14, n < 128 ? t : (t |= (127 & (n = c[this.pos++])) << 21, n < 128 ? t : function(f, v, x) {
          var E, T, M = x.buf;
          if (E = (112 & (T = M[x.pos++])) >> 4, T < 128 || (E |= (127 & (T = M[x.pos++])) << 3, T < 128) || (E |= (127 & (T = M[x.pos++])) << 10, T < 128) || (E |= (127 & (T = M[x.pos++])) << 17, T < 128) || (E |= (127 & (T = M[x.pos++])) << 24, T < 128) || (E |= (1 & (T = M[x.pos++])) << 31, T < 128)) return ic(f, E, v);
          throw new Error("Expected varint not more than 10 bytes");
        }(t |= (15 & (n = c[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, t = this.pos;
        return this.pos = i, i - t >= 12 && Jf ? function(n, c, f) {
          return Jf.decode(n.subarray(c, f));
        }(this.buf, t, i) : function(n, c, f) {
          for (var v = "", x = c; x < f; ) {
            var E, T, M, R = n[x], U = null, H = R > 239 ? 4 : R > 223 ? 3 : R > 191 ? 2 : 1;
            if (x + H > f) break;
            H === 1 ? R < 128 && (U = R) : H === 2 ? (192 & (E = n[x + 1])) == 128 && (U = (31 & R) << 6 | 63 & E) <= 127 && (U = null) : H === 3 ? (T = n[x + 2], (192 & (E = n[x + 1])) == 128 && (192 & T) == 128 && ((U = (15 & R) << 12 | (63 & E) << 6 | 63 & T) <= 2047 || U >= 55296 && U <= 57343) && (U = null)) : H === 4 && (T = n[x + 2], M = n[x + 3], (192 & (E = n[x + 1])) == 128 && (192 & T) == 128 && (192 & M) == 128 && ((U = (15 & R) << 18 | (63 & E) << 12 | (63 & T) << 6 | 63 & M) <= 65535 || U >= 1114112) && (U = null)), U === null ? (U = 65533, H = 1) : U > 65535 && (U -= 65536, v += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), v += String.fromCharCode(U), x += H;
          }
          return v;
        }(this.buf, t, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, i);
        return this.pos = i, t;
      }, readPackedVarint: function(i, t) {
        if (this.type !== Ki.Bytes) return i.push(this.readVarint(t));
        var n = xl(this);
        for (i = i || []; this.pos < n; ) i.push(this.readVarint(t));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSVarint());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readBoolean());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFloat());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readDouble());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFixed32());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSFixed32());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFixed64());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSFixed64());
        var t = xl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var t = 7 & i;
        if (t === Ki.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (t === Ki.Bytes) this.pos = this.readVarint() + this.pos;
        else if (t === Ki.Fixed32) this.pos += 4;
        else {
          if (t !== Ki.Fixed64) throw new Error("Unimplemented type: " + t);
          this.pos += 8;
        }
      }, writeTag: function(i, t) {
        this.writeVarint(i << 3 | t);
      }, realloc: function(i) {
        for (var t = this.length || 16; t < this.pos + i; ) t *= 2;
        if (t !== this.length) {
          var n = new Uint8Array(t);
          n.set(this.buf), this.buf = n, this.length = t;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), rc(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), rc(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), rc(this.buf, -1 & i, this.pos), rc(this.buf, Math.floor(i * Yf), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), rc(this.buf, -1 & i, this.pos), rc(this.buf, Math.floor(i * Yf), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(t, n) {
          var c, f;
          if (t >= 0 ? (c = t % 4294967296 | 0, f = t / 4294967296 | 0) : (f = ~(-t / 4294967296), 4294967295 ^ (c = ~(-t % 4294967296)) ? c = c + 1 | 0 : (c = 0, f = f + 1 | 0)), t >= 18446744073709552e3 || t < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          n.realloc(10), function(v, x, E) {
            E.buf[E.pos++] = 127 & v | 128, v >>>= 7, E.buf[E.pos++] = 127 & v | 128, v >>>= 7, E.buf[E.pos++] = 127 & v | 128, v >>>= 7, E.buf[E.pos++] = 127 & v | 128, E.buf[E.pos] = 127 & (v >>>= 7);
          }(c, 0, n), function(v, x) {
            var E = (7 & v) << 4;
            x.buf[x.pos++] |= E | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
          }(f, n);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var t = this.pos;
        this.pos = function(c, f, v) {
          for (var x, E, T = 0; T < f.length; T++) {
            if ((x = f.charCodeAt(T)) > 55295 && x < 57344) {
              if (!E) {
                x > 56319 || T + 1 === f.length ? (c[v++] = 239, c[v++] = 191, c[v++] = 189) : E = x;
                continue;
              }
              if (x < 56320) {
                c[v++] = 239, c[v++] = 191, c[v++] = 189, E = x;
                continue;
              }
              x = E - 55296 << 10 | x - 56320 | 65536, E = null;
            } else E && (c[v++] = 239, c[v++] = 191, c[v++] = 189, E = null);
            x < 128 ? c[v++] = x : (x < 2048 ? c[v++] = x >> 6 | 192 : (x < 65536 ? c[v++] = x >> 12 | 224 : (c[v++] = x >> 18 | 240, c[v++] = x >> 12 & 63 | 128), c[v++] = x >> 6 & 63 | 128), c[v++] = 63 & x | 128);
          }
          return v;
        }(this.buf, i, this.pos);
        var n = this.pos - t;
        n >= 128 && Kf(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
      }, writeFloat: function(i) {
        this.realloc(4), Xf(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Xf(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var t = i.length;
        this.writeVarint(t), this.realloc(t);
        for (var n = 0; n < t; n++) this.buf[this.pos++] = i[n];
      }, writeRawMessage: function(i, t) {
        this.pos++;
        var n = this.pos;
        i(t, this);
        var c = this.pos - n;
        c >= 128 && Kf(n, c, this), this.pos = n - 1, this.writeVarint(c), this.pos += c;
      }, writeMessage: function(i, t, n) {
        this.writeTag(i, Ki.Bytes), this.writeRawMessage(t, n);
      }, writePackedVarint: function(i, t) {
        t.length && this.writeMessage(i, C2, t);
      }, writePackedSVarint: function(i, t) {
        t.length && this.writeMessage(i, T2, t);
      }, writePackedBoolean: function(i, t) {
        t.length && this.writeMessage(i, I2, t);
      }, writePackedFloat: function(i, t) {
        t.length && this.writeMessage(i, k2, t);
      }, writePackedDouble: function(i, t) {
        t.length && this.writeMessage(i, D2, t);
      }, writePackedFixed32: function(i, t) {
        t.length && this.writeMessage(i, P2, t);
      }, writePackedSFixed32: function(i, t) {
        t.length && this.writeMessage(i, L2, t);
      }, writePackedFixed64: function(i, t) {
        t.length && this.writeMessage(i, M2, t);
      }, writePackedSFixed64: function(i, t) {
        t.length && this.writeMessage(i, N2, t);
      }, writeBytesField: function(i, t) {
        this.writeTag(i, Ki.Bytes), this.writeBytes(t);
      }, writeFixed32Field: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeFixed32(t);
      }, writeSFixed32Field: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeSFixed32(t);
      }, writeFixed64Field: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeFixed64(t);
      }, writeSFixed64Field: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeSFixed64(t);
      }, writeVarintField: function(i, t) {
        this.writeTag(i, Ki.Varint), this.writeVarint(t);
      }, writeSVarintField: function(i, t) {
        this.writeTag(i, Ki.Varint), this.writeSVarint(t);
      }, writeStringField: function(i, t) {
        this.writeTag(i, Ki.Bytes), this.writeString(t);
      }, writeFloatField: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeFloat(t);
      }, writeDoubleField: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeDouble(t);
      }, writeBooleanField: function(i, t) {
        this.writeVarintField(i, !!t);
      } };
      var jd = k(Hf);
      const qd = 3;
      function z2(i, t, n) {
        i === 1 && n.readMessage(F2, t);
      }
      function F2(i, t, n) {
        if (i === 3) {
          const { id: c, bitmap: f, width: v, height: x, left: E, top: T, advance: M } = n.readMessage(B2, {});
          t.push({ id: c, bitmap: new jc({ width: v + 2 * qd, height: x + 2 * qd }, f), metrics: { width: v, height: x, left: E, top: T, advance: M } });
        }
      }
      function B2(i, t, n) {
        i === 1 ? t.id = n.readVarint() : i === 2 ? t.bitmap = n.readBytes() : i === 3 ? t.width = n.readVarint() : i === 4 ? t.height = n.readVarint() : i === 5 ? t.left = n.readSVarint() : i === 6 ? t.top = n.readSVarint() : i === 7 && (t.advance = n.readVarint());
      }
      const em = qd;
      function tm(i) {
        let t = 0, n = 0;
        for (const x of i) t += x.w * x.h, n = Math.max(n, x.w);
        i.sort((x, E) => E.h - x.h);
        const c = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
        let f = 0, v = 0;
        for (const x of i) for (let E = c.length - 1; E >= 0; E--) {
          const T = c[E];
          if (!(x.w > T.w || x.h > T.h)) {
            if (x.x = T.x, x.y = T.y, v = Math.max(v, x.y + x.h), f = Math.max(f, x.x + x.w), x.w === T.w && x.h === T.h) {
              const M = c.pop();
              E < c.length && (c[E] = M);
            } else x.h === T.h ? (T.x += x.w, T.w -= x.w) : x.w === T.w ? (T.y += x.h, T.h -= x.h) : (c.push({ x: T.x + x.w, y: T.y, w: T.w - x.w, h: x.h }), T.y += x.h, T.h -= x.h);
            break;
          }
        }
        return { w: f, h: v, fill: t / (f * v) || 0 };
      }
      const vs = 1;
      class Ud {
        constructor(t, { pixelRatio: n, version: c, stretchX: f, stretchY: v, content: x, textFitWidth: E, textFitHeight: T }) {
          this.paddedRect = t, this.pixelRatio = n, this.stretchX = f, this.stretchY = v, this.content = x, this.version = c, this.textFitWidth = E, this.textFitHeight = T;
        }
        get tl() {
          return [this.paddedRect.x + vs, this.paddedRect.y + vs];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - vs, this.paddedRect.y + this.paddedRect.h - vs];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * vs) / this.pixelRatio, (this.paddedRect.h - 2 * vs) / this.pixelRatio];
        }
      }
      class im {
        constructor(t, n) {
          const c = {}, f = {};
          this.haveRenderCallbacks = [];
          const v = [];
          this.addImages(t, c, v), this.addImages(n, f, v);
          const { w: x, h: E } = tm(v), T = new ra({ width: x || 1, height: E || 1 });
          for (const M in t) {
            const R = t[M], U = c[M].paddedRect;
            ra.copy(R.data, T, { x: 0, y: 0 }, { x: U.x + vs, y: U.y + vs }, R.data);
          }
          for (const M in n) {
            const R = n[M], U = f[M].paddedRect, H = U.x + vs, J = U.y + vs, ne = R.data.width, he = R.data.height;
            ra.copy(R.data, T, { x: 0, y: 0 }, { x: H, y: J }, R.data), ra.copy(R.data, T, { x: 0, y: he - 1 }, { x: H, y: J - 1 }, { width: ne, height: 1 }), ra.copy(R.data, T, { x: 0, y: 0 }, { x: H, y: J + he }, { width: ne, height: 1 }), ra.copy(R.data, T, { x: ne - 1, y: 0 }, { x: H - 1, y: J }, { width: 1, height: he }), ra.copy(R.data, T, { x: 0, y: 0 }, { x: H + ne, y: J }, { width: 1, height: he });
          }
          this.image = T, this.iconPositions = c, this.patternPositions = f;
        }
        addImages(t, n, c) {
          for (const f in t) {
            const v = t[f], x = { x: 0, y: 0, w: v.data.width + 2 * vs, h: v.data.height + 2 * vs };
            c.push(x), n[f] = new Ud(x, v), v.hasRenderCallback && this.haveRenderCallbacks.push(f);
          }
        }
        patchUpdatedImages(t, n) {
          t.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const c in t.updatedImages) this.patchUpdatedImage(this.iconPositions[c], t.getImage(c), n), this.patchUpdatedImage(this.patternPositions[c], t.getImage(c), n);
        }
        patchUpdatedImage(t, n, c) {
          if (!t || !n || t.version === n.version) return;
          t.version = n.version;
          const [f, v] = t.tl;
          c.update(n.data, void 0, { x: f, y: v });
        }
      }
      var $l;
      Ot("ImagePosition", Ud), Ot("ImageAtlas", im), g.ah = void 0, ($l = g.ah || (g.ah = {}))[$l.none = 0] = "none", $l[$l.horizontal = 1] = "horizontal", $l[$l.vertical = 2] = "vertical", $l[$l.horizontalOnly = 3] = "horizontalOnly";
      const Hc = -17;
      class Wc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t, n) {
          const c = new Wc();
          return c.scale = t || 1, c.fontStack = n, c;
        }
        static forImage(t) {
          const n = new Wc();
          return n.imageName = t, n;
        }
      }
      class nc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t, n) {
          const c = new nc();
          for (let f = 0; f < t.sections.length; f++) {
            const v = t.sections[f];
            v.image ? c.addImageSection(v) : c.addTextSection(v, n);
          }
          return c;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCharCode(t) {
          return this.text.charCodeAt(t);
        }
        verticalizePunctuation() {
          this.text = function(t) {
            let n = "";
            for (let c = 0; c < t.length; c++) {
              const f = t.charCodeAt(c + 1) || null, v = t.charCodeAt(c - 1) || null;
              n += f && dl(f) && !Gc[t[c + 1]] || v && dl(v) && !Gc[t[c - 1]] || !Gc[t[c]] ? t[c] : Gc[t[c]];
            }
            return n;
          }(this.text);
        }
        trim() {
          let t = 0;
          for (let c = 0; c < this.text.length && Rh[this.text.charCodeAt(c)]; c++) t++;
          let n = this.text.length;
          for (let c = this.text.length - 1; c >= 0 && c >= t && Rh[this.text.charCodeAt(c)]; c--) n--;
          this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
        }
        substring(t, n) {
          const c = new nc();
          return c.text = this.text.substring(t, n), c.sectionIndex = this.sectionIndex.slice(t, n), c.sections = this.sections, c;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t, n) => Math.max(t, this.sections[n].scale), 0);
        }
        addTextSection(t, n) {
          this.text += t.text, this.sections.push(Wc.forText(t.scale, t.fontStack || n));
          const c = this.sections.length - 1;
          for (let f = 0; f < t.text.length; ++f) this.sectionIndex.push(c);
        }
        addImageSection(t) {
          const n = t.image ? t.image.name : "";
          if (n.length === 0) return void xe("Can't add FormattedSection with an empty image.");
          const c = this.getNextImageSectionCharCode();
          c ? (this.text += String.fromCharCode(c), this.sections.push(Wc.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : xe("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Bh(i, t, n, c, f, v, x, E, T, M, R, U, H, J, ne) {
        const he = nc.fromFeature(i, f);
        let Se;
        U === g.ah.vertical && he.verticalizePunctuation();
        const { processBidirectionalText: Pe, processStyledBidirectionalText: Xe } = Ln;
        if (Pe && he.sections.length === 1) {
          Se = [];
          const at = Pe(he.toString(), Vd(he, M, v, t, c, J));
          for (const Ct of at) {
            const Bt = new nc();
            Bt.text = Ct, Bt.sections = he.sections;
            for (let hi = 0; hi < Ct.length; hi++) Bt.sectionIndex.push(0);
            Se.push(Bt);
          }
        } else if (Xe) {
          Se = [];
          const at = Xe(he.text, he.sectionIndex, Vd(he, M, v, t, c, J));
          for (const Ct of at) {
            const Bt = new nc();
            Bt.text = Ct[0], Bt.sectionIndex = Ct[1], Bt.sections = he.sections, Se.push(Bt);
          }
        } else Se = function(at, Ct) {
          const Bt = [], hi = at.text;
          let Ft = 0;
          for (const Nt of Ct) Bt.push(at.substring(Ft, Nt)), Ft = Nt;
          return Ft < hi.length && Bt.push(at.substring(Ft, hi.length)), Bt;
        }(he, Vd(he, M, v, t, c, J));
        const Be = [], Ge = { positionedLines: Be, text: he.toString(), top: R[1], bottom: R[1], left: R[0], right: R[0], writingMode: U, iconsInText: !1, verticalizable: !1 };
        return function(at, Ct, Bt, hi, Ft, Nt, Xt, Vt, qt, dt, Yt, Ht) {
          let _i = 0, ir = Hc, Qi = 0, nn = 0;
          const Ia = Vt === "right" ? 1 : Vt === "left" ? 0 : 0.5;
          let wn = 0;
          for (const Mr of Ft) {
            Mr.trim();
            const an = Mr.getMaxScale(), Fn = (an - 1) * $r, An = { positionedGlyphs: [], lineOffset: 0 };
            at.positionedLines[wn] = An;
            const es = An.positionedGlyphs;
            let Sn = 0;
            if (!Mr.length()) {
              ir += Nt, ++wn;
              continue;
            }
            for (let bs = 0; bs < Mr.length(); bs++) {
              const Vi = Mr.getSection(bs), lr = Mr.getSectionIndex(bs), fr = Mr.getCharCode(bs);
              let Bs = 0, Dr = null, lc = null, Oo = null, jo = $r;
              const Pa = !(qt === g.ah.horizontal || !Yt && !yu(fr) || Yt && (Rh[fr] || (sn = fr, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(sn)))));
              if (Vi.imageName) {
                const aa = hi[Vi.imageName];
                if (!aa) continue;
                Oo = Vi.imageName, at.iconsInText = at.iconsInText || !0, lc = aa.paddedRect;
                const mn = aa.displaySize;
                Vi.scale = Vi.scale * $r / Ht, Dr = { width: mn[0], height: mn[1], left: vs, top: -em, advance: Pa ? mn[1] : mn[0] }, Bs = Fn + ($r - mn[1] * Vi.scale), jo = Dr.advance;
                const wl = Pa ? mn[0] * Vi.scale - $r * an : mn[1] * Vi.scale - $r * an;
                wl > 0 && wl > Sn && (Sn = wl);
              } else {
                const aa = Bt[Vi.fontStack], mn = aa && aa[fr];
                if (mn && mn.rect) lc = mn.rect, Dr = mn.metrics;
                else {
                  const wl = Ct[Vi.fontStack], eh = wl && wl[fr];
                  if (!eh) continue;
                  Dr = eh.metrics;
                }
                Bs = (an - Vi.scale) * $r;
              }
              Pa ? (at.verticalizable = !0, es.push({ glyph: fr, imageName: Oo, x: _i, y: ir + Bs, vertical: Pa, scale: Vi.scale, fontStack: Vi.fontStack, sectionIndex: lr, metrics: Dr, rect: lc }), _i += jo * Vi.scale + dt) : (es.push({ glyph: fr, imageName: Oo, x: _i, y: ir + Bs, vertical: Pa, scale: Vi.scale, fontStack: Vi.fontStack, sectionIndex: lr, metrics: Dr, rect: lc }), _i += Dr.advance * Vi.scale + dt);
            }
            es.length !== 0 && (Qi = Math.max(_i - dt, Qi), q2(es, 0, es.length - 1, Ia, Sn)), _i = 0;
            const sa = Nt * an + Sn;
            An.lineOffset = Math.max(Sn, Fn), ir += sa, nn = Math.max(sa, nn), ++wn;
          }
          var sn;
          const Jn = ir - Hc, { horizontalAlign: Kn, verticalAlign: Qn } = $d(Xt);
          (function(Mr, an, Fn, An, es, Sn, sa, bs, Vi) {
            const lr = (an - Fn) * es;
            let fr = 0;
            fr = Sn !== sa ? -bs * An - Hc : (-An * Vi + 0.5) * sa;
            for (const Bs of Mr) for (const Dr of Bs.positionedGlyphs) Dr.x += lr, Dr.y += fr;
          })(at.positionedLines, Ia, Kn, Qn, Qi, nn, Nt, Jn, Ft.length), at.top += -Qn * Jn, at.bottom = at.top + Jn, at.left += -Kn * Qi, at.right = at.left + Qi;
        }(Ge, t, n, c, Se, x, E, T, U, M, H, ne), !function(at) {
          for (const Ct of at) if (Ct.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Be) && Ge;
      }
      const Rh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, R2 = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, O2 = { 40: !0 };
      function rm(i, t, n, c, f, v) {
        if (t.imageName) {
          const x = c[t.imageName];
          return x ? x.displaySize[0] * t.scale * $r / v + f : 0;
        }
        {
          const x = n[t.fontStack], E = x && x[i];
          return E ? E.metrics.advance * t.scale + f : 0;
        }
      }
      function nm(i, t, n, c) {
        const f = Math.pow(i - t, 2);
        return c ? i < t ? f / 2 : 2 * f : f + Math.abs(n) * n;
      }
      function j2(i, t, n) {
        let c = 0;
        return i === 10 && (c -= 1e4), n && (c += 150), i !== 40 && i !== 65288 || (c += 50), t !== 41 && t !== 65289 || (c += 50), c;
      }
      function sm(i, t, n, c, f, v) {
        let x = null, E = nm(t, n, f, v);
        for (const T of c) {
          const M = nm(t - T.x, n, f, v) + T.badness;
          M <= E && (x = T, E = M);
        }
        return { index: i, x: t, priorBreak: x, badness: E };
      }
      function am(i) {
        return i ? am(i.priorBreak).concat(i.index) : [];
      }
      function Vd(i, t, n, c, f, v) {
        if (!i) return [];
        const x = [], E = function(U, H, J, ne, he, Se) {
          let Pe = 0;
          for (let Xe = 0; Xe < U.length(); Xe++) {
            const Be = U.getSection(Xe);
            Pe += rm(U.getCharCode(Xe), Be, ne, he, H, Se);
          }
          return Pe / Math.max(1, Math.ceil(Pe / J));
        }(i, t, n, c, f, v), T = i.text.indexOf("") >= 0;
        let M = 0;
        for (let U = 0; U < i.length(); U++) {
          const H = i.getSection(U), J = i.getCharCode(U);
          if (Rh[J] || (M += rm(J, H, c, f, t, v)), U < i.length() - 1) {
            const ne = !((R = J) < 11904) && (!!vi["CJK Compatibility Forms"](R) || !!vi["CJK Compatibility"](R) || !!vi["CJK Strokes"](R) || !!vi["CJK Symbols and Punctuation"](R) || !!vi["Enclosed CJK Letters and Months"](R) || !!vi["Halfwidth and Fullwidth Forms"](R) || !!vi["Ideographic Description Characters"](R) || !!vi["Vertical Forms"](R) || _u.test(String.fromCodePoint(R)));
            (R2[J] || ne || H.imageName || U !== i.length() - 2 && O2[i.getCharCode(U + 1)]) && x.push(sm(U + 1, M, E, x, j2(J, i.getCharCode(U + 1), ne && T), !1));
          }
        }
        var R;
        return am(sm(i.length(), M, E, x, 0, !0));
      }
      function $d(i) {
        let t = 0.5, n = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            t = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: t, verticalAlign: n };
      }
      function q2(i, t, n, c, f) {
        if (!c && !f) return;
        const v = i[n], x = (i[n].x + v.metrics.advance * v.scale) * c;
        for (let E = t; E <= n; E++) i[E].x -= x, i[E].y += f;
      }
      function U2(i, t, n) {
        const { horizontalAlign: c, verticalAlign: f } = $d(n), v = t[0] - i.displaySize[0] * c, x = t[1] - i.displaySize[1] * f;
        return { image: i, top: x, bottom: x + i.displaySize[1], left: v, right: v + i.displaySize[0] };
      }
      function om(i) {
        var t, n;
        let c = i.left, f = i.top, v = i.right - c, x = i.bottom - f;
        const E = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", T = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", M = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (T === "proportional") {
          if (E === "stretchOnly" && v / x < M || E === "proportional") {
            const R = Math.ceil(x * M);
            c *= R / v, v = R;
          }
        } else if (E === "proportional" && T === "stretchOnly" && M !== 0 && v / x > M) {
          const R = Math.ceil(v / M);
          f *= R / x, x = R;
        }
        return { x1: c, y1: f, x2: c + v, y2: f + x };
      }
      function lm(i, t, n, c, f, v) {
        const x = i.image;
        let E;
        if (x.content) {
          const Se = x.content, Pe = x.pixelRatio || 1;
          E = [Se[0] / Pe, Se[1] / Pe, x.displaySize[0] - Se[2] / Pe, x.displaySize[1] - Se[3] / Pe];
        }
        const T = t.left * v, M = t.right * v;
        let R, U, H, J;
        n === "width" || n === "both" ? (J = f[0] + T - c[3], U = f[0] + M + c[1]) : (J = f[0] + (T + M - x.displaySize[0]) / 2, U = J + x.displaySize[0]);
        const ne = t.top * v, he = t.bottom * v;
        return n === "height" || n === "both" ? (R = f[1] + ne - c[0], H = f[1] + he + c[2]) : (R = f[1] + (ne + he - x.displaySize[1]) / 2, H = R + x.displaySize[1]), { image: x, top: R, right: U, bottom: H, left: J, collisionPadding: E };
      }
      const Xc = 255, Ro = 128, Zl = Xc * Ro;
      function um(i, t) {
        const { expression: n } = t;
        if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Ji(i + 1)) };
        if (n.kind === "source") return { kind: "source" };
        {
          const { zoomStops: c, interpolationType: f } = n;
          let v = 0;
          for (; v < c.length && c[v] <= i; ) v++;
          v = Math.max(0, v - 1);
          let x = v;
          for (; x < c.length && c[x] < i + 1; ) x++;
          x = Math.min(c.length - 1, x);
          const E = c[v], T = c[x];
          return n.kind === "composite" ? { kind: "composite", minZoom: E, maxZoom: T, interpolationType: f } : { kind: "camera", minZoom: E, maxZoom: T, minSize: n.evaluate(new Ji(E)), maxSize: n.evaluate(new Ji(T)), interpolationType: f };
        }
      }
      function Zd(i, t, n) {
        let c = "never";
        const f = i.get(t);
        return f ? c = f : i.get(n) && (c = "always"), c;
      }
      const V2 = Vl.VectorTileFeature.types, $2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Oh(i, t, n, c, f, v, x, E, T, M, R, U, H) {
        const J = E ? Math.min(Zl, Math.round(E[0])) : 0, ne = E ? Math.min(Zl, Math.round(E[1])) : 0;
        i.emplaceBack(t, n, Math.round(32 * c), Math.round(32 * f), v, x, (J << 1) + (T ? 1 : 0), ne, 16 * M, 16 * R, 256 * U, 256 * H);
      }
      function Gd(i, t, n) {
        i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n);
      }
      function Z2(i) {
        for (const t of i.sections) if ($u(t.text)) return !0;
        return !1;
      }
      class Hd {
        constructor(t) {
          this.layoutVertexArray = new gl(), this.indexArray = new tn(), this.programConfigurations = t, this.segments = new Li(), this.dynamicLayoutVertexArray = new Po(), this.opacityVertexArray = new en(), this.hasVisibleVertices = !1, this.placedSymbolArray = new di();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t, n, c, f) {
          this.isEmpty() || (c && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, x2.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, w2.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, $2, !0), this.opacityVertexBuffer.itemSize = 1), (c || f) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Ot("SymbolBuffers", Hd);
      class Wd {
        constructor(t, n, c) {
          this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new c(), this.segments = new Li(), this.collisionVertexArray = new Rr();
        }
        upload(t) {
          this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, A2.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Ot("CollisionBuffers", Wd);
      class sc {
        constructor(t) {
          this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((x) => x.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Td([]), this.placementViewportMatrix = Td([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = um(this.zoom, n["text-size"]), this.iconSizeData = um(this.zoom, n["icon-size"]);
          const c = this.layers[0].layout, f = c.get("symbol-sort-key"), v = c.get("symbol-z-order");
          this.canOverlap = Zd(c, "text-overlap", "text-allow-overlap") !== "never" || Zd(c, "icon-overlap", "icon-allow-overlap") !== "never" || c.get("text-ignore-placement") || c.get("icon-ignore-placement"), this.sortFeaturesByKey = v !== "viewport-y" && !f.isConstant(), this.sortFeaturesByY = (v === "viewport-y" || v === "auto" && !this.sortFeaturesByKey) && this.canOverlap, c.get("symbol-placement") === "point" && (this.writingModes = c.get("text-writing-mode").map((x) => g.ah[x])), this.stateDependentLayerIds = this.layers.filter((x) => x.isStateDependent()).map((x) => x.id), this.sourceID = t.sourceID;
        }
        createArrays() {
          this.text = new Hd(new No(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new Hd(new No(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new Ei(), this.lineVertexArray = new qi(), this.symbolInstances = new gi(), this.textAnchorOffsets = new Fi();
        }
        calculateGlyphDependencies(t, n, c, f, v) {
          for (let x = 0; x < t.length; x++) if (n[t.charCodeAt(x)] = !0, (c || f) && v) {
            const E = Gc[t.charAt(x)];
            E && (n[E.charCodeAt(0)] = !0);
          }
        }
        populate(t, n, c) {
          const f = this.layers[0], v = f.layout, x = v.get("text-font"), E = v.get("text-field"), T = v.get("icon-image"), M = (E.value.kind !== "constant" || E.value.value instanceof Wr && !E.value.value.isEmpty() || E.value.value.toString().length > 0) && (x.value.kind !== "constant" || x.value.value.length > 0), R = T.value.kind !== "constant" || !!T.value.value || Object.keys(T.parameters).length > 0, U = v.get("symbol-sort-key");
          if (this.features = [], !M && !R) return;
          const H = n.iconDependencies, J = n.glyphDependencies, ne = n.availableImages, he = new Ji(this.zoom);
          for (const { feature: Se, id: Pe, index: Xe, sourceLayerIndex: Be } of t) {
            const Ge = f._featureFilter.needGeometry, at = zo(Se, Ge);
            if (!f._featureFilter.filter(he, at, c)) continue;
            let Ct, Bt;
            if (Ge || (at.geometry = vl(Se)), M) {
              const Ft = f.getValueAndResolveTokens("text-field", at, c, ne), Nt = Wr.factory(Ft), Xt = this.hasRTLText = this.hasRTLText || Z2(Nt);
              (!Xt || Ln.getRTLTextPluginStatus() === "unavailable" || Xt && Ln.isParsed()) && (Ct = E2(Nt, f, at));
            }
            if (R) {
              const Ft = f.getValueAndResolveTokens("icon-image", at, c, ne);
              Bt = Ft instanceof Xr ? Ft : Xr.fromString(Ft);
            }
            if (!Ct && !Bt) continue;
            const hi = this.sortFeaturesByKey ? U.evaluate(at, {}, c) : void 0;
            if (this.features.push({ id: Pe, text: Ct, icon: Bt, index: Xe, sourceLayerIndex: Be, geometry: at.geometry, properties: Se.properties, type: V2[Se.type], sortKey: hi }), Bt && (H[Bt.name] = !0), Ct) {
              const Ft = x.evaluate(at, {}, c).join(","), Nt = v.get("text-rotation-alignment") !== "viewport" && v.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(g.ah.vertical) >= 0;
              for (const Xt of Ct.sections) if (Xt.image) H[Xt.image.name] = !0;
              else {
                const Vt = gu(Ct.toString()), qt = Xt.fontStack || Ft, dt = J[qt] = J[qt] || {};
                this.calculateGlyphDependencies(Xt.text, dt, Nt, this.allowVerticalPlacement, Vt);
              }
            }
          }
          v.get("symbol-placement") === "line" && (this.features = function(Se) {
            const Pe = {}, Xe = {}, Be = [];
            let Ge = 0;
            function at(Ft) {
              Be.push(Se[Ft]), Ge++;
            }
            function Ct(Ft, Nt, Xt) {
              const Vt = Xe[Ft];
              return delete Xe[Ft], Xe[Nt] = Vt, Be[Vt].geometry[0].pop(), Be[Vt].geometry[0] = Be[Vt].geometry[0].concat(Xt[0]), Vt;
            }
            function Bt(Ft, Nt, Xt) {
              const Vt = Pe[Nt];
              return delete Pe[Nt], Pe[Ft] = Vt, Be[Vt].geometry[0].shift(), Be[Vt].geometry[0] = Xt[0].concat(Be[Vt].geometry[0]), Vt;
            }
            function hi(Ft, Nt, Xt) {
              const Vt = Xt ? Nt[0][Nt[0].length - 1] : Nt[0][0];
              return `${Ft}:${Vt.x}:${Vt.y}`;
            }
            for (let Ft = 0; Ft < Se.length; Ft++) {
              const Nt = Se[Ft], Xt = Nt.geometry, Vt = Nt.text ? Nt.text.toString() : null;
              if (!Vt) {
                at(Ft);
                continue;
              }
              const qt = hi(Vt, Xt), dt = hi(Vt, Xt, !0);
              if (qt in Xe && dt in Pe && Xe[qt] !== Pe[dt]) {
                const Yt = Bt(qt, dt, Xt), Ht = Ct(qt, dt, Be[Yt].geometry);
                delete Pe[qt], delete Xe[dt], Xe[hi(Vt, Be[Ht].geometry, !0)] = Ht, Be[Yt].geometry = null;
              } else qt in Xe ? Ct(qt, dt, Xt) : dt in Pe ? Bt(qt, dt, Xt) : (at(Ft), Pe[qt] = Ge - 1, Xe[dt] = Ge - 1);
            }
            return Be.filter((Ft) => Ft.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((Se, Pe) => Se.sortKey - Pe.sortKey);
        }
        update(t, n, c) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, c), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, c));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t, n) {
          const c = this.lineVertexArray.length;
          if (t.segment !== void 0) {
            let f = t.dist(n[t.segment + 1]), v = t.dist(n[t.segment]);
            const x = {};
            for (let E = t.segment + 1; E < n.length; E++) x[E] = { x: n[E].x, y: n[E].y, tileUnitDistanceFromAnchor: f }, E < n.length - 1 && (f += n[E + 1].dist(n[E]));
            for (let E = t.segment || 0; E >= 0; E--) x[E] = { x: n[E].x, y: n[E].y, tileUnitDistanceFromAnchor: v }, E > 0 && (v += n[E - 1].dist(n[E]));
            for (let E = 0; E < n.length; E++) {
              const T = x[E];
              this.lineVertexArray.emplaceBack(T.x, T.y, T.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: c, lineLength: this.lineVertexArray.length - c };
        }
        addSymbols(t, n, c, f, v, x, E, T, M, R, U, H) {
          const J = t.indexArray, ne = t.layoutVertexArray, he = t.segments.prepareSegment(4 * n.length, ne, J, this.canOverlap ? x.sortKey : void 0), Se = this.glyphOffsetArray.length, Pe = he.vertexLength, Xe = this.allowVerticalPlacement && E === g.ah.vertical ? Math.PI / 2 : 0, Be = x.text && x.text.sections;
          for (let Ge = 0; Ge < n.length; Ge++) {
            const { tl: at, tr: Ct, bl: Bt, br: hi, tex: Ft, pixelOffsetTL: Nt, pixelOffsetBR: Xt, minFontScaleX: Vt, minFontScaleY: qt, glyphOffset: dt, isSDF: Yt, sectionIndex: Ht } = n[Ge], _i = he.vertexLength, ir = dt[1];
            Oh(ne, T.x, T.y, at.x, ir + at.y, Ft.x, Ft.y, c, Yt, Nt.x, Nt.y, Vt, qt), Oh(ne, T.x, T.y, Ct.x, ir + Ct.y, Ft.x + Ft.w, Ft.y, c, Yt, Xt.x, Nt.y, Vt, qt), Oh(ne, T.x, T.y, Bt.x, ir + Bt.y, Ft.x, Ft.y + Ft.h, c, Yt, Nt.x, Xt.y, Vt, qt), Oh(ne, T.x, T.y, hi.x, ir + hi.y, Ft.x + Ft.w, Ft.y + Ft.h, c, Yt, Xt.x, Xt.y, Vt, qt), Gd(t.dynamicLayoutVertexArray, T, Xe), J.emplaceBack(_i, _i + 1, _i + 2), J.emplaceBack(_i + 1, _i + 2, _i + 3), he.vertexLength += 4, he.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), Ge !== n.length - 1 && Ht === n[Ge + 1].sectionIndex || t.programConfigurations.populatePaintArrays(ne.length, x, x.index, {}, H, Be && Be[Ht]);
          }
          t.placedSymbolArray.emplaceBack(T.x, T.y, Se, this.glyphOffsetArray.length - Se, Pe, M, R, T.segment, c ? c[0] : 0, c ? c[1] : 0, f[0], f[1], E, 0, !1, 0, U);
        }
        _addCollisionDebugVertex(t, n, c, f, v, x) {
          return n.emplaceBack(0, 0), t.emplaceBack(c.x, c.y, f, v, Math.round(x.x), Math.round(x.y));
        }
        addCollisionDebugVertices(t, n, c, f, v, x, E) {
          const T = v.segments.prepareSegment(4, v.layoutVertexArray, v.indexArray), M = T.vertexLength, R = v.layoutVertexArray, U = v.collisionVertexArray, H = E.anchorX, J = E.anchorY;
          this._addCollisionDebugVertex(R, U, x, H, J, new j(t, n)), this._addCollisionDebugVertex(R, U, x, H, J, new j(c, n)), this._addCollisionDebugVertex(R, U, x, H, J, new j(c, f)), this._addCollisionDebugVertex(R, U, x, H, J, new j(t, f)), T.vertexLength += 4;
          const ne = v.indexArray;
          ne.emplaceBack(M, M + 1), ne.emplaceBack(M + 1, M + 2), ne.emplaceBack(M + 2, M + 3), ne.emplaceBack(M + 3, M), T.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t, n, c, f) {
          for (let v = t; v < n; v++) {
            const x = this.collisionBoxArray.get(v);
            this.addCollisionDebugVertices(x.x1, x.y1, x.x2, x.y2, f ? this.textCollisionBox : this.iconCollisionBox, x.anchorPoint, c);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Wd(fn, Gf.members, Ar), this.iconCollisionBox = new Wd(fn, Gf.members, Ar);
          for (let t = 0; t < this.symbolInstances.length; t++) {
            const n = this.symbolInstances.get(t);
            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(t, n, c, f, v, x, E, T, M) {
          const R = {};
          for (let U = n; U < c; U++) {
            const H = t.get(U);
            R.textBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.textFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = f; U < v; U++) {
            const H = t.get(U);
            R.verticalTextBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.verticalTextFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = x; U < E; U++) {
            const H = t.get(U);
            R.iconBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.iconFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = T; U < M; U++) {
            const H = t.get(U);
            R.verticalIconBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.verticalIconFeatureIndex = H.featureIndex;
            break;
          }
          return R;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const c = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, c.textBoxStartIndex, c.textBoxEndIndex, c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c.iconBoxStartIndex, c.iconBoxEndIndex, c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t, n) {
          const c = t.placedSymbolArray.get(n), f = c.vertexStartIndex + 4 * c.numGlyphs;
          for (let v = c.vertexStartIndex; v < f; v += 4) t.indexArray.emplaceBack(v, v + 1, v + 2), t.indexArray.emplaceBack(v + 1, v + 2, v + 3);
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const n = Math.sin(t), c = Math.cos(t), f = [], v = [], x = [];
          for (let E = 0; E < this.symbolInstances.length; ++E) {
            x.push(E);
            const T = this.symbolInstances.get(E);
            f.push(0 | Math.round(n * T.anchorX + c * T.anchorY)), v.push(T.featureIndex);
          }
          return x.sort((E, T) => f[E] - f[T] || v[T] - v[E]), x;
        }
        addToSortKeyRanges(t, n) {
          const c = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          c && c.sortKey === n ? c.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
        }
        sortFeatures(t) {
          if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const c = this.symbolInstances.get(n);
              this.featureSortOrder.push(c.featureIndex), [c.rightJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.leftJustifiedTextSymbolIndex].forEach((f, v, x) => {
                f >= 0 && x.indexOf(f) === v && this.addIndicesForPlacedSymbol(this.text, f);
              }), c.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, c.verticalPlacedTextSymbolIndex), c.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.placedIconSymbolIndex), c.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let cm, hm;
      Ot("SymbolBucket", sc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), sc.MAX_GLYPHS = 65535, sc.addDynamicAttributes = Gd;
      var Xd = { get paint() {
        return hm = hm || new h({ "icon-opacity": new li(Y.paint_symbol["icon-opacity"]), "icon-color": new li(Y.paint_symbol["icon-color"]), "icon-halo-color": new li(Y.paint_symbol["icon-halo-color"]), "icon-halo-width": new li(Y.paint_symbol["icon-halo-width"]), "icon-halo-blur": new li(Y.paint_symbol["icon-halo-blur"]), "icon-translate": new Gt(Y.paint_symbol["icon-translate"]), "icon-translate-anchor": new Gt(Y.paint_symbol["icon-translate-anchor"]), "text-opacity": new li(Y.paint_symbol["text-opacity"]), "text-color": new li(Y.paint_symbol["text-color"], { runtimeType: Si, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new li(Y.paint_symbol["text-halo-color"]), "text-halo-width": new li(Y.paint_symbol["text-halo-width"]), "text-halo-blur": new li(Y.paint_symbol["text-halo-blur"]), "text-translate": new Gt(Y.paint_symbol["text-translate"]), "text-translate-anchor": new Gt(Y.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return cm = cm || new h({ "symbol-placement": new Gt(Y.layout_symbol["symbol-placement"]), "symbol-spacing": new Gt(Y.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Gt(Y.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new li(Y.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Gt(Y.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Gt(Y.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Gt(Y.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Gt(Y.layout_symbol["icon-ignore-placement"]), "icon-optional": new Gt(Y.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Gt(Y.layout_symbol["icon-rotation-alignment"]), "icon-size": new li(Y.layout_symbol["icon-size"]), "icon-text-fit": new Gt(Y.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Gt(Y.layout_symbol["icon-text-fit-padding"]), "icon-image": new li(Y.layout_symbol["icon-image"]), "icon-rotate": new li(Y.layout_symbol["icon-rotate"]), "icon-padding": new li(Y.layout_symbol["icon-padding"]), "icon-keep-upright": new Gt(Y.layout_symbol["icon-keep-upright"]), "icon-offset": new li(Y.layout_symbol["icon-offset"]), "icon-anchor": new li(Y.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Gt(Y.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Gt(Y.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Gt(Y.layout_symbol["text-rotation-alignment"]), "text-field": new li(Y.layout_symbol["text-field"]), "text-font": new li(Y.layout_symbol["text-font"]), "text-size": new li(Y.layout_symbol["text-size"]), "text-max-width": new li(Y.layout_symbol["text-max-width"]), "text-line-height": new Gt(Y.layout_symbol["text-line-height"]), "text-letter-spacing": new li(Y.layout_symbol["text-letter-spacing"]), "text-justify": new li(Y.layout_symbol["text-justify"]), "text-radial-offset": new li(Y.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Gt(Y.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new li(Y.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new li(Y.layout_symbol["text-anchor"]), "text-max-angle": new Gt(Y.layout_symbol["text-max-angle"]), "text-writing-mode": new Gt(Y.layout_symbol["text-writing-mode"]), "text-rotate": new li(Y.layout_symbol["text-rotate"]), "text-padding": new Gt(Y.layout_symbol["text-padding"]), "text-keep-upright": new Gt(Y.layout_symbol["text-keep-upright"]), "text-transform": new li(Y.layout_symbol["text-transform"]), "text-offset": new li(Y.layout_symbol["text-offset"]), "text-allow-overlap": new Gt(Y.layout_symbol["text-allow-overlap"]), "text-overlap": new Gt(Y.layout_symbol["text-overlap"]), "text-ignore-placement": new Gt(Y.layout_symbol["text-ignore-placement"]), "text-optional": new Gt(Y.layout_symbol["text-optional"]) });
      } };
      class dm {
        constructor(t) {
          if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t.property.overrides ? t.property.overrides.runtimeType : Zi, this.defaultValue = t;
        }
        evaluate(t) {
          if (t.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Ot("FormatSectionOverride", dm, { omit: ["defaultValue"] });
      class jh extends r {
        constructor(t) {
          super(t, Xd);
        }
        recalculate(t, n) {
          if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const c = this.layout.get("text-writing-mode");
            if (c) {
              const f = [];
              for (const v of c) f.indexOf(v) < 0 && f.push(v);
              this.layout._values["text-writing-mode"] = f;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, n, c, f) {
          const v = this.layout.get(t).evaluate(n, {}, c, f), x = this._unevaluatedLayout._values[t];
          return x.isDataDriven() || fs(x.value) || !v ? v : function(E, T) {
            return T.replace(/{([^{}]+)}/g, (M, R) => E && R in E ? String(E[R]) : "");
          }(n.properties, v);
        }
        createBucket(t) {
          return new sc(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t of Xd.paint.overridableProperties) {
            if (!jh.hasPaintOverride(this.layout, t)) continue;
            const n = this.paint.get(t), c = new dm(n), f = new ba(c, n.property.specification);
            let v = null;
            v = n.value.kind === "constant" || n.value.kind === "source" ? new vn("source", f) : new Vn("composite", f, n.value.zoomStops), this.paint._values[t] = new _s(n.property, v, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t, n, c) {
          return !(!this.layout || n.isDataDriven() || c.isDataDriven()) && jh.hasPaintOverride(this.layout, t);
        }
        static hasPaintOverride(t, n) {
          const c = t.get("text-field"), f = Xd.paint.properties[n];
          let v = !1;
          const x = (E) => {
            for (const T of E) if (f.overrides && f.overrides.hasOverride(T)) return void (v = !0);
          };
          if (c.value.kind === "constant" && c.value.value instanceof Wr) x(c.value.value.sections);
          else if (c.value.kind === "source") {
            const E = (M) => {
              v || (M instanceof _n && xr(M.value) === Ni ? x(M.value.sections) : M instanceof fo ? x(M.sections) : M.eachChild(E));
            }, T = c.value;
            T._styleExpression && E(T._styleExpression.expression);
          }
          return v;
        }
      }
      let pm;
      var G2 = { get paint() {
        return pm = pm || new h({ "background-color": new Gt(Y.paint_background["background-color"]), "background-pattern": new b(Y.paint_background["background-pattern"]), "background-opacity": new Gt(Y.paint_background["background-opacity"]) });
      } };
      class H2 extends r {
        constructor(t) {
          super(t, G2);
        }
      }
      let fm;
      var W2 = { get paint() {
        return fm = fm || new h({ "raster-opacity": new Gt(Y.paint_raster["raster-opacity"]), "raster-hue-rotate": new Gt(Y.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Gt(Y.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Gt(Y.paint_raster["raster-brightness-max"]), "raster-saturation": new Gt(Y.paint_raster["raster-saturation"]), "raster-contrast": new Gt(Y.paint_raster["raster-contrast"]), "raster-resampling": new Gt(Y.paint_raster["raster-resampling"]), "raster-fade-duration": new Gt(Y.paint_raster["raster-fade-duration"]) });
      } };
      class X2 extends r {
        constructor(t) {
          super(t, W2);
        }
      }
      class Y2 extends r {
        constructor(t) {
          super(t, {}), this.onAdd = (n) => {
            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
          }, this.onRemove = (n) => {
            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
          }, this.implementation = t;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class J2 {
        constructor(t) {
          this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const Yd = 63710088e-1;
      class Gl {
        constructor(t, n) {
          if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
          if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Gl(Qe(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const n = Math.PI / 180, c = this.lat * n, f = t.lat * n, v = Math.sin(c) * Math.sin(f) + Math.cos(c) * Math.cos(f) * Math.cos((t.lng - this.lng) * n);
          return Yd * Math.acos(Math.min(v, 1));
        }
        static convert(t) {
          if (t instanceof Gl) return t;
          if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Gl(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Gl(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const mm = 2 * Math.PI * Yd;
      function gm(i) {
        return mm * Math.cos(i * Math.PI / 180);
      }
      function _m(i) {
        return (180 + i) / 360;
      }
      function ym(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function vm(i, t) {
        return i / gm(t);
      }
      function Jd(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class Yc {
        constructor(t, n, c = 0) {
          this.x = +t, this.y = +n, this.z = +c;
        }
        static fromLngLat(t, n = 0) {
          const c = Gl.convert(t);
          return new Yc(_m(c.lng), ym(c.lat), vm(n, c.lat));
        }
        toLngLat() {
          return new Gl(360 * this.x - 180, Jd(this.y));
        }
        toAltitude() {
          return this.z * gm(Jd(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / mm * (t = Jd(this.y), 1 / Math.cos(t * Math.PI / 180));
          var t;
        }
      }
      function bm(i, t, n) {
        var c = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
        return [i * c - 2 * Math.PI * 6378137 / 2, t * c - 2 * Math.PI * 6378137 / 2];
      }
      class Kd {
        constructor(t, n, c) {
          if (!function(f, v, x) {
            return !(f < 0 || f > 25 || x < 0 || x >= Math.pow(2, f) || v < 0 || v >= Math.pow(2, f));
          }(t, n, c)) throw new Error(`x=${n}, y=${c}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
          this.z = t, this.x = n, this.y = c, this.key = Jc(0, t, t, n, c);
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, n, c) {
          const f = (x = this.y, E = this.z, T = bm(256 * (v = this.x), 256 * (x = Math.pow(2, E) - x - 1), E), M = bm(256 * (v + 1), 256 * (x + 1), E), T[0] + "," + T[1] + "," + M[0] + "," + M[1]);
          var v, x, E, T, M;
          const R = function(U, H, J) {
            let ne, he = "";
            for (let Se = U; Se > 0; Se--) ne = 1 << Se - 1, he += (H & ne ? 1 : 0) + (J & ne ? 2 : 0);
            return he;
          }(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(c === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, R).replace(/{bbox-epsg-3857}/g, f);
        }
        isChildOf(t) {
          const n = this.z - t.z;
          return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
        }
        getTilePoint(t) {
          const n = Math.pow(2, this.z);
          return new j((t.x * n - this.x) * or, (t.y * n - this.y) * or);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class xm {
        constructor(t, n) {
          this.wrap = t, this.canonical = n, this.key = Jc(t, n.z, n.z, n.x, n.y);
        }
      }
      class na {
        constructor(t, n, c, f, v) {
          if (t < c) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${c}`);
          this.overscaledZ = t, this.wrap = n, this.canonical = new Kd(c, +f, +v), this.key = Jc(n, t, c, f, v);
        }
        clone() {
          return new na(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t) {
          return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
        }
        scaledTo(t) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const n = this.canonical.z - t;
          return t > this.canonical.z ? new na(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new na(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(t, n) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const c = this.canonical.z - t;
          return t > this.canonical.z ? Jc(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Jc(this.wrap * +n, t, t, this.canonical.x >> c, this.canonical.y >> c);
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          const n = this.canonical.z - t.canonical.z;
          return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
        }
        children(t) {
          if (this.overscaledZ >= t) return [new na(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, c = 2 * this.canonical.x, f = 2 * this.canonical.y;
          return [new na(n, this.wrap, n, c, f), new na(n, this.wrap, n, c + 1, f), new na(n, this.wrap, n, c, f + 1), new na(n, this.wrap, n, c + 1, f + 1)];
        }
        isLessThan(t) {
          return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
        }
        wrapped() {
          return new na(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t) {
          return new na(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new xm(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t) {
          return this.canonical.getTilePoint(new Yc(t.x - this.wrap, t.y));
        }
      }
      function Jc(i, t, n, c, f) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const v = 1 << n;
        return (v * v * i + v * f + c).toString(36) + n.toString(36) + t.toString(36);
      }
      Ot("CanonicalTileID", Kd), Ot("OverscaledTileID", na, { omit: ["posMatrix"] });
      class wm {
        constructor(t, n, c, f = 1, v = 1, x = 1, E = 0) {
          if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
          if (c && !["mapbox", "terrarium", "custom"].includes(c)) return void xe(`"${c}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = n.height;
          const T = this.dim = n.height - 2;
          switch (this.data = new Uint32Array(n.data.buffer), c) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = f, this.greenFactor = v, this.blueFactor = x, this.baseShift = E;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let M = 0; M < T; M++) this.data[this._idx(-1, M)] = this.data[this._idx(0, M)], this.data[this._idx(T, M)] = this.data[this._idx(T - 1, M)], this.data[this._idx(M, -1)] = this.data[this._idx(M, 0)], this.data[this._idx(M, T)] = this.data[this._idx(M, T - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(T, -1)] = this.data[this._idx(T - 1, 0)], this.data[this._idx(-1, T)] = this.data[this._idx(0, T - 1)], this.data[this._idx(T, T)] = this.data[this._idx(T - 1, T - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let M = 0; M < T; M++) for (let R = 0; R < T; R++) {
            const U = this.get(M, R);
            U > this.max && (this.max = U), U < this.min && (this.min = U);
          }
        }
        get(t, n) {
          const c = new Uint8Array(this.data.buffer), f = 4 * this._idx(t, n);
          return this.unpack(c[f], c[f + 1], c[f + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t, n) {
          if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (t + 1);
        }
        unpack(t, n, c) {
          return t * this.redFactor + n * this.greenFactor + c * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new ra({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t, n, c) {
          if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
          let f = n * this.dim, v = n * this.dim + this.dim, x = c * this.dim, E = c * this.dim + this.dim;
          switch (n) {
            case -1:
              f = v - 1;
              break;
            case 1:
              v = f + 1;
          }
          switch (c) {
            case -1:
              x = E - 1;
              break;
            case 1:
              E = x + 1;
          }
          const T = -n * this.dim, M = -c * this.dim;
          for (let R = x; R < E; R++) for (let U = f; U < v; U++) this.data[this._idx(U, R)] = t.data[this._idx(U + T, R + M)];
        }
      }
      Ot("DEMData", wm);
      class Am {
        constructor(t) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < t.length; n++) {
            const c = t[n];
            this._stringToNumber[c] = n, this._numberToString[n] = c;
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t];
        }
      }
      class Sm {
        constructor(t, n, c, f, v) {
          this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = c, t._y = f, this.properties = t.properties, this.id = v;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { geometry: this.geometry };
          for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
          return t;
        }
      }
      class Em {
        constructor(t, n) {
          this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ko(or, 16, 0), this.grid3D = new ko(or, 16, 0), this.featureIndexArray = new Ui(), this.promoteId = n;
        }
        insert(t, n, c, f, v, x) {
          const E = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(c, f, v);
          const T = x ? this.grid3D : this.grid;
          for (let M = 0; M < n.length; M++) {
            const R = n[M], U = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let H = 0; H < R.length; H++) {
              const J = R[H];
              U[0] = Math.min(U[0], J.x), U[1] = Math.min(U[1], J.y), U[2] = Math.max(U[2], J.x), U[3] = Math.max(U[3], J.y);
            }
            U[0] < or && U[1] < or && U[2] >= 0 && U[3] >= 0 && T.insert(E, U[0], U[1], U[2], U[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Vl.VectorTile(new jd(this.rawTileData)).layers, this.sourceLayerCoder = new Am(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t, n, c, f) {
          this.loadVTLayers();
          const v = t.params || {}, x = or / t.tileSize / t.scale, E = ms(v.filter), T = t.queryGeometry, M = t.queryPadding * x, R = Tm(T), U = this.grid.query(R.minX - M, R.minY - M, R.maxX + M, R.maxY + M), H = Tm(t.cameraQueryGeometry), J = this.grid3D.query(H.minX - M, H.minY - M, H.maxX + M, H.maxY + M, (Se, Pe, Xe, Be) => function(Ge, at, Ct, Bt, hi) {
            for (const Nt of Ge) if (at <= Nt.x && Ct <= Nt.y && Bt >= Nt.x && hi >= Nt.y) return !0;
            const Ft = [new j(at, Ct), new j(at, hi), new j(Bt, hi), new j(Bt, Ct)];
            if (Ge.length > 2) {
              for (const Nt of Ft) if (Bo(Ge, Nt)) return !0;
            }
            for (let Nt = 0; Nt < Ge.length - 1; Nt++) if (Bc(Ge[Nt], Ge[Nt + 1], Ft)) return !0;
            return !1;
          }(t.cameraQueryGeometry, Se - M, Pe - M, Xe + M, Be + M));
          for (const Se of J) U.push(Se);
          U.sort(K2);
          const ne = {};
          let he;
          for (let Se = 0; Se < U.length; Se++) {
            const Pe = U[Se];
            if (Pe === he) continue;
            he = Pe;
            const Xe = this.featureIndexArray.get(Pe);
            let Be = null;
            this.loadMatchingFeature(ne, Xe.bucketIndex, Xe.sourceLayerIndex, Xe.featureIndex, E, v.layers, v.availableImages, n, c, f, (Ge, at, Ct) => (Be || (Be = vl(Ge)), at.queryIntersectsFeature(T, Ge, Ct, Be, this.z, t.transform, x, t.pixelPosMatrix)));
          }
          return ne;
        }
        loadMatchingFeature(t, n, c, f, v, x, E, T, M, R, U) {
          const H = this.bucketLayerIDs[n];
          if (x && !function(Se, Pe) {
            for (let Xe = 0; Xe < Se.length; Xe++) if (Pe.indexOf(Se[Xe]) >= 0) return !0;
            return !1;
          }(x, H)) return;
          const J = this.sourceLayerCoder.decode(c), ne = this.vtLayers[J].feature(f);
          if (v.needGeometry) {
            const Se = zo(ne, !0);
            if (!v.filter(new Ji(this.tileID.overscaledZ), Se, this.tileID.canonical)) return;
          } else if (!v.filter(new Ji(this.tileID.overscaledZ), ne)) return;
          const he = this.getId(ne, J);
          for (let Se = 0; Se < H.length; Se++) {
            const Pe = H[Se];
            if (x && x.indexOf(Pe) < 0) continue;
            const Xe = T[Pe];
            if (!Xe) continue;
            let Be = {};
            he && R && (Be = R.getState(Xe.sourceLayer || "_geojsonTileLayer", he));
            const Ge = ke({}, M[Pe]);
            Ge.paint = Cm(Ge.paint, Xe.paint, ne, Be, E), Ge.layout = Cm(Ge.layout, Xe.layout, ne, Be, E);
            const at = !U || U(ne, Xe, Be);
            if (!at) continue;
            const Ct = new Sm(ne, this.z, this.x, this.y, he);
            Ct.layer = Ge;
            let Bt = t[Pe];
            Bt === void 0 && (Bt = t[Pe] = []), Bt.push({ featureIndex: f, feature: Ct, intersectionZ: at });
          }
        }
        lookupSymbolFeatures(t, n, c, f, v, x, E, T) {
          const M = {};
          this.loadVTLayers();
          const R = ms(v);
          for (const U of t) this.loadMatchingFeature(M, c, f, U, R, x, E, T, n);
          return M;
        }
        hasLayer(t) {
          for (const n of this.bucketLayerIDs) for (const c of n) if (t === c) return !0;
          return !1;
        }
        getId(t, n) {
          let c = t.id;
          return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof c == "boolean" && (c = Number(c))), c;
        }
      }
      function Cm(i, t, n, c, f) {
        return me(i, (v, x) => {
          const E = t instanceof Sa ? t.get(x) : null;
          return E && E.evaluate ? E.evaluate(n, c, f) : E;
        });
      }
      function Tm(i) {
        let t = 1 / 0, n = 1 / 0, c = -1 / 0, f = -1 / 0;
        for (const v of i) t = Math.min(t, v.x), n = Math.min(n, v.y), c = Math.max(c, v.x), f = Math.max(f, v.y);
        return { minX: t, minY: n, maxX: c, maxY: f };
      }
      function K2(i, t) {
        return t - i;
      }
      function km(i, t, n, c, f) {
        const v = [];
        for (let x = 0; x < i.length; x++) {
          const E = i[x];
          let T;
          for (let M = 0; M < E.length - 1; M++) {
            let R = E[M], U = E[M + 1];
            R.x < t && U.x < t || (R.x < t ? R = new j(t, R.y + (t - R.x) / (U.x - R.x) * (U.y - R.y))._round() : U.x < t && (U = new j(t, R.y + (t - R.x) / (U.x - R.x) * (U.y - R.y))._round()), R.y < n && U.y < n || (R.y < n ? R = new j(R.x + (n - R.y) / (U.y - R.y) * (U.x - R.x), n)._round() : U.y < n && (U = new j(R.x + (n - R.y) / (U.y - R.y) * (U.x - R.x), n)._round()), R.x >= c && U.x >= c || (R.x >= c ? R = new j(c, R.y + (c - R.x) / (U.x - R.x) * (U.y - R.y))._round() : U.x >= c && (U = new j(c, R.y + (c - R.x) / (U.x - R.x) * (U.y - R.y))._round()), R.y >= f && U.y >= f || (R.y >= f ? R = new j(R.x + (f - R.y) / (U.y - R.y) * (U.x - R.x), f)._round() : U.y >= f && (U = new j(R.x + (f - R.y) / (U.y - R.y) * (U.x - R.x), f)._round()), T && R.equals(T[T.length - 1]) || (T = [R], v.push(T)), T.push(U)))));
          }
        }
        return v;
      }
      Ot("FeatureIndex", Em, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Hl extends j {
        constructor(t, n, c, f) {
          super(t, n), this.angle = c, f !== void 0 && (this.segment = f);
        }
        clone() {
          return new Hl(this.x, this.y, this.angle, this.segment);
        }
      }
      function Dm(i, t, n, c, f) {
        if (t.segment === void 0 || n === 0) return !0;
        let v = t, x = t.segment + 1, E = 0;
        for (; E > -n / 2; ) {
          if (x--, x < 0) return !1;
          E -= i[x].dist(v), v = i[x];
        }
        E += i[x].dist(i[x + 1]), x++;
        const T = [];
        let M = 0;
        for (; E < n / 2; ) {
          const R = i[x], U = i[x + 1];
          if (!U) return !1;
          let H = i[x - 1].angleTo(R) - R.angleTo(U);
          for (H = Math.abs((H + 3 * Math.PI) % (2 * Math.PI) - Math.PI), T.push({ distance: E, angleDelta: H }), M += H; E - T[0].distance > c; ) M -= T.shift().angleDelta;
          if (M > f) return !1;
          x++, E += R.dist(U);
        }
        return !0;
      }
      function Im(i) {
        let t = 0;
        for (let n = 0; n < i.length - 1; n++) t += i[n].dist(i[n + 1]);
        return t;
      }
      function Pm(i, t, n) {
        return i ? 0.6 * t * n : 0;
      }
      function Lm(i, t) {
        return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0);
      }
      function Q2(i, t, n, c, f, v) {
        const x = Pm(n, f, v), E = Lm(n, c) * v;
        let T = 0;
        const M = Im(i) / 2;
        for (let R = 0; R < i.length - 1; R++) {
          const U = i[R], H = i[R + 1], J = U.dist(H);
          if (T + J > M) {
            const ne = (M - T) / J, he = qr.number(U.x, H.x, ne), Se = qr.number(U.y, H.y, ne), Pe = new Hl(he, Se, H.angleTo(U), R);
            return Pe._round(), !x || Dm(i, Pe, E, x, t) ? Pe : void 0;
          }
          T += J;
        }
      }
      function e_(i, t, n, c, f, v, x, E, T) {
        const M = Pm(c, v, x), R = Lm(c, f), U = R * x, H = i[0].x === 0 || i[0].x === T || i[0].y === 0 || i[0].y === T;
        return t - U < t / 4 && (t = U + t / 4), Mm(i, H ? t / 2 * E % t : (R / 2 + 2 * v) * x * E % t, t, M, n, U, H, !1, T);
      }
      function Mm(i, t, n, c, f, v, x, E, T) {
        const M = v / 2, R = Im(i);
        let U = 0, H = t - n, J = [];
        for (let ne = 0; ne < i.length - 1; ne++) {
          const he = i[ne], Se = i[ne + 1], Pe = he.dist(Se), Xe = Se.angleTo(he);
          for (; H + n < U + Pe; ) {
            H += n;
            const Be = (H - U) / Pe, Ge = qr.number(he.x, Se.x, Be), at = qr.number(he.y, Se.y, Be);
            if (Ge >= 0 && Ge < T && at >= 0 && at < T && H - M >= 0 && H + M <= R) {
              const Ct = new Hl(Ge, at, Xe, ne);
              Ct._round(), c && !Dm(i, Ct, v, c, f) || J.push(Ct);
            }
          }
          U += Pe;
        }
        return E || J.length || x || (J = Mm(i, U / 2, n, c, f, v, x, !0, T)), J;
      }
      Ot("Anchor", Hl);
      const ac = vs;
      function Nm(i, t, n, c) {
        const f = [], v = i.image, x = v.pixelRatio, E = v.paddedRect.w - 2 * ac, T = v.paddedRect.h - 2 * ac;
        let M = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const R = v.stretchX || [[0, E]], U = v.stretchY || [[0, T]], H = (dt, Yt) => dt + Yt[1] - Yt[0], J = R.reduce(H, 0), ne = U.reduce(H, 0), he = E - J, Se = T - ne;
        let Pe = 0, Xe = J, Be = 0, Ge = ne, at = 0, Ct = he, Bt = 0, hi = Se;
        if (v.content && c) {
          const dt = v.content, Yt = dt[2] - dt[0], Ht = dt[3] - dt[1];
          (v.textFitWidth || v.textFitHeight) && (M = om(i)), Pe = qh(R, 0, dt[0]), Be = qh(U, 0, dt[1]), Xe = qh(R, dt[0], dt[2]), Ge = qh(U, dt[1], dt[3]), at = dt[0] - Pe, Bt = dt[1] - Be, Ct = Yt - Xe, hi = Ht - Ge;
        }
        const Ft = M.x1, Nt = M.y1, Xt = M.x2 - Ft, Vt = M.y2 - Nt, qt = (dt, Yt, Ht, _i) => {
          const ir = Uh(dt.stretch - Pe, Xe, Xt, Ft), Qi = Vh(dt.fixed - at, Ct, dt.stretch, J), nn = Uh(Yt.stretch - Be, Ge, Vt, Nt), Ia = Vh(Yt.fixed - Bt, hi, Yt.stretch, ne), wn = Uh(Ht.stretch - Pe, Xe, Xt, Ft), sn = Vh(Ht.fixed - at, Ct, Ht.stretch, J), Jn = Uh(_i.stretch - Be, Ge, Vt, Nt), Kn = Vh(_i.fixed - Bt, hi, _i.stretch, ne), Qn = new j(ir, nn), Mr = new j(wn, nn), an = new j(wn, Jn), Fn = new j(ir, Jn), An = new j(Qi / x, Ia / x), es = new j(sn / x, Kn / x), Sn = t * Math.PI / 180;
          if (Sn) {
            const Vi = Math.sin(Sn), lr = Math.cos(Sn), fr = [lr, -Vi, Vi, lr];
            Qn._matMult(fr), Mr._matMult(fr), Fn._matMult(fr), an._matMult(fr);
          }
          const sa = dt.stretch + dt.fixed, bs = Yt.stretch + Yt.fixed;
          return { tl: Qn, tr: Mr, bl: Fn, br: an, tex: { x: v.paddedRect.x + ac + sa, y: v.paddedRect.y + ac + bs, w: Ht.stretch + Ht.fixed - sa, h: _i.stretch + _i.fixed - bs }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: An, pixelOffsetBR: es, minFontScaleX: Ct / x / Xt, minFontScaleY: hi / x / Vt, isSDF: n };
        };
        if (c && (v.stretchX || v.stretchY)) {
          const dt = zm(R, he, J), Yt = zm(U, Se, ne);
          for (let Ht = 0; Ht < dt.length - 1; Ht++) {
            const _i = dt[Ht], ir = dt[Ht + 1];
            for (let Qi = 0; Qi < Yt.length - 1; Qi++) f.push(qt(_i, Yt[Qi], ir, Yt[Qi + 1]));
          }
        } else f.push(qt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: E + 1 }, { fixed: 0, stretch: T + 1 }));
        return f;
      }
      function qh(i, t, n) {
        let c = 0;
        for (const f of i) c += Math.max(t, Math.min(n, f[1])) - Math.max(t, Math.min(n, f[0]));
        return c;
      }
      function zm(i, t, n) {
        const c = [{ fixed: -ac, stretch: 0 }];
        for (const [f, v] of i) {
          const x = c[c.length - 1];
          c.push({ fixed: f - x.stretch, stretch: x.stretch }), c.push({ fixed: f - x.stretch, stretch: x.stretch + (v - f) });
        }
        return c.push({ fixed: t + ac, stretch: n }), c;
      }
      function Uh(i, t, n, c) {
        return i / t * n + c;
      }
      function Vh(i, t, n, c) {
        return i - t * n / c;
      }
      class $h {
        constructor(t, n, c, f, v, x, E, T, M, R) {
          var U;
          if (this.boxStartIndex = t.length, M) {
            let H = x.top, J = x.bottom;
            const ne = x.collisionPadding;
            ne && (H -= ne[1], J += ne[3]);
            let he = J - H;
            he > 0 && (he = Math.max(10, he), this.circleDiameter = he);
          } else {
            const H = !((U = x.image) === null || U === void 0) && U.content && (x.image.textFitWidth || x.image.textFitHeight) ? om(x) : { x1: x.left, y1: x.top, x2: x.right, y2: x.bottom };
            H.y1 = H.y1 * E - T[0], H.y2 = H.y2 * E + T[2], H.x1 = H.x1 * E - T[3], H.x2 = H.x2 * E + T[1];
            const J = x.collisionPadding;
            if (J && (H.x1 -= J[0] * E, H.y1 -= J[1] * E, H.x2 += J[2] * E, H.y2 += J[3] * E), R) {
              const ne = new j(H.x1, H.y1), he = new j(H.x2, H.y1), Se = new j(H.x1, H.y2), Pe = new j(H.x2, H.y2), Xe = R * Math.PI / 180;
              ne._rotate(Xe), he._rotate(Xe), Se._rotate(Xe), Pe._rotate(Xe), H.x1 = Math.min(ne.x, he.x, Se.x, Pe.x), H.x2 = Math.max(ne.x, he.x, Se.x, Pe.x), H.y1 = Math.min(ne.y, he.y, Se.y, Pe.y), H.y2 = Math.max(ne.y, he.y, Se.y, Pe.y);
            }
            t.emplaceBack(n.x, n.y, H.x1, H.y1, H.x2, H.y2, c, f, v);
          }
          this.boxEndIndex = t.length;
        }
      }
      class t_ {
        constructor(t = [], n = (c, f) => c < f ? -1 : c > f ? 1 : 0) {
          if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let c = (this.length >> 1) - 1; c >= 0; c--) this._down(c);
        }
        push(t) {
          this.data.push(t), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const t = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: n, compare: c } = this, f = n[t];
          for (; t > 0; ) {
            const v = t - 1 >> 1, x = n[v];
            if (c(f, x) >= 0) break;
            n[t] = x, t = v;
          }
          n[t] = f;
        }
        _down(t) {
          const { data: n, compare: c } = this, f = this.length >> 1, v = n[t];
          for (; t < f; ) {
            let x = 1 + (t << 1);
            const E = x + 1;
            if (E < this.length && c(n[E], n[x]) < 0 && (x = E), c(n[x], v) >= 0) break;
            n[t] = n[x], t = x;
          }
          n[t] = v;
        }
      }
      function i_(i, t = 1, n = !1) {
        let c = 1 / 0, f = 1 / 0, v = -1 / 0, x = -1 / 0;
        const E = i[0];
        for (let J = 0; J < E.length; J++) {
          const ne = E[J];
          (!J || ne.x < c) && (c = ne.x), (!J || ne.y < f) && (f = ne.y), (!J || ne.x > v) && (v = ne.x), (!J || ne.y > x) && (x = ne.y);
        }
        const T = Math.min(v - c, x - f);
        let M = T / 2;
        const R = new t_([], r_);
        if (T === 0) return new j(c, f);
        for (let J = c; J < v; J += T) for (let ne = f; ne < x; ne += T) R.push(new oc(J + M, ne + M, M, i));
        let U = function(J) {
          let ne = 0, he = 0, Se = 0;
          const Pe = J[0];
          for (let Xe = 0, Be = Pe.length, Ge = Be - 1; Xe < Be; Ge = Xe++) {
            const at = Pe[Xe], Ct = Pe[Ge], Bt = at.x * Ct.y - Ct.x * at.y;
            he += (at.x + Ct.x) * Bt, Se += (at.y + Ct.y) * Bt, ne += 3 * Bt;
          }
          return new oc(he / ne, Se / ne, 0, J);
        }(i), H = R.length;
        for (; R.length; ) {
          const J = R.pop();
          (J.d > U.d || !U.d) && (U = J, n && console.log("found best %d after %d probes", Math.round(1e4 * J.d) / 1e4, H)), J.max - U.d <= t || (M = J.h / 2, R.push(new oc(J.p.x - M, J.p.y - M, M, i)), R.push(new oc(J.p.x + M, J.p.y - M, M, i)), R.push(new oc(J.p.x - M, J.p.y + M, M, i)), R.push(new oc(J.p.x + M, J.p.y + M, M, i)), H += 4);
        }
        return n && (console.log(`num probes: ${H}`), console.log(`best distance: ${U.d}`)), U.p;
      }
      function r_(i, t) {
        return t.max - i.max;
      }
      function oc(i, t, n, c) {
        this.p = new j(i, t), this.h = n, this.d = function(f, v) {
          let x = !1, E = 1 / 0;
          for (let T = 0; T < v.length; T++) {
            const M = v[T];
            for (let R = 0, U = M.length, H = U - 1; R < U; H = R++) {
              const J = M[R], ne = M[H];
              J.y > f.y != ne.y > f.y && f.x < (ne.x - J.x) * (f.y - J.y) / (ne.y - J.y) + J.x && (x = !x), E = Math.min(E, Fc(f, J, ne));
            }
          }
          return (x ? 1 : -1) * Math.sqrt(E);
        }(this.p, c), this.max = this.d + this.h * Math.SQRT2;
      }
      var xn;
      g.aq = void 0, (xn = g.aq || (g.aq = {}))[xn.center = 1] = "center", xn[xn.left = 2] = "left", xn[xn.right = 3] = "right", xn[xn.top = 4] = "top", xn[xn.bottom = 5] = "bottom", xn[xn["top-left"] = 6] = "top-left", xn[xn["top-right"] = 7] = "top-right", xn[xn["bottom-left"] = 8] = "bottom-left", xn[xn["bottom-right"] = 9] = "bottom-right";
      const Wl = 7, Qd = Number.POSITIVE_INFINITY;
      function Fm(i, t) {
        return t[1] !== Qd ? function(n, c, f) {
          let v = 0, x = 0;
          switch (c = Math.abs(c), f = Math.abs(f), n) {
            case "top-right":
            case "top-left":
            case "top":
              x = f - Wl;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              x = -f + Wl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -c;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = c;
          }
          return [v, x];
        }(i, t[0], t[1]) : function(n, c) {
          let f = 0, v = 0;
          c < 0 && (c = 0);
          const x = c / Math.SQRT2;
          switch (n) {
            case "top-right":
            case "top-left":
              v = x - Wl;
              break;
            case "bottom-right":
            case "bottom-left":
              v = -x + Wl;
              break;
            case "bottom":
              v = -c + Wl;
              break;
            case "top":
              v = c - Wl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
              f = -x;
              break;
            case "top-left":
            case "bottom-left":
              f = x;
              break;
            case "left":
              f = c;
              break;
            case "right":
              f = -c;
          }
          return [f, v];
        }(i, t[0]);
      }
      function Bm(i, t, n) {
        var c;
        const f = i.layout, v = (c = f.get("text-variable-anchor-offset")) === null || c === void 0 ? void 0 : c.evaluate(t, {}, n);
        if (v) {
          const E = v.values, T = [];
          for (let M = 0; M < E.length; M += 2) {
            const R = T[M] = E[M], U = E[M + 1].map((H) => H * $r);
            R.startsWith("top") ? U[1] -= Wl : R.startsWith("bottom") && (U[1] += Wl), T[M + 1] = U;
          }
          return new gn(T);
        }
        const x = f.get("text-variable-anchor");
        if (x) {
          let E;
          E = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [f.get("text-radial-offset").evaluate(t, {}, n) * $r, Qd] : f.get("text-offset").evaluate(t, {}, n).map((M) => M * $r);
          const T = [];
          for (const M of x) T.push(M, Fm(M, E));
          return new gn(T);
        }
        return null;
      }
      function ep(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function n_(i, t, n, c, f, v, x, E, T, M, R) {
        let U = v.textMaxSize.evaluate(t, {});
        U === void 0 && (U = x);
        const H = i.layers[0].layout, J = H.get("icon-offset").evaluate(t, {}, R), ne = Om(n.horizontal), he = x / 24, Se = i.tilePixelRatio * he, Pe = i.tilePixelRatio * U / 24, Xe = i.tilePixelRatio * E, Be = i.tilePixelRatio * H.get("symbol-spacing"), Ge = H.get("text-padding") * i.tilePixelRatio, at = function(dt, Yt, Ht, _i = 1) {
          const ir = dt.get("icon-padding").evaluate(Yt, {}, Ht), Qi = ir && ir.values;
          return [Qi[0] * _i, Qi[1] * _i, Qi[2] * _i, Qi[3] * _i];
        }(H, t, R, i.tilePixelRatio), Ct = H.get("text-max-angle") / 180 * Math.PI, Bt = H.get("text-rotation-alignment") !== "viewport" && H.get("symbol-placement") !== "point", hi = H.get("icon-rotation-alignment") === "map" && H.get("symbol-placement") !== "point", Ft = H.get("symbol-placement"), Nt = Be / 2, Xt = H.get("icon-text-fit");
        let Vt;
        c && Xt !== "none" && (i.allowVerticalPlacement && n.vertical && (Vt = lm(c, n.vertical, Xt, H.get("icon-text-fit-padding"), J, he)), ne && (c = lm(c, ne, Xt, H.get("icon-text-fit-padding"), J, he)));
        const qt = (dt, Yt) => {
          Yt.x < 0 || Yt.x >= or || Yt.y < 0 || Yt.y >= or || function(Ht, _i, ir, Qi, nn, Ia, wn, sn, Jn, Kn, Qn, Mr, an, Fn, An, es, Sn, sa, bs, Vi, lr, fr, Bs, Dr, lc) {
            const Oo = Ht.addToLineVertexArray(_i, ir);
            let jo, Pa, aa, mn, wl = 0, eh = 0, Vm = 0, $m = 0, lp = -1, up = -1;
            const Al = {};
            let Zm = ql("");
            if (Ht.allowVerticalPlacement && Qi.vertical) {
              const Bn = sn.layout.get("text-rotate").evaluate(lr, {}, Dr) + 90;
              aa = new $h(Jn, _i, Kn, Qn, Mr, Qi.vertical, an, Fn, An, Bn), wn && (mn = new $h(Jn, _i, Kn, Qn, Mr, wn, Sn, sa, An, Bn));
            }
            if (nn) {
              const Bn = sn.layout.get("icon-rotate").evaluate(lr, {}), oa = sn.layout.get("icon-text-fit") !== "none", Cu = Nm(nn, Bn, Bs, oa), Ka = wn ? Nm(wn, Bn, Bs, oa) : void 0;
              Pa = new $h(Jn, _i, Kn, Qn, Mr, nn, Sn, sa, !1, Bn), wl = 4 * Cu.length;
              const Tu = Ht.iconSizeData;
              let qo = null;
              Tu.kind === "source" ? (qo = [Ro * sn.layout.get("icon-size").evaluate(lr, {})], qo[0] > Zl && xe(`${Ht.layerIds[0]}: Value for "icon-size" is >= ${Xc}. Reduce your "icon-size".`)) : Tu.kind === "composite" && (qo = [Ro * fr.compositeIconSizes[0].evaluate(lr, {}, Dr), Ro * fr.compositeIconSizes[1].evaluate(lr, {}, Dr)], (qo[0] > Zl || qo[1] > Zl) && xe(`${Ht.layerIds[0]}: Value for "icon-size" is >= ${Xc}. Reduce your "icon-size".`)), Ht.addSymbols(Ht.icon, Cu, qo, Vi, bs, lr, g.ah.none, _i, Oo.lineStartIndex, Oo.lineLength, -1, Dr), lp = Ht.icon.placedSymbolArray.length - 1, Ka && (eh = 4 * Ka.length, Ht.addSymbols(Ht.icon, Ka, qo, Vi, bs, lr, g.ah.vertical, _i, Oo.lineStartIndex, Oo.lineLength, -1, Dr), up = Ht.icon.placedSymbolArray.length - 1);
            }
            const Gm = Object.keys(Qi.horizontal);
            for (const Bn of Gm) {
              const oa = Qi.horizontal[Bn];
              if (!jo) {
                Zm = ql(oa.text);
                const Ka = sn.layout.get("text-rotate").evaluate(lr, {}, Dr);
                jo = new $h(Jn, _i, Kn, Qn, Mr, oa, an, Fn, An, Ka);
              }
              const Cu = oa.positionedLines.length === 1;
              if (Vm += Rm(Ht, _i, oa, Ia, sn, An, lr, es, Oo, Qi.vertical ? g.ah.horizontal : g.ah.horizontalOnly, Cu ? Gm : [Bn], Al, lp, fr, Dr), Cu) break;
            }
            Qi.vertical && ($m += Rm(Ht, _i, Qi.vertical, Ia, sn, An, lr, es, Oo, g.ah.vertical, ["vertical"], Al, up, fr, Dr));
            const o_ = jo ? jo.boxStartIndex : Ht.collisionBoxArray.length, l_ = jo ? jo.boxEndIndex : Ht.collisionBoxArray.length, u_ = aa ? aa.boxStartIndex : Ht.collisionBoxArray.length, c_ = aa ? aa.boxEndIndex : Ht.collisionBoxArray.length, h_ = Pa ? Pa.boxStartIndex : Ht.collisionBoxArray.length, d_ = Pa ? Pa.boxEndIndex : Ht.collisionBoxArray.length, p_ = mn ? mn.boxStartIndex : Ht.collisionBoxArray.length, f_ = mn ? mn.boxEndIndex : Ht.collisionBoxArray.length;
            let Ja = -1;
            const Gh = (Bn, oa) => Bn && Bn.circleDiameter ? Math.max(Bn.circleDiameter, oa) : oa;
            Ja = Gh(jo, Ja), Ja = Gh(aa, Ja), Ja = Gh(Pa, Ja), Ja = Gh(mn, Ja);
            const Hm = Ja > -1 ? 1 : 0;
            Hm && (Ja *= lc / $r), Ht.glyphOffsetArray.length >= sc.MAX_GLYPHS && xe("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), lr.sortKey !== void 0 && Ht.addToSortKeyRanges(Ht.symbolInstances.length, lr.sortKey);
            const m_ = Bm(sn, lr, Dr), [g_, __] = function(Bn, oa) {
              const Cu = Bn.length, Ka = oa == null ? void 0 : oa.values;
              if ((Ka == null ? void 0 : Ka.length) > 0) for (let Tu = 0; Tu < Ka.length; Tu += 2) {
                const qo = Ka[Tu + 1];
                Bn.emplaceBack(g.aq[Ka[Tu]], qo[0], qo[1]);
              }
              return [Cu, Bn.length];
            }(Ht.textAnchorOffsets, m_);
            Ht.symbolInstances.emplaceBack(_i.x, _i.y, Al.right >= 0 ? Al.right : -1, Al.center >= 0 ? Al.center : -1, Al.left >= 0 ? Al.left : -1, Al.vertical || -1, lp, up, Zm, o_, l_, u_, c_, h_, d_, p_, f_, Kn, Vm, $m, wl, eh, Hm, 0, an, Ja, g_, __);
          }(i, Yt, dt, n, c, f, Vt, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, Se, [Ge, Ge, Ge, Ge], Bt, T, Xe, at, hi, J, t, v, M, R, x);
        };
        if (Ft === "line") for (const dt of km(t.geometry, 0, 0, or, or)) {
          const Yt = e_(dt, Be, Ct, n.vertical || ne, c, 24, Pe, i.overscaling, or);
          for (const Ht of Yt) ne && s_(i, ne.text, Nt, Ht) || qt(dt, Ht);
        }
        else if (Ft === "line-center") {
          for (const dt of t.geometry) if (dt.length > 1) {
            const Yt = Q2(dt, Ct, n.vertical || ne, c, 24, Pe);
            Yt && qt(dt, Yt);
          }
        } else if (t.type === "Polygon") for (const dt of Cs(t.geometry, 0)) {
          const Yt = i_(dt, 16);
          qt(dt[0], new Hl(Yt.x, Yt.y, 0));
        }
        else if (t.type === "LineString") for (const dt of t.geometry) qt(dt, new Hl(dt[0].x, dt[0].y, 0));
        else if (t.type === "Point") for (const dt of t.geometry) for (const Yt of dt) qt([Yt], new Hl(Yt.x, Yt.y, 0));
      }
      function Rm(i, t, n, c, f, v, x, E, T, M, R, U, H, J, ne) {
        const he = function(Xe, Be, Ge, at, Ct, Bt, hi, Ft) {
          const Nt = at.layout.get("text-rotate").evaluate(Bt, {}) * Math.PI / 180, Xt = [];
          for (const Vt of Be.positionedLines) for (const qt of Vt.positionedGlyphs) {
            if (!qt.rect) continue;
            const dt = qt.rect || {};
            let Yt = em + 1, Ht = !0, _i = 1, ir = 0;
            const Qi = (Ct || Ft) && qt.vertical, nn = qt.metrics.advance * qt.scale / 2;
            if (Ft && Be.verticalizable && (ir = Vt.lineOffset / 2 - (qt.imageName ? -($r - qt.metrics.width * qt.scale) / 2 : (qt.scale - 1) * $r)), qt.imageName) {
              const Vi = hi[qt.imageName];
              Ht = Vi.sdf, _i = Vi.pixelRatio, Yt = vs / _i;
            }
            const Ia = Ct ? [qt.x + nn, qt.y] : [0, 0];
            let wn = Ct ? [0, 0] : [qt.x + nn + Ge[0], qt.y + Ge[1] - ir], sn = [0, 0];
            Qi && (sn = wn, wn = [0, 0]);
            const Jn = qt.metrics.isDoubleResolution ? 2 : 1, Kn = (qt.metrics.left - Yt) * qt.scale - nn + wn[0], Qn = (-qt.metrics.top - Yt) * qt.scale + wn[1], Mr = Kn + dt.w / Jn * qt.scale / _i, an = Qn + dt.h / Jn * qt.scale / _i, Fn = new j(Kn, Qn), An = new j(Mr, Qn), es = new j(Kn, an), Sn = new j(Mr, an);
            if (Qi) {
              const Vi = new j(-nn, nn - Hc), lr = -Math.PI / 2, fr = $r / 2 - nn, Bs = new j(5 - Hc - fr, -(qt.imageName ? fr : 0)), Dr = new j(...sn);
              Fn._rotateAround(lr, Vi)._add(Bs)._add(Dr), An._rotateAround(lr, Vi)._add(Bs)._add(Dr), es._rotateAround(lr, Vi)._add(Bs)._add(Dr), Sn._rotateAround(lr, Vi)._add(Bs)._add(Dr);
            }
            if (Nt) {
              const Vi = Math.sin(Nt), lr = Math.cos(Nt), fr = [lr, -Vi, Vi, lr];
              Fn._matMult(fr), An._matMult(fr), es._matMult(fr), Sn._matMult(fr);
            }
            const sa = new j(0, 0), bs = new j(0, 0);
            Xt.push({ tl: Fn, tr: An, bl: es, br: Sn, tex: dt, writingMode: Be.writingMode, glyphOffset: Ia, sectionIndex: qt.sectionIndex, isSDF: Ht, pixelOffsetTL: sa, pixelOffsetBR: bs, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Xt;
        }(0, n, E, f, v, x, c, i.allowVerticalPlacement), Se = i.textSizeData;
        let Pe = null;
        Se.kind === "source" ? (Pe = [Ro * f.layout.get("text-size").evaluate(x, {})], Pe[0] > Zl && xe(`${i.layerIds[0]}: Value for "text-size" is >= ${Xc}. Reduce your "text-size".`)) : Se.kind === "composite" && (Pe = [Ro * J.compositeTextSizes[0].evaluate(x, {}, ne), Ro * J.compositeTextSizes[1].evaluate(x, {}, ne)], (Pe[0] > Zl || Pe[1] > Zl) && xe(`${i.layerIds[0]}: Value for "text-size" is >= ${Xc}. Reduce your "text-size".`)), i.addSymbols(i.text, he, Pe, E, v, x, M, t, T.lineStartIndex, T.lineLength, H, ne);
        for (const Xe of R) U[Xe] = i.text.placedSymbolArray.length - 1;
        return 4 * he.length;
      }
      function Om(i) {
        for (const t in i) return i[t];
        return null;
      }
      function s_(i, t, n, c) {
        const f = i.compareText;
        if (t in f) {
          const v = f[t];
          for (let x = v.length - 1; x >= 0; x--) if (c.dist(v[x]) < n) return !0;
        } else f[t] = [];
        return f[t].push(c), !1;
      }
      const jm = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class tp {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, c] = new Uint8Array(t, 0, 2);
          if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const f = c >> 4;
          if (f !== 1) throw new Error(`Got v${f} data when expected v1.`);
          const v = jm[15 & c];
          if (!v) throw new Error("Unrecognized array type.");
          const [x] = new Uint16Array(t, 2, 1), [E] = new Uint32Array(t, 4, 1);
          return new tp(E, x, v, t);
        }
        constructor(t, n = 64, c = Float64Array, f) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = c, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
          const v = jm.indexOf(this.ArrayType), x = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, E = t * this.IndexArrayType.BYTES_PER_ELEMENT, T = (8 - E % 8) % 8;
          if (v < 0) throw new Error(`Unexpected typed array class: ${c}.`);
          f && f instanceof ArrayBuffer ? (this.data = f, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + E + T, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + x + E + T), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + E + T, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + v]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
        }
        add(t, n) {
          const c = this._pos >> 1;
          return this.ids[c] = c, this.coords[this._pos++] = t, this.coords[this._pos++] = n, c;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return ip(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(t, n, c, f) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: v, coords: x, nodeSize: E } = this, T = [0, v.length - 1, 0], M = [];
          for (; T.length; ) {
            const R = T.pop() || 0, U = T.pop() || 0, H = T.pop() || 0;
            if (U - H <= E) {
              for (let Se = H; Se <= U; Se++) {
                const Pe = x[2 * Se], Xe = x[2 * Se + 1];
                Pe >= t && Pe <= c && Xe >= n && Xe <= f && M.push(v[Se]);
              }
              continue;
            }
            const J = H + U >> 1, ne = x[2 * J], he = x[2 * J + 1];
            ne >= t && ne <= c && he >= n && he <= f && M.push(v[J]), (R === 0 ? t <= ne : n <= he) && (T.push(H), T.push(J - 1), T.push(1 - R)), (R === 0 ? c >= ne : f >= he) && (T.push(J + 1), T.push(U), T.push(1 - R));
          }
          return M;
        }
        within(t, n, c) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: f, coords: v, nodeSize: x } = this, E = [0, f.length - 1, 0], T = [], M = c * c;
          for (; E.length; ) {
            const R = E.pop() || 0, U = E.pop() || 0, H = E.pop() || 0;
            if (U - H <= x) {
              for (let Se = H; Se <= U; Se++) Um(v[2 * Se], v[2 * Se + 1], t, n) <= M && T.push(f[Se]);
              continue;
            }
            const J = H + U >> 1, ne = v[2 * J], he = v[2 * J + 1];
            Um(ne, he, t, n) <= M && T.push(f[J]), (R === 0 ? t - c <= ne : n - c <= he) && (E.push(H), E.push(J - 1), E.push(1 - R)), (R === 0 ? t + c >= ne : n + c >= he) && (E.push(J + 1), E.push(U), E.push(1 - R));
          }
          return T;
        }
      }
      function ip(i, t, n, c, f, v) {
        if (f - c <= n) return;
        const x = c + f >> 1;
        qm(i, t, x, c, f, v), ip(i, t, n, c, x - 1, 1 - v), ip(i, t, n, x + 1, f, 1 - v);
      }
      function qm(i, t, n, c, f, v) {
        for (; f > c; ) {
          if (f - c > 600) {
            const M = f - c + 1, R = n - c + 1, U = Math.log(M), H = 0.5 * Math.exp(2 * U / 3), J = 0.5 * Math.sqrt(U * H * (M - H) / M) * (R - M / 2 < 0 ? -1 : 1);
            qm(i, t, n, Math.max(c, Math.floor(n - R * H / M + J)), Math.min(f, Math.floor(n + (M - R) * H / M + J)), v);
          }
          const x = t[2 * n + v];
          let E = c, T = f;
          for (Kc(i, t, c, n), t[2 * f + v] > x && Kc(i, t, c, f); E < T; ) {
            for (Kc(i, t, E, T), E++, T--; t[2 * E + v] < x; ) E++;
            for (; t[2 * T + v] > x; ) T--;
          }
          t[2 * c + v] === x ? Kc(i, t, c, T) : (T++, Kc(i, t, T, f)), T <= n && (c = T + 1), n <= T && (f = T - 1);
        }
      }
      function Kc(i, t, n, c) {
        rp(i, n, c), rp(t, 2 * n, 2 * c), rp(t, 2 * n + 1, 2 * c + 1);
      }
      function rp(i, t, n) {
        const c = i[t];
        i[t] = i[n], i[n] = c;
      }
      function Um(i, t, n, c) {
        const f = i - n, v = t - c;
        return f * f + v * v;
      }
      var np;
      g.bg = void 0, (np = g.bg || (g.bg = {})).create = "create", np.load = "load", np.fullLoad = "fullLoad";
      let Zh = null, Qc = [];
      const sp = 1e3 / 60, ap = "loadTime", op = "fullLoadTime", a_ = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const t = i;
        Zh != null && Qc.push(t - Zh), Zh = t;
      }, clearMetrics() {
        Zh = null, Qc = [], performance.clearMeasures(ap), performance.clearMeasures(op);
        for (const i in g.bg) performance.clearMarks(g.bg[i]);
      }, getPerformanceMetrics() {
        performance.measure(ap, g.bg.create, g.bg.load), performance.measure(op, g.bg.create, g.bg.fullLoad);
        const i = performance.getEntriesByName(ap)[0].duration, t = performance.getEntriesByName(op)[0].duration, n = Qc.length, c = 1 / (Qc.reduce((v, x) => v + x, 0) / n / 1e3), f = Qc.filter((v) => v > sp).reduce((v, x) => v + (x - sp) / sp, 0);
        return { loadTime: i, fullLoadTime: t, fps: c, percentDroppedFrames: f / (n + f) * 100, totalFrames: n };
      } };
      g.$ = class extends F {
      }, g.A = Qu, g.B = Dc, g.C = function(i) {
        if (He == null) {
          const t = i.navigator ? i.navigator.userAgent : null;
          He = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
        }
        return He;
      }, g.D = Gt, g.E = rt, g.F = class {
        constructor(i, t) {
          this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new J2(() => this.process()), this.subscription = function(n, c, f, v) {
            return n.addEventListener(c, f, !1), { unsubscribe: () => {
              n.removeEventListener(c, f, !1);
            } };
          }(this.target, "message", (n) => this.receive(n)), this.globalScope = Ve(self) ? i : window;
        }
        registerMessageHandler(i, t) {
          this.messageHandlers[i] = t;
        }
        sendAsync(i, t) {
          return new Promise((n, c) => {
            const f = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[f] = { resolve: n, reject: c }, t && t.signal.addEventListener("abort", () => {
              delete this.resolveRejects[f];
              const E = { id: f, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(E);
            }, { once: !0 });
            const v = [], x = Object.assign(Object.assign({}, i), { id: f, sourceMapId: this.mapId, origin: location.origin, data: Do(i.data, v) });
            this.target.postMessage(x, { transfer: v });
          });
        }
        receive(i) {
          const t = i.data, n = t.id;
          if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
            if (t.type === "<cancel>") {
              delete this.tasks[n];
              const c = this.abortControllers[n];
              return delete this.abortControllers[n], void (c && c.abort());
            }
            if (Ve(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
            this.processTask(n, t);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), t = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t);
        }
        processTask(i, t) {
          return o(this, void 0, void 0, function* () {
            if (t.type === "<response>") {
              const f = this.resolveRejects[i];
              return delete this.resolveRejects[i], f ? void (t.error ? f.reject(Ha(t.error)) : f.resolve(Ha(t.data))) : void 0;
            }
            if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const n = Ha(t.data), c = new AbortController();
            this.abortControllers[i] = c;
            try {
              const f = yield this.messageHandlers[t.type](t.sourceMapId, n, c);
              this.completeTask(i, null, f);
            } catch (f) {
              this.completeTask(i, f);
            }
          });
        }
        completeTask(i, t, n) {
          const c = [];
          delete this.abortControllers[i];
          const f = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Do(t) : null, data: Do(n, c) };
          this.target.postMessage(f, { transfer: c });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, g.G = Oe, g.H = function() {
        var i = new Qu(16);
        return Qu != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, g.I = Ud, g.J = function(i, t, n) {
        var c, f, v, x, E, T, M, R, U, H, J, ne, he = n[0], Se = n[1], Pe = n[2];
        return t === i ? (i[12] = t[0] * he + t[4] * Se + t[8] * Pe + t[12], i[13] = t[1] * he + t[5] * Se + t[9] * Pe + t[13], i[14] = t[2] * he + t[6] * Se + t[10] * Pe + t[14], i[15] = t[3] * he + t[7] * Se + t[11] * Pe + t[15]) : (f = t[1], v = t[2], x = t[3], E = t[4], T = t[5], M = t[6], R = t[7], U = t[8], H = t[9], J = t[10], ne = t[11], i[0] = c = t[0], i[1] = f, i[2] = v, i[3] = x, i[4] = E, i[5] = T, i[6] = M, i[7] = R, i[8] = U, i[9] = H, i[10] = J, i[11] = ne, i[12] = c * he + E * Se + U * Pe + t[12], i[13] = f * he + T * Se + H * Pe + t[13], i[14] = v * he + M * Se + J * Pe + t[14], i[15] = x * he + R * Se + ne * Pe + t[15]), i;
      }, g.K = function(i, t, n) {
        var c = n[0], f = n[1], v = n[2];
        return i[0] = t[0] * c, i[1] = t[1] * c, i[2] = t[2] * c, i[3] = t[3] * c, i[4] = t[4] * f, i[5] = t[5] * f, i[6] = t[6] * f, i[7] = t[7] * f, i[8] = t[8] * v, i[9] = t[9] * v, i[10] = t[10] * v, i[11] = t[11] * v, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, g.L = wf, g.M = function(i, t) {
        const n = {};
        for (let c = 0; c < t.length; c++) {
          const f = t[c];
          f in i && (n[f] = i[f]);
        }
        return n;
      }, g.N = Gl, g.O = _m, g.P = j, g.Q = ym, g.R = ra, g.S = na, g.T = jl, g.U = Q, g.V = fe, g.W = Je, g.X = or, g.Y = w, g.Z = Yc, g._ = o, g.a = be, g.a$ = function(i, t) {
        var n = i[0], c = i[1], f = i[2], v = i[3], x = i[4], E = i[5], T = i[6], M = i[7], R = i[8], U = i[9], H = i[10], J = i[11], ne = i[12], he = i[13], Se = i[14], Pe = i[15], Xe = t[0], Be = t[1], Ge = t[2], at = t[3], Ct = t[4], Bt = t[5], hi = t[6], Ft = t[7], Nt = t[8], Xt = t[9], Vt = t[10], qt = t[11], dt = t[12], Yt = t[13], Ht = t[14], _i = t[15];
        return Math.abs(n - Xe) <= Yn * Math.max(1, Math.abs(n), Math.abs(Xe)) && Math.abs(c - Be) <= Yn * Math.max(1, Math.abs(c), Math.abs(Be)) && Math.abs(f - Ge) <= Yn * Math.max(1, Math.abs(f), Math.abs(Ge)) && Math.abs(v - at) <= Yn * Math.max(1, Math.abs(v), Math.abs(at)) && Math.abs(x - Ct) <= Yn * Math.max(1, Math.abs(x), Math.abs(Ct)) && Math.abs(E - Bt) <= Yn * Math.max(1, Math.abs(E), Math.abs(Bt)) && Math.abs(T - hi) <= Yn * Math.max(1, Math.abs(T), Math.abs(hi)) && Math.abs(M - Ft) <= Yn * Math.max(1, Math.abs(M), Math.abs(Ft)) && Math.abs(R - Nt) <= Yn * Math.max(1, Math.abs(R), Math.abs(Nt)) && Math.abs(U - Xt) <= Yn * Math.max(1, Math.abs(U), Math.abs(Xt)) && Math.abs(H - Vt) <= Yn * Math.max(1, Math.abs(H), Math.abs(Vt)) && Math.abs(J - qt) <= Yn * Math.max(1, Math.abs(J), Math.abs(qt)) && Math.abs(ne - dt) <= Yn * Math.max(1, Math.abs(ne), Math.abs(dt)) && Math.abs(he - Yt) <= Yn * Math.max(1, Math.abs(he), Math.abs(Yt)) && Math.abs(Se - Ht) <= Yn * Math.max(1, Math.abs(Se), Math.abs(Ht)) && Math.abs(Pe - _i) <= Yn * Math.max(1, Math.abs(Pe), Math.abs(_i));
      }, g.a0 = Li, g.a1 = Kd, g.a2 = pt, g.a3 = (i) => {
        const t = window.document.createElement("video");
        return t.muted = !0, new Promise((n) => {
          t.onloadstart = () => {
            n(t);
          };
          for (const c of i) {
            const f = window.document.createElement("source");
            nt(c) || (t.crossOrigin = "Anonymous"), f.src = c, t.appendChild(f);
          }
        });
      }, g.a4 = function() {
        return Ae++;
      }, g.a5 = kt, g.a6 = sc, g.a7 = ms, g.a8 = zo, g.a9 = Sm, g.aA = function(i) {
        if (i.type === "custom") return new Y2(i);
        switch (i.type) {
          case "background":
            return new H2(i);
          case "circle":
            return new N1(i);
          case "fill":
            return new J1(i);
          case "fill-extrusion":
            return new d2(i);
          case "heatmap":
            return new F1(i);
          case "hillshade":
            return new R1(i);
          case "line":
            return new b2(i);
          case "raster":
            return new X2(i);
          case "symbol":
            return new jh(i);
        }
      }, g.aB = X, g.aC = function(i, t) {
        if (!i) return [{ command: "setStyle", args: [t] }];
        let n = [];
        try {
          if (!lt(i.version, t.version)) return [{ command: "setStyle", args: [t] }];
          lt(i.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), lt(i.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), lt(i.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), lt(i.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), lt(i.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), lt(i.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), lt(i.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), lt(i.light, t.light) || n.push({ command: "setLight", args: [t.light] }), lt(i.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), lt(i.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), lt(i.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
          const c = {}, f = [];
          (function(x, E, T, M) {
            let R;
            for (R in E = E || {}, x = x || {}) Object.prototype.hasOwnProperty.call(x, R) && (Object.prototype.hasOwnProperty.call(E, R) || Et(R, T, M));
            for (R in E) Object.prototype.hasOwnProperty.call(E, R) && (Object.prototype.hasOwnProperty.call(x, R) ? lt(x[R], E[R]) || (x[R].type === "geojson" && E[R].type === "geojson" && ni(x, E, R) ? xt(T, { command: "setGeoJSONSourceData", args: [R, E[R].data] }) : jt(R, E, T, M)) : At(R, E, T));
          })(i.sources, t.sources, f, c);
          const v = [];
          i.layers && i.layers.forEach((x) => {
            "source" in x && c[x.source] ? n.push({ command: "removeLayer", args: [x.id] }) : v.push(x);
          }), n = n.concat(f), function(x, E, T) {
            E = E || [];
            const M = (x = x || []).map(yi), R = E.map(yi), U = x.reduce(xi, {}), H = E.reduce(xi, {}), J = M.slice(), ne = /* @__PURE__ */ Object.create(null);
            let he, Se, Pe, Xe, Be;
            for (let Ge = 0, at = 0; Ge < M.length; Ge++) he = M[Ge], Object.prototype.hasOwnProperty.call(H, he) ? at++ : (xt(T, { command: "removeLayer", args: [he] }), J.splice(J.indexOf(he, at), 1));
            for (let Ge = 0, at = 0; Ge < R.length; Ge++) he = R[R.length - 1 - Ge], J[J.length - 1 - Ge] !== he && (Object.prototype.hasOwnProperty.call(U, he) ? (xt(T, { command: "removeLayer", args: [he] }), J.splice(J.lastIndexOf(he, J.length - at), 1)) : at++, Xe = J[J.length - Ge], xt(T, { command: "addLayer", args: [H[he], Xe] }), J.splice(J.length - Ge, 0, he), ne[he] = !0);
            for (let Ge = 0; Ge < R.length; Ge++) if (he = R[Ge], Se = U[he], Pe = H[he], !ne[he] && !lt(Se, Pe)) if (lt(Se.source, Pe.source) && lt(Se["source-layer"], Pe["source-layer"]) && lt(Se.type, Pe.type)) {
              for (Be in ii(Se.layout, Pe.layout, T, he, null, "setLayoutProperty"), ii(Se.paint, Pe.paint, T, he, null, "setPaintProperty"), lt(Se.filter, Pe.filter) || xt(T, { command: "setFilter", args: [he, Pe.filter] }), lt(Se.minzoom, Pe.minzoom) && lt(Se.maxzoom, Pe.maxzoom) || xt(T, { command: "setLayerZoomRange", args: [he, Pe.minzoom, Pe.maxzoom] }), Se) Object.prototype.hasOwnProperty.call(Se, Be) && Be !== "layout" && Be !== "paint" && Be !== "filter" && Be !== "metadata" && Be !== "minzoom" && Be !== "maxzoom" && (Be.indexOf("paint.") === 0 ? ii(Se[Be], Pe[Be], T, he, Be.slice(6), "setPaintProperty") : lt(Se[Be], Pe[Be]) || xt(T, { command: "setLayerProperty", args: [he, Be, Pe[Be]] }));
              for (Be in Pe) Object.prototype.hasOwnProperty.call(Pe, Be) && !Object.prototype.hasOwnProperty.call(Se, Be) && Be !== "layout" && Be !== "paint" && Be !== "filter" && Be !== "metadata" && Be !== "minzoom" && Be !== "maxzoom" && (Be.indexOf("paint.") === 0 ? ii(Se[Be], Pe[Be], T, he, Be.slice(6), "setPaintProperty") : lt(Se[Be], Pe[Be]) || xt(T, { command: "setLayerProperty", args: [he, Be, Pe[Be]] }));
            } else xt(T, { command: "removeLayer", args: [he] }), Xe = J[J.lastIndexOf(he) + 1], xt(T, { command: "addLayer", args: [Pe, Xe] });
          }(v, t.layers, n);
        } catch (c) {
          console.warn("Unable to compute style diff:", c), n = [{ command: "setStyle", args: [t] }];
        }
        return n;
      }, g.aD = function(i) {
        const t = [], n = i.id;
        return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), i.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
      }, g.aE = function i(t, n) {
        if (Array.isArray(t)) {
          if (!Array.isArray(n) || t.length !== n.length) return !1;
          for (let c = 0; c < t.length; c++) if (!i(t[c], n[c])) return !1;
          return !0;
        }
        if (typeof t == "object" && t !== null && n !== null) {
          if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
          for (const c in t) if (!i(t[c], n[c])) return !1;
          return !0;
        }
        return t === n;
      }, g.aF = me, g.aG = ve, g.aH = class extends Mo {
        constructor(i, t) {
          super(i, t), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, g.aI = bu, g.aJ = class extends Mo {
        constructor(i, t) {
          super(i, t), this.current = wu;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let t = 1; t < 16; t++) if (i[t] !== this.current[t]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, g.aK = xu, g.aL = Hu, g.aM = ji, g.aN = class extends Mo {
        constructor(i, t) {
          super(i, t), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, g.aO = class extends Mo {
        constructor(i, t) {
          super(i, t), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, g.aP = function(i, t, n, c, f, v, x) {
        var E = 1 / (t - n), T = 1 / (c - f), M = 1 / (v - x);
        return i[0] = -2 * E, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * T, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * M, i[11] = 0, i[12] = (t + n) * E, i[13] = (f + c) * T, i[14] = (x + v) * M, i[15] = 1, i;
      }, g.aQ = M1, g.aR = class extends we {
      }, g.aS = S2, g.aT = class extends Ie {
      }, g.aU = Id, g.aV = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, g.aW = Tf, g.aX = pr, g.aY = tn, g.aZ = class extends St {
      }, g.a_ = function(i, t) {
        return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
      }, g.aa = function(i) {
        const t = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, c, f, v) => {
          const x = f || v;
          return t[c] = !x || x.toLowerCase(), "";
        }), t["max-age"]) {
          const n = parseInt(t["max-age"], 10);
          isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
        }
        return t;
      }, g.ab = function(i, t) {
        const n = [];
        for (const c in i) c in t || n.push(c);
        return n;
      }, g.ac = je, g.ad = function(i, t, n) {
        var c = Math.sin(n), f = Math.cos(n), v = t[0], x = t[1], E = t[2], T = t[3], M = t[4], R = t[5], U = t[6], H = t[7];
        return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = v * f + M * c, i[1] = x * f + R * c, i[2] = E * f + U * c, i[3] = T * f + H * c, i[4] = M * f - v * c, i[5] = R * f - x * c, i[6] = U * f - E * c, i[7] = H * f - T * c, i;
      }, g.ae = function(i) {
        var t = new Qu(16);
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t;
      }, g.af = Ph, g.ag = function(i, t) {
        let n = 0, c = 0;
        if (i.kind === "constant") c = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: f, minZoom: v, maxZoom: x } = i, E = f ? je(ai.interpolationFactor(f, t, v, x), 0, 1) : 0;
          i.kind === "camera" ? c = qr.number(i.minSize, i.maxSize, E) : n = E;
        }
        return { uSizeT: n, uSize: c };
      }, g.ai = function(i, { uSize: t, uSizeT: n }, { lowerSize: c, upperSize: f }) {
        return i.kind === "source" ? c / Ro : i.kind === "composite" ? qr.number(c / Ro, f / Ro, n) : t;
      }, g.aj = Gd, g.ak = function(i, t, n, c) {
        const f = t.y - i.y, v = t.x - i.x, x = c.y - n.y, E = c.x - n.x, T = x * v - E * f;
        if (T === 0) return null;
        const M = (E * (i.y - n.y) - x * (i.x - n.x)) / T;
        return new j(i.x + M * v, i.y + M * f);
      }, g.al = km, g.am = Yu, g.an = Td, g.ao = function(i) {
        let t = 1 / 0, n = 1 / 0, c = -1 / 0, f = -1 / 0;
        for (const v of i) t = Math.min(t, v.x), n = Math.min(n, v.y), c = Math.max(c, v.x), f = Math.max(f, v.y);
        return [t, n, c, f];
      }, g.ap = $r, g.ar = Zd, g.as = function(i, t) {
        var n = t[0], c = t[1], f = t[2], v = t[3], x = t[4], E = t[5], T = t[6], M = t[7], R = t[8], U = t[9], H = t[10], J = t[11], ne = t[12], he = t[13], Se = t[14], Pe = t[15], Xe = n * E - c * x, Be = n * T - f * x, Ge = n * M - v * x, at = c * T - f * E, Ct = c * M - v * E, Bt = f * M - v * T, hi = R * he - U * ne, Ft = R * Se - H * ne, Nt = R * Pe - J * ne, Xt = U * Se - H * he, Vt = U * Pe - J * he, qt = H * Pe - J * Se, dt = Xe * qt - Be * Vt + Ge * Xt + at * Nt - Ct * Ft + Bt * hi;
        return dt ? (i[0] = (E * qt - T * Vt + M * Xt) * (dt = 1 / dt), i[1] = (f * Vt - c * qt - v * Xt) * dt, i[2] = (he * Bt - Se * Ct + Pe * at) * dt, i[3] = (H * Ct - U * Bt - J * at) * dt, i[4] = (T * Nt - x * qt - M * Ft) * dt, i[5] = (n * qt - f * Nt + v * Ft) * dt, i[6] = (Se * Ge - ne * Bt - Pe * Be) * dt, i[7] = (R * Bt - H * Ge + J * Be) * dt, i[8] = (x * Vt - E * Nt + M * hi) * dt, i[9] = (c * Nt - n * Vt - v * hi) * dt, i[10] = (ne * Ct - he * Ge + Pe * Xe) * dt, i[11] = (U * Ge - R * Ct - J * Xe) * dt, i[12] = (E * Ft - x * Xt - T * hi) * dt, i[13] = (n * Xt - c * Ft + f * hi) * dt, i[14] = (he * Be - ne * at - Se * Xe) * dt, i[15] = (R * at - U * Be + H * Xe) * dt, i) : null;
      }, g.at = ep, g.au = $d, g.av = tp, g.aw = function() {
        const i = {}, t = Y.$version;
        for (const n in Y.$root) {
          const c = Y.$root[n];
          if (c.required) {
            let f = null;
            f = n === "version" ? t : c.type === "array" ? [] : {}, f != null && (i[n] = f);
          }
        }
        return i;
      }, g.ax = Ns, g.ay = Ue, g.az = function(i) {
        i = i.slice();
        const t = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < i.length; n++) t[i[n].id] = i[n];
        for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = Rt(i[n], t[i[n].ref]));
        return i;
      }, g.b = Ze, g.b0 = function(i, t) {
        return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, g.b1 = function(i, t, n) {
        return i[0] = t[0] * n[0], i[1] = t[1] * n[1], i[2] = t[2] * n[2], i[3] = t[3] * n[3], i;
      }, g.b2 = function(i, t) {
        return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3] * t[3];
      }, g.b3 = Qe, g.b4 = xm, g.b5 = vm, g.b6 = function(i, t, n, c, f) {
        var v, x = 1 / Math.tan(t / 2);
        return i[0] = x / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = x, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, f != null && f !== 1 / 0 ? (i[10] = (f + c) * (v = 1 / (c - f)), i[14] = 2 * f * c * v) : (i[10] = -1, i[14] = -2 * c), i;
      }, g.b7 = function(i, t, n) {
        var c = Math.sin(n), f = Math.cos(n), v = t[4], x = t[5], E = t[6], T = t[7], M = t[8], R = t[9], U = t[10], H = t[11];
        return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = v * f + M * c, i[5] = x * f + R * c, i[6] = E * f + U * c, i[7] = T * f + H * c, i[8] = M * f - v * c, i[9] = R * f - x * c, i[10] = U * f - E * c, i[11] = H * f - T * c, i;
      }, g.b8 = Ce, g.b9 = ze, g.bA = Hf, g.bB = function(i) {
        return i.message === ee;
      }, g.bC = Qr, g.bD = Ln, g.ba = function(i) {
        return i * Math.PI / 180;
      }, g.bb = function(i, t) {
        const { x: n, y: c } = Yc.fromLngLat(t);
        return !(i < 0 || i > 25 || c < 0 || c >= 1 || n < 0 || n >= 1);
      }, g.bc = function(i, t) {
        return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, g.bd = class extends P {
      }, g.be = Yd, g.bf = a_, g.bh = $e, g.bi = function(i, t) {
        be.REGISTERED_PROTOCOLS[i] = t;
      }, g.bj = function(i) {
        delete be.REGISTERED_PROTOCOLS[i];
      }, g.bk = function(i, t) {
        const n = {};
        for (let f = 0; f < i.length; f++) {
          const v = t && t[i[f].id] || uu(i[f]);
          t && (t[i[f].id] = v);
          let x = n[v];
          x || (x = n[v] = []), x.push(i[f]);
        }
        const c = [];
        for (const f in n) c.push(n[f]);
        return c;
      }, g.bl = Ot, g.bm = Am, g.bn = Em, g.bo = im, g.bp = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = or / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const t = i.bucket.layers[0], n = t.layout, c = t._unevaluatedLayout._values, f = { layoutIconSize: c["icon-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical), layoutTextSize: c["text-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical), textMaxSize: c["text-size"].possiblyEvaluate(new Ji(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: M, maxZoom: R } = i.bucket.textSizeData;
          f.compositeTextSizes = [c["text-size"].possiblyEvaluate(new Ji(M), i.canonical), c["text-size"].possiblyEvaluate(new Ji(R), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: M, maxZoom: R } = i.bucket.iconSizeData;
          f.compositeIconSizes = [c["icon-size"].possiblyEvaluate(new Ji(M), i.canonical), c["icon-size"].possiblyEvaluate(new Ji(R), i.canonical)];
        }
        const v = n.get("text-line-height") * $r, x = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", E = n.get("text-keep-upright"), T = n.get("text-size");
        for (const M of i.bucket.features) {
          const R = n.get("text-font").evaluate(M, {}, i.canonical).join(","), U = T.evaluate(M, {}, i.canonical), H = f.layoutTextSize.evaluate(M, {}, i.canonical), J = f.layoutIconSize.evaluate(M, {}, i.canonical), ne = { horizontal: {}, vertical: void 0 }, he = M.text;
          let Se, Pe = [0, 0];
          if (he) {
            const Ge = he.toString(), at = n.get("text-letter-spacing").evaluate(M, {}, i.canonical) * $r, Ct = Ic(Ge) ? at : 0, Bt = n.get("text-anchor").evaluate(M, {}, i.canonical), hi = Bm(t, M, i.canonical);
            if (!hi) {
              const Vt = n.get("text-radial-offset").evaluate(M, {}, i.canonical);
              Pe = Vt ? Fm(Bt, [Vt * $r, Qd]) : n.get("text-offset").evaluate(M, {}, i.canonical).map((qt) => qt * $r);
            }
            let Ft = x ? "center" : n.get("text-justify").evaluate(M, {}, i.canonical);
            const Nt = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(M, {}, i.canonical) * $r : 1 / 0, Xt = () => {
              i.bucket.allowVerticalPlacement && gu(Ge) && (ne.vertical = Bh(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, v, Bt, "left", Ct, Pe, g.ah.vertical, !0, H, U));
            };
            if (!x && hi) {
              const Vt = /* @__PURE__ */ new Set();
              if (Ft === "auto") for (let dt = 0; dt < hi.values.length; dt += 2) Vt.add(ep(hi.values[dt]));
              else Vt.add(Ft);
              let qt = !1;
              for (const dt of Vt) if (!ne.horizontal[dt]) if (qt) ne.horizontal[dt] = ne.horizontal[0];
              else {
                const Yt = Bh(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, v, "center", dt, Ct, Pe, g.ah.horizontal, !1, H, U);
                Yt && (ne.horizontal[dt] = Yt, qt = Yt.positionedLines.length === 1);
              }
              Xt();
            } else {
              Ft === "auto" && (Ft = ep(Bt));
              const Vt = Bh(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, v, Bt, Ft, Ct, Pe, g.ah.horizontal, !1, H, U);
              Vt && (ne.horizontal[Ft] = Vt), Xt(), gu(Ge) && x && E && (ne.vertical = Bh(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, v, Bt, Ft, Ct, Pe, g.ah.vertical, !1, H, U));
            }
          }
          let Xe = !1;
          if (M.icon && M.icon.name) {
            const Ge = i.imageMap[M.icon.name];
            Ge && (Se = U2(i.imagePositions[M.icon.name], n.get("icon-offset").evaluate(M, {}, i.canonical), n.get("icon-anchor").evaluate(M, {}, i.canonical)), Xe = !!Ge.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Xe : i.bucket.sdfIcons !== Xe && xe("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ge.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const Be = Om(ne.horizontal) || ne.vertical;
          i.bucket.iconsInText = !!Be && Be.iconsInText, (Be || Se) && n_(i.bucket, M, ne, Se, i.imageMap, f, H, J, Pe, Xe, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, g.bq = Rd, g.br = zd, g.bs = Bd, g.bt = Vl, g.bu = jd, g.bv = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, g.bw = function(i, t, n, c, f) {
        return o(this, void 0, void 0, function* () {
          if (fe()) try {
            return yield Je(i, t, n, c, f);
          } catch {
          }
          return function(v, x, E, T, M) {
            const R = v.width, U = v.height;
            et && st || (et = new OffscreenCanvas(R, U), st = et.getContext("2d", { willReadFrequently: !0 })), et.width = R, et.height = U, st.drawImage(v, 0, 0, R, U);
            const H = st.getImageData(x, E, T, M);
            return st.clearRect(0, 0, R, U), H.data;
          }(i, t, n, c, f);
        });
      }, g.bx = wm, g.by = k, g.bz = D, g.c = _e, g.d = (i) => o(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const t = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(t);
        } catch (n) {
          throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), g.e = ke, g.f = (i) => new Promise((t, n) => {
        const c = new Image();
        c.onload = () => {
          t(c), URL.revokeObjectURL(c.src), c.onload = null, window.requestAnimationFrame(() => {
            c.src = qe;
          });
        }, c.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const f = new Blob([new Uint8Array(i)], { type: "image/png" });
        c.src = i.byteLength ? URL.createObjectURL(f) : qe;
      }), g.g = Te, g.h = (i, t) => Ke(ke(i, { type: "json" }), t), g.i = Ve, g.j = Pt, g.k = mt, g.l = (i, t) => Ke(ke(i, { type: "arrayBuffer" }), t), g.m = Ke, g.n = function(i) {
        return new jd(i).readFields(z2, []);
      }, g.o = jc, g.p = tm, g.q = h, g.r = hl, g.s = nt, g.t = mu, g.u = Qs, g.v = Y, g.w = xe, g.x = function([i, t, n]) {
        return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: i * Math.cos(t) * Math.sin(n), y: i * Math.sin(t) * Math.sin(n), z: i * Math.cos(n) };
      }, g.y = qr, g.z = Ji;
    }), y("worker", ["./shared"], function(g) {
      class o {
        constructor(B) {
          this.keyCache = {}, B && this.replace(B);
        }
        replace(B) {
          this._layerConfigs = {}, this._layers = {}, this.update(B, []);
        }
        update(B, q) {
          for (const ge of B) {
            this._layerConfigs[ge.id] = ge;
            const Me = this._layers[ge.id] = g.aA(ge);
            Me._featureFilter = g.a7(Me.filter), this.keyCache[ge.id] && delete this.keyCache[ge.id];
          }
          for (const ge of q) delete this.keyCache[ge], delete this._layerConfigs[ge], delete this._layers[ge];
          this.familiesBySource = {};
          const te = g.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ge of te) {
            const Me = ge.map((We) => this._layers[We.id]), Fe = Me[0];
            if (Fe.visibility === "none") continue;
            const Ne = Fe.source || "";
            let De = this.familiesBySource[Ne];
            De || (De = this.familiesBySource[Ne] = {});
            const tt = Fe.sourceLayer || "_geojsonTileLayer";
            let ut = De[tt];
            ut || (ut = De[tt] = []), ut.push(Me);
          }
        }
      }
      class k {
        constructor(B) {
          const q = {}, te = [];
          for (const Ne in B) {
            const De = B[Ne], tt = q[Ne] = {};
            for (const ut in De) {
              const We = De[+ut];
              if (!We || We.bitmap.width === 0 || We.bitmap.height === 0) continue;
              const gt = { x: 0, y: 0, w: We.bitmap.width + 2, h: We.bitmap.height + 2 };
              te.push(gt), tt[ut] = { rect: gt, metrics: We.metrics };
            }
          }
          const { w: ge, h: Me } = g.p(te), Fe = new g.o({ width: ge || 1, height: Me || 1 });
          for (const Ne in B) {
            const De = B[Ne];
            for (const tt in De) {
              const ut = De[+tt];
              if (!ut || ut.bitmap.width === 0 || ut.bitmap.height === 0) continue;
              const We = q[Ne][tt].rect;
              g.o.copy(ut.bitmap, Fe, { x: 0, y: 0 }, { x: We.x + 1, y: We.y + 1 }, ut.bitmap);
            }
          }
          this.image = Fe, this.positions = q;
        }
      }
      g.bl("GlyphAtlas", k);
      class D {
        constructor(B) {
          this.tileID = new g.S(B.tileID.overscaledZ, B.tileID.wrap, B.tileID.canonical.z, B.tileID.canonical.x, B.tileID.canonical.y), this.uid = B.uid, this.zoom = B.zoom, this.pixelRatio = B.pixelRatio, this.tileSize = B.tileSize, this.source = B.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = B.showCollisionBoxes, this.collectResourceTiming = !!B.collectResourceTiming, this.returnDependencies = !!B.returnDependencies, this.promoteId = B.promoteId, this.inFlightDependencies = [];
        }
        parse(B, q, te, ge) {
          return g._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = B, this.collisionBoxArray = new g.a5();
            const Me = new g.bm(Object.keys(B.layers).sort()), Fe = new g.bn(this.tileID, this.promoteId);
            Fe.bucketLayerIDs = [];
            const Ne = {}, De = { featureIndex: Fe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: te }, tt = q.familiesBySource[this.source];
            for (const mi in tt) {
              const Bi = B.layers[mi];
              if (!Bi) continue;
              Bi.version === 1 && g.w(`Vector tile source "${this.source}" layer "${mi}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Hi = Me.encode(mi), gr = [];
              for (let br = 0; br < Bi.length; br++) {
                const Pr = Bi.feature(br), Vs = Fe.getId(Pr, mi);
                gr.push({ feature: Pr, id: Vs, index: br, sourceLayerIndex: Hi });
              }
              for (const br of tt[mi]) {
                const Pr = br[0];
                Pr.source !== this.source && g.w(`layer.source = ${Pr.source} does not equal this.source = ${this.source}`), Pr.minzoom && this.zoom < Math.floor(Pr.minzoom) || Pr.maxzoom && this.zoom >= Pr.maxzoom || Pr.visibility !== "none" && (L(br, this.zoom, te), (Ne[Pr.id] = Pr.createBucket({ index: Fe.bucketLayerIDs.length, layers: br, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Hi, sourceID: this.source })).populate(gr, De, this.tileID.canonical), Fe.bucketLayerIDs.push(br.map((Vs) => Vs.id)));
              }
            }
            const ut = g.aF(De.glyphDependencies, (mi) => Object.keys(mi).map(Number));
            this.inFlightDependencies.forEach((mi) => mi == null ? void 0 : mi.abort()), this.inFlightDependencies = [];
            let We = Promise.resolve({});
            if (Object.keys(ut).length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), We = ge.sendAsync({ type: "GG", data: { stacks: ut, source: this.source, tileID: this.tileID, type: "glyphs" } }, mi);
            }
            const gt = Object.keys(De.iconDependencies);
            let Mt = Promise.resolve({});
            if (gt.length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), Mt = ge.sendAsync({ type: "GI", data: { icons: gt, source: this.source, tileID: this.tileID, type: "icons" } }, mi);
            }
            const $t = Object.keys(De.patternDependencies);
            let Qt = Promise.resolve({});
            if ($t.length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), Qt = ge.sendAsync({ type: "GI", data: { icons: $t, source: this.source, tileID: this.tileID, type: "patterns" } }, mi);
            }
            const [ei, pi, fi] = yield Promise.all([We, Mt, Qt]), Wi = new k(ei), Oi = new g.bo(pi, fi);
            for (const mi in Ne) {
              const Bi = Ne[mi];
              Bi instanceof g.a6 ? (L(Bi.layers, this.zoom, te), g.bp({ bucket: Bi, glyphMap: ei, glyphPositions: Wi.positions, imageMap: pi, imagePositions: Oi.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Bi.hasPattern && (Bi instanceof g.bq || Bi instanceof g.br || Bi instanceof g.bs) && (L(Bi.layers, this.zoom, te), Bi.addFeatures(De, this.tileID.canonical, Oi.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Ne).filter((mi) => !mi.isEmpty()), featureIndex: Fe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Wi.image, imageAtlas: Oi, glyphMap: this.returnDependencies ? ei : null, iconMap: this.returnDependencies ? pi : null, glyphPositions: this.returnDependencies ? Wi.positions : null };
          });
        }
      }
      function L($, B, q) {
        const te = new g.z(B);
        for (const ge of $) ge.recalculate(te, q);
      }
      class j {
        constructor(B, q, te) {
          this.actor = B, this.layerIndex = q, this.availableImages = te, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(B, q) {
          return g._(this, void 0, void 0, function* () {
            const te = yield g.l(B.request, q);
            try {
              return { vectorTile: new g.bt.VectorTile(new g.bu(te.data)), rawData: te.data, cacheControl: te.cacheControl, expires: te.expires };
            } catch (ge) {
              const Me = new Uint8Array(te.data);
              let Fe = `Unable to parse the tile at ${B.request.url}, `;
              throw Fe += Me[0] === 31 && Me[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ge.message}`, new Error(Fe);
            }
          });
        }
        loadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const q = B.uid, te = !!(B && B.request && B.request.collectResourceTiming) && new g.bv(B.request), ge = new D(B);
            this.loading[q] = ge;
            const Me = new AbortController();
            ge.abort = Me;
            try {
              const Fe = yield this.loadVectorTile(B, Me);
              if (delete this.loading[q], !Fe) return null;
              const Ne = Fe.rawData, De = {};
              Fe.expires && (De.expires = Fe.expires), Fe.cacheControl && (De.cacheControl = Fe.cacheControl);
              const tt = {};
              if (te) {
                const We = te.finish();
                We && (tt.resourceTiming = JSON.parse(JSON.stringify(We)));
              }
              ge.vectorTile = Fe.vectorTile;
              const ut = ge.parse(Fe.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[q] = ge, this.fetching[q] = { rawTileData: Ne, cacheControl: De, resourceTiming: tt };
              try {
                const We = yield ut;
                return g.e({ rawTileData: Ne.slice(0) }, We, De, tt);
              } finally {
                delete this.fetching[q];
              }
            } catch (Fe) {
              throw delete this.loading[q], ge.status = "done", this.loaded[q] = ge, Fe;
            }
          });
        }
        reloadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const q = B.uid;
            if (!this.loaded || !this.loaded[q]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const te = this.loaded[q];
            if (te.showCollisionBoxes = B.showCollisionBoxes, te.status === "parsing") {
              const ge = yield te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Me;
              if (this.fetching[q]) {
                const { rawTileData: Fe, cacheControl: Ne, resourceTiming: De } = this.fetching[q];
                delete this.fetching[q], Me = g.e({ rawTileData: Fe.slice(0) }, ge, Ne, De);
              } else Me = ge;
              return Me;
            }
            if (te.status === "done" && te.vectorTile) return te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(B) {
          return g._(this, void 0, void 0, function* () {
            const q = this.loading, te = B.uid;
            q && q[te] && q[te].abort && (q[te].abort.abort(), delete q[te]);
          });
        }
        removeTile(B) {
          return g._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[B.uid] && delete this.loaded[B.uid];
          });
        }
      }
      class O {
        constructor() {
          this.loaded = {};
        }
        loadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const { uid: q, encoding: te, rawImageData: ge, redFactor: Me, greenFactor: Fe, blueFactor: Ne, baseShift: De } = B, tt = ge.width + 2, ut = ge.height + 2, We = g.b(ge) ? new g.R({ width: tt, height: ut }, yield g.bw(ge, -1, -1, tt, ut)) : ge, gt = new g.bx(q, We, te, Me, Fe, Ne, De);
            return this.loaded = this.loaded || {}, this.loaded[q] = gt, gt;
          });
        }
        removeTile(B) {
          const q = this.loaded, te = B.uid;
          q && q[te] && delete q[te];
        }
      }
      function z($, B) {
        if ($.length !== 0) {
          pe($[0], B);
          for (var q = 1; q < $.length; q++) pe($[q], !B);
        }
      }
      function pe($, B) {
        for (var q = 0, te = 0, ge = 0, Me = $.length, Fe = Me - 1; ge < Me; Fe = ge++) {
          var Ne = ($[ge][0] - $[Fe][0]) * ($[Fe][1] + $[ge][1]), De = q + Ne;
          te += Math.abs(q) >= Math.abs(Ne) ? q - De + Ne : Ne - De + q, q = De;
        }
        q + te >= 0 != !!B && $.reverse();
      }
      var oe = g.by(function $(B, q) {
        var te, ge = B && B.type;
        if (ge === "FeatureCollection") for (te = 0; te < B.features.length; te++) $(B.features[te], q);
        else if (ge === "GeometryCollection") for (te = 0; te < B.geometries.length; te++) $(B.geometries[te], q);
        else if (ge === "Feature") $(B.geometry, q);
        else if (ge === "Polygon") z(B.coordinates, q);
        else if (ge === "MultiPolygon") for (te = 0; te < B.coordinates.length; te++) z(B.coordinates[te], q);
        return B;
      });
      const ae = g.bt.VectorTileFeature.prototype.toGeoJSON;
      var Q = { exports: {} }, fe = g.bz, Ce = g.bt.VectorTileFeature, ze = je;
      function je($, B) {
        this.options = B || {}, this.features = $, this.length = $.length;
      }
      function Qe($, B) {
        this.id = typeof $.id == "number" ? $.id : void 0, this.type = $.type, this.rawGeometry = $.type === 1 ? [$.geometry] : $.geometry, this.properties = $.tags, this.extent = B || 4096;
      }
      je.prototype.feature = function($) {
        return new Qe(this.features[$], this.options.extent);
      }, Qe.prototype.loadGeometry = function() {
        var $ = this.rawGeometry;
        this.geometry = [];
        for (var B = 0; B < $.length; B++) {
          for (var q = $[B], te = [], ge = 0; ge < q.length; ge++) te.push(new fe(q[ge][0], q[ge][1]));
          this.geometry.push(te);
        }
        return this.geometry;
      }, Qe.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var $ = this.geometry, B = 1 / 0, q = -1 / 0, te = 1 / 0, ge = -1 / 0, Me = 0; Me < $.length; Me++) for (var Fe = $[Me], Ne = 0; Ne < Fe.length; Ne++) {
          var De = Fe[Ne];
          B = Math.min(B, De.x), q = Math.max(q, De.x), te = Math.min(te, De.y), ge = Math.max(ge, De.y);
        }
        return [B, te, q, ge];
      }, Qe.prototype.toGeoJSON = Ce.prototype.toGeoJSON;
      var ke = g.bA, Ae = ze;
      function me($) {
        var B = new ke();
        return function(q, te) {
          for (var ge in q.layers) te.writeMessage(3, ve, q.layers[ge]);
        }($, B), B.finish();
      }
      function ve($, B) {
        var q;
        B.writeVarintField(15, $.version || 1), B.writeStringField(1, $.name || ""), B.writeVarintField(5, $.extent || 4096);
        var te = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (q = 0; q < $.length; q++) te.feature = $.feature(q), B.writeMessage(2, X, te);
        var ge = te.keys;
        for (q = 0; q < ge.length; q++) B.writeStringField(3, ge[q]);
        var Me = te.values;
        for (q = 0; q < Me.length; q++) B.writeMessage(4, He, Me[q]);
      }
      function X($, B) {
        var q = $.feature;
        q.id !== void 0 && B.writeVarintField(1, q.id), B.writeMessage(2, re, $), B.writeVarintField(3, q.type), B.writeMessage(4, Ve, q);
      }
      function re($, B) {
        var q = $.feature, te = $.keys, ge = $.values, Me = $.keycache, Fe = $.valuecache;
        for (var Ne in q.properties) {
          var De = q.properties[Ne], tt = Me[Ne];
          if (De !== null) {
            tt === void 0 && (te.push(Ne), Me[Ne] = tt = te.length - 1), B.writeVarint(tt);
            var ut = typeof De;
            ut !== "string" && ut !== "boolean" && ut !== "number" && (De = JSON.stringify(De));
            var We = ut + ":" + De, gt = Fe[We];
            gt === void 0 && (ge.push(De), Fe[We] = gt = ge.length - 1), B.writeVarint(gt);
          }
        }
      }
      function xe($, B) {
        return (B << 3) + (7 & $);
      }
      function ye($) {
        return $ << 1 ^ $ >> 31;
      }
      function Ve($, B) {
        for (var q = $.loadGeometry(), te = $.type, ge = 0, Me = 0, Fe = q.length, Ne = 0; Ne < Fe; Ne++) {
          var De = q[Ne], tt = 1;
          te === 1 && (tt = De.length), B.writeVarint(xe(1, tt));
          for (var ut = te === 3 ? De.length - 1 : De.length, We = 0; We < ut; We++) {
            We === 1 && te !== 1 && B.writeVarint(xe(2, ut - 1));
            var gt = De[We].x - ge, Mt = De[We].y - Me;
            B.writeVarint(ye(gt)), B.writeVarint(ye(Mt)), ge += gt, Me += Mt;
          }
          te === 3 && B.writeVarint(xe(7, 1));
        }
      }
      function He($, B) {
        var q = typeof $;
        q === "string" ? B.writeStringField(1, $) : q === "boolean" ? B.writeBooleanField(7, $) : q === "number" && ($ % 1 != 0 ? B.writeDoubleField(3, $) : $ < 0 ? B.writeSVarintField(6, $) : B.writeVarintField(5, $));
      }
      Q.exports = me, Q.exports.fromVectorTileJs = me, Q.exports.fromGeojsonVt = function($, B) {
        B = B || {};
        var q = {};
        for (var te in $) q[te] = new Ae($[te].features, B), q[te].name = te, q[te].version = B.version, q[te].extent = B.extent;
        return me({ layers: q });
      }, Q.exports.GeoJSONWrapper = Ae;
      var Ze = g.by(Q.exports);
      const qe = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: ($) => $ }, Je = Math.fround || (et = new Float32Array(1), ($) => (et[0] = +$, et[0]));
      var et;
      const st = 3, ee = 5, _e = 6;
      class be {
        constructor(B) {
          this.options = Object.assign(Object.create(qe), B), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(B) {
          const { log: q, minZoom: te, maxZoom: ge } = this.options;
          q && console.time("total time");
          const Me = `prepare ${B.length} points`;
          q && console.time(Me), this.points = B;
          const Fe = [];
          for (let De = 0; De < B.length; De++) {
            const tt = B[De];
            if (!tt.geometry) continue;
            const [ut, We] = tt.geometry.coordinates, gt = Je($e(ut)), Mt = Je(Ue(We));
            Fe.push(gt, Mt, 1 / 0, De, -1, 1), this.options.reduce && Fe.push(0);
          }
          let Ne = this.trees[ge + 1] = this._createTree(Fe);
          q && console.timeEnd(Me);
          for (let De = ge; De >= te; De--) {
            const tt = +Date.now();
            Ne = this.trees[De] = this._createTree(this._cluster(Ne, De)), q && console.log("z%d: %d clusters in %dms", De, Ne.numItems, +Date.now() - tt);
          }
          return q && console.timeEnd("total time"), this;
        }
        getClusters(B, q) {
          let te = ((B[0] + 180) % 360 + 360) % 360 - 180;
          const ge = Math.max(-90, Math.min(90, B[1]));
          let Me = B[2] === 180 ? 180 : ((B[2] + 180) % 360 + 360) % 360 - 180;
          const Fe = Math.max(-90, Math.min(90, B[3]));
          if (B[2] - B[0] >= 360) te = -180, Me = 180;
          else if (te > Me) {
            const We = this.getClusters([te, ge, 180, Fe], q), gt = this.getClusters([-180, ge, Me, Fe], q);
            return We.concat(gt);
          }
          const Ne = this.trees[this._limitZoom(q)], De = Ne.range($e(te), Ue(Fe), $e(Me), Ue(ge)), tt = Ne.data, ut = [];
          for (const We of De) {
            const gt = this.stride * We;
            ut.push(tt[gt + ee] > 1 ? Te(tt, gt, this.clusterProps) : this.points[tt[gt + st]]);
          }
          return ut;
        }
        getChildren(B) {
          const q = this._getOriginId(B), te = this._getOriginZoom(B), ge = "No cluster with the specified id.", Me = this.trees[te];
          if (!Me) throw new Error(ge);
          const Fe = Me.data;
          if (q * this.stride >= Fe.length) throw new Error(ge);
          const Ne = this.options.radius / (this.options.extent * Math.pow(2, te - 1)), De = Me.within(Fe[q * this.stride], Fe[q * this.stride + 1], Ne), tt = [];
          for (const ut of De) {
            const We = ut * this.stride;
            Fe[We + 4] === B && tt.push(Fe[We + ee] > 1 ? Te(Fe, We, this.clusterProps) : this.points[Fe[We + st]]);
          }
          if (tt.length === 0) throw new Error(ge);
          return tt;
        }
        getLeaves(B, q, te) {
          const ge = [];
          return this._appendLeaves(ge, B, q = q || 10, te = te || 0, 0), ge;
        }
        getTile(B, q, te) {
          const ge = this.trees[this._limitZoom(B)], Me = Math.pow(2, B), { extent: Fe, radius: Ne } = this.options, De = Ne / Fe, tt = (te - De) / Me, ut = (te + 1 + De) / Me, We = { features: [] };
          return this._addTileFeatures(ge.range((q - De) / Me, tt, (q + 1 + De) / Me, ut), ge.data, q, te, Me, We), q === 0 && this._addTileFeatures(ge.range(1 - De / Me, tt, 1, ut), ge.data, Me, te, Me, We), q === Me - 1 && this._addTileFeatures(ge.range(0, tt, De / Me, ut), ge.data, -1, te, Me, We), We.features.length ? We : null;
        }
        getClusterExpansionZoom(B) {
          let q = this._getOriginZoom(B) - 1;
          for (; q <= this.options.maxZoom; ) {
            const te = this.getChildren(B);
            if (q++, te.length !== 1) break;
            B = te[0].properties.cluster_id;
          }
          return q;
        }
        _appendLeaves(B, q, te, ge, Me) {
          const Fe = this.getChildren(q);
          for (const Ne of Fe) {
            const De = Ne.properties;
            if (De && De.cluster ? Me + De.point_count <= ge ? Me += De.point_count : Me = this._appendLeaves(B, De.cluster_id, te, ge, Me) : Me < ge ? Me++ : B.push(Ne), B.length === te) break;
          }
          return Me;
        }
        _createTree(B) {
          const q = new g.av(B.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let te = 0; te < B.length; te += this.stride) q.add(B[te], B[te + 1]);
          return q.finish(), q.data = B, q;
        }
        _addTileFeatures(B, q, te, ge, Me, Fe) {
          for (const Ne of B) {
            const De = Ne * this.stride, tt = q[De + ee] > 1;
            let ut, We, gt;
            if (tt) ut = Oe(q, De, this.clusterProps), We = q[De], gt = q[De + 1];
            else {
              const Qt = this.points[q[De + st]];
              ut = Qt.properties;
              const [ei, pi] = Qt.geometry.coordinates;
              We = $e(ei), gt = Ue(pi);
            }
            const Mt = { type: 1, geometry: [[Math.round(this.options.extent * (We * Me - te)), Math.round(this.options.extent * (gt * Me - ge))]], tags: ut };
            let $t;
            $t = tt || this.options.generateId ? q[De + st] : this.points[q[De + st]].id, $t !== void 0 && (Mt.id = $t), Fe.features.push(Mt);
          }
        }
        _limitZoom(B) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+B), this.options.maxZoom + 1));
        }
        _cluster(B, q) {
          const { radius: te, extent: ge, reduce: Me, minPoints: Fe } = this.options, Ne = te / (ge * Math.pow(2, q)), De = B.data, tt = [], ut = this.stride;
          for (let We = 0; We < De.length; We += ut) {
            if (De[We + 2] <= q) continue;
            De[We + 2] = q;
            const gt = De[We], Mt = De[We + 1], $t = B.within(De[We], De[We + 1], Ne), Qt = De[We + ee];
            let ei = Qt;
            for (const pi of $t) {
              const fi = pi * ut;
              De[fi + 2] > q && (ei += De[fi + ee]);
            }
            if (ei > Qt && ei >= Fe) {
              let pi, fi = gt * Qt, Wi = Mt * Qt, Oi = -1;
              const mi = ((We / ut | 0) << 5) + (q + 1) + this.points.length;
              for (const Bi of $t) {
                const Hi = Bi * ut;
                if (De[Hi + 2] <= q) continue;
                De[Hi + 2] = q;
                const gr = De[Hi + ee];
                fi += De[Hi] * gr, Wi += De[Hi + 1] * gr, De[Hi + 4] = mi, Me && (pi || (pi = this._map(De, We, !0), Oi = this.clusterProps.length, this.clusterProps.push(pi)), Me(pi, this._map(De, Hi)));
              }
              De[We + 4] = mi, tt.push(fi / ei, Wi / ei, 1 / 0, mi, -1, ei), Me && tt.push(Oi);
            } else {
              for (let pi = 0; pi < ut; pi++) tt.push(De[We + pi]);
              if (ei > 1) for (const pi of $t) {
                const fi = pi * ut;
                if (!(De[fi + 2] <= q)) {
                  De[fi + 2] = q;
                  for (let Wi = 0; Wi < ut; Wi++) tt.push(De[fi + Wi]);
                }
              }
            }
          }
          return tt;
        }
        _getOriginId(B) {
          return B - this.points.length >> 5;
        }
        _getOriginZoom(B) {
          return (B - this.points.length) % 32;
        }
        _map(B, q, te) {
          if (B[q + ee] > 1) {
            const Fe = this.clusterProps[B[q + _e]];
            return te ? Object.assign({}, Fe) : Fe;
          }
          const ge = this.points[B[q + st]].properties, Me = this.options.map(ge);
          return te && Me === ge ? Object.assign({}, Me) : Me;
        }
      }
      function Te($, B, q) {
        return { type: "Feature", id: $[B + st], properties: Oe($, B, q), geometry: { type: "Point", coordinates: [(te = $[B], 360 * (te - 0.5)), Ke($[B + 1])] } };
        var te;
      }
      function Oe($, B, q) {
        const te = $[B + ee], ge = te >= 1e4 ? `${Math.round(te / 1e3)}k` : te >= 1e3 ? Math.round(te / 100) / 10 + "k" : te, Me = $[B + _e], Fe = Me === -1 ? {} : Object.assign({}, q[Me]);
        return Object.assign(Fe, { cluster: !0, cluster_id: $[B + st], point_count: te, point_count_abbreviated: ge });
      }
      function $e($) {
        return $ / 360 + 0.5;
      }
      function Ue($) {
        const B = Math.sin($ * Math.PI / 180), q = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
        return q < 0 ? 0 : q > 1 ? 1 : q;
      }
      function Ke($) {
        const B = (180 - 360 * $) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(B)) / Math.PI - 90;
      }
      function nt($, B, q, te) {
        let ge = te;
        const Me = B + (q - B >> 1);
        let Fe, Ne = q - B;
        const De = $[B], tt = $[B + 1], ut = $[q], We = $[q + 1];
        for (let gt = B + 3; gt < q; gt += 3) {
          const Mt = ot($[gt], $[gt + 1], De, tt, ut, We);
          if (Mt > ge) Fe = gt, ge = Mt;
          else if (Mt === ge) {
            const $t = Math.abs(gt - Me);
            $t < Ne && (Fe = gt, Ne = $t);
          }
        }
        ge > te && (Fe - B > 3 && nt($, B, Fe, te), $[Fe + 2] = ge, q - Fe > 3 && nt($, Fe, q, te));
      }
      function ot($, B, q, te, ge, Me) {
        let Fe = ge - q, Ne = Me - te;
        if (Fe !== 0 || Ne !== 0) {
          const De = (($ - q) * Fe + (B - te) * Ne) / (Fe * Fe + Ne * Ne);
          De > 1 ? (q = ge, te = Me) : De > 0 && (q += Fe * De, te += Ne * De);
        }
        return Fe = $ - q, Ne = B - te, Fe * Fe + Ne * Ne;
      }
      function vt($, B, q, te) {
        const ge = { id: $ ?? null, type: B, geometry: q, tags: te, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (B === "Point" || B === "MultiPoint" || B === "LineString") mt(ge, q);
        else if (B === "Polygon") mt(ge, q[0]);
        else if (B === "MultiLineString") for (const Me of q) mt(ge, Me);
        else if (B === "MultiPolygon") for (const Me of q) mt(ge, Me[0]);
        return ge;
      }
      function mt($, B) {
        for (let q = 0; q < B.length; q += 3) $.minX = Math.min($.minX, B[q]), $.minY = Math.min($.minY, B[q + 1]), $.maxX = Math.max($.maxX, B[q]), $.maxY = Math.max($.maxY, B[q + 1]);
      }
      function Pt($, B, q, te) {
        if (!B.geometry) return;
        const ge = B.geometry.coordinates;
        if (ge && ge.length === 0) return;
        const Me = B.geometry.type, Fe = Math.pow(q.tolerance / ((1 << q.maxZoom) * q.extent), 2);
        let Ne = [], De = B.id;
        if (q.promoteId ? De = B.properties[q.promoteId] : q.generateId && (De = te || 0), Me === "Point") rt(ge, Ne);
        else if (Me === "MultiPoint") for (const tt of ge) rt(tt, Ne);
        else if (Me === "LineString") Y(ge, Ne, Fe, !1);
        else if (Me === "MultiLineString") {
          if (q.lineMetrics) {
            for (const tt of ge) Ne = [], Y(tt, Ne, Fe, !1), $.push(vt(De, "LineString", Ne, B.properties));
            return;
          }
          Kt(ge, Ne, Fe, !1);
        } else if (Me === "Polygon") Kt(ge, Ne, Fe, !0);
        else {
          if (Me !== "MultiPolygon") {
            if (Me === "GeometryCollection") {
              for (const tt of B.geometry.geometries) Pt($, { id: De, geometry: tt, properties: B.properties }, q, te);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const tt of ge) {
            const ut = [];
            Kt(tt, ut, Fe, !0), Ne.push(ut);
          }
        }
        $.push(vt(De, Me, Ne, B.properties));
      }
      function rt($, B) {
        B.push(Rt($[0]), lt($[1]), 0);
      }
      function Y($, B, q, te) {
        let ge, Me, Fe = 0;
        for (let De = 0; De < $.length; De++) {
          const tt = Rt($[De][0]), ut = lt($[De][1]);
          B.push(tt, ut, 0), De > 0 && (Fe += te ? (ge * ut - tt * Me) / 2 : Math.sqrt(Math.pow(tt - ge, 2) + Math.pow(ut - Me, 2))), ge = tt, Me = ut;
        }
        const Ne = B.length - 3;
        B[2] = 1, nt(B, 0, Ne, q), B[Ne + 2] = 1, B.size = Math.abs(Fe), B.start = 0, B.end = B.size;
      }
      function Kt($, B, q, te) {
        for (let ge = 0; ge < $.length; ge++) {
          const Me = [];
          Y($[ge], Me, q, te), B.push(Me);
        }
      }
      function Rt($) {
        return $ / 360 + 0.5;
      }
      function lt($) {
        const B = Math.sin($ * Math.PI / 180), q = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
        return q < 0 ? 0 : q > 1 ? 1 : q;
      }
      function xt($, B, q, te, ge, Me, Fe, Ne) {
        if (te /= B, Me >= (q /= B) && Fe < te) return $;
        if (Fe < q || Me >= te) return null;
        const De = [];
        for (const tt of $) {
          const ut = tt.geometry;
          let We = tt.type;
          const gt = ge === 0 ? tt.minX : tt.minY, Mt = ge === 0 ? tt.maxX : tt.maxY;
          if (gt >= q && Mt < te) {
            De.push(tt);
            continue;
          }
          if (Mt < q || gt >= te) continue;
          let $t = [];
          if (We === "Point" || We === "MultiPoint") At(ut, $t, q, te, ge);
          else if (We === "LineString") Et(ut, $t, q, te, ge, !1, Ne.lineMetrics);
          else if (We === "MultiLineString") ni(ut, $t, q, te, ge, !1);
          else if (We === "Polygon") ni(ut, $t, q, te, ge, !0);
          else if (We === "MultiPolygon") for (const Qt of ut) {
            const ei = [];
            ni(Qt, ei, q, te, ge, !0), ei.length && $t.push(ei);
          }
          if ($t.length) {
            if (Ne.lineMetrics && We === "LineString") {
              for (const Qt of $t) De.push(vt(tt.id, We, Qt, tt.tags));
              continue;
            }
            We !== "LineString" && We !== "MultiLineString" || ($t.length === 1 ? (We = "LineString", $t = $t[0]) : We = "MultiLineString"), We !== "Point" && We !== "MultiPoint" || (We = $t.length === 3 ? "Point" : "MultiPoint"), De.push(vt(tt.id, We, $t, tt.tags));
          }
        }
        return De.length ? De : null;
      }
      function At($, B, q, te, ge) {
        for (let Me = 0; Me < $.length; Me += 3) {
          const Fe = $[Me + ge];
          Fe >= q && Fe <= te && ii(B, $[Me], $[Me + 1], $[Me + 2]);
        }
      }
      function Et($, B, q, te, ge, Me, Fe) {
        let Ne = jt($);
        const De = ge === 0 ? yi : xi;
        let tt, ut, We = $.start;
        for (let ei = 0; ei < $.length - 3; ei += 3) {
          const pi = $[ei], fi = $[ei + 1], Wi = $[ei + 2], Oi = $[ei + 3], mi = $[ei + 4], Bi = ge === 0 ? pi : fi, Hi = ge === 0 ? Oi : mi;
          let gr = !1;
          Fe && (tt = Math.sqrt(Math.pow(pi - Oi, 2) + Math.pow(fi - mi, 2))), Bi < q ? Hi > q && (ut = De(Ne, pi, fi, Oi, mi, q), Fe && (Ne.start = We + tt * ut)) : Bi > te ? Hi < te && (ut = De(Ne, pi, fi, Oi, mi, te), Fe && (Ne.start = We + tt * ut)) : ii(Ne, pi, fi, Wi), Hi < q && Bi >= q && (ut = De(Ne, pi, fi, Oi, mi, q), gr = !0), Hi > te && Bi <= te && (ut = De(Ne, pi, fi, Oi, mi, te), gr = !0), !Me && gr && (Fe && (Ne.end = We + tt * ut), B.push(Ne), Ne = jt($)), Fe && (We += tt);
        }
        let gt = $.length - 3;
        const Mt = $[gt], $t = $[gt + 1], Qt = ge === 0 ? Mt : $t;
        Qt >= q && Qt <= te && ii(Ne, Mt, $t, $[gt + 2]), gt = Ne.length - 3, Me && gt >= 3 && (Ne[gt] !== Ne[0] || Ne[gt + 1] !== Ne[1]) && ii(Ne, Ne[0], Ne[1], Ne[2]), Ne.length && B.push(Ne);
      }
      function jt($) {
        const B = [];
        return B.size = $.size, B.start = $.start, B.end = $.end, B;
      }
      function ni($, B, q, te, ge, Me) {
        for (const Fe of $) Et(Fe, B, q, te, ge, Me, !1);
      }
      function ii($, B, q, te) {
        $.push(B, q, te);
      }
      function yi($, B, q, te, ge, Me) {
        const Fe = (Me - B) / (te - B);
        return ii($, Me, q + (ge - q) * Fe, 1), Fe;
      }
      function xi($, B, q, te, ge, Me) {
        const Fe = (Me - q) / (ge - q);
        return ii($, B + (te - B) * Fe, Me, 1), Fe;
      }
      function pt($, B) {
        const q = [];
        for (let te = 0; te < $.length; te++) {
          const ge = $[te], Me = ge.type;
          let Fe;
          if (Me === "Point" || Me === "MultiPoint" || Me === "LineString") Fe = Jt(ge.geometry, B);
          else if (Me === "MultiLineString" || Me === "Polygon") {
            Fe = [];
            for (const Ne of ge.geometry) Fe.push(Jt(Ne, B));
          } else if (Me === "MultiPolygon") {
            Fe = [];
            for (const Ne of ge.geometry) {
              const De = [];
              for (const tt of Ne) De.push(Jt(tt, B));
              Fe.push(De);
            }
          }
          q.push(vt(ge.id, Me, Fe, ge.tags));
        }
        return q;
      }
      function Jt($, B) {
        const q = [];
        q.size = $.size, $.start !== void 0 && (q.start = $.start, q.end = $.end);
        for (let te = 0; te < $.length; te += 3) q.push($[te] + B, $[te + 1], $[te + 2]);
        return q;
      }
      function si($, B) {
        if ($.transformed) return $;
        const q = 1 << $.z, te = $.x, ge = $.y;
        for (const Me of $.features) {
          const Fe = Me.geometry, Ne = Me.type;
          if (Me.geometry = [], Ne === 1) for (let De = 0; De < Fe.length; De += 2) Me.geometry.push(It(Fe[De], Fe[De + 1], B, q, te, ge));
          else for (let De = 0; De < Fe.length; De++) {
            const tt = [];
            for (let ut = 0; ut < Fe[De].length; ut += 2) tt.push(It(Fe[De][ut], Fe[De][ut + 1], B, q, te, ge));
            Me.geometry.push(tt);
          }
        }
        return $.transformed = !0, $;
      }
      function It($, B, q, te, ge, Me) {
        return [Math.round(q * ($ * te - ge)), Math.round(q * (B * te - Me))];
      }
      function Zi($, B, q, te, ge) {
        const Me = B === ge.maxZoom ? 0 : ge.tolerance / ((1 << B) * ge.extent), Fe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: $.length, source: null, x: q, y: te, z: B, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const Ne of $) ft(Fe, Ne, Me, ge);
        return Fe;
      }
      function ft($, B, q, te) {
        const ge = B.geometry, Me = B.type, Fe = [];
        if ($.minX = Math.min($.minX, B.minX), $.minY = Math.min($.minY, B.minY), $.maxX = Math.max($.maxX, B.maxX), $.maxY = Math.max($.maxY, B.maxY), Me === "Point" || Me === "MultiPoint") for (let Ne = 0; Ne < ge.length; Ne += 3) Fe.push(ge[Ne], ge[Ne + 1]), $.numPoints++, $.numSimplified++;
        else if (Me === "LineString") ri(Fe, ge, $, q, !1, !1);
        else if (Me === "MultiLineString" || Me === "Polygon") for (let Ne = 0; Ne < ge.length; Ne++) ri(Fe, ge[Ne], $, q, Me === "Polygon", Ne === 0);
        else if (Me === "MultiPolygon") for (let Ne = 0; Ne < ge.length; Ne++) {
          const De = ge[Ne];
          for (let tt = 0; tt < De.length; tt++) ri(Fe, De[tt], $, q, !0, tt === 0);
        }
        if (Fe.length) {
          let Ne = B.tags || null;
          if (Me === "LineString" && te.lineMetrics) {
            Ne = {};
            for (const tt in B.tags) Ne[tt] = B.tags[tt];
            Ne.mapbox_clip_start = ge.start / ge.size, Ne.mapbox_clip_end = ge.end / ge.size;
          }
          const De = { geometry: Fe, type: Me === "Polygon" || Me === "MultiPolygon" ? 3 : Me === "LineString" || Me === "MultiLineString" ? 2 : 1, tags: Ne };
          B.id !== null && (De.id = B.id), $.features.push(De);
        }
      }
      function ri($, B, q, te, ge, Me) {
        const Fe = te * te;
        if (te > 0 && B.size < (ge ? Fe : te)) return void (q.numPoints += B.length / 3);
        const Ne = [];
        for (let De = 0; De < B.length; De += 3) (te === 0 || B[De + 2] > Fe) && (q.numSimplified++, Ne.push(B[De], B[De + 1])), q.numPoints++;
        ge && function(De, tt) {
          let ut = 0;
          for (let We = 0, gt = De.length, Mt = gt - 2; We < gt; Mt = We, We += 2) ut += (De[We] - De[Mt]) * (De[We + 1] + De[Mt + 1]);
          if (ut > 0 === tt) for (let We = 0, gt = De.length; We < gt / 2; We += 2) {
            const Mt = De[We], $t = De[We + 1];
            De[We] = De[gt - 2 - We], De[We + 1] = De[gt - 1 - We], De[gt - 2 - We] = Mt, De[gt - 1 - We] = $t;
          }
        }(Ne, Me), $.push(Ne);
      }
      const Lt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class Si {
        constructor(B, q) {
          const te = (q = this.options = function(Me, Fe) {
            for (const Ne in Fe) Me[Ne] = Fe[Ne];
            return Me;
          }(Object.create(Lt), q)).debug;
          if (te && console.time("preprocess data"), q.maxZoom < 0 || q.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (q.promoteId && q.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ge = function(Me, Fe) {
            const Ne = [];
            if (Me.type === "FeatureCollection") for (let De = 0; De < Me.features.length; De++) Pt(Ne, Me.features[De], Fe, De);
            else Pt(Ne, Me.type === "Feature" ? Me : { geometry: Me }, Fe);
            return Ne;
          }(B, q);
          this.tiles = {}, this.tileCoords = [], te && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", q.indexMaxZoom, q.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ge = function(Me, Fe) {
            const Ne = Fe.buffer / Fe.extent;
            let De = Me;
            const tt = xt(Me, 1, -1 - Ne, Ne, 0, -1, 2, Fe), ut = xt(Me, 1, 1 - Ne, 2 + Ne, 0, -1, 2, Fe);
            return (tt || ut) && (De = xt(Me, 1, -Ne, 1 + Ne, 0, -1, 2, Fe) || [], tt && (De = pt(tt, 1).concat(De)), ut && (De = De.concat(pt(ut, -1)))), De;
          }(ge, q), ge.length && this.splitTile(ge, 0, 0, 0), te && (ge.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(B, q, te, ge, Me, Fe, Ne) {
          const De = [B, q, te, ge], tt = this.options, ut = tt.debug;
          for (; De.length; ) {
            ge = De.pop(), te = De.pop(), q = De.pop(), B = De.pop();
            const We = 1 << q, gt = Gi(q, te, ge);
            let Mt = this.tiles[gt];
            if (!Mt && (ut > 1 && console.time("creation"), Mt = this.tiles[gt] = Zi(B, q, te, ge, tt), this.tileCoords.push({ z: q, x: te, y: ge }), ut)) {
              ut > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", q, te, ge, Mt.numFeatures, Mt.numPoints, Mt.numSimplified), console.timeEnd("creation"));
              const gr = `z${q}`;
              this.stats[gr] = (this.stats[gr] || 0) + 1, this.total++;
            }
            if (Mt.source = B, Me == null) {
              if (q === tt.indexMaxZoom || Mt.numPoints <= tt.indexMaxPoints) continue;
            } else {
              if (q === tt.maxZoom || q === Me) continue;
              if (Me != null) {
                const gr = Me - q;
                if (te !== Fe >> gr || ge !== Ne >> gr) continue;
              }
            }
            if (Mt.source = null, B.length === 0) continue;
            ut > 1 && console.time("clipping");
            const $t = 0.5 * tt.buffer / tt.extent, Qt = 0.5 - $t, ei = 0.5 + $t, pi = 1 + $t;
            let fi = null, Wi = null, Oi = null, mi = null, Bi = xt(B, We, te - $t, te + ei, 0, Mt.minX, Mt.maxX, tt), Hi = xt(B, We, te + Qt, te + pi, 0, Mt.minX, Mt.maxX, tt);
            B = null, Bi && (fi = xt(Bi, We, ge - $t, ge + ei, 1, Mt.minY, Mt.maxY, tt), Wi = xt(Bi, We, ge + Qt, ge + pi, 1, Mt.minY, Mt.maxY, tt), Bi = null), Hi && (Oi = xt(Hi, We, ge - $t, ge + ei, 1, Mt.minY, Mt.maxY, tt), mi = xt(Hi, We, ge + Qt, ge + pi, 1, Mt.minY, Mt.maxY, tt), Hi = null), ut > 1 && console.timeEnd("clipping"), De.push(fi || [], q + 1, 2 * te, 2 * ge), De.push(Wi || [], q + 1, 2 * te, 2 * ge + 1), De.push(Oi || [], q + 1, 2 * te + 1, 2 * ge), De.push(mi || [], q + 1, 2 * te + 1, 2 * ge + 1);
          }
        }
        getTile(B, q, te) {
          B = +B, q = +q, te = +te;
          const ge = this.options, { extent: Me, debug: Fe } = ge;
          if (B < 0 || B > 24) return null;
          const Ne = 1 << B, De = Gi(B, q = q + Ne & Ne - 1, te);
          if (this.tiles[De]) return si(this.tiles[De], Me);
          Fe > 1 && console.log("drilling down to z%d-%d-%d", B, q, te);
          let tt, ut = B, We = q, gt = te;
          for (; !tt && ut > 0; ) ut--, We >>= 1, gt >>= 1, tt = this.tiles[Gi(ut, We, gt)];
          return tt && tt.source ? (Fe > 1 && (console.log("found parent tile z%d-%d-%d", ut, We, gt), console.time("drilling down")), this.splitTile(tt.source, ut, We, gt, B, q, te), Fe > 1 && console.timeEnd("drilling down"), this.tiles[De] ? si(this.tiles[De], Me) : null) : null;
        }
      }
      function Gi($, B, q) {
        return 32 * ((1 << $) * q + B) + $;
      }
      function zt($, B) {
        return B ? $.properties[B] : $.id;
      }
      function cr($, B) {
        if ($ == null) return !0;
        if ($.type === "Feature") return zt($, B) != null;
        if ($.type === "FeatureCollection") {
          const q = /* @__PURE__ */ new Set();
          for (const te of $.features) {
            const ge = zt(te, B);
            if (ge == null || q.has(ge)) return !1;
            q.add(ge);
          }
          return !0;
        }
        return !1;
      }
      function Ni($, B) {
        const q = /* @__PURE__ */ new Map();
        if ($ != null) if ($.type === "Feature") q.set(zt($, B), $);
        else for (const te of $.features) q.set(zt(te, B), te);
        return q;
      }
      class ie extends j {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(B, q) {
          return g._(this, void 0, void 0, function* () {
            const te = B.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ge = this._geoJSONIndex.getTile(te.z, te.x, te.y);
            if (!ge) return null;
            const Me = new class {
              constructor(Ne) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = g.X, this.length = Ne.length, this._features = Ne;
              }
              feature(Ne) {
                return new class {
                  constructor(De) {
                    this._feature = De, this.extent = g.X, this.type = De.type, this.properties = De.tags, "id" in De && !isNaN(De.id) && (this.id = parseInt(De.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const De = [];
                      for (const tt of this._feature.geometry) De.push([new g.P(tt[0], tt[1])]);
                      return De;
                    }
                    {
                      const De = [];
                      for (const tt of this._feature.geometry) {
                        const ut = [];
                        for (const We of tt) ut.push(new g.P(We[0], We[1]));
                        De.push(ut);
                      }
                      return De;
                    }
                  }
                  toGeoJSON(De, tt, ut) {
                    return ae.call(this, De, tt, ut);
                  }
                }(this._features[Ne]);
              }
            }(ge.features);
            let Fe = Ze(Me);
            return Fe.byteOffset === 0 && Fe.byteLength === Fe.buffer.byteLength || (Fe = new Uint8Array(Fe)), { vectorTile: Me, rawData: Fe.buffer };
          });
        }
        loadData(B) {
          return g._(this, void 0, void 0, function* () {
            var q;
            (q = this._pendingRequest) === null || q === void 0 || q.abort();
            const te = !!(B && B.request && B.request.collectResourceTiming) && new g.bv(B.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(B, this._pendingRequest), this._geoJSONIndex = B.cluster ? new be(function({ superclusterOptions: Fe, clusterProperties: Ne }) {
                if (!Ne || !Fe) return Fe;
                const De = {}, tt = {}, ut = { accumulated: null, zoom: 0 }, We = { properties: null }, gt = Object.keys(Ne);
                for (const Mt of gt) {
                  const [$t, Qt] = Ne[Mt], ei = g.bC(Qt), pi = g.bC(typeof $t == "string" ? [$t, ["accumulated"], ["get", Mt]] : $t);
                  De[Mt] = ei.value, tt[Mt] = pi.value;
                }
                return Fe.map = (Mt) => {
                  We.properties = Mt;
                  const $t = {};
                  for (const Qt of gt) $t[Qt] = De[Qt].evaluate(ut, We);
                  return $t;
                }, Fe.reduce = (Mt, $t) => {
                  We.properties = $t;
                  for (const Qt of gt) ut.accumulated = Mt[Qt], Mt[Qt] = tt[Qt].evaluate(ut, We);
                }, Fe;
              }(B)).load((yield this._pendingData).features) : (ge = yield this._pendingData, new Si(ge, B.geojsonVtOptions)), this.loaded = {};
              const Me = {};
              if (te) {
                const Fe = te.finish();
                Fe && (Me.resourceTiming = {}, Me.resourceTiming[B.source] = JSON.parse(JSON.stringify(Fe)));
              }
              return Me;
            } catch (Me) {
              if (delete this._pendingRequest, g.bB(Me)) return { abandoned: !0 };
              throw Me;
            }
            var ge;
          });
        }
        getData() {
          return g._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(B) {
          const q = this.loaded;
          return q && q[B.uid] ? super.reloadTile(B) : this.loadTile(B);
        }
        loadAndProcessGeoJSON(B, q) {
          return g._(this, void 0, void 0, function* () {
            let te = yield this.loadGeoJSON(B, q);
            if (delete this._pendingRequest, typeof te != "object") throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            if (oe(te, !0), B.filter) {
              const ge = g.bC(B.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ge.result === "error") throw new Error(ge.value.map((Fe) => `${Fe.key}: ${Fe.message}`).join(", "));
              te = { type: "FeatureCollection", features: te.features.filter((Fe) => ge.value.evaluate({ zoom: 0 }, Fe)) };
            }
            return te;
          });
        }
        loadGeoJSON(B, q) {
          return g._(this, void 0, void 0, function* () {
            const { promoteId: te } = B;
            if (B.request) {
              const ge = yield g.h(B.request, q);
              return this._dataUpdateable = cr(ge.data, te) ? Ni(ge.data, te) : void 0, ge.data;
            }
            if (typeof B.data == "string") try {
              const ge = JSON.parse(B.data);
              return this._dataUpdateable = cr(ge, te) ? Ni(ge, te) : void 0, ge;
            } catch {
              throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            }
            if (!B.dataDiff) throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${B.source}`);
            return function(ge, Me, Fe) {
              var Ne, De, tt, ut;
              if (Me.removeAll && ge.clear(), Me.remove) for (const We of Me.remove) ge.delete(We);
              if (Me.add) for (const We of Me.add) {
                const gt = zt(We, Fe);
                gt != null && ge.set(gt, We);
              }
              if (Me.update) for (const We of Me.update) {
                let gt = ge.get(We.id);
                if (gt == null) continue;
                const Mt = !We.removeAllProperties && (((Ne = We.removeProperties) === null || Ne === void 0 ? void 0 : Ne.length) > 0 || ((De = We.addOrUpdateProperties) === null || De === void 0 ? void 0 : De.length) > 0);
                if ((We.newGeometry || We.removeAllProperties || Mt) && (gt = Object.assign({}, gt), ge.set(We.id, gt), Mt && (gt.properties = Object.assign({}, gt.properties))), We.newGeometry && (gt.geometry = We.newGeometry), We.removeAllProperties) gt.properties = {};
                else if (((tt = We.removeProperties) === null || tt === void 0 ? void 0 : tt.length) > 0) for (const $t of We.removeProperties) Object.prototype.hasOwnProperty.call(gt.properties, $t) && delete gt.properties[$t];
                if (((ut = We.addOrUpdateProperties) === null || ut === void 0 ? void 0 : ut.length) > 0) for (const { key: $t, value: Qt } of We.addOrUpdateProperties) gt.properties[$t] = Qt;
              }
            }(this._dataUpdateable, B.dataDiff, te), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(B) {
          return g._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(B) {
          return this._geoJSONIndex.getClusterExpansionZoom(B.clusterId);
        }
        getClusterChildren(B) {
          return this._geoJSONIndex.getChildren(B.clusterId);
        }
        getClusterLeaves(B) {
          return this._geoJSONIndex.getLeaves(B.clusterId, B.limit, B.offset);
        }
      }
      class ue {
        constructor(B) {
          this.self = B, this.actor = new g.F(B), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (q, te) => {
            if (this.externalWorkerSourceTypes[q]) throw new Error(`Worker source with name "${q}" already registered.`);
            this.externalWorkerSourceTypes[q] = te;
          }, this.self.addProtocol = g.bi, this.self.removeProtocol = g.bj, this.self.registerRTLTextPlugin = (q) => {
            if (g.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            g.bD.setMethods(q);
          }, this.actor.registerMessageHandler("LDT", (q, te) => this._getDEMWorkerSource(q, te.source).loadTile(te)), this.actor.registerMessageHandler("RDT", (q, te) => g._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(q, te.source).removeTile(te);
          })), this.actor.registerMessageHandler("GCEZ", (q, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(q, te.type, te.source).getClusterExpansionZoom(te);
          })), this.actor.registerMessageHandler("GCC", (q, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(q, te.type, te.source).getClusterChildren(te);
          })), this.actor.registerMessageHandler("GCL", (q, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(q, te.type, te.source).getClusterLeaves(te);
          })), this.actor.registerMessageHandler("LD", (q, te) => this._getWorkerSource(q, te.type, te.source).loadData(te)), this.actor.registerMessageHandler("GD", (q, te) => this._getWorkerSource(q, te.type, te.source).getData()), this.actor.registerMessageHandler("LT", (q, te) => this._getWorkerSource(q, te.type, te.source).loadTile(te)), this.actor.registerMessageHandler("RT", (q, te) => this._getWorkerSource(q, te.type, te.source).reloadTile(te)), this.actor.registerMessageHandler("AT", (q, te) => this._getWorkerSource(q, te.type, te.source).abortTile(te)), this.actor.registerMessageHandler("RMT", (q, te) => this._getWorkerSource(q, te.type, te.source).removeTile(te)), this.actor.registerMessageHandler("RS", (q, te) => g._(this, void 0, void 0, function* () {
            if (!this.workerSources[q] || !this.workerSources[q][te.type] || !this.workerSources[q][te.type][te.source]) return;
            const ge = this.workerSources[q][te.type][te.source];
            delete this.workerSources[q][te.type][te.source], ge.removeSource !== void 0 && ge.removeSource(te);
          })), this.actor.registerMessageHandler("RM", (q) => g._(this, void 0, void 0, function* () {
            delete this.layerIndexes[q], delete this.availableImages[q], delete this.workerSources[q], delete this.demWorkerSources[q];
          })), this.actor.registerMessageHandler("SR", (q, te) => g._(this, void 0, void 0, function* () {
            this.referrer = te;
          })), this.actor.registerMessageHandler("SRPS", (q, te) => this._syncRTLPluginState(q, te)), this.actor.registerMessageHandler("IS", (q, te) => g._(this, void 0, void 0, function* () {
            this.self.importScripts(te);
          })), this.actor.registerMessageHandler("SI", (q, te) => this._setImages(q, te)), this.actor.registerMessageHandler("UL", (q, te) => g._(this, void 0, void 0, function* () {
            this._getLayerIndex(q).update(te.layers, te.removedIds);
          })), this.actor.registerMessageHandler("SL", (q, te) => g._(this, void 0, void 0, function* () {
            this._getLayerIndex(q).replace(te);
          }));
        }
        _setImages(B, q) {
          return g._(this, void 0, void 0, function* () {
            this.availableImages[B] = q;
            for (const te in this.workerSources[B]) {
              const ge = this.workerSources[B][te];
              for (const Me in ge) ge[Me].availableImages = q;
            }
          });
        }
        _syncRTLPluginState(B, q) {
          return g._(this, void 0, void 0, function* () {
            if (g.bD.isParsed()) return g.bD.getState();
            if (q.pluginStatus !== "loading") return g.bD.setState(q), q;
            const te = q.pluginURL;
            if (this.self.importScripts(te), g.bD.isParsed()) {
              const ge = { pluginStatus: "loaded", pluginURL: te };
              return g.bD.setState(ge), ge;
            }
            throw g.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${te}`);
          });
        }
        _getAvailableImages(B) {
          let q = this.availableImages[B];
          return q || (q = []), q;
        }
        _getLayerIndex(B) {
          let q = this.layerIndexes[B];
          return q || (q = this.layerIndexes[B] = new o()), q;
        }
        _getWorkerSource(B, q, te) {
          if (this.workerSources[B] || (this.workerSources[B] = {}), this.workerSources[B][q] || (this.workerSources[B][q] = {}), !this.workerSources[B][q][te]) {
            const ge = { sendAsync: (Me, Fe) => (Me.targetMapId = B, this.actor.sendAsync(Me, Fe)) };
            switch (q) {
              case "vector":
                this.workerSources[B][q][te] = new j(ge, this._getLayerIndex(B), this._getAvailableImages(B));
                break;
              case "geojson":
                this.workerSources[B][q][te] = new ie(ge, this._getLayerIndex(B), this._getAvailableImages(B));
                break;
              default:
                this.workerSources[B][q][te] = new this.externalWorkerSourceTypes[q](ge, this._getLayerIndex(B), this._getAvailableImages(B));
            }
          }
          return this.workerSources[B][q][te];
        }
        _getDEMWorkerSource(B, q) {
          return this.demWorkerSources[B] || (this.demWorkerSources[B] = {}), this.demWorkerSources[B][q] || (this.demWorkerSources[B][q] = new O()), this.demWorkerSources[B][q];
        }
      }
      return g.i(self) && (self.worker = new ue(self)), ue;
    }), y("index", ["exports", "./shared"], function(g, o) {
      var k = "4.7.1";
      let D, L;
      const j = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (h) => new Promise((e, r) => {
        const u = requestAnimationFrame(e);
        h.signal.addEventListener("abort", () => {
          cancelAnimationFrame(u), r(o.c());
        });
      }), getImageData(h, e = 0) {
        return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e);
      }, getImageCanvasContext(h) {
        const e = window.document.createElement("canvas"), r = e.getContext("2d", { willReadFrequently: !0 });
        if (!r) throw new Error("failed to create canvas 2d context");
        return e.width = h.width, e.height = h.height, r.drawImage(h, 0, 0, h.width, h.height), r;
      }, resolveURL: (h) => (D || (D = document.createElement("a")), D.href = h, D.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (L == null && (L = matchMedia("(prefers-reduced-motion: reduce)")), L.matches);
      } };
      class O {
        static testProp(e) {
          if (!O.docStyle) return e[0];
          for (let r = 0; r < e.length; r++) if (e[r] in O.docStyle) return e[r];
          return e[0];
        }
        static create(e, r, u) {
          const d = window.document.createElement(e);
          return r !== void 0 && (d.className = r), u && u.appendChild(d), d;
        }
        static createNS(e, r) {
          return window.document.createElementNS(e, r);
        }
        static disableDrag() {
          O.docStyle && O.selectProp && (O.userSelect = O.docStyle[O.selectProp], O.docStyle[O.selectProp] = "none");
        }
        static enableDrag() {
          O.docStyle && O.selectProp && (O.docStyle[O.selectProp] = O.userSelect);
        }
        static setTransform(e, r) {
          e.style[O.transformProp] = r;
        }
        static addEventListener(e, r, u, d = {}) {
          e.addEventListener(r, u, "passive" in d ? d : d.capture);
        }
        static removeEventListener(e, r, u, d = {}) {
          e.removeEventListener(r, u, "passive" in d ? d : d.capture);
        }
        static suppressClickInternal(e) {
          e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", O.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", O.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", O.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(e) {
          const r = e.getBoundingClientRect();
          return { x: r.width / e.offsetWidth || 1, y: r.height / e.offsetHeight || 1, boundingClientRect: r };
        }
        static getPoint(e, r, u) {
          const d = r.boundingClientRect;
          return new o.P((u.clientX - d.left) / r.x - e.clientLeft, (u.clientY - d.top) / r.y - e.clientTop);
        }
        static mousePos(e, r) {
          const u = O.getScale(e);
          return O.getPoint(e, u, r);
        }
        static touchPos(e, r) {
          const u = [], d = O.getScale(e);
          for (let p = 0; p < r.length; p++) u.push(O.getPoint(e, d, r[p]));
          return u;
        }
        static mouseButton(e) {
          return e.button;
        }
        static remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
      }
      O.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, O.selectProp = O.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), O.transformProp = O.testProp(["transform", "WebkitTransform"]);
      const z = { supported: !1, testSupport: function(h) {
        !ae && oe && (Q ? fe(h) : pe = h);
      } };
      let pe, oe, ae = !1, Q = !1;
      function fe(h) {
        const e = h.createTexture();
        h.bindTexture(h.TEXTURE_2D, e);
        try {
          if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, oe), h.isContextLost()) return;
          z.supported = !0;
        } catch {
        }
        h.deleteTexture(e), ae = !0;
      }
      var Ce;
      typeof document < "u" && (oe = document.createElement("img"), oe.onload = () => {
        pe && fe(pe), pe = null, Q = !0;
      }, oe.onerror = () => {
        ae = !0, pe = null;
      }, oe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(h) {
        let e, r, u, d;
        h.resetRequestQueue = () => {
          e = [], r = 0, u = 0, d = {};
        }, h.addThrottleControl = (C) => {
          const P = u++;
          return d[P] = C, P;
        }, h.removeThrottleControl = (C) => {
          delete d[C], w();
        }, h.getImage = (C, P, F = !0) => new Promise((N, Z) => {
          z.supported && (C.headers || (C.headers = {}), C.headers.accept = "image/webp,*/*"), o.e(C, { type: "image" }), e.push({ abortController: P, requestParameters: C, supportImageRefresh: F, state: "queued", onError: (G) => {
            Z(G);
          }, onSuccess: (G) => {
            N(G);
          } }), w();
        });
        const p = (C) => o._(this, void 0, void 0, function* () {
          C.state = "running";
          const { requestParameters: P, supportImageRefresh: F, onError: N, onSuccess: Z, abortController: G } = C, V = F === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce((le, de) => le && de === "accept", !0));
          r++;
          const W = V ? A(P, G) : o.m(P, G);
          try {
            const le = yield W;
            delete C.abortController, C.state = "completed", le.data instanceof HTMLImageElement || o.b(le.data) ? Z(le) : le.data && Z({ data: yield (se = le.data, typeof createImageBitmap == "function" ? o.d(se) : o.f(se)), cacheControl: le.cacheControl, expires: le.expires });
          } catch (le) {
            delete C.abortController, N(le);
          } finally {
            r--, w();
          }
          var se;
        }), w = () => {
          const C = (() => {
            for (const P of Object.keys(d)) if (d[P]()) return !0;
            return !1;
          })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let P = r; P < C && e.length > 0; P++) {
            const F = e.shift();
            F.abortController.signal.aborted ? P-- : p(F);
          }
        }, A = (C, P) => new Promise((F, N) => {
          const Z = new Image(), G = C.url, V = C.credentials;
          V && V === "include" ? Z.crossOrigin = "use-credentials" : (V && V === "same-origin" || !o.s(G)) && (Z.crossOrigin = "anonymous"), P.signal.addEventListener("abort", () => {
            Z.src = "", N(o.c());
          }), Z.fetchPriority = "high", Z.onload = () => {
            Z.onerror = Z.onload = null, F({ data: Z });
          }, Z.onerror = () => {
            Z.onerror = Z.onload = null, P.signal.aborted || N(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, Z.src = G;
        });
      }(Ce || (Ce = {})), Ce.resetRequestQueue();
      class ze {
        constructor(e) {
          this._transformRequestFn = e;
        }
        transformRequest(e, r) {
          return this._transformRequestFn && this._transformRequestFn(e, r) || { url: e };
        }
        setTransformRequest(e) {
          this._transformRequestFn = e;
        }
      }
      function je(h) {
        var e = new o.A(3);
        return e[0] = h[0], e[1] = h[1], e[2] = h[2], e;
      }
      var Qe, ke = function(h, e, r) {
        return h[0] = e[0] - r[0], h[1] = e[1] - r[1], h[2] = e[2] - r[2], h;
      };
      Qe = new o.A(3), o.A != Float32Array && (Qe[0] = 0, Qe[1] = 0, Qe[2] = 0);
      var Ae = function(h) {
        var e = h[0], r = h[1];
        return e * e + r * r;
      };
      function me(h) {
        const e = [];
        if (typeof h == "string") e.push({ id: "default", url: h });
        else if (h && h.length > 0) {
          const r = [];
          for (const { id: u, url: d } of h) {
            const p = `${u}${d}`;
            r.indexOf(p) === -1 && (r.push(p), e.push({ id: u, url: d }));
          }
        }
        return e;
      }
      function ve(h, e, r) {
        const u = h.split("?");
        return u[0] += `${e}${r}`, u.join("?");
      }
      (function() {
        var h = new o.A(2);
        o.A != Float32Array && (h[0] = 0, h[1] = 0);
      })();
      class X {
        constructor(e, r, u, d) {
          this.context = e, this.format = u, this.texture = e.gl.createTexture(), this.update(r, d);
        }
        update(e, r, u) {
          const { width: d, height: p } = e, w = !(this.size && this.size[0] === d && this.size[1] === p || u), { context: A } = this, { gl: C } = A;
          if (this.useMipmap = !!(r && r.useMipmap), C.bindTexture(C.TEXTURE_2D, this.texture), A.pixelStoreUnpackFlipY.set(!1), A.pixelStoreUnpack.set(1), A.pixelStoreUnpackPremultiplyAlpha.set(this.format === C.RGBA && (!r || r.premultiply !== !1)), w) this.size = [d, p], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || o.b(e) ? C.texImage2D(C.TEXTURE_2D, 0, this.format, this.format, C.UNSIGNED_BYTE, e) : C.texImage2D(C.TEXTURE_2D, 0, this.format, d, p, 0, this.format, C.UNSIGNED_BYTE, e.data);
          else {
            const { x: P, y: F } = u || { x: 0, y: 0 };
            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || o.b(e) ? C.texSubImage2D(C.TEXTURE_2D, 0, P, F, C.RGBA, C.UNSIGNED_BYTE, e) : C.texSubImage2D(C.TEXTURE_2D, 0, P, F, d, p, C.RGBA, C.UNSIGNED_BYTE, e.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && C.generateMipmap(C.TEXTURE_2D);
        }
        bind(e, r, u) {
          const { context: d } = this, { gl: p } = d;
          p.bindTexture(p.TEXTURE_2D, this.texture), u !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = p.LINEAR), e !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, e), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, u || e), this.filter = e), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      function re(h) {
        const { userImage: e } = h;
        return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0);
      }
      class xe extends o.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e) {
          if (this.loaded !== e && (this.loaded = e, e)) {
            for (const { ids: r, promiseResolve: u } of this.requestors) u(this._getImagesForIds(r));
            this.requestors = [];
          }
        }
        getImage(e) {
          const r = this.images[e];
          if (r && !r.data && r.spriteData) {
            const u = r.spriteData;
            r.data = new o.R({ width: u.width, height: u.height }, u.context.getImageData(u.x, u.y, u.width, u.height).data), r.spriteData = null;
          }
          return r;
        }
        addImage(e, r) {
          if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
          this._validate(e, r) && (this.images[e] = r);
        }
        _validate(e, r) {
          let u = !0;
          const d = r.data || r.spriteData;
          return this._validateStretch(r.stretchX, d && d.width) || (this.fire(new o.j(new Error(`Image "${e}" has invalid "stretchX" value`))), u = !1), this._validateStretch(r.stretchY, d && d.height) || (this.fire(new o.j(new Error(`Image "${e}" has invalid "stretchY" value`))), u = !1), this._validateContent(r.content, r) || (this.fire(new o.j(new Error(`Image "${e}" has invalid "content" value`))), u = !1), u;
        }
        _validateStretch(e, r) {
          if (!e) return !0;
          let u = 0;
          for (const d of e) {
            if (d[0] < u || d[1] < d[0] || r < d[1]) return !1;
            u = d[1];
          }
          return !0;
        }
        _validateContent(e, r) {
          if (!e) return !0;
          if (e.length !== 4) return !1;
          const u = r.spriteData, d = u && u.width || r.data.width, p = u && u.height || r.data.height;
          return !(e[0] < 0 || d < e[0] || e[1] < 0 || p < e[1] || e[2] < 0 || d < e[2] || e[3] < 0 || p < e[3] || e[2] < e[0] || e[3] < e[1]);
        }
        updateImage(e, r, u = !0) {
          const d = this.getImage(e);
          if (u && (d.data.width !== r.data.width || d.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${d.data.width}x${d.data.height}) and new image (${r.data.width}x${r.data.height}).`);
          r.version = d.version + 1, this.images[e] = r, this.updatedImages[e] = !0;
        }
        removeImage(e) {
          const r = this.images[e];
          delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e) {
          return new Promise((r, u) => {
            let d = !0;
            if (!this.isLoaded()) for (const p of e) this.images[p] || (d = !1);
            this.isLoaded() || d ? r(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r });
          });
        }
        _getImagesForIds(e) {
          const r = {};
          for (const u of e) {
            let d = this.getImage(u);
            d || (this.fire(new o.k("styleimagemissing", { id: u })), d = this.getImage(u)), d ? r[u] = { data: d.data.clone(), pixelRatio: d.pixelRatio, sdf: d.sdf, version: d.version, stretchX: d.stretchX, stretchY: d.stretchY, content: d.content, textFitWidth: d.textFitWidth, textFitHeight: d.textFitHeight, hasRenderCallback: !!(d.userImage && d.userImage.render) } : o.w(`Image "${u}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return r;
        }
        getPixelSize() {
          const { width: e, height: r } = this.atlasImage;
          return { width: e, height: r };
        }
        getPattern(e) {
          const r = this.patterns[e], u = this.getImage(e);
          if (!u) return null;
          if (r && r.position.version === u.version) return r.position;
          if (r) r.position.version = u.version;
          else {
            const d = { w: u.data.width + 2, h: u.data.height + 2, x: 0, y: 0 }, p = new o.I(d, u);
            this.patterns[e] = { bin: d, position: p };
          }
          return this._updatePatternAtlas(), this.patterns[e].position;
        }
        bind(e) {
          const r = e.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new X(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e = [];
          for (const p in this.patterns) e.push(this.patterns[p].bin);
          const { w: r, h: u } = o.p(e), d = this.atlasImage;
          d.resize({ width: r || 1, height: u || 1 });
          for (const p in this.patterns) {
            const { bin: w } = this.patterns[p], A = w.x + 1, C = w.y + 1, P = this.getImage(p).data, F = P.width, N = P.height;
            o.R.copy(P, d, { x: 0, y: 0 }, { x: A, y: C }, { width: F, height: N }), o.R.copy(P, d, { x: 0, y: N - 1 }, { x: A, y: C - 1 }, { width: F, height: 1 }), o.R.copy(P, d, { x: 0, y: 0 }, { x: A, y: C + N }, { width: F, height: 1 }), o.R.copy(P, d, { x: F - 1, y: 0 }, { x: A - 1, y: C }, { width: 1, height: N }), o.R.copy(P, d, { x: 0, y: 0 }, { x: A + F, y: C }, { width: 1, height: N });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e) {
          for (const r of e) {
            if (this.callbackDispatchedThisFrame[r]) continue;
            this.callbackDispatchedThisFrame[r] = !0;
            const u = this.getImage(r);
            u || o.w(`Image with ID: "${r}" was not found`), re(u) && this.updateImage(r, u);
          }
        }
      }
      const ye = 1e20;
      function Ve(h, e, r, u, d, p, w, A, C) {
        for (let P = e; P < e + u; P++) He(h, r * p + P, p, d, w, A, C);
        for (let P = r; P < r + d; P++) He(h, P * p + e, 1, u, w, A, C);
      }
      function He(h, e, r, u, d, p, w) {
        p[0] = 0, w[0] = -ye, w[1] = ye, d[0] = h[e];
        for (let A = 1, C = 0, P = 0; A < u; A++) {
          d[A] = h[e + A * r];
          const F = A * A;
          do {
            const N = p[C];
            P = (d[A] - d[N] + F - N * N) / (A - N) / 2;
          } while (P <= w[C] && --C > -1);
          C++, p[C] = A, w[C] = P, w[C + 1] = ye;
        }
        for (let A = 0, C = 0; A < u; A++) {
          for (; w[C + 1] < A; ) C++;
          const P = p[C], F = A - P;
          h[e + A * r] = d[P] + F * F;
        }
      }
      class Ze {
        constructor(e, r) {
          this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {};
        }
        setURL(e) {
          this.url = e;
        }
        getGlyphs(e) {
          return o._(this, void 0, void 0, function* () {
            const r = [];
            for (const p in e) for (const w of e[p]) r.push(this._getAndCacheGlyphsPromise(p, w));
            const u = yield Promise.all(r), d = {};
            for (const { stack: p, id: w, glyph: A } of u) d[p] || (d[p] = {}), d[p][w] = A && { id: A.id, bitmap: A.bitmap.clone(), metrics: A.metrics };
            return d;
          });
        }
        _getAndCacheGlyphsPromise(e, r) {
          return o._(this, void 0, void 0, function* () {
            let u = this.entries[e];
            u || (u = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
            let d = u.glyphs[r];
            if (d !== void 0) return { stack: e, id: r, glyph: d };
            if (d = this._tinySDF(u, e, r), d) return u.glyphs[r] = d, { stack: e, id: r, glyph: d };
            const p = Math.floor(r / 256);
            if (256 * p > 65535) throw new Error("glyphs > 65535 not supported");
            if (u.ranges[p]) return { stack: e, id: r, glyph: d };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!u.requests[p]) {
              const A = Ze.loadGlyphRange(e, p, this.url, this.requestManager);
              u.requests[p] = A;
            }
            const w = yield u.requests[p];
            for (const A in w) this._doesCharSupportLocalGlyph(+A) || (u.glyphs[+A] = w[+A]);
            return u.ranges[p] = !0, { stack: e, id: r, glyph: w[r] || null };
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e));
        }
        _tinySDF(e, r, u) {
          const d = this.localIdeographFontFamily;
          if (!d || !this._doesCharSupportLocalGlyph(u)) return;
          let p = e.tinySDF;
          if (!p) {
            let A = "400";
            /bold/i.test(r) ? A = "900" : /medium/i.test(r) ? A = "500" : /light/i.test(r) && (A = "200"), p = e.tinySDF = new Ze.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: d, fontWeight: A });
          }
          const w = p.draw(String.fromCharCode(u));
          return { id: u, bitmap: new o.o({ width: w.width || 60, height: w.height || 60 }, w.data), metrics: { width: w.glyphWidth / 2 || 24, height: w.glyphHeight / 2 || 24, left: w.glyphLeft / 2 + 0.5 || 0, top: w.glyphTop / 2 - 27.5 || -8, advance: w.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Ze.loadGlyphRange = function(h, e, r, u) {
        return o._(this, void 0, void 0, function* () {
          const d = 256 * e, p = d + 255, w = u.transformRequest(r.replace("{fontstack}", h).replace("{range}", `${d}-${p}`), "Glyphs"), A = yield o.l(w, new AbortController());
          if (!A || !A.data) throw new Error(`Could not load glyph range. range: ${e}, ${d}-${p}`);
          const C = {};
          for (const P of o.n(A.data)) C[P.id] = P;
          return C;
        });
      }, Ze.TinySDF = class {
        constructor({ fontSize: h = 24, buffer: e = 3, radius: r = 8, cutoff: u = 0.25, fontFamily: d = "sans-serif", fontWeight: p = "normal", fontStyle: w = "normal" } = {}) {
          this.buffer = e, this.cutoff = u, this.radius = r;
          const A = this.size = h + 4 * e, C = this._createCanvas(A), P = this.ctx = C.getContext("2d", { willReadFrequently: !0 });
          P.font = `${w} ${p} ${h}px ${d}`, P.textBaseline = "alphabetic", P.textAlign = "left", P.fillStyle = "black", this.gridOuter = new Float64Array(A * A), this.gridInner = new Float64Array(A * A), this.f = new Float64Array(A), this.z = new Float64Array(A + 1), this.v = new Uint16Array(A);
        }
        _createCanvas(h) {
          const e = document.createElement("canvas");
          return e.width = e.height = h, e;
        }
        draw(h) {
          const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: u, actualBoundingBoxLeft: d, actualBoundingBoxRight: p } = this.ctx.measureText(h), w = Math.ceil(r), A = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - d))), C = Math.min(this.size - this.buffer, w + Math.ceil(u)), P = A + 2 * this.buffer, F = C + 2 * this.buffer, N = Math.max(P * F, 0), Z = new Uint8ClampedArray(N), G = { data: Z, width: P, height: F, glyphWidth: A, glyphHeight: C, glyphTop: w, glyphLeft: 0, glyphAdvance: e };
          if (A === 0 || C === 0) return G;
          const { ctx: V, buffer: W, gridInner: se, gridOuter: le } = this;
          V.clearRect(W, W, A, C), V.fillText(h, W, W + w);
          const de = V.getImageData(W, W, A, C);
          le.fill(ye, 0, N), se.fill(0, 0, N);
          for (let ce = 0; ce < C; ce++) for (let we = 0; we < A; we++) {
            const Le = de.data[4 * (ce * A + we) + 3] / 255;
            if (Le === 0) continue;
            const Ie = (ce + W) * P + we + W;
            if (Le === 1) le[Ie] = 0, se[Ie] = ye;
            else {
              const it = 0.5 - Le;
              le[Ie] = it > 0 ? it * it : 0, se[Ie] = it < 0 ? it * it : 0;
            }
          }
          Ve(le, 0, 0, P, F, P, this.f, this.v, this.z), Ve(se, W, W, A, C, P, this.f, this.v, this.z);
          for (let ce = 0; ce < N; ce++) {
            const we = Math.sqrt(le[ce]) - Math.sqrt(se[ce]);
            Z[ce] = Math.round(255 - 255 * (we / this.radius + this.cutoff));
          }
          return G;
        }
      };
      class qe {
        constructor() {
          this.specification = o.v.light.position;
        }
        possiblyEvaluate(e, r) {
          return o.x(e.expression.evaluate(r));
        }
        interpolate(e, r, u) {
          return { x: o.y.number(e.x, r.x, u), y: o.y.number(e.y, r.y, u), z: o.y.number(e.z, r.z, u) };
        }
      }
      let Je;
      class et extends o.E {
        constructor(e) {
          super(), Je = Je || new o.q({ anchor: new o.D(o.v.light.anchor), position: new qe(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.T(Je), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e, r = {}) {
          if (!this._validate(o.r, e, r)) for (const u in e) {
            const d = e[u];
            u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), d) : this._transitionable.setValue(u, d);
          }
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, u) {
          return (!u || u.validate !== !1) && o.t(this, e.call(o.u, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v }));
        }
      }
      const st = new o.q({ "sky-color": new o.D(o.v.sky["sky-color"]), "horizon-color": new o.D(o.v.sky["horizon-color"]), "fog-color": new o.D(o.v.sky["fog-color"]), "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]), "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]), "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"]) });
      class ee extends o.E {
        constructor(e) {
          super(), this._transitionable = new o.T(st), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.z(0));
        }
        setSky(e, r = {}) {
          if (!this._validate(o.B, e, r)) {
            e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const u in e) {
              const d = e[u];
              u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), d) : this._transitionable.setValue(u, d);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, u = {}) {
          return (u == null ? void 0 : u.validate) !== !1 && o.t(this, e.call(o.u, o.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v })));
        }
        calculateFogBlendOpacity(e) {
          return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
        }
      }
      class _e {
        constructor(e, r) {
          this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(e, r) {
          const u = e.join(",") + String(r);
          return this.dashEntry[u] || (this.dashEntry[u] = this.addDash(e, r)), this.dashEntry[u];
        }
        getDashRanges(e, r, u) {
          const d = [];
          let p = e.length % 2 == 1 ? -e[e.length - 1] * u : 0, w = e[0] * u, A = !0;
          d.push({ left: p, right: w, isDash: A, zeroLength: e[0] === 0 });
          let C = e[0];
          for (let P = 1; P < e.length; P++) {
            A = !A;
            const F = e[P];
            p = C * u, C += F, w = C * u, d.push({ left: p, right: w, isDash: A, zeroLength: F === 0 });
          }
          return d;
        }
        addRoundDash(e, r, u) {
          const d = r / 2;
          for (let p = -u; p <= u; p++) {
            const w = this.width * (this.nextRow + u + p);
            let A = 0, C = e[A];
            for (let P = 0; P < this.width; P++) {
              P / C.right > 1 && (C = e[++A]);
              const F = Math.abs(P - C.left), N = Math.abs(P - C.right), Z = Math.min(F, N);
              let G;
              const V = p / u * (d + 1);
              if (C.isDash) {
                const W = d - Math.abs(V);
                G = Math.sqrt(Z * Z + W * W);
              } else G = d - Math.sqrt(Z * Z + V * V);
              this.data[w + P] = Math.max(0, Math.min(255, G + 128));
            }
          }
        }
        addRegularDash(e) {
          for (let A = e.length - 1; A >= 0; --A) {
            const C = e[A], P = e[A + 1];
            C.zeroLength ? e.splice(A, 1) : P && P.isDash === C.isDash && (P.left = C.left, e.splice(A, 1));
          }
          const r = e[0], u = e[e.length - 1];
          r.isDash === u.isDash && (r.left = u.left - this.width, u.right = r.right + this.width);
          const d = this.width * this.nextRow;
          let p = 0, w = e[p];
          for (let A = 0; A < this.width; A++) {
            A / w.right > 1 && (w = e[++p]);
            const C = Math.abs(A - w.left), P = Math.abs(A - w.right), F = Math.min(C, P);
            this.data[d + A] = Math.max(0, Math.min(255, (w.isDash ? F : -F) + 128));
          }
        }
        addDash(e, r) {
          const u = r ? 7 : 0, d = 2 * u + 1;
          if (this.nextRow + d > this.height) return o.w("LineAtlas out of space"), null;
          let p = 0;
          for (let A = 0; A < e.length; A++) p += e[A];
          if (p !== 0) {
            const A = this.width / p, C = this.getDashRanges(e, this.width, A);
            r ? this.addRoundDash(C, A, u) : this.addRegularDash(C);
          }
          const w = { y: (this.nextRow + u + 0.5) / this.height, height: 2 * u / this.height, width: p };
          return this.nextRow += d, this.dirty = !0, w;
        }
        bind(e) {
          const r = e.gl;
          this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
        }
      }
      const be = "maplibre_preloaded_worker_pool";
      class Te {
        constructor() {
          this.active = {};
        }
        acquire(e) {
          if (!this.workers) for (this.workers = []; this.workers.length < Te.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
          return this.active[e] = !0, this.workers.slice();
        }
        release(e) {
          delete this.active[e], this.numActive() === 0 && (this.workers.forEach((r) => {
            r.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[be];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const Oe = Math.floor(j.hardwareConcurrency / 2);
      let $e, Ue;
      function Ke() {
        return $e || ($e = new Te()), $e;
      }
      Te.workerCount = o.C(globalThis) ? Math.max(Math.min(Oe, 3), 1) : 1;
      class nt {
        constructor(e, r) {
          this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
          const u = this.workerPool.acquire(r);
          for (let d = 0; d < u.length; d++) {
            const p = new o.F(u[d], r);
            p.name = `Worker ${d}`, this.actors.push(p);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(e, r) {
          const u = [];
          for (const d of this.actors) u.push(d.sendAsync({ type: e, data: r }));
          return Promise.all(u);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(e = !0) {
          this.actors.forEach((r) => {
            r.remove();
          }), this.actors = [], e && this.workerPool.release(this.id);
        }
        registerMessageHandler(e, r) {
          for (const u of this.actors) u.registerMessageHandler(e, r);
        }
      }
      function ot() {
        return Ue || (Ue = new nt(Ke(), o.G), Ue.registerMessageHandler("GR", (h, e, r) => o.m(e, r))), Ue;
      }
      function vt(h, e) {
        const r = o.H();
        return o.J(r, r, [1, 1, 0]), o.K(r, r, [0.5 * h.width, 0.5 * h.height, 1]), o.L(r, r, h.calculatePosMatrix(e.toUnwrapped()));
      }
      function mt(h, e, r, u, d, p) {
        const w = function(N, Z, G) {
          if (N) for (const V of N) {
            const W = Z[V];
            if (W && W.source === G && W.type === "fill-extrusion") return !0;
          }
          else for (const V in Z) {
            const W = Z[V];
            if (W.source === G && W.type === "fill-extrusion") return !0;
          }
          return !1;
        }(d && d.layers, e, h.id), A = p.maxPitchScaleFactor(), C = h.tilesIn(u, A, w);
        C.sort(Pt);
        const P = [];
        for (const N of C) P.push({ wrappedTileID: N.tileID.wrapped().key, queryResults: N.tile.queryRenderedFeatures(e, r, h._state, N.queryGeometry, N.cameraQueryGeometry, N.scale, d, p, A, vt(h.transform, N.tileID)) });
        const F = function(N) {
          const Z = {}, G = {};
          for (const V of N) {
            const W = V.queryResults, se = V.wrappedTileID, le = G[se] = G[se] || {};
            for (const de in W) {
              const ce = W[de], we = le[de] = le[de] || {}, Le = Z[de] = Z[de] || [];
              for (const Ie of ce) we[Ie.featureIndex] || (we[Ie.featureIndex] = !0, Le.push(Ie));
            }
          }
          return Z;
        }(P);
        for (const N in F) F[N].forEach((Z) => {
          const G = Z.feature, V = h.getFeatureState(G.layer["source-layer"], G.id);
          G.source = G.layer.source, G.layer["source-layer"] && (G.sourceLayer = G.layer["source-layer"]), G.state = V;
        });
        return F;
      }
      function Pt(h, e) {
        const r = h.tileID, u = e.tileID;
        return r.overscaledZ - u.overscaledZ || r.canonical.y - u.canonical.y || r.wrap - u.wrap || r.canonical.x - u.canonical.x;
      }
      function rt(h, e, r) {
        return o._(this, void 0, void 0, function* () {
          let u = h;
          if (h.url ? u = (yield o.h(e.transformRequest(h.url, "Source"), r)).data : yield j.frameAsync(r), !u) return null;
          const d = o.M(o.e(u, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in u && u.vector_layers && (d.vectorLayerIds = u.vector_layers.map((p) => p.id)), d;
        });
      }
      class Y {
        constructor(e, r) {
          e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
        }
        setNorthEast(e) {
          return this._ne = e instanceof o.N ? new o.N(e.lng, e.lat) : o.N.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof o.N ? new o.N(e.lng, e.lat) : o.N.convert(e), this;
        }
        extend(e) {
          const r = this._sw, u = this._ne;
          let d, p;
          if (e instanceof o.N) d = e, p = e;
          else {
            if (!(e instanceof Y)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Y.convert(e)) : this.extend(o.N.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(o.N.convert(e)) : this;
            if (d = e._sw, p = e._ne, !d || !p) return this;
          }
          return r || u ? (r.lng = Math.min(d.lng, r.lng), r.lat = Math.min(d.lat, r.lat), u.lng = Math.max(p.lng, u.lng), u.lat = Math.max(p.lat, u.lat)) : (this._sw = new o.N(d.lng, d.lat), this._ne = new o.N(p.lng, p.lat)), this;
        }
        getCenter() {
          return new o.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new o.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new o.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: r, lat: u } = o.N.convert(e);
          let d = this._sw.lng <= r && r <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (d = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= u && u <= this._ne.lat && d;
        }
        static convert(e) {
          return e instanceof Y ? e : e && new Y(e);
        }
        static fromLngLat(e, r = 0) {
          const u = 360 * r / 40075017, d = u / Math.cos(Math.PI / 180 * e.lat);
          return new Y(new o.N(e.lng - d, e.lat - u), new o.N(e.lng + d, e.lat + u));
        }
        adjustAntiMeridian() {
          const e = new o.N(this._sw.lng, this._sw.lat), r = new o.N(this._ne.lng, this._ne.lat);
          return new Y(e, e.lng > r.lng ? new o.N(r.lng + 360, r.lat) : r);
        }
      }
      class Kt {
        constructor(e, r, u) {
          this.bounds = Y.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = u || 24;
        }
        validateBounds(e) {
          return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
        }
        contains(e) {
          const r = Math.pow(2, e.z), u = Math.floor(o.O(this.bounds.getWest()) * r), d = Math.floor(o.Q(this.bounds.getNorth()) * r), p = Math.ceil(o.O(this.bounds.getEast()) * r), w = Math.ceil(o.Q(this.bounds.getSouth()) * r);
          return e.x >= u && e.x < p && e.y >= d && e.y < w;
        }
      }
      class Rt extends o.E {
        constructor(e, r, u, d) {
          if (super(), this.id = e, this.dispatcher = u, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.M(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(d);
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield rt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (o.e(this, e), e.bounds && (this.tileBounds = new Kt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new o.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setSourceProperty(e) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return o.e({}, this._options);
        }
        loadTile(e) {
          return o._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), u = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            u.request.collectResourceTiming = this._collectResourceTiming;
            let d = "RT";
            if (e.actor && e.state !== "expired") {
              if (e.state === "loading") return new Promise((p, w) => {
                e.reloadPromise = { resolve: p, reject: w };
              });
            } else e.actor = this.dispatcher.getActor(), d = "LT";
            e.abortController = new AbortController();
            try {
              const p = yield e.actor.sendAsync({ type: d, data: u }, e.abortController);
              if (delete e.abortController, e.aborted) return;
              this._afterTileLoadWorkerResponse(e, p);
            } catch (p) {
              if (delete e.abortController, e.aborted) return;
              if (p && p.status !== 404) throw p;
              this._afterTileLoadWorkerResponse(e, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(e, r) {
          if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
            const u = e.reloadPromise;
            e.reloadPromise = null, this.loadTile(e).then(u.resolve).catch(u.reject);
          }
        }
        abortTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class lt extends o.E {
        constructor(e, r, u, d) {
          super(), this.id = e, this.dispatcher = u, this.setEventedParent(d), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({ type: "raster" }, r), o.e(this, o.M(r, ["url", "scheme", "tileSize"]));
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield rt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, e && (o.e(this, e), e.bounds && (this.tileBounds = new Kt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new o.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(e) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        serialize() {
          return o.e({}, this._options);
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        loadTile(e) {
          return o._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e.abortController = new AbortController();
            try {
              const u = yield Ce.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (u && u.data) {
                this.map._refreshExpiredTiles && u.cacheControl && u.expires && e.setExpiryData({ cacheControl: u.cacheControl, expires: u.expires });
                const d = this.map.painter.context, p = d.gl, w = u.data;
                e.texture = this.map.painter.getTileTexture(w.width), e.texture ? e.texture.update(w, { useMipmap: !0 }) : (e.texture = new X(d, w, p.RGBA, { useMipmap: !0 }), e.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
              }
            } catch (u) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (u) throw e.state = "errored", u;
            }
          });
        }
        abortTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController);
          });
        }
        unloadTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.texture && this.map.painter.saveTileTexture(e.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class xt extends lt {
        constructor(e, r, u, d) {
          super(e, r, u, d), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
        }
        loadTile(e) {
          return o._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), u = this.map._requestManager.transformRequest(r, "Tile");
            e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
            try {
              const d = yield Ce.getImage(u, e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (d && d.data) {
                const p = d.data;
                this.map._refreshExpiredTiles && d.cacheControl && d.expires && e.setExpiryData({ cacheControl: d.cacheControl, expires: d.expires });
                const w = o.b(p) && o.U() ? p : yield this.readImageNow(p), A = { type: this.type, uid: e.uid, source: this.id, rawImageData: w, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!e.actor || e.state === "expired") {
                  e.actor = this.dispatcher.getActor();
                  const C = yield e.actor.sendAsync({ type: "LDT", data: A });
                  e.dem = C, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                }
              }
            } catch (d) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (d) throw e.state = "errored", d;
            }
          });
        }
        readImageNow(e) {
          return o._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && o.V()) {
              const r = e.width + 2, u = e.height + 2;
              try {
                return new o.R({ width: r, height: u }, yield o.W(e, -1, -1, r, u));
              } catch {
              }
            }
            return j.getImageData(e, 1);
          });
        }
        _getNeighboringTiles(e) {
          const r = e.canonical, u = Math.pow(2, r.z), d = (r.x - 1 + u) % u, p = r.x === 0 ? e.wrap - 1 : e.wrap, w = (r.x + 1 + u) % u, A = r.x + 1 === u ? e.wrap + 1 : e.wrap, C = {};
          return C[new o.S(e.overscaledZ, p, r.z, d, r.y).key] = { backfilled: !1 }, C[new o.S(e.overscaledZ, A, r.z, w, r.y).key] = { backfilled: !1 }, r.y > 0 && (C[new o.S(e.overscaledZ, p, r.z, d, r.y - 1).key] = { backfilled: !1 }, C[new o.S(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, C[new o.S(e.overscaledZ, A, r.z, w, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < u && (C[new o.S(e.overscaledZ, p, r.z, d, r.y + 1).key] = { backfilled: !1 }, C[new o.S(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, C[new o.S(e.overscaledZ, A, r.z, w, r.y + 1).key] = { backfilled: !1 }), C;
        }
        unloadTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
          });
        }
      }
      class At extends o.E {
        constructor(e, r, u, d) {
          super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = u.getActor(), this.setEventedParent(d), this._data = r.data, this._options = o.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId;
          const p = o.X / this.tileSize;
          r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = o.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (r.buffer !== void 0 ? r.buffer : 128) * p, tolerance: (r.tolerance !== void 0 ? r.tolerance : 0.375) * p, extent: o.X, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: r.clusterMaxZoom !== void 0 ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: o.X, radius: (r.clusterRadius || 50) * p, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setData(e) {
          return this._data = e, this._updateWorkerData(), this;
        }
        updateData(e) {
          return this._updateWorkerData(e), this;
        }
        getData() {
          return o._(this, void 0, void 0, function* () {
            const e = o.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: e });
          });
        }
        setClusterOptions(e) {
          return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterChildren(e) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterLeaves(e, r, u) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r, offset: u } });
        }
        _updateWorkerData(e) {
          return o._(this, void 0, void 0, function* () {
            const r = o.e({ type: this.type }, this.workerOptions);
            e ? r.dataDiff = e : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(j.resolveURL(this._data), "Source"), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new o.k("dataloading", { dataType: "source" }));
            try {
              const u = yield this.actor.sendAsync({ type: "LD", data: r });
              if (this._pendingLoads--, this._removed || u.abandoned) return void this.fire(new o.k("dataabort", { dataType: "source" }));
              let d = null;
              u.resourceTiming && u.resourceTiming[this.id] && (d = u.resourceTiming[this.id].slice(0));
              const p = { dataType: "source" };
              this._collectResourceTiming && d && d.length > 0 && o.e(p, { resourceTiming: d }), this.fire(new o.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "metadata" }))), this.fire(new o.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "content" })));
            } catch (u) {
              if (this._pendingLoads--, this._removed) return void this.fire(new o.k("dataabort", { dataType: "source" }));
              this.fire(new o.j(u));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(e) {
          return o._(this, void 0, void 0, function* () {
            const r = e.actor ? "RT" : "LT";
            e.actor = this.actor;
            const u = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            e.abortController = new AbortController();
            const d = yield this.actor.sendAsync({ type: r, data: u }, e.abortController);
            delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(d, this.map.painter, r === "RT");
          });
        }
        abortTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
          });
        }
        unloadTile(e) {
          return o._(this, void 0, void 0, function* () {
            e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return o.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Et = o.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class jt extends o.E {
        constructor(e, r, u, d) {
          super(), this.id = e, this.dispatcher = u, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(d), this.options = r;
        }
        load(e) {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const r = yield Ce.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading());
            } catch (r) {
              this._request = null, this._loaded = !0, this.fire(new o.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e) {
          return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(e) {
          this.coordinates = e;
          const r = e.map(o.Z.fromLngLat);
          this.tileID = function(d) {
            let p = 1 / 0, w = 1 / 0, A = -1 / 0, C = -1 / 0;
            for (const Z of d) p = Math.min(p, Z.x), w = Math.min(w, Z.y), A = Math.max(A, Z.x), C = Math.max(C, Z.y);
            const P = Math.max(A - p, C - w), F = Math.max(0, Math.floor(-Math.log(P) / Math.LN2)), N = Math.pow(2, F);
            return new o.a1(F, Math.floor((p + A) / 2 * N), Math.floor((w + C) / 2 * N));
          }(r), this.minzoom = this.maxzoom = this.tileID.z;
          const u = r.map((d) => this.tileID.getTilePoint(d)._round());
          return this._boundsArray = new o.$(), this._boundsArray.emplaceBack(u[0].x, u[0].y, 0, 0), this._boundsArray.emplaceBack(u[1].x, u[1].y, o.X, 0), this._boundsArray.emplaceBack(u[3].x, u[3].y, 0, o.X), this._boundsArray.emplaceBack(u[2].x, u[2].y, o.X, o.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = o.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new X(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let u = !1;
          for (const d in this.tiles) {
            const p = this.tiles[d];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, u = !0);
          }
          u && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(e) {
          return o._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class ni extends jt {
        constructor(e, r, u, d) {
          super(e, r, u, d), this.roundZoom = !0, this.type = "video", this.options = r;
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const e = this.options;
            this.urls = [];
            for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
            try {
              const r = yield o.a3(this.urls);
              if (this._loaded = !0, !r) return;
              this.video = r, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (r) {
              this.fire(new o.j(r));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e) {
          if (this.video) {
            const r = this.video.seekable;
            e < r.start(0) || e > r.end(0) ? this.fire(new o.j(new o.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e) {
          this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = o.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new X(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let u = !1;
          for (const d in this.tiles) {
            const p = this.tiles[d];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, u = !0);
          }
          u && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class ii extends jt {
        constructor(e, r, u, d) {
          super(e, r, u, d), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((p) => !Array.isArray(p) || p.length !== 2 || p.some((w) => typeof w != "number")) || this.fire(new o.j(new o.a2(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.j(new o.a2(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new o.j(new o.a2(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new o.j(new o.a2(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.j(new o.a2(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e) {
          this.map = e, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const r = this.map.painter.context, u = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = o.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new X(r, this.canvas, u.RGBA, { premultiply: !0 });
          let d = !1;
          for (const p in this.tiles) {
            const w = this.tiles[p];
            w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, d = !0);
          }
          d && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
          return !1;
        }
      }
      const yi = {}, xi = (h) => {
        switch (h) {
          case "geojson":
            return At;
          case "image":
            return jt;
          case "raster":
            return lt;
          case "raster-dem":
            return xt;
          case "vector":
            return Rt;
          case "video":
            return ni;
          case "canvas":
            return ii;
        }
        return yi[h];
      }, pt = "RTLPluginLoaded";
      class Jt extends o.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ot();
        }
        _syncState(e) {
          return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((r) => {
            throw this.status = "error", r;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(e) {
          return o._(this, arguments, void 0, function* (r, u = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = j.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
            if (this.status === "unavailable") {
              if (!u) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return o._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new o.k(pt));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let si = null;
      function It() {
        return si || (si = new Jt()), si;
      }
      class Zi {
        constructor(e, r) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = o.a4(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(e) {
          const r = e + this.timeAdded;
          r < this.fadeEndTime || (this.fadeEndTime = r);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(e) {
          this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e, r, u) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
            e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(d, p) {
              const w = {};
              if (!p) return w;
              for (const A of d) {
                const C = A.layerIds.map((P) => p.getLayer(P)).filter(Boolean);
                if (C.length !== 0) {
                  A.layers = C, A.stateDependentLayerIds && (A.stateDependentLayers = A.stateDependentLayerIds.map((P) => C.filter((F) => F.id === P)[0]));
                  for (const P of C) w[P.id] = A;
                }
              }
              return w;
            }(e.buckets, r.style), this.hasSymbolBuckets = !1;
            for (const d in this.buckets) {
              const p = this.buckets[d];
              if (p instanceof o.a6) {
                if (this.hasSymbolBuckets = !0, !u) break;
                p.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const d in this.buckets) {
              const p = this.buckets[d];
              if (p instanceof o.a6 && p.hasRTLText) {
                this.hasRTLText = !0, It().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const d in this.buckets) {
              const p = this.buckets[d];
              this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(d).queryRadius(p));
            }
            e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
          } else this.collisionBoxArray = new o.a5();
        }
        unloadVectorData() {
          for (const e in this.buckets) this.buckets[e].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(e) {
          return this.buckets[e.id];
        }
        upload(e) {
          for (const u in this.buckets) {
            const d = this.buckets[u];
            d.uploadPending() && d.upload(e);
          }
          const r = e.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new X(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new X(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(e) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e, r, u, d, p, w, A, C, P, F) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: d, cameraQueryGeometry: p, scale: w, tileSize: this.tileSize, pixelPosMatrix: F, transform: C, params: A, queryPadding: this.queryPadding * P }, e, r, u) : {};
        }
        querySourceFeatures(e, r) {
          const u = this.latestFeatureIndex;
          if (!u || !u.rawTileData) return;
          const d = u.loadVTLayers(), p = r && r.sourceLayer ? r.sourceLayer : "", w = d._geojsonTileLayer || d[p];
          if (!w) return;
          const A = o.a7(r && r.filter), { z: C, x: P, y: F } = this.tileID.canonical, N = { z: C, x: P, y: F };
          for (let Z = 0; Z < w.length; Z++) {
            const G = w.feature(Z);
            if (A.needGeometry) {
              const se = o.a8(G, !0);
              if (!A.filter(new o.z(this.tileID.overscaledZ), se, this.tileID.canonical)) continue;
            } else if (!A.filter(new o.z(this.tileID.overscaledZ), G)) continue;
            const V = u.getId(G, p), W = new o.a9(G, C, P, F, V);
            W.tile = N, e.push(W);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e) {
          const r = this.expirationTime;
          if (e.cacheControl) {
            const u = o.aa(e.cacheControl);
            u["max-age"] && (this.expirationTime = Date.now() + 1e3 * u["max-age"]);
          } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
          if (this.expirationTime) {
            const u = Date.now();
            let d = !1;
            if (this.expirationTime > u) d = !1;
            else if (r) if (this.expirationTime < r) d = !0;
            else {
              const p = this.expirationTime - r;
              p ? this.expirationTime = u + Math.max(p, 3e4) : d = !0;
            }
            else d = !0;
            d ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e, r) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
          const u = this.latestFeatureIndex.loadVTLayers();
          for (const d in this.buckets) {
            if (!r.style.hasLayer(d)) continue;
            const p = this.buckets[d], w = p.layers[0].sourceLayer || "_geojsonTileLayer", A = u[w], C = e[w];
            if (!A || !C || Object.keys(C).length === 0) continue;
            p.update(C, A, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const P = r && r.style && r.style.getLayer(d);
            P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(p)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < j.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e) {
          this.symbolFadeHoldUntil = j.now() + e;
        }
        setDependencies(e, r) {
          const u = {};
          for (const d of r) u[d] = !0;
          this.dependencies[e] = u;
        }
        hasDependency(e, r) {
          for (const u of e) {
            const d = this.dependencies[u];
            if (d) {
              for (const p of r) if (d[p]) return !0;
            }
          }
          return !1;
        }
      }
      class ft {
        constructor(e, r) {
          this.max = e, this.onRemove = r, this.reset();
        }
        reset() {
          for (const e in this.data) for (const r of this.data[e]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
          return this.data = {}, this.order = [], this;
        }
        add(e, r, u) {
          const d = e.wrapped().key;
          this.data[d] === void 0 && (this.data[d] = []);
          const p = { value: r, timeout: void 0 };
          if (u !== void 0 && (p.timeout = setTimeout(() => {
            this.remove(e, p);
          }, u)), this.data[d].push(p), this.order.push(d), this.order.length > this.max) {
            const w = this._getAndRemoveByKey(this.order[0]);
            w && this.onRemove(w);
          }
          return this;
        }
        has(e) {
          return e.wrapped().key in this.data;
        }
        getAndRemove(e) {
          return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
        }
        _getAndRemoveByKey(e) {
          const r = this.data[e].shift();
          return r.timeout && clearTimeout(r.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r.value;
        }
        getByKey(e) {
          const r = this.data[e];
          return r ? r[0].value : null;
        }
        get(e) {
          return this.has(e) ? this.data[e.wrapped().key][0].value : null;
        }
        remove(e, r) {
          if (!this.has(e)) return this;
          const u = e.wrapped().key, d = r === void 0 ? 0 : this.data[u].indexOf(r), p = this.data[u][d];
          return this.data[u].splice(d, 1), p.timeout && clearTimeout(p.timeout), this.data[u].length === 0 && delete this.data[u], this.onRemove(p.value), this.order.splice(this.order.indexOf(u), 1), this;
        }
        setMaxSize(e) {
          for (this.max = e; this.order.length > this.max; ) {
            const r = this._getAndRemoveByKey(this.order[0]);
            r && this.onRemove(r);
          }
          return this;
        }
        filter(e) {
          const r = [];
          for (const u in this.data) for (const d of this.data[u]) e(d.value) || r.push(d);
          for (const u of r) this.remove(u.value.tileID, u);
        }
      }
      class ri {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e, r, u) {
          const d = String(r);
          if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][d] = this.stateChanges[e][d] || {}, o.e(this.stateChanges[e][d], u), this.deletedStates[e] === null) {
            this.deletedStates[e] = {};
            for (const p in this.state[e]) p !== d && (this.deletedStates[e][p] = null);
          } else if (this.deletedStates[e] && this.deletedStates[e][d] === null) {
            this.deletedStates[e][d] = {};
            for (const p in this.state[e][d]) u[p] || (this.deletedStates[e][d][p] = null);
          } else for (const p in u) this.deletedStates[e] && this.deletedStates[e][d] && this.deletedStates[e][d][p] === null && delete this.deletedStates[e][d][p];
        }
        removeFeatureState(e, r, u) {
          if (this.deletedStates[e] === null) return;
          const d = String(r);
          if (this.deletedStates[e] = this.deletedStates[e] || {}, u && r !== void 0) this.deletedStates[e][d] !== null && (this.deletedStates[e][d] = this.deletedStates[e][d] || {}, this.deletedStates[e][d][u] = null);
          else if (r !== void 0) if (this.stateChanges[e] && this.stateChanges[e][d]) for (u in this.deletedStates[e][d] = {}, this.stateChanges[e][d]) this.deletedStates[e][d][u] = null;
          else this.deletedStates[e][d] = null;
          else this.deletedStates[e] = null;
        }
        getState(e, r) {
          const u = String(r), d = o.e({}, (this.state[e] || {})[u], (this.stateChanges[e] || {})[u]);
          if (this.deletedStates[e] === null) return {};
          if (this.deletedStates[e]) {
            const p = this.deletedStates[e][r];
            if (p === null) return {};
            for (const w in p) delete d[w];
          }
          return d;
        }
        initializeTileState(e, r) {
          e.setFeatureState(this.state, r);
        }
        coalesceChanges(e, r) {
          const u = {};
          for (const d in this.stateChanges) {
            this.state[d] = this.state[d] || {};
            const p = {};
            for (const w in this.stateChanges[d]) this.state[d][w] || (this.state[d][w] = {}), o.e(this.state[d][w], this.stateChanges[d][w]), p[w] = this.state[d][w];
            u[d] = p;
          }
          for (const d in this.deletedStates) {
            this.state[d] = this.state[d] || {};
            const p = {};
            if (this.deletedStates[d] === null) for (const w in this.state[d]) p[w] = {}, this.state[d][w] = {};
            else for (const w in this.deletedStates[d]) {
              if (this.deletedStates[d][w] === null) this.state[d][w] = {};
              else for (const A of Object.keys(this.deletedStates[d][w])) delete this.state[d][w][A];
              p[w] = this.state[d][w];
            }
            u[d] = u[d] || {}, o.e(u[d], p);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(u).length !== 0) for (const d in e) e[d].setFeatureState(u, r);
        }
      }
      class Lt extends o.E {
        constructor(e, r, u) {
          super(), this.id = e, this.dispatcher = u, this.on("data", (d) => this._dataHandler(d)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((d, p, w, A) => {
            const C = new (xi(p.type))(d, p, w, A);
            if (C.id !== d) throw new Error(`Expected Source id to be ${d} instead of ${C.id}`);
            return C;
          })(e, r, u, this), this._tiles = {}, this._cache = new ft(0, (d) => this._unloadTile(d)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ri(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(e) {
          this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
        }
        onRemove(e) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const e in this._tiles) {
            const r = this._tiles[e];
            if (r.state !== "loaded" && r.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const e = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(e, r, u) {
          return o._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(e), this._tileLoaded(e, r, u);
            } catch (d) {
              e.state = "errored", d.status !== 404 ? this._source.fire(new o.j(d, { tile: e })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(e) {
          this._source.unloadTile && this._source.unloadTile(e);
        }
        _abortTile(e) {
          this._source.abortTile && this._source.abortTile(e), this._source.fire(new o.k("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const r in this._tiles) {
            const u = this._tiles[r];
            u.upload(e), u.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((e) => e.tileID).sort(Si).map((e) => e.key);
        }
        getRenderableIds(e) {
          const r = [];
          for (const u in this._tiles) this._isIdRenderable(u, e) && r.push(this._tiles[u]);
          return e ? r.sort((u, d) => {
            const p = u.tileID, w = d.tileID, A = new o.P(p.canonical.x, p.canonical.y)._rotate(this.transform.angle), C = new o.P(w.canonical.x, w.canonical.y)._rotate(this.transform.angle);
            return p.overscaledZ - w.overscaledZ || C.y - A.y || C.x - A.x;
          }).map((u) => u.tileID.key) : r.map((u) => u.tileID).sort(Si).map((u) => u.key);
        }
        hasRenderableParent(e) {
          const r = this.findLoadedParent(e, 0);
          return !!r && this._isIdRenderable(r.tileID.key);
        }
        _isIdRenderable(e, r) {
          return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
          }
        }
        _reloadTile(e, r) {
          return o._(this, void 0, void 0, function* () {
            const u = this._tiles[e];
            u && (u.state !== "loading" && (u.state = r), yield this._loadTile(u, e, r));
          });
        }
        _tileLoaded(e, r, u) {
          e.timeAdded = j.now(), u === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new o.k("data", { dataType: "source", tile: e, coord: e.tileID }));
        }
        _backfillDEM(e) {
          const r = this.getRenderableIds();
          for (let d = 0; d < r.length; d++) {
            const p = r[d];
            if (e.neighboringTiles && e.neighboringTiles[p]) {
              const w = this.getTileByID(p);
              u(e, w), u(w, e);
            }
          }
          function u(d, p) {
            d.needsHillshadePrepare = !0, d.needsTerrainPrepare = !0;
            let w = p.tileID.canonical.x - d.tileID.canonical.x;
            const A = p.tileID.canonical.y - d.tileID.canonical.y, C = Math.pow(2, d.tileID.canonical.z), P = p.tileID.key;
            w === 0 && A === 0 || Math.abs(A) > 1 || (Math.abs(w) > 1 && (Math.abs(w + C) === 1 ? w += C : Math.abs(w - C) === 1 && (w -= C)), p.dem && d.dem && (d.dem.backfillBorder(p.dem, w, A), d.neighboringTiles && d.neighboringTiles[P] && (d.neighboringTiles[P].backfilled = !0)));
          }
        }
        getTile(e) {
          return this.getTileByID(e.key);
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        _retainLoadedChildren(e, r, u, d) {
          for (const p in this._tiles) {
            let w = this._tiles[p];
            if (d[p] || !w.hasData() || w.tileID.overscaledZ <= r || w.tileID.overscaledZ > u) continue;
            let A = w.tileID;
            for (; w && w.tileID.overscaledZ > r + 1; ) {
              const P = w.tileID.scaledTo(w.tileID.overscaledZ - 1);
              w = this._tiles[P.key], w && w.hasData() && (A = P);
            }
            let C = A;
            for (; C.overscaledZ > r; ) if (C = C.scaledTo(C.overscaledZ - 1), e[C.key]) {
              d[A.key] = A;
              break;
            }
          }
        }
        findLoadedParent(e, r) {
          if (e.key in this._loadedParentTiles) {
            const u = this._loadedParentTiles[e.key];
            return u && u.tileID.overscaledZ >= r ? u : null;
          }
          for (let u = e.overscaledZ - 1; u >= r; u--) {
            const d = e.scaledTo(u), p = this._getLoadedTile(d);
            if (p) return p;
          }
        }
        findLoadedSibling(e) {
          return this._getLoadedTile(e);
        }
        _getLoadedTile(e) {
          const r = this._tiles[e.key];
          return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key);
        }
        updateCacheSize(e) {
          const r = Math.ceil(e.width / this._source.tileSize) + 1, u = Math.ceil(e.height / this._source.tileSize) + 1, d = Math.floor(r * u * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, d) : d;
          this._cache.setMaxSize(p);
        }
        handleWrapJump(e) {
          const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
          if (this._prevLng = e, r) {
            const u = {};
            for (const d in this._tiles) {
              const p = this._tiles[d];
              p.tileID = p.tileID.unwrapTo(p.tileID.wrap + r), u[p.tileID.key] = p;
            }
            this._tiles = u;
            for (const d in this._timers) clearTimeout(this._timers[d]), delete this._timers[d];
            for (const d in this._tiles) this._setTileReloadTimer(d, this._tiles[d]);
          }
        }
        _updateCoveredAndRetainedTiles(e, r, u, d, p, w) {
          const A = {}, C = {}, P = Object.keys(e), F = j.now();
          for (const N of P) {
            const Z = e[N], G = this._tiles[N];
            if (!G || G.fadeEndTime !== 0 && G.fadeEndTime <= F) continue;
            const V = this.findLoadedParent(Z, r), W = this.findLoadedSibling(Z), se = V || W || null;
            se && (this._addTile(se.tileID), A[se.tileID.key] = se.tileID), C[N] = Z;
          }
          this._retainLoadedChildren(C, d, u, e);
          for (const N in A) e[N] || (this._coveredTiles[N] = !0, e[N] = A[N]);
          if (w) {
            const N = {}, Z = {};
            for (const G of p) this._tiles[G.key].hasData() ? N[G.key] = G : Z[G.key] = G;
            for (const G in Z) {
              const V = Z[G].children(this._source.maxzoom);
              this._tiles[V[0].key] && this._tiles[V[1].key] && this._tiles[V[2].key] && this._tiles[V[3].key] && (N[V[0].key] = e[V[0].key] = V[0], N[V[1].key] = e[V[1].key] = V[1], N[V[2].key] = e[V[2].key] = V[2], N[V[3].key] = e[V[3].key] = V[3], delete Z[G]);
            }
            for (const G in Z) {
              const V = Z[G], W = this.findLoadedParent(V, this._source.minzoom), se = this.findLoadedSibling(V), le = W || se || null;
              if (le) {
                N[le.tileID.key] = e[le.tileID.key] = le.tileID;
                for (const de in N) N[de].isChildOf(le.tileID) && delete N[de];
              }
            }
            for (const G in this._tiles) N[G] || (this._coveredTiles[G] = !0);
          }
        }
        update(e, r) {
          if (!this._sourceLoaded || this._paused) return;
          let u;
          this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? u = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((F) => new o.S(F.canonical.z, F.wrap, F.canonical.z, F.canonical.x, F.canonical.y)) : (u = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r }), this._source.hasTile && (u = u.filter((F) => this._source.hasTile(F)))) : u = [];
          const d = e.coveringZoomLevel(this._source), p = Math.max(d - Lt.maxOverzooming, this._source.minzoom), w = Math.max(d + Lt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const F = {};
            for (const N of u) if (N.canonical.z > this._source.minzoom) {
              const Z = N.scaledTo(N.canonical.z - 1);
              F[Z.key] = Z;
              const G = N.scaledTo(Math.max(this._source.minzoom, Math.min(N.canonical.z, 5)));
              F[G.key] = G;
            }
            u = u.concat(Object.values(F));
          }
          const A = u.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, A && this.fire(new o.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const C = this._updateRetainedTiles(u, d);
          Gi(this._source.type) && this._updateCoveredAndRetainedTiles(C, p, w, d, u, r);
          for (const F in C) this._tiles[F].clearFadeHold();
          const P = o.ab(this._tiles, C);
          for (const F of P) {
            const N = this._tiles[F];
            N.hasSymbolBuckets && !N.holdingForFade() ? N.setHoldDuration(this.map._fadeDuration) : N.hasSymbolBuckets && !N.symbolFadeFinished() || this._removeTile(F);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
        }
        _updateRetainedTiles(e, r) {
          var u;
          const d = {}, p = {}, w = Math.max(r - Lt.maxOverzooming, this._source.minzoom), A = Math.max(r + Lt.maxUnderzooming, this._source.minzoom), C = {};
          for (const P of e) {
            const F = this._addTile(P);
            d[P.key] = P, F.hasData() || r < this._source.maxzoom && (C[P.key] = P);
          }
          this._retainLoadedChildren(C, r, A, d);
          for (const P of e) {
            let F = this._tiles[P.key];
            if (F.hasData()) continue;
            if (r + 1 > this._source.maxzoom) {
              const Z = P.children(this._source.maxzoom)[0], G = this.getTile(Z);
              if (G && G.hasData()) {
                d[Z.key] = Z;
                continue;
              }
            } else {
              const Z = P.children(this._source.maxzoom);
              if (d[Z[0].key] && d[Z[1].key] && d[Z[2].key] && d[Z[3].key]) continue;
            }
            let N = F.wasRequested();
            for (let Z = P.overscaledZ - 1; Z >= w; --Z) {
              const G = P.scaledTo(Z);
              if (p[G.key]) break;
              if (p[G.key] = !0, F = this.getTile(G), !F && N && (F = this._addTile(G)), F) {
                const V = F.hasData();
                if ((V || !(!((u = this.map) === null || u === void 0) && u.cancelPendingTileRequestsWhileZooming) || N) && (d[G.key] = G), N = F.wasRequested(), V) break;
              }
            }
          }
          return d;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e in this._tiles) {
            const r = [];
            let u, d = this._tiles[e].tileID;
            for (; d.overscaledZ > 0; ) {
              if (d.key in this._loadedParentTiles) {
                u = this._loadedParentTiles[d.key];
                break;
              }
              r.push(d.key);
              const p = d.scaledTo(d.overscaledZ - 1);
              if (u = this._getLoadedTile(p), u) break;
              d = p;
            }
            for (const p of r) this._loadedParentTiles[p] = u;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const e in this._tiles) {
            const r = this._tiles[e].tileID, u = this._getLoadedTile(r);
            this._loadedSiblingTiles[r.key] = u;
          }
        }
        _addTile(e) {
          let r = this._tiles[e.key];
          if (r) return r;
          r = this._cache.getAndRemove(e), r && (this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r)));
          const u = r;
          return r || (r = new Zi(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, u || this._source.fire(new o.k("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
        }
        _setTileReloadTimer(e, r) {
          e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
          const u = r.getExpiryTimeout();
          u && (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, "expired"), delete this._timers[e];
          }, u));
        }
        _removeTile(e) {
          const r = this._tiles[e];
          r && (r.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
        }
        _dataHandler(e) {
          const r = e.sourceDataType;
          e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const e in this._tiles) this._removeTile(e);
          this._cache.reset();
        }
        tilesIn(e, r, u) {
          const d = [], p = this.transform;
          if (!p) return d;
          const w = u ? p.getCameraQueryGeometry(e) : e, A = e.map((V) => p.pointCoordinate(V, this.terrain)), C = w.map((V) => p.pointCoordinate(V, this.terrain)), P = this.getIds();
          let F = 1 / 0, N = 1 / 0, Z = -1 / 0, G = -1 / 0;
          for (const V of C) F = Math.min(F, V.x), N = Math.min(N, V.y), Z = Math.max(Z, V.x), G = Math.max(G, V.y);
          for (let V = 0; V < P.length; V++) {
            const W = this._tiles[P[V]];
            if (W.holdingForFade()) continue;
            const se = W.tileID, le = Math.pow(2, p.zoom - W.tileID.overscaledZ), de = r * W.queryPadding * o.X / W.tileSize / le, ce = [se.getTilePoint(new o.Z(F, N)), se.getTilePoint(new o.Z(Z, G))];
            if (ce[0].x - de < o.X && ce[0].y - de < o.X && ce[1].x + de >= 0 && ce[1].y + de >= 0) {
              const we = A.map((Ie) => se.getTilePoint(Ie)), Le = C.map((Ie) => se.getTilePoint(Ie));
              d.push({ tile: W, tileID: se, queryGeometry: we, cameraQueryGeometry: Le, scale: le });
            }
          }
          return d;
        }
        getVisibleCoordinates(e) {
          const r = this.getRenderableIds(e).map((u) => this._tiles[u].tileID);
          for (const u of r) u.posMatrix = this.transform.calculatePosMatrix(u.toUnwrapped());
          return r;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Gi(this._source.type)) {
            const e = j.now();
            for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= e) return !0;
          }
          return !1;
        }
        setFeatureState(e, r, u) {
          this._state.updateState(e = e || "_geojsonTileLayer", r, u);
        }
        removeFeatureState(e, r, u) {
          this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, u);
        }
        getFeatureState(e, r) {
          return this._state.getState(e = e || "_geojsonTileLayer", r);
        }
        setDependencies(e, r, u) {
          const d = this._tiles[e];
          d && d.setDependencies(r, u);
        }
        reloadTilesForDependencies(e, r) {
          for (const u in this._tiles) this._tiles[u].hasDependency(e, r) && this._reloadTile(u, "reloading");
          this._cache.filter((u) => !u.hasDependency(e, r));
        }
      }
      function Si(h, e) {
        const r = Math.abs(2 * h.wrap) - +(h.wrap < 0), u = Math.abs(2 * e.wrap) - +(e.wrap < 0);
        return h.overscaledZ - e.overscaledZ || u - r || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x;
      }
      function Gi(h) {
        return h === "raster" || h === "image" || h === "video";
      }
      Lt.maxOverzooming = 10, Lt.maxUnderzooming = 3;
      class zt {
        constructor(e, r) {
          this.reset(e, r);
        }
        reset(e, r) {
          this.points = e || [], this._distances = [0];
          for (let u = 1; u < this.points.length; u++) this._distances[u] = this._distances[u - 1] + this.points[u].dist(this.points[u - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e) {
          if (this.points.length === 1) return this.points[0];
          e = o.ac(e, 0, 1);
          let r = 1, u = this._distances[r];
          const d = e * this.paddedLength + this.padding;
          for (; u < d && r < this._distances.length; ) u = this._distances[++r];
          const p = r - 1, w = this._distances[p], A = u - w, C = A > 0 ? (d - w) / A : 0;
          return this.points[p].mult(1 - C).add(this.points[r].mult(C));
        }
      }
      function cr(h, e) {
        let r = !0;
        return h === "always" || h !== "never" && e !== "never" || (r = !1), r;
      }
      class Ni {
        constructor(e, r, u) {
          const d = this.boxCells = [], p = this.circleCells = [];
          this.xCellCount = Math.ceil(e / u), this.yCellCount = Math.ceil(r / u);
          for (let w = 0; w < this.xCellCount * this.yCellCount; w++) d.push([]), p.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e, r, u, d, p) {
          this._forEachCell(r, u, d, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(u), this.bboxes.push(d), this.bboxes.push(p);
        }
        insertCircle(e, r, u, d) {
          this._forEachCell(r - d, u - d, r + d, u + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(u), this.circles.push(d);
        }
        _insertBoxCell(e, r, u, d, p, w) {
          this.boxCells[p].push(w);
        }
        _insertCircleCell(e, r, u, d, p, w) {
          this.circleCells[p].push(w);
        }
        _query(e, r, u, d, p, w, A) {
          if (u < 0 || e > this.width || d < 0 || r > this.height) return [];
          const C = [];
          if (e <= 0 && r <= 0 && this.width <= u && this.height <= d) {
            if (p) return [{ key: null, x1: e, y1: r, x2: u, y2: d }];
            for (let P = 0; P < this.boxKeys.length; P++) C.push({ key: this.boxKeys[P], x1: this.bboxes[4 * P], y1: this.bboxes[4 * P + 1], x2: this.bboxes[4 * P + 2], y2: this.bboxes[4 * P + 3] });
            for (let P = 0; P < this.circleKeys.length; P++) {
              const F = this.circles[3 * P], N = this.circles[3 * P + 1], Z = this.circles[3 * P + 2];
              C.push({ key: this.circleKeys[P], x1: F - Z, y1: N - Z, x2: F + Z, y2: N + Z });
            }
          } else this._forEachCell(e, r, u, d, this._queryCell, C, { hitTest: p, overlapMode: w, seenUids: { box: {}, circle: {} } }, A);
          return C;
        }
        query(e, r, u, d) {
          return this._query(e, r, u, d, !1, null);
        }
        hitTest(e, r, u, d, p, w) {
          return this._query(e, r, u, d, !0, p, w).length > 0;
        }
        hitTestCircle(e, r, u, d, p) {
          const w = e - u, A = e + u, C = r - u, P = r + u;
          if (A < 0 || w > this.width || P < 0 || C > this.height) return !1;
          const F = [];
          return this._forEachCell(w, C, A, P, this._queryCellCircle, F, { hitTest: !0, overlapMode: d, circle: { x: e, y: r, radius: u }, seenUids: { box: {}, circle: {} } }, p), F.length > 0;
        }
        _queryCell(e, r, u, d, p, w, A, C) {
          const { seenUids: P, hitTest: F, overlapMode: N } = A, Z = this.boxCells[p];
          if (Z !== null) {
            const V = this.bboxes;
            for (const W of Z) if (!P.box[W]) {
              P.box[W] = !0;
              const se = 4 * W, le = this.boxKeys[W];
              if (e <= V[se + 2] && r <= V[se + 3] && u >= V[se + 0] && d >= V[se + 1] && (!C || C(le)) && (!F || !cr(N, le.overlapMode)) && (w.push({ key: le, x1: V[se], y1: V[se + 1], x2: V[se + 2], y2: V[se + 3] }), F)) return !0;
            }
          }
          const G = this.circleCells[p];
          if (G !== null) {
            const V = this.circles;
            for (const W of G) if (!P.circle[W]) {
              P.circle[W] = !0;
              const se = 3 * W, le = this.circleKeys[W];
              if (this._circleAndRectCollide(V[se], V[se + 1], V[se + 2], e, r, u, d) && (!C || C(le)) && (!F || !cr(N, le.overlapMode))) {
                const de = V[se], ce = V[se + 1], we = V[se + 2];
                if (w.push({ key: le, x1: de - we, y1: ce - we, x2: de + we, y2: ce + we }), F) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(e, r, u, d, p, w, A, C) {
          const { circle: P, seenUids: F, overlapMode: N } = A, Z = this.boxCells[p];
          if (Z !== null) {
            const V = this.bboxes;
            for (const W of Z) if (!F.box[W]) {
              F.box[W] = !0;
              const se = 4 * W, le = this.boxKeys[W];
              if (this._circleAndRectCollide(P.x, P.y, P.radius, V[se + 0], V[se + 1], V[se + 2], V[se + 3]) && (!C || C(le)) && !cr(N, le.overlapMode)) return w.push(!0), !0;
            }
          }
          const G = this.circleCells[p];
          if (G !== null) {
            const V = this.circles;
            for (const W of G) if (!F.circle[W]) {
              F.circle[W] = !0;
              const se = 3 * W, le = this.circleKeys[W];
              if (this._circlesCollide(V[se], V[se + 1], V[se + 2], P.x, P.y, P.radius) && (!C || C(le)) && !cr(N, le.overlapMode)) return w.push(!0), !0;
            }
          }
        }
        _forEachCell(e, r, u, d, p, w, A, C) {
          const P = this._convertToXCellCoord(e), F = this._convertToYCellCoord(r), N = this._convertToXCellCoord(u), Z = this._convertToYCellCoord(d);
          for (let G = P; G <= N; G++) for (let V = F; V <= Z; V++) if (p.call(this, e, r, u, d, this.xCellCount * V + G, w, A, C)) return;
        }
        _convertToXCellCoord(e) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
        }
        _convertToYCellCoord(e) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
        }
        _circlesCollide(e, r, u, d, p, w) {
          const A = d - e, C = p - r, P = u + w;
          return P * P > A * A + C * C;
        }
        _circleAndRectCollide(e, r, u, d, p, w, A) {
          const C = (w - d) / 2, P = Math.abs(e - (d + C));
          if (P > C + u) return !1;
          const F = (A - p) / 2, N = Math.abs(r - (p + F));
          if (N > F + u) return !1;
          if (P <= C || N <= F) return !0;
          const Z = P - C, G = N - F;
          return Z * Z + G * G <= u * u;
        }
      }
      function ie(h, e, r, u, d) {
        const p = o.H();
        return e ? (o.K(p, p, [1 / d, 1 / d, 1]), r || o.ad(p, p, u.angle)) : o.L(p, u.labelPlaneMatrix, h), p;
      }
      function ue(h, e, r, u, d) {
        if (e) {
          const p = o.ae(h);
          return o.K(p, p, [d, d, 1]), r || o.ad(p, p, -u.angle), p;
        }
        return u.glCoordMatrix;
      }
      function $(h, e, r, u) {
        let d;
        u ? (d = [h, e, u(h, e), 1], o.af(d, d, r)) : (d = [h, e, 0, 1], Qt(d, d, r));
        const p = d[3];
        return { point: new o.P(d[0] / p, d[1] / p), signedDistanceFromCamera: p, isOccluded: !1 };
      }
      function B(h, e) {
        return 0.5 + h / e * 0.5;
      }
      function q(h, e) {
        return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1];
      }
      function te(h, e, r, u, d, p, w, A, C, P, F, N, Z, G, V) {
        const W = u ? h.textSizeData : h.iconSizeData, se = o.ag(W, r.transform.zoom), le = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], de = u ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
        de.clear();
        const ce = h.lineVertexArray, we = u ? h.text.placedSymbolArray : h.icon.placedSymbolArray, Le = r.transform.width / r.transform.height;
        let Ie = !1;
        for (let it = 0; it < we.length; it++) {
          const ht = we.get(it);
          if (ht.hidden || ht.writingMode === o.ah.vertical && !Ie) {
            $t(ht.numGlyphs, de);
            continue;
          }
          Ie = !1;
          const _t = $(ht.anchorX, ht.anchorY, e, V);
          if (!q(_t.point, le)) {
            $t(ht.numGlyphs, de);
            continue;
          }
          const wt = B(r.transform.cameraToCenterDistance, _t.signedDistanceFromCamera), bt = o.ai(W, se, ht), yt = w ? bt / wt : bt * wt, St = { getElevation: V, labelPlaneMatrix: d, lineVertexArray: ce, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: P, tileAnchorPoint: new o.P(ht.anchorX, ht.anchorY), unwrappedTileID: F, width: N, height: Z, translation: G }, Zt = Fe(St, ht, yt, !1, A, e, p, h.glyphOffsetArray, de, Le, C);
          Ie = Zt.useVertical, (Zt.notEnoughRoom || Ie || Zt.needsFlipping && Fe(St, ht, yt, !0, A, e, p, h.glyphOffsetArray, de, Le, C).notEnoughRoom) && $t(ht.numGlyphs, de);
        }
        u ? h.text.dynamicLayoutVertexBuffer.updateData(de) : h.icon.dynamicLayoutVertexBuffer.updateData(de);
      }
      function ge(h, e, r, u, d, p, w, A) {
        const C = p.glyphStartIndex + p.numGlyphs, P = p.lineStartIndex, F = p.lineStartIndex + p.lineLength, N = e.getoffsetX(p.glyphStartIndex), Z = e.getoffsetX(C - 1), G = gt(h * N, r, u, d, p.segment, P, F, A, w);
        if (!G) return null;
        const V = gt(h * Z, r, u, d, p.segment, P, F, A, w);
        return V ? A.projectionCache.anyProjectionOccluded ? null : { first: G, last: V } : null;
      }
      function Me(h, e, r, u) {
        return h === o.ah.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * u ? { useVertical: !0 } : (h === o.ah.vertical ? e.y < r.y : e.x > r.x) ? { needsFlipping: !0 } : null;
      }
      function Fe(h, e, r, u, d, p, w, A, C, P, F) {
        const N = r / 24, Z = e.lineOffsetX * N, G = e.lineOffsetY * N;
        let V;
        if (e.numGlyphs > 1) {
          const W = e.glyphStartIndex + e.numGlyphs, se = e.lineStartIndex, le = e.lineStartIndex + e.lineLength, de = ge(N, A, Z, G, u, e, F, h);
          if (!de) return { notEnoughRoom: !0 };
          const ce = $(de.first.point.x, de.first.point.y, w, h.getElevation).point, we = $(de.last.point.x, de.last.point.y, w, h.getElevation).point;
          if (d && !u) {
            const Le = Me(e.writingMode, ce, we, P);
            if (Le) return Le;
          }
          V = [de.first];
          for (let Le = e.glyphStartIndex + 1; Le < W - 1; Le++) V.push(gt(N * A.getoffsetX(Le), Z, G, u, e.segment, se, le, h, F));
          V.push(de.last);
        } else {
          if (d && !u) {
            const se = $(h.tileAnchorPoint.x, h.tileAnchorPoint.y, p, h.getElevation).point, le = e.lineStartIndex + e.segment + 1, de = new o.P(h.lineVertexArray.getx(le), h.lineVertexArray.gety(le)), ce = $(de.x, de.y, p, h.getElevation), we = ce.signedDistanceFromCamera > 0 ? ce.point : function(Ie, it, ht, _t, wt, bt) {
              return Ne(Ie, it, ht, 1, wt, bt);
            }(h.tileAnchorPoint, de, se, 0, p, h), Le = Me(e.writingMode, se, we, P);
            if (Le) return Le;
          }
          const W = gt(N * A.getoffsetX(e.glyphStartIndex), Z, G, u, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, h, F);
          if (!W || h.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          V = [W];
        }
        for (const W of V) o.aj(C, W.point, W.angle);
        return {};
      }
      function Ne(h, e, r, u, d, p) {
        const w = h.add(h.sub(e)._unit()), A = d !== void 0 ? $(w.x, w.y, d, p.getElevation).point : tt(w.x, w.y, p).point, C = r.sub(A);
        return r.add(C._mult(u / C.mag()));
      }
      function De(h, e, r) {
        const u = e.projectionCache;
        if (u.projections[h]) return u.projections[h];
        const d = new o.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)), p = tt(d.x, d.y, e);
        if (p.signedDistanceFromCamera > 0) return u.projections[h] = p.point, u.anyProjectionOccluded = u.anyProjectionOccluded || p.isOccluded, p.point;
        const w = h - r.direction;
        return function(A, C, P, F, N) {
          return Ne(A, C, P, F, void 0, N);
        }(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(w), e.lineVertexArray.gety(w)), d, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e);
      }
      function tt(h, e, r) {
        const u = h + r.translation[0], d = e + r.translation[1];
        let p;
        return !r.pitchWithMap && r.projection.useSpecialProjectionForSymbols ? (p = r.projection.projectTileCoordinates(u, d, r.unwrappedTileID, r.getElevation), p.point.x = (0.5 * p.point.x + 0.5) * r.width, p.point.y = (0.5 * -p.point.y + 0.5) * r.height) : (p = $(u, d, r.labelPlaneMatrix, r.getElevation), p.isOccluded = !1), p;
      }
      function ut(h, e, r) {
        return h._unit()._perp()._mult(e * r);
      }
      function We(h, e, r, u, d, p, w, A, C) {
        if (A.projectionCache.offsets[h]) return A.projectionCache.offsets[h];
        const P = r.add(e);
        if (h + C.direction < u || h + C.direction >= d) return A.projectionCache.offsets[h] = P, P;
        const F = De(h + C.direction, A, C), N = ut(F.sub(r), w, C.direction), Z = r.add(N), G = F.add(N);
        return A.projectionCache.offsets[h] = o.ak(p, P, Z, G) || P, A.projectionCache.offsets[h];
      }
      function gt(h, e, r, u, d, p, w, A, C) {
        const P = u ? h - e : h + e;
        let F = P > 0 ? 1 : -1, N = 0;
        u && (F *= -1, N = Math.PI), F < 0 && (N += Math.PI);
        let Z, G = F > 0 ? p + d : p + d + 1;
        A.projectionCache.cachedAnchorPoint ? Z = A.projectionCache.cachedAnchorPoint : (Z = tt(A.tileAnchorPoint.x, A.tileAnchorPoint.y, A).point, A.projectionCache.cachedAnchorPoint = Z);
        let V, W, se = Z, le = Z, de = 0, ce = 0;
        const we = Math.abs(P), Le = [];
        let Ie;
        for (; de + ce <= we; ) {
          if (G += F, G < p || G >= w) return null;
          de += ce, le = se, W = V;
          const _t = { absOffsetX: we, direction: F, distanceFromAnchor: de, previousVertex: le };
          if (se = De(G, A, _t), r === 0) Le.push(le), Ie = se.sub(le);
          else {
            let wt;
            const bt = se.sub(le);
            wt = bt.mag() === 0 ? ut(De(G + F, A, _t).sub(se), r, F) : ut(bt, r, F), W || (W = le.add(wt)), V = We(G, wt, se, p, w, W, r, A, _t), Le.push(W), Ie = V.sub(W);
          }
          ce = Ie.mag();
        }
        const it = Ie._mult((we - de) / ce)._add(W || le), ht = N + Math.atan2(se.y - le.y, se.x - le.x);
        return Le.push(it), { point: it, angle: C ? ht : 0, path: Le };
      }
      const Mt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function $t(h, e) {
        for (let r = 0; r < h; r++) {
          const u = e.length;
          e.resize(u + 4), e.float32.set(Mt, 3 * u);
        }
      }
      function Qt(h, e, r) {
        const u = e[0], d = e[1];
        return h[0] = r[0] * u + r[4] * d + r[12], h[1] = r[1] * u + r[5] * d + r[13], h[3] = r[3] * u + r[7] * d + r[15], h;
      }
      const ei = 100;
      class pi {
        constructor(e, r, u = new Ni(e.width + 200, e.height + 200, 25), d = new Ni(e.width + 200, e.height + 200, 25)) {
          this.transform = e, this.mapProjection = r, this.grid = u, this.ignoredGrid = d, this.pitchFactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + ei, this.screenBottomBoundary = e.height + ei, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(e, r, u, d, p, w, A, C, P, F, N) {
          const Z = e.anchorPointX + C[0], G = e.anchorPointY + C[1], V = this.projectAndGetPerspectiveRatio(d, Z, G, p, F), W = u * V.perspectiveRatio;
          let se;
          if (w || A) se = this._projectCollisionBox(e, W, d, p, w, A, C, V, F, N);
          else {
            const Le = V.point.x + (N ? N.x * W : 0), Ie = V.point.y + (N ? N.y * W : 0);
            se = { allPointsOccluded: !1, box: [Le + e.x1 * W, Ie + e.y1 * W, Le + e.x2 * W, Ie + e.y2 * W] };
          }
          const [le, de, ce, we] = se.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (w ? se.allPointsOccluded : this.mapProjection.isOccluded(Z, G, p)) || V.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(le, de, ce, we) || r !== "always" && this.grid.hitTest(le, de, ce, we, r, P) ? { box: [le, de, ce, we], placeable: !1, offscreen: !1 } : { box: [le, de, ce, we], placeable: !0, offscreen: this.isOffscreen(le, de, ce, we) };
        }
        placeCollisionCircles(e, r, u, d, p, w, A, C, P, F, N, Z, G, V, W, se) {
          const le = [], de = new o.P(r.anchorX, r.anchorY), ce = this.getPerspectiveRatio(w, de.x, de.y, A, se), we = (N ? p / ce : p * ce) / o.ap, Le = { getElevation: se, labelPlaneMatrix: C, lineVertexArray: u, pitchWithMap: N, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: de, unwrappedTileID: A, width: this.transform.width, height: this.transform.height, translation: W }, Ie = ge(we, d, r.lineOffsetX * we, r.lineOffsetY * we, !1, r, !1, Le);
          let it = !1, ht = !1, _t = !0;
          if (Ie) {
            const wt = 0.5 * G * ce + V, bt = new o.P(-100, -100), yt = new o.P(this.screenRightBoundary, this.screenBottomBoundary), St = new zt(), Zt = Ie.first, Tt = Ie.last;
            let kt = [];
            for (let ci = Zt.path.length - 1; ci >= 1; ci--) kt.push(Zt.path[ci]);
            for (let ci = 1; ci < Tt.path.length; ci++) kt.push(Tt.path[ci]);
            const Wt = 2.5 * wt;
            if (P) {
              const ci = this.projectPathToScreenSpace(kt, Le, P);
              kt = ci.some((gi) => gi.signedDistanceFromCamera <= 0) ? [] : ci.map((gi) => gi.point);
            }
            let di = [];
            if (kt.length > 0) {
              const ci = kt[0].clone(), gi = kt[0].clone();
              for (let Ei = 1; Ei < kt.length; Ei++) ci.x = Math.min(ci.x, kt[Ei].x), ci.y = Math.min(ci.y, kt[Ei].y), gi.x = Math.max(gi.x, kt[Ei].x), gi.y = Math.max(gi.y, kt[Ei].y);
              di = ci.x >= bt.x && gi.x <= yt.x && ci.y >= bt.y && gi.y <= yt.y ? [kt] : gi.x < bt.x || ci.x > yt.x || gi.y < bt.y || ci.y > yt.y ? [] : o.al([kt], bt.x, bt.y, yt.x, yt.y);
            }
            for (const ci of di) {
              St.reset(ci, 0.25 * wt);
              let gi = 0;
              gi = St.length <= 0.5 * wt ? 1 : Math.ceil(St.paddedLength / Wt) + 1;
              for (let Ei = 0; Ei < gi; Ei++) {
                const qi = Ei / Math.max(gi - 1, 1), sr = St.lerp(qi), Fi = sr.x + ei, yr = sr.y + ei;
                le.push(Fi, yr, wt, 0);
                const Ui = Fi - wt, pr = yr - wt, kr = Fi + wt, pn = yr + wt;
                if (_t = _t && this.isOffscreen(Ui, pr, kr, pn), ht = ht || this.isInsideGrid(Ui, pr, kr, pn), e !== "always" && this.grid.hitTestCircle(Fi, yr, wt, e, Z) && (it = !0, !F)) return { circles: [], offscreen: !1, collisionDetected: it };
              }
            }
          }
          return { circles: !F && it || !ht || ce < this.perspectiveRatioCutoff ? [] : le, offscreen: _t, collisionDetected: it };
        }
        projectPathToScreenSpace(e, r, u) {
          return e.map((d) => $(d.x, d.y, u, r.getElevation));
        }
        queryRenderedSymbols(e) {
          if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const r = [];
          let u = 1 / 0, d = 1 / 0, p = -1 / 0, w = -1 / 0;
          for (const F of e) {
            const N = new o.P(F.x + ei, F.y + ei);
            u = Math.min(u, N.x), d = Math.min(d, N.y), p = Math.max(p, N.x), w = Math.max(w, N.y), r.push(N);
          }
          const A = this.grid.query(u, d, p, w).concat(this.ignoredGrid.query(u, d, p, w)), C = {}, P = {};
          for (const F of A) {
            const N = F.key;
            if (C[N.bucketInstanceId] === void 0 && (C[N.bucketInstanceId] = {}), C[N.bucketInstanceId][N.featureIndex]) continue;
            const Z = [new o.P(F.x1, F.y1), new o.P(F.x2, F.y1), new o.P(F.x2, F.y2), new o.P(F.x1, F.y2)];
            o.am(r, Z) && (C[N.bucketInstanceId][N.featureIndex] = !0, P[N.bucketInstanceId] === void 0 && (P[N.bucketInstanceId] = []), P[N.bucketInstanceId].push(N.featureIndex));
          }
          return P;
        }
        insertCollisionBox(e, r, u, d, p, w) {
          (u ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: d, featureIndex: p, collisionGroupID: w, overlapMode: r }, e[0], e[1], e[2], e[3]);
        }
        insertCollisionCircles(e, r, u, d, p, w) {
          const A = u ? this.ignoredGrid : this.grid, C = { bucketInstanceId: d, featureIndex: p, collisionGroupID: w, overlapMode: r };
          for (let P = 0; P < e.length; P += 4) A.insertCircle(C, e[P], e[P + 1], e[P + 2]);
        }
        projectAndGetPerspectiveRatio(e, r, u, d, p) {
          let w;
          p ? (w = [r, u, p(r, u), 1], o.af(w, w, e)) : (w = [r, u, 0, 1], Qt(w, w, e));
          const A = w[3];
          return { point: new o.P((w[0] / A + 1) / 2 * this.transform.width + ei, (-w[1] / A + 1) / 2 * this.transform.height + ei), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / A * 0.5, isOccluded: !1, signedDistanceFromCamera: A };
        }
        getPerspectiveRatio(e, r, u, d, p) {
          const w = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(r, u, d, p) : $(r, u, e, p);
          return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(e, r, u, d) {
          return u < ei || e >= this.screenRightBoundary || d < ei || r > this.screenBottomBoundary;
        }
        isInsideGrid(e, r, u, d) {
          return u >= 0 && e < this.gridRightBoundary && d >= 0 && r < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e = o.an([]);
          return o.J(e, e, [-100, -100, 0]), e;
        }
        _projectCollisionBox(e, r, u, d, p, w, A, C, P, F) {
          let N = new o.P(1, 0), Z = new o.P(0, 1);
          const G = new o.P(e.anchorPointX + A[0], e.anchorPointY + A[1]);
          if (w && !p) {
            const _t = this.projectAndGetPerspectiveRatio(u, G.x + 1, G.y, d, P).point.sub(C.point).unit(), wt = Math.atan(_t.y / _t.x) + (_t.x < 0 ? Math.PI : 0), bt = Math.sin(wt), yt = Math.cos(wt);
            N = new o.P(yt, bt), Z = new o.P(-bt, yt);
          } else if (!w && p) {
            const _t = -this.transform.angle, wt = Math.sin(_t), bt = Math.cos(_t);
            N = new o.P(bt, wt), Z = new o.P(-wt, bt);
          }
          let V = C.point, W = r;
          if (p) {
            V = G;
            const _t = this.transform.zoom - Math.floor(this.transform.zoom);
            W = Math.pow(2, -_t), W *= this.mapProjection.getPitchedTextCorrection(this.transform, G, d), F || (W *= o.ac(0.5 + C.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          F && (V = V.add(N.mult(F.x * W)).add(Z.mult(F.y * W)));
          const se = e.x1 * W, le = e.x2 * W, de = (se + le) / 2, ce = e.y1 * W, we = e.y2 * W, Le = (ce + we) / 2, Ie = [{ offsetX: se, offsetY: ce }, { offsetX: de, offsetY: ce }, { offsetX: le, offsetY: ce }, { offsetX: le, offsetY: Le }, { offsetX: le, offsetY: we }, { offsetX: de, offsetY: we }, { offsetX: se, offsetY: we }, { offsetX: se, offsetY: Le }];
          let it = [];
          for (const { offsetX: _t, offsetY: wt } of Ie) it.push(new o.P(V.x + N.x * _t + Z.x * wt, V.y + N.y * _t + Z.y * wt));
          let ht = !1;
          if (p) {
            const _t = it.map((wt) => this.projectAndGetPerspectiveRatio(u, wt.x, wt.y, d, P));
            ht = _t.some((wt) => !wt.isOccluded), it = _t.map((wt) => wt.point);
          } else ht = !0;
          return { box: o.ao(it), allPointsOccluded: !ht };
        }
      }
      function fi(h, e, r) {
        return e * (o.X / (h.tileSize * Math.pow(2, r - h.tileID.overscaledZ)));
      }
      class Wi {
        constructor(e, r, u, d) {
          this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : d && u ? 1 : 0, this.placed = u;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Oi {
        constructor(e, r, u, d, p) {
          this.text = new Wi(e ? e.text : null, r, u, p), this.icon = new Wi(e ? e.icon : null, r, d, p);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class mi {
        constructor(e, r, u) {
          this.text = e, this.icon = r, this.skipFade = u;
        }
      }
      class Bi {
        constructor() {
          this.invProjMatrix = o.H(), this.viewportMatrix = o.H(), this.circles = [];
        }
      }
      class Hi {
        constructor(e, r, u, d, p) {
          this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = u, this.bucketIndex = d, this.tileID = p;
        }
      }
      class gr {
        constructor(e) {
          this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[e]) {
            const r = ++this.maxGroupID;
            this.collisionGroups[e] = { ID: r, predicate: (u) => u.collisionGroupID === r };
          }
          return this.collisionGroups[e];
        }
      }
      function br(h, e, r, u, d) {
        const { horizontalAlign: p, verticalAlign: w } = o.au(h);
        return new o.P(-(p - 0.5) * e + u[0] * d, -(w - 0.5) * r + u[1] * d);
      }
      class Pr {
        constructor(e, r, u, d, p, w) {
          this.transform = e.clone(), this.terrain = u, this.collisionIndex = new pi(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = d, this.retainedQueryData = {}, this.collisionGroups = new gr(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(e) {
          const r = this.terrain;
          return r ? (u, d) => r.getElevation(e, u, d) : null;
        }
        getBucketParts(e, r, u, d) {
          const p = u.getBucket(r), w = u.latestFeatureIndex;
          if (!p || !w || r.id !== p.layerIds[0]) return;
          const A = u.collisionBoxArray, C = p.layers[0].layout, P = p.layers[0].paint, F = Math.pow(2, this.transform.zoom - u.tileID.overscaledZ), N = u.tileSize / o.X, Z = u.tileID.toUnwrapped(), G = this.transform.calculatePosMatrix(Z), V = C.get("text-pitch-alignment") === "map", W = C.get("text-rotation-alignment") === "map", se = fi(u, 1, this.transform.zoom), le = this.collisionIndex.mapProjection.translatePosition(this.transform, u, P.get("text-translate"), P.get("text-translate-anchor")), de = this.collisionIndex.mapProjection.translatePosition(this.transform, u, P.get("icon-translate"), P.get("icon-translate-anchor")), ce = ie(G, V, W, this.transform, se);
          let we = null;
          if (V) {
            const Ie = ue(G, V, W, this.transform, se);
            we = o.L([], this.transform.labelPlaneMatrix, Ie);
          }
          this.retainedQueryData[p.bucketInstanceId] = new Hi(p.bucketInstanceId, w, p.sourceLayerIndex, p.index, u.tileID);
          const Le = { bucket: p, layout: C, translationText: le, translationIcon: de, posMatrix: G, unwrappedTileID: Z, textLabelPlaneMatrix: ce, labelToScreenMatrix: we, scale: F, textPixelRatio: N, holdingForFade: u.holdingForFade(), collisionBoxArray: A, partiallyEvaluatedTextSize: o.ag(p.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(p.sourceID) };
          if (d) for (const Ie of p.sortKeyRanges) {
            const { sortKey: it, symbolInstanceStart: ht, symbolInstanceEnd: _t } = Ie;
            e.push({ sortKey: it, symbolInstanceStart: ht, symbolInstanceEnd: _t, parameters: Le });
          }
          else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: p.symbolInstances.length, parameters: Le });
        }
        attemptAnchorPlacement(e, r, u, d, p, w, A, C, P, F, N, Z, G, V, W, se, le, de, ce) {
          const we = o.aq[e.textAnchor], Le = [e.textOffset0, e.textOffset1], Ie = br(we, u, d, Le, p), it = this.collisionIndex.placeCollisionBox(r, Z, C, P, F, A, w, se, N.predicate, ce, Ie);
          if ((!de || this.collisionIndex.placeCollisionBox(de, Z, C, P, F, A, w, le, N.predicate, ce, Ie).placeable) && it.placeable) {
            let ht;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[G.crossTileID] && this.prevPlacement.placements[G.crossTileID] && this.prevPlacement.placements[G.crossTileID].text && (ht = this.prevPlacement.variableOffsets[G.crossTileID].anchor), G.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[G.crossTileID] = { textOffset: Le, width: u, height: d, anchor: we, textBoxScale: p, prevAnchor: ht }, this.markUsedJustification(V, we, G, W), V.allowVerticalPlacement && (this.markUsedOrientation(V, W, G), this.placedOrientations[G.crossTileID] = W), { shift: Ie, placedGlyphBoxes: it };
          }
        }
        placeLayerBucketPart(e, r, u) {
          const { bucket: d, layout: p, translationText: w, translationIcon: A, posMatrix: C, unwrappedTileID: P, textLabelPlaneMatrix: F, labelToScreenMatrix: N, textPixelRatio: Z, holdingForFade: G, collisionBoxArray: V, partiallyEvaluatedTextSize: W, collisionGroup: se } = e.parameters, le = p.get("text-optional"), de = p.get("icon-optional"), ce = o.ar(p, "text-overlap", "text-allow-overlap"), we = ce === "always", Le = o.ar(p, "icon-overlap", "icon-allow-overlap"), Ie = Le === "always", it = p.get("text-rotation-alignment") === "map", ht = p.get("text-pitch-alignment") === "map", _t = p.get("icon-text-fit") !== "none", wt = p.get("symbol-z-order") === "viewport-y", bt = we && (Ie || !d.hasIconData() || de), yt = Ie && (we || !d.hasTextData() || le);
          !d.collisionArrays && V && d.deserializeCollisionBoxes(V);
          const St = this._getTerrainElevationFunc(this.retainedQueryData[d.bucketInstanceId].tileID), Zt = (Tt, kt, Wt) => {
            var di, ci;
            if (r[Tt.crossTileID]) return;
            if (G) return void (this.placements[Tt.crossTileID] = new mi(!1, !1, !1));
            let gi = !1, Ei = !1, qi = !0, sr = null, Fi = { box: null, placeable: !1, offscreen: null }, yr = { box: null, placeable: !1, offscreen: null }, Ui = null, pr = null, kr = null, pn = 0, Mn = 0, ar = 0;
            kt.textFeatureIndex ? pn = kt.textFeatureIndex : Tt.useRuntimeCollisionCircles && (pn = Tt.featureIndex), kt.verticalTextFeatureIndex && (Mn = kt.verticalTextFeatureIndex);
            const Ea = kt.textBox;
            if (Ea) {
              const en = (Ar) => {
                let Vr = o.ah.horizontal;
                if (d.allowVerticalPlacement && !Ar && this.prevPlacement) {
                  const rn = this.prevPlacement.placedOrientations[Tt.crossTileID];
                  rn && (this.placedOrientations[Tt.crossTileID] = rn, Vr = rn, this.markUsedOrientation(d, Vr, Tt));
                }
                return Vr;
              }, fn = (Ar, Vr) => {
                if (d.allowVerticalPlacement && Tt.numVerticalGlyphVertices > 0 && kt.verticalTextBox) {
                  for (const rn of d.writingModes) if (rn === o.ah.vertical ? (Fi = Vr(), yr = Fi) : Fi = Ar(), Fi && Fi.placeable) break;
                } else Fi = Ar();
              }, Rr = Tt.textAnchorOffsetStartIndex, tn = Tt.textAnchorOffsetEndIndex;
              if (tn === Rr) {
                const Ar = (Vr, rn) => {
                  const Li = this.collisionIndex.placeCollisionBox(Vr, ce, Z, C, P, ht, it, w, se.predicate, St);
                  return Li && Li.placeable && (this.markUsedOrientation(d, rn, Tt), this.placedOrientations[Tt.crossTileID] = rn), Li;
                };
                fn(() => Ar(Ea, o.ah.horizontal), () => {
                  const Vr = kt.verticalTextBox;
                  return d.allowVerticalPlacement && Tt.numVerticalGlyphVertices > 0 && Vr ? Ar(Vr, o.ah.vertical) : { box: null, offscreen: null };
                }), en(Fi && Fi.placeable);
              } else {
                let Ar = o.aq[(ci = (di = this.prevPlacement) === null || di === void 0 ? void 0 : di.variableOffsets[Tt.crossTileID]) === null || ci === void 0 ? void 0 : ci.anchor];
                const Vr = (Li, zs, Ca) => {
                  const ea = Li.x2 - Li.x1, Lo = Li.y2 - Li.y1, Pc = Tt.textBoxScale, Gu = _t && Le === "never" ? zs : null;
                  let Fs = null, ta = ce === "never" ? 1 : 2, ql = "never";
                  Ar && ta++;
                  for (let _l = 0; _l < ta; _l++) {
                    for (let Ul = Rr; Ul < tn; Ul++) {
                      const yl = d.textAnchorOffsets.get(Ul);
                      if (Ar && yl.textAnchor !== Ar) continue;
                      const ia = this.attemptAnchorPlacement(yl, Li, ea, Lo, Pc, it, ht, Z, C, P, se, ql, Tt, d, Ca, w, A, Gu, St);
                      if (ia && (Fs = ia.placedGlyphBoxes, Fs && Fs.placeable)) return gi = !0, sr = ia.shift, Fs;
                    }
                    Ar ? Ar = null : ql = ce;
                  }
                  return u && !Fs && (Fs = { box: this.collisionIndex.placeCollisionBox(Ea, "always", Z, C, P, ht, it, w, se.predicate, St, new o.P(0, 0)).box, offscreen: !1, placeable: !1 }), Fs;
                };
                fn(() => Vr(Ea, kt.iconBox, o.ah.horizontal), () => {
                  const Li = kt.verticalTextBox;
                  return d.allowVerticalPlacement && (!Fi || !Fi.placeable) && Tt.numVerticalGlyphVertices > 0 && Li ? Vr(Li, kt.verticalIconBox, o.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), Fi && (gi = Fi.placeable, qi = Fi.offscreen);
                const rn = en(Fi && Fi.placeable);
                if (!gi && this.prevPlacement) {
                  const Li = this.prevPlacement.variableOffsets[Tt.crossTileID];
                  Li && (this.variableOffsets[Tt.crossTileID] = Li, this.markUsedJustification(d, Li.anchor, Tt, rn));
                }
              }
            }
            if (Ui = Fi, gi = Ui && Ui.placeable, qi = Ui && Ui.offscreen, Tt.useRuntimeCollisionCircles) {
              const en = d.text.placedSymbolArray.get(Tt.centerJustifiedTextSymbolIndex), fn = o.ai(d.textSizeData, W, en), Rr = p.get("text-padding");
              pr = this.collisionIndex.placeCollisionCircles(ce, en, d.lineVertexArray, d.glyphOffsetArray, fn, C, P, F, N, u, ht, se.predicate, Tt.collisionCircleDiameter, Rr, w, St), pr.circles.length && pr.collisionDetected && !u && o.w("Collisions detected, but collision boxes are not shown"), gi = we || pr.circles.length > 0 && !pr.collisionDetected, qi = qi && pr.offscreen;
            }
            if (kt.iconFeatureIndex && (ar = kt.iconFeatureIndex), kt.iconBox) {
              const en = (fn) => this.collisionIndex.placeCollisionBox(fn, Le, Z, C, P, ht, it, A, se.predicate, St, _t && sr ? sr : void 0);
              yr && yr.placeable && kt.verticalIconBox ? (kr = en(kt.verticalIconBox), Ei = kr.placeable) : (kr = en(kt.iconBox), Ei = kr.placeable), qi = qi && kr.offscreen;
            }
            const Nn = le || Tt.numHorizontalGlyphVertices === 0 && Tt.numVerticalGlyphVertices === 0, gl = de || Tt.numIconVertices === 0;
            Nn || gl ? gl ? Nn || (Ei = Ei && gi) : gi = Ei && gi : Ei = gi = Ei && gi;
            const Po = Ei && kr.placeable;
            if (gi && Ui.placeable && this.collisionIndex.insertCollisionBox(Ui.box, ce, p.get("text-ignore-placement"), d.bucketInstanceId, yr && yr.placeable && Mn ? Mn : pn, se.ID), Po && this.collisionIndex.insertCollisionBox(kr.box, Le, p.get("icon-ignore-placement"), d.bucketInstanceId, ar, se.ID), pr && gi && this.collisionIndex.insertCollisionCircles(pr.circles, ce, p.get("text-ignore-placement"), d.bucketInstanceId, pn, se.ID), u && this.storeCollisionData(d.bucketInstanceId, Wt, kt, Ui, kr, pr), Tt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (d.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Tt.crossTileID] = new mi(gi || bt, Ei || yt, qi || d.justReloaded), r[Tt.crossTileID] = !0;
          };
          if (wt) {
            if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Tt = d.getSortedSymbolIndexes(this.transform.angle);
            for (let kt = Tt.length - 1; kt >= 0; --kt) {
              const Wt = Tt[kt];
              Zt(d.symbolInstances.get(Wt), d.collisionArrays[Wt], Wt);
            }
          } else for (let Tt = e.symbolInstanceStart; Tt < e.symbolInstanceEnd; Tt++) Zt(d.symbolInstances.get(Tt), d.collisionArrays[Tt], Tt);
          if (u && d.bucketInstanceId in this.collisionCircleArrays) {
            const Tt = this.collisionCircleArrays[d.bucketInstanceId];
            o.as(Tt.invProjMatrix, C), Tt.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          d.justReloaded = !1;
        }
        storeCollisionData(e, r, u, d, p, w) {
          if (u.textBox || u.iconBox) {
            let A, C;
            this.collisionBoxArrays.has(e) ? A = this.collisionBoxArrays.get(e) : (A = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, A)), A.has(r) ? C = A.get(r) : (C = { text: null, icon: null }, A.set(r, C)), u.textBox && (C.text = d.box), u.iconBox && (C.icon = p.box);
          }
          if (w) {
            let A = this.collisionCircleArrays[e];
            A === void 0 && (A = this.collisionCircleArrays[e] = new Bi());
            for (let C = 0; C < w.circles.length; C += 4) A.circles.push(w.circles[C + 0]), A.circles.push(w.circles[C + 1]), A.circles.push(w.circles[C + 2]), A.circles.push(w.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(e, r, u, d) {
          let p;
          p = d === o.ah.vertical ? u.verticalPlacedTextSymbolIndex : { left: u.leftJustifiedTextSymbolIndex, center: u.centerJustifiedTextSymbolIndex, right: u.rightJustifiedTextSymbolIndex }[o.at(r)];
          const w = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex, u.verticalPlacedTextSymbolIndex];
          for (const A of w) A >= 0 && (e.text.placedSymbolArray.get(A).crossTileID = p >= 0 && A !== p ? 0 : u.crossTileID);
        }
        markUsedOrientation(e, r, u) {
          const d = r === o.ah.horizontal || r === o.ah.horizontalOnly ? r : 0, p = r === o.ah.vertical ? r : 0, w = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex];
          for (const A of w) e.text.placedSymbolArray.get(A).placedOrientation = d;
          u.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(u.verticalPlacedTextSymbolIndex).placedOrientation = p);
        }
        commit(e) {
          this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const r = this.prevPlacement;
          let u = !1;
          this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
          const d = r ? r.symbolFadeChange(e) : 1, p = r ? r.opacities : {}, w = r ? r.variableOffsets : {}, A = r ? r.placedOrientations : {};
          for (const C in this.placements) {
            const P = this.placements[C], F = p[C];
            F ? (this.opacities[C] = new Oi(F, d, P.text, P.icon), u = u || P.text !== F.text.placed || P.icon !== F.icon.placed) : (this.opacities[C] = new Oi(null, d, P.text, P.icon, P.skipFade), u = u || P.text || P.icon);
          }
          for (const C in p) {
            const P = p[C];
            if (!this.opacities[C]) {
              const F = new Oi(P, d, !1, !1);
              F.isHidden() || (this.opacities[C] = F, u = u || P.text.placed || P.icon.placed);
            }
          }
          for (const C in w) this.variableOffsets[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.variableOffsets[C] = w[C]);
          for (const C in A) this.placedOrientations[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.placedOrientations[C] = A[C]);
          if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          u ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e);
        }
        updateLayerOpacities(e, r) {
          const u = {};
          for (const d of r) {
            const p = d.getBucket(e);
            p && d.latestFeatureIndex && e.id === p.layerIds[0] && this.updateBucketOpacities(p, d.tileID, u, d.collisionBoxArray);
          }
        }
        updateBucketOpacities(e, r, u, d) {
          e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
          const p = e.layers[0], w = p.layout, A = new Oi(null, 0, !1, !1, !0), C = w.get("text-allow-overlap"), P = w.get("icon-allow-overlap"), F = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"), N = w.get("text-rotation-alignment") === "map", Z = w.get("text-pitch-alignment") === "map", G = w.get("icon-text-fit") !== "none", V = new Oi(null, 0, C && (P || !e.hasIconData() || w.get("icon-optional")), P && (C || !e.hasTextData() || w.get("text-optional")), !0);
          !e.collisionArrays && d && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(d);
          const W = (le, de, ce) => {
            for (let we = 0; we < de / 4; we++) le.opacityVertexArray.emplaceBack(ce);
            le.hasVisibleVertices = le.hasVisibleVertices || ce !== ha;
          }, se = this.collisionBoxArrays.get(e.bucketInstanceId);
          for (let le = 0; le < e.symbolInstances.length; le++) {
            const de = e.symbolInstances.get(le), { numHorizontalGlyphVertices: ce, numVerticalGlyphVertices: we, crossTileID: Le } = de;
            let Ie = this.opacities[Le];
            u[Le] ? Ie = A : Ie || (Ie = V, this.opacities[Le] = Ie), u[Le] = !0;
            const it = de.numIconVertices > 0, ht = this.placedOrientations[de.crossTileID], _t = ht === o.ah.vertical, wt = ht === o.ah.horizontal || ht === o.ah.horizontalOnly;
            if (ce > 0 || we > 0) {
              const yt = Xr(Ie.text);
              W(e.text, ce, _t ? ha : yt), W(e.text, we, wt ? ha : yt);
              const St = Ie.text.isHidden();
              [de.rightJustifiedTextSymbolIndex, de.centerJustifiedTextSymbolIndex, de.leftJustifiedTextSymbolIndex].forEach((kt) => {
                kt >= 0 && (e.text.placedSymbolArray.get(kt).hidden = St || _t ? 1 : 0);
              }), de.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(de.verticalPlacedTextSymbolIndex).hidden = St || wt ? 1 : 0);
              const Zt = this.variableOffsets[de.crossTileID];
              Zt && this.markUsedJustification(e, Zt.anchor, de, ht);
              const Tt = this.placedOrientations[de.crossTileID];
              Tt && (this.markUsedJustification(e, "left", de, Tt), this.markUsedOrientation(e, Tt, de));
            }
            if (it) {
              const yt = Xr(Ie.icon), St = !(G && de.verticalPlacedIconSymbolIndex && _t);
              de.placedIconSymbolIndex >= 0 && (W(e.icon, de.numIconVertices, St ? yt : ha), e.icon.placedSymbolArray.get(de.placedIconSymbolIndex).hidden = Ie.icon.isHidden()), de.verticalPlacedIconSymbolIndex >= 0 && (W(e.icon, de.numVerticalIconVertices, St ? ha : yt), e.icon.placedSymbolArray.get(de.verticalPlacedIconSymbolIndex).hidden = Ie.icon.isHidden());
            }
            const bt = se && se.has(le) ? se.get(le) : { text: null, icon: null };
            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
              const yt = e.collisionArrays[le];
              if (yt) {
                let St = new o.P(0, 0);
                if (yt.textBox || yt.verticalTextBox) {
                  let Zt = !0;
                  if (F) {
                    const Tt = this.variableOffsets[Le];
                    Tt ? (St = br(Tt.anchor, Tt.width, Tt.height, Tt.textOffset, Tt.textBoxScale), N && St._rotate(Z ? this.transform.angle : -this.transform.angle)) : Zt = !1;
                  }
                  if (yt.textBox || yt.verticalTextBox) {
                    let Tt;
                    yt.textBox && (Tt = _t), yt.verticalTextBox && (Tt = wt), Vs(e.textCollisionBox.collisionVertexArray, Ie.text.placed, !Zt || Tt, bt.text, St.x, St.y);
                  }
                }
                if (yt.iconBox || yt.verticalIconBox) {
                  const Zt = !!(!wt && yt.verticalIconBox);
                  let Tt;
                  yt.iconBox && (Tt = Zt), yt.verticalIconBox && (Tt = !Zt), Vs(e.iconCollisionBox.collisionVertexArray, Ie.icon.placed, Tt, bt.icon, G ? St.x : 0, G ? St.y : 0);
                }
              }
            }
          }
          if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
          if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
          if (e.bucketInstanceId in this.collisionCircleArrays) {
            const le = this.collisionCircleArrays[e.bucketInstanceId];
            e.placementInvProjMatrix = le.invProjMatrix, e.placementViewportMatrix = le.viewportMatrix, e.collisionCircleArray = le.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
          }
        }
        symbolFadeChange(e) {
          return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e) {
          return Math.max(0, (this.transform.zoom - e) / 1.5);
        }
        hasTransitions(e) {
          return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e, r) {
          const u = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
          return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * u > e;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Vs(h, e, r, u, d, p) {
        u && u.length !== 0 || (u = [0, 0, 0, 0]);
        const w = u[0] - ei, A = u[1] - ei, C = u[2] - ei, P = u[3] - ei;
        h.emplaceBack(e ? 1 : 0, r ? 1 : 0, d || 0, p || 0, w, A), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, d || 0, p || 0, C, A), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, d || 0, p || 0, C, P), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, d || 0, p || 0, w, P);
      }
      const ji = Math.pow(2, 25), Yo = Math.pow(2, 24), ca = Math.pow(2, 17), Wr = Math.pow(2, 16), on = Math.pow(2, 9), Jo = Math.pow(2, 8), gn = Math.pow(2, 1);
      function Xr(h) {
        if (h.opacity === 0 && !h.placed) return 0;
        if (h.opacity === 1 && h.placed) return 4294967295;
        const e = h.placed ? 1 : 0, r = Math.floor(127 * h.opacity);
        return r * ji + e * Yo + r * ca + e * Wr + r * on + e * Jo + r * gn + e;
      }
      const ha = 0;
      function On() {
        return { isOccluded: (h, e, r) => !1, getPitchedTextCorrection: (h, e, r) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(h, e, r, u) {
          throw new Error("Not implemented.");
        }, translatePosition: (h, e, r, u) => function(d, p, w, A, C = !1) {
          if (!w[0] && !w[1]) return [0, 0];
          const P = C ? A === "map" ? d.angle : 0 : A === "viewport" ? -d.angle : 0;
          if (P) {
            const F = Math.sin(P), N = Math.cos(P);
            w = [w[0] * N - w[1] * F, w[0] * F + w[1] * N];
          }
          return [C ? w[0] : fi(p, w[0], d.zoom), C ? w[1] : fi(p, w[1], d.zoom)];
        }(h, e, r, u), getCircleRadiusCorrection: (h) => 1 };
      }
      class xr {
        constructor(e) {
          this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e, r, u, d, p) {
          const w = this._bucketParts;
          for (; this._currentTileIndex < e.length; ) if (r.getBucketParts(w, d, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort((A, C) => A.sortKey - C.sortKey)); this._currentPartIndex < w.length; ) if (r.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, u), this._currentPartIndex++, p()) return !0;
          return !1;
        }
      }
      class rr {
        constructor(e, r, u, d, p, w, A, C) {
          this.placement = new Pr(e, On(), r, w, A, C), this._currentPlacementIndex = u.length - 1, this._forceFullPlacement = d, this._showCollisionBoxes = p, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e, r, u) {
          const d = j.now(), p = () => !this._forceFullPlacement && j.now() - d > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const w = r[e[this._currentPlacementIndex]], A = this.placement.collisionIndex.transform.zoom;
            if (w.type === "symbol" && (!w.minzoom || w.minzoom <= A) && (!w.maxzoom || w.maxzoom > A)) {
              if (this._inProgressLayer || (this._inProgressLayer = new xr(w)), this._inProgressLayer.continuePlacement(u[w.source], this.placement, this._showCollisionBoxes, w, p)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(e) {
          return this.placement.commit(e), this.placement;
        }
      }
      const _n = 512 / o.X / 2;
      class hr {
        constructor(e, r, u) {
          this.tileID = e, this.bucketInstanceId = u, this._symbolsByKey = {};
          const d = /* @__PURE__ */ new Map();
          for (let p = 0; p < r.length; p++) {
            const w = r.get(p), A = w.key, C = d.get(A);
            C ? C.push(w) : d.set(A, [w]);
          }
          for (const [p, w] of d) {
            const A = { positions: w.map((C) => ({ x: Math.floor(C.anchorX * _n), y: Math.floor(C.anchorY * _n) })), crossTileIDs: w.map((C) => C.crossTileID) };
            if (A.positions.length > 128) {
              const C = new o.av(A.positions.length, 16, Uint16Array);
              for (const { x: P, y: F } of A.positions) C.add(P, F);
              C.finish(), delete A.positions, A.index = C;
            }
            this._symbolsByKey[p] = A;
          }
        }
        getScaledCoordinates(e, r) {
          const { x: u, y: d, z: p } = this.tileID.canonical, { x: w, y: A, z: C } = r.canonical, P = _n / Math.pow(2, C - p), F = (A * o.X + e.anchorY) * P, N = d * o.X * _n;
          return { x: Math.floor((w * o.X + e.anchorX) * P - u * o.X * _n), y: Math.floor(F - N) };
        }
        findMatches(e, r, u) {
          const d = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
          for (let p = 0; p < e.length; p++) {
            const w = e.get(p);
            if (w.crossTileID) continue;
            const A = this._symbolsByKey[w.key];
            if (!A) continue;
            const C = this.getScaledCoordinates(w, r);
            if (A.index) {
              const P = A.index.range(C.x - d, C.y - d, C.x + d, C.y + d).sort();
              for (const F of P) {
                const N = A.crossTileIDs[F];
                if (!u[N]) {
                  u[N] = !0, w.crossTileID = N;
                  break;
                }
              }
            } else if (A.positions) for (let P = 0; P < A.positions.length; P++) {
              const F = A.positions[P], N = A.crossTileIDs[P];
              if (Math.abs(F.x - C.x) <= d && Math.abs(F.y - C.y) <= d && !u[N]) {
                u[N] = !0, w.crossTileID = N;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
        }
      }
      class Na {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class ln {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e) {
          const r = Math.round((e - this.lng) / 360);
          if (r !== 0) for (const u in this.indexes) {
            const d = this.indexes[u], p = {};
            for (const w in d) {
              const A = d[w];
              A.tileID = A.tileID.unwrapTo(A.tileID.wrap + r), p[A.tileID.key] = A;
            }
            this.indexes[u] = p;
          }
          this.lng = e;
        }
        addBucket(e, r, u) {
          if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
          }
          for (let p = 0; p < r.symbolInstances.length; p++) r.symbolInstances.get(p).crossTileID = 0;
          this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
          const d = this.usedCrossTileIDs[e.overscaledZ];
          for (const p in this.indexes) {
            const w = this.indexes[p];
            if (Number(p) > e.overscaledZ) for (const A in w) {
              const C = w[A];
              C.tileID.isChildOf(e) && C.findMatches(r.symbolInstances, e, d);
            }
            else {
              const A = w[e.scaledTo(Number(p)).key];
              A && A.findMatches(r.symbolInstances, e, d);
            }
          }
          for (let p = 0; p < r.symbolInstances.length; p++) {
            const w = r.symbolInstances.get(p);
            w.crossTileID || (w.crossTileID = u.generate(), d[w.crossTileID] = !0);
          }
          return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new hr(e, r.symbolInstances, r.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(e, r) {
          for (const u of r.getCrossTileIDsLists()) for (const d of u) delete this.usedCrossTileIDs[e][d];
        }
        removeStaleBuckets(e) {
          let r = !1;
          for (const u in this.indexes) {
            const d = this.indexes[u];
            for (const p in d) e[d[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(u, d[p]), delete d[p], r = !0);
          }
          return r;
        }
      }
      class Ko {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Na(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e, r, u) {
          let d = this.layerIndexes[e.id];
          d === void 0 && (d = this.layerIndexes[e.id] = new ln());
          let p = !1;
          const w = {};
          d.handleWrapJump(u);
          for (const A of r) {
            const C = A.getBucket(e);
            C && e.id === C.layerIds[0] && (C.bucketInstanceId || (C.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(A.tileID, C, this.crossTileIDs) && (p = !0), w[C.bucketInstanceId] = !0);
          }
          return d.removeStaleBuckets(w) && (p = !0), p;
        }
        pruneUnusedLayers(e) {
          const r = {};
          e.forEach((u) => {
            r[u] = !0;
          });
          for (const u in this.layerIndexes) r[u] || delete this.layerIndexes[u];
        }
      }
      const Sr = (h, e) => o.t(h, e && e.filter((r) => r.identifier !== "source.canvas")), no = o.aw();
      class jr extends o.E {
        constructor(e, r = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const u in this.sourceCaches) {
              const d = this.sourceCaches[u].getSource().type;
              d !== "vector" && d !== "geojson" || this.sourceCaches[u].reload();
            }
          }, this.map = e, this.dispatcher = new nt(Ke(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (u, d) => this.getGlyphs(u, d)), this.dispatcher.registerMessageHandler("GI", (u, d) => this.getImages(u, d)), this.imageManager = new xe(), this.imageManager.setEventedParent(this), this.glyphManager = new Ze(e._requestManager, r.localIdeographFontFamily), this.lineAtlas = new _e(256, 512), this.crossTileSymbolIndex = new Ko(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", o.ay()), It().on(pt, this._rtlPluginLoaded), this.on("data", (u) => {
            if (u.dataType !== "source" || u.sourceDataType !== "metadata") return;
            const d = this.sourceCaches[u.sourceId];
            if (!d) return;
            const p = d.getSource();
            if (p && p.vectorLayerIds) for (const w in this._layers) {
              const A = this._layers[w];
              A.source === p.id && this._validateLayer(A);
            }
          });
        }
        loadURL(e, r = {}, u) {
          this.fire(new o.k("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
          const d = this.map._requestManager.transformRequest(e, "Style");
          this._loadStyleRequest = new AbortController();
          const p = this._loadStyleRequest;
          o.h(d, this._loadStyleRequest).then((w) => {
            this._loadStyleRequest = null, this._load(w.data, r, u);
          }).catch((w) => {
            this._loadStyleRequest = null, w && !p.signal.aborted && this.fire(new o.j(w));
          });
        }
        loadJSON(e, r = {}, u) {
          this.fire(new o.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), j.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, u);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new o.k("dataloading", { dataType: "style" })), this._load(no, { validate: !1 });
        }
        _load(e, r, u) {
          var d;
          const p = r.transformStyle ? r.transformStyle(u, e) : e;
          if (!r.validate || !Sr(this, o.u(p))) {
            this._loaded = !0, this.stylesheet = p;
            for (const w in p.sources) this.addSource(w, p.sources[w], { validate: !1 });
            p.sprite ? this._loadSprite(p.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(p.glyphs), this._createLayers(), this.light = new et(this.stylesheet.light), this.sky = new ee(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.fire(new o.k("data", { dataType: "style" })), this.fire(new o.k("style.load"));
          }
        }
        _createLayers() {
          const e = o.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", e), this._order = e.map((r) => r.id), this._layers = {}, this._serializedLayers = null;
          for (const r of e) {
            const u = o.aA(r);
            u.setEventedParent(this, { layer: { id: r.id } }), this._layers[r.id] = u;
          }
        }
        _loadSprite(e, r = !1, u = void 0) {
          let d;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(p, w, A, C) {
            return o._(this, void 0, void 0, function* () {
              const P = me(p), F = A > 1 ? "@2x" : "", N = {}, Z = {};
              for (const { id: G, url: V } of P) {
                const W = w.transformRequest(ve(V, F, ".json"), "SpriteJSON");
                N[G] = o.h(W, C);
                const se = w.transformRequest(ve(V, F, ".png"), "SpriteImage");
                Z[G] = Ce.getImage(se, C);
              }
              return yield Promise.all([...Object.values(N), ...Object.values(Z)]), function(G, V) {
                return o._(this, void 0, void 0, function* () {
                  const W = {};
                  for (const se in G) {
                    W[se] = {};
                    const le = j.getImageCanvasContext((yield V[se]).data), de = (yield G[se]).data;
                    for (const ce in de) {
                      const { width: we, height: Le, x: Ie, y: it, sdf: ht, pixelRatio: _t, stretchX: wt, stretchY: bt, content: yt, textFitWidth: St, textFitHeight: Zt } = de[ce];
                      W[se][ce] = { data: null, pixelRatio: _t, sdf: ht, stretchX: wt, stretchY: bt, content: yt, textFitWidth: St, textFitHeight: Zt, spriteData: { width: we, height: Le, x: Ie, y: it, context: le } };
                    }
                  }
                  return W;
                });
              }(N, Z);
            });
          }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p) => {
            if (this._spriteRequest = null, p) for (const w in p) {
              this._spritesImagesIds[w] = [];
              const A = this._spritesImagesIds[w] ? this._spritesImagesIds[w].filter((C) => !(C in p)) : [];
              for (const C of A) this.imageManager.removeImage(C), this._changedImages[C] = !0;
              for (const C in p[w]) {
                const P = w === "default" ? C : `${w}:${C}`;
                this._spritesImagesIds[w].push(P), P in this.imageManager.images ? this.imageManager.updateImage(P, p[w][C], !1) : this.imageManager.addImage(P, p[w][C]), r && (this._changedImages[P] = !0);
              }
            }
          }).catch((p) => {
            this._spriteRequest = null, d = p, this.fire(new o.j(d));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" })), u && u(d);
          });
        }
        _unloadSprite() {
          for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
        }
        _validateLayer(e) {
          const r = this.sourceCaches[e.source];
          if (!r) return;
          const u = e.sourceLayer;
          if (!u) return;
          const d = r.getSource();
          (d.type === "geojson" || d.vectorLayerIds && d.vectorLayerIds.indexOf(u) === -1) && this.fire(new o.j(new Error(`Source layer "${u}" does not exist on source "${d.id}" as specified by style layer "${e.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(e, r = !1) {
          const u = this._serializedAllLayers();
          if (!e || e.length === 0) return Object.values(r ? o.aB(u) : u);
          const d = [];
          for (const p of e) if (u[p]) {
            const w = r ? o.aB(u[p]) : u[p];
            d.push(w);
          }
          return d;
        }
        _serializedAllLayers() {
          let e = this._serializedLayers;
          if (e) return e;
          e = this._serializedLayers = {};
          const r = Object.keys(this._layers);
          for (const u of r) {
            const d = this._layers[u];
            d.type !== "custom" && (e[u] = d.serialize());
          }
          return e;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
          for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(e) {
          if (!this._loaded) return;
          const r = this._changed;
          if (r) {
            const d = Object.keys(this._updatedLayers), p = Object.keys(this._removedLayers);
            (d.length || p.length) && this._updateWorkerLayers(d, p);
            for (const w in this._updatedSources) {
              const A = this._updatedSources[w];
              if (A === "reload") this._reloadSource(w);
              else {
                if (A !== "clear") throw new Error(`Invalid action ${A}`);
                this._clearSource(w);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const w in this._updatedPaintProps) this._layers[w].updateTransitions(e);
            this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
          }
          const u = {};
          for (const d in this.sourceCaches) {
            const p = this.sourceCaches[d];
            u[d] = p.used, p.used = !1;
          }
          for (const d of this._order) {
            const p = this._layers[d];
            p.recalculate(e, this._availableImages), !p.isHidden(e.zoom) && p.source && (this.sourceCaches[p.source].used = !0);
          }
          for (const d in u) {
            const p = this.sourceCaches[d];
            !!u[d] != !!p.used && p.fire(new o.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: d }));
          }
          this.light.recalculate(e), this.sky.recalculate(e), this.z = e.zoom, r && this.fire(new o.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e = Object.keys(this._changedImages);
          if (e.length) {
            for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(e, r) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: r });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(e, r = {}) {
          var u;
          this._checkLoaded();
          const d = this.serialize();
          if (e = r.transformStyle ? r.transformStyle(d, e) : e, ((u = r.validate) === null || u === void 0 || u) && Sr(this, o.u(e))) return !1;
          (e = o.aB(e)).layers = o.az(e.layers);
          const p = o.aC(d, e), w = this._getOperationsToPerform(p);
          if (w.unimplemented.length > 0) throw new Error(`Unimplemented: ${w.unimplemented.join(", ")}.`);
          if (w.operations.length === 0) return !1;
          for (const A of w.operations) A();
          return this.stylesheet = e, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(e) {
          const r = [], u = [];
          for (const d of e) switch (d.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              r.push(() => this.addLayer.apply(this, d.args));
              break;
            case "removeLayer":
              r.push(() => this.removeLayer.apply(this, d.args));
              break;
            case "setPaintProperty":
              r.push(() => this.setPaintProperty.apply(this, d.args));
              break;
            case "setLayoutProperty":
              r.push(() => this.setLayoutProperty.apply(this, d.args));
              break;
            case "setFilter":
              r.push(() => this.setFilter.apply(this, d.args));
              break;
            case "addSource":
              r.push(() => this.addSource.apply(this, d.args));
              break;
            case "removeSource":
              r.push(() => this.removeSource.apply(this, d.args));
              break;
            case "setLayerZoomRange":
              r.push(() => this.setLayerZoomRange.apply(this, d.args));
              break;
            case "setLight":
              r.push(() => this.setLight.apply(this, d.args));
              break;
            case "setGeoJSONSourceData":
              r.push(() => this.setGeoJSONSourceData.apply(this, d.args));
              break;
            case "setGlyphs":
              r.push(() => this.setGlyphs.apply(this, d.args));
              break;
            case "setSprite":
              r.push(() => this.setSprite.apply(this, d.args));
              break;
            case "setSky":
              r.push(() => this.setSky.apply(this, d.args));
              break;
            case "setTerrain":
              r.push(() => this.map.setTerrain.apply(this, d.args));
              break;
            case "setTransition":
              r.push(() => {
              });
              break;
            default:
              u.push(d.command);
          }
          return { operations: r, unimplemented: u };
        }
        addImage(e, r) {
          if (this.getImage(e)) return this.fire(new o.j(new Error(`An image named "${e}" already exists.`)));
          this.imageManager.addImage(e, r), this._afterImageUpdated(e);
        }
        updateImage(e, r) {
          this.imageManager.updateImage(e, r);
        }
        getImage(e) {
          return this.imageManager.getImage(e);
        }
        removeImage(e) {
          if (!this.getImage(e)) return this.fire(new o.j(new Error(`An image named "${e}" does not exist.`)));
          this.imageManager.removeImage(e), this._afterImageUpdated(e);
        }
        _afterImageUpdated(e) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e, r, u = {}) {
          if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
          if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(o.u.source, `sources.${e}`, r, null, u)) return;
          this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
          const d = this.sourceCaches[e] = new Lt(e, r, this.dispatcher);
          d.style = this, d.setEventedParent(this, () => ({ isSourceLoaded: d.loaded(), source: d.serialize(), sourceId: e })), d.onAdd(this.map), this._changed = !0;
        }
        removeSource(e) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
          for (const u in this._layers) if (this._layers[u].source === e) return this.fire(new o.j(new Error(`Source "${e}" cannot be removed while layer "${u}" is using it.`)));
          const r = this.sourceCaches[e];
          delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new o.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(e, r) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
          const u = this.sourceCaches[e].getSource();
          if (u.type !== "geojson") throw new Error(`geojsonSource.type is ${u.type}, which is !== 'geojson`);
          u.setData(r), this._changed = !0;
        }
        getSource(e) {
          return this.sourceCaches[e] && this.sourceCaches[e].getSource();
        }
        addLayer(e, r, u = {}) {
          this._checkLoaded();
          const d = e.id;
          if (this.getLayer(d)) return void this.fire(new o.j(new Error(`Layer "${d}" already exists on this map.`)));
          let p;
          if (e.type === "custom") {
            if (Sr(this, o.aD(e))) return;
            p = o.aA(e);
          } else {
            if ("source" in e && typeof e.source == "object" && (this.addSource(d, e.source), e = o.aB(e), e = o.e(e, { source: d })), this._validate(o.u.layer, `layers.${d}`, e, { arrayIndex: -1 }, u)) return;
            p = o.aA(e), this._validateLayer(p), p.setEventedParent(this, { layer: { id: d } });
          }
          const w = r ? this._order.indexOf(r) : this._order.length;
          if (r && w === -1) this.fire(new o.j(new Error(`Cannot add layer "${d}" before non-existing layer "${r}".`)));
          else {
            if (this._order.splice(w, 0, d), this._layerOrderChanged = !0, this._layers[d] = p, this._removedLayers[d] && p.source && p.type !== "custom") {
              const A = this._removedLayers[d];
              delete this._removedLayers[d], A.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.sourceCaches[p.source].pause());
            }
            this._updateLayer(p), p.onAdd && p.onAdd(this.map);
          }
        }
        moveLayer(e, r) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new o.j(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
          if (e === r) return;
          const u = this._order.indexOf(e);
          this._order.splice(u, 1);
          const d = r ? this._order.indexOf(r) : this._order.length;
          r && d === -1 ? this.fire(new o.j(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(d, 0, e), this._layerOrderChanged = !0);
        }
        removeLayer(e) {
          this._checkLoaded();
          const r = this._layers[e];
          if (!r) return void this.fire(new o.j(new Error(`Cannot remove non-existing layer "${e}".`)));
          r.setEventedParent(null);
          const u = this._order.indexOf(e);
          this._order.splice(u, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map);
        }
        getLayer(e) {
          return this._layers[e];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(e) {
          return e in this._layers;
        }
        setLayerZoomRange(e, r, u) {
          this._checkLoaded();
          const d = this.getLayer(e);
          d ? d.minzoom === r && d.maxzoom === u || (r != null && (d.minzoom = r), u != null && (d.maxzoom = u), this._updateLayer(d)) : this.fire(new o.j(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
        }
        setFilter(e, r, u = {}) {
          this._checkLoaded();
          const d = this.getLayer(e);
          if (d) {
            if (!o.aE(d.filter, r)) return r == null ? (d.filter = void 0, void this._updateLayer(d)) : void (this._validate(o.u.filter, `layers.${d.id}.filter`, r, null, u) || (d.filter = o.aB(r), this._updateLayer(d)));
          } else this.fire(new o.j(new Error(`Cannot filter non-existing layer "${e}".`)));
        }
        getFilter(e) {
          return o.aB(this.getLayer(e).filter);
        }
        setLayoutProperty(e, r, u, d = {}) {
          this._checkLoaded();
          const p = this.getLayer(e);
          p ? o.aE(p.getLayoutProperty(r), u) || (p.setLayoutProperty(r, u, d), this._updateLayer(p)) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getLayoutProperty(e, r) {
          const u = this.getLayer(e);
          if (u) return u.getLayoutProperty(r);
          this.fire(new o.j(new Error(`Cannot get style of non-existing layer "${e}".`)));
        }
        setPaintProperty(e, r, u, d = {}) {
          this._checkLoaded();
          const p = this.getLayer(e);
          p ? o.aE(p.getPaintProperty(r), u) || (p.setPaintProperty(r, u, d) && this._updateLayer(p), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getPaintProperty(e, r) {
          return this.getLayer(e).getPaintProperty(r);
        }
        setFeatureState(e, r) {
          this._checkLoaded();
          const u = e.source, d = e.sourceLayer, p = this.sourceCaches[u];
          if (p === void 0) return void this.fire(new o.j(new Error(`The source '${u}' does not exist in the map's style.`)));
          const w = p.getSource().type;
          w === "geojson" && d ? this.fire(new o.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : w !== "vector" || d ? (e.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), p.setFeatureState(d, e.id, r)) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(e, r) {
          this._checkLoaded();
          const u = e.source, d = this.sourceCaches[u];
          if (d === void 0) return void this.fire(new o.j(new Error(`The source '${u}' does not exist in the map's style.`)));
          const p = d.getSource().type, w = p === "vector" ? e.sourceLayer : void 0;
          p !== "vector" || w ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.j(new Error("A feature id is required to remove its specific state property."))) : d.removeFeatureState(w, e.id, r) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(e) {
          this._checkLoaded();
          const r = e.source, u = e.sourceLayer, d = this.sourceCaches[r];
          if (d !== void 0) return d.getSource().type !== "vector" || u ? (e.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), d.getFeatureState(u, e.id)) : void this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new o.j(new Error(`The source '${r}' does not exist in the map's style.`)));
        }
        getTransition() {
          return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const e = o.aF(this.sourceCaches, (p) => p.serialize()), r = this._serializeByIds(this._order, !0), u = this.map.getTerrain() || void 0, d = this.stylesheet;
          return o.aG({ version: d.version, name: d.name, metadata: d.metadata, light: d.light, sky: d.sky, center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch, sprite: d.sprite, glyphs: d.glyphs, transition: d.transition, sources: e, layers: r, terrain: u }, (p) => p !== void 0);
        }
        _updateLayer(e) {
          this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(e) {
          const r = (w) => this._layers[w].type === "fill-extrusion", u = {}, d = [];
          for (let w = this._order.length - 1; w >= 0; w--) {
            const A = this._order[w];
            if (r(A)) {
              u[A] = w;
              for (const C of e) {
                const P = C[A];
                if (P) for (const F of P) d.push(F);
              }
            }
          }
          d.sort((w, A) => A.intersectionZ - w.intersectionZ);
          const p = [];
          for (let w = this._order.length - 1; w >= 0; w--) {
            const A = this._order[w];
            if (r(A)) for (let C = d.length - 1; C >= 0; C--) {
              const P = d[C].feature;
              if (u[P.layer.id] < w) break;
              p.push(P), d.pop();
            }
            else for (const C of e) {
              const P = C[A];
              if (P) for (const F of P) p.push(F.feature);
            }
          }
          return p;
        }
        queryRenderedFeatures(e, r, u) {
          r && r.filter && this._validate(o.u.filter, "queryRenderedFeatures.filter", r.filter, null, r);
          const d = {};
          if (r && r.layers) {
            if (!Array.isArray(r.layers)) return this.fire(new o.j(new Error("parameters.layers must be an Array."))), [];
            for (const A of r.layers) {
              const C = this._layers[A];
              if (!C) return this.fire(new o.j(new Error(`The layer '${A}' does not exist in the map's style and cannot be queried for features.`))), [];
              d[C.source] = !0;
            }
          }
          const p = [];
          r.availableImages = this._availableImages;
          const w = this._serializedAllLayers();
          for (const A in this.sourceCaches) r.layers && !d[A] || p.push(mt(this.sourceCaches[A], this._layers, w, e, r, u));
          return this.placement && p.push(function(A, C, P, F, N, Z, G) {
            const V = {}, W = Z.queryRenderedSymbols(F), se = [];
            for (const le of Object.keys(W).map(Number)) se.push(G[le]);
            se.sort(Pt);
            for (const le of se) {
              const de = le.featureIndex.lookupSymbolFeatures(W[le.bucketInstanceId], C, le.bucketIndex, le.sourceLayerIndex, N.filter, N.layers, N.availableImages, A);
              for (const ce in de) {
                const we = V[ce] = V[ce] || [], Le = de[ce];
                Le.sort((Ie, it) => {
                  const ht = le.featureSortOrder;
                  if (ht) {
                    const _t = ht.indexOf(Ie.featureIndex);
                    return ht.indexOf(it.featureIndex) - _t;
                  }
                  return it.featureIndex - Ie.featureIndex;
                });
                for (const Ie of Le) we.push(Ie);
              }
            }
            for (const le in V) V[le].forEach((de) => {
              const ce = de.feature, we = P[A[le].source].getFeatureState(ce.layer["source-layer"], ce.id);
              ce.source = ce.layer.source, ce.layer["source-layer"] && (ce.sourceLayer = ce.layer["source-layer"]), ce.state = we;
            });
            return V;
          }(this._layers, w, this.sourceCaches, e, r, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p);
        }
        querySourceFeatures(e, r) {
          r && r.filter && this._validate(o.u.filter, "querySourceFeatures.filter", r.filter, null, r);
          const u = this.sourceCaches[e];
          return u ? function(d, p) {
            const w = d.getRenderableIds().map((P) => d.getTileByID(P)), A = [], C = {};
            for (let P = 0; P < w.length; P++) {
              const F = w[P], N = F.tileID.canonical.key;
              C[N] || (C[N] = !0, F.querySourceFeatures(A, p));
            }
            return A;
          }(u, r) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e, r = {}) {
          this._checkLoaded();
          const u = this.light.getLight();
          let d = !1;
          for (const w in e) if (!o.aE(e[w], u[w])) {
            d = !0;
            break;
          }
          if (!d) return;
          const p = { now: j.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e, r), this.light.updateTransitions(p);
        }
        getSky() {
          var e;
          return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
        }
        setSky(e, r = {}) {
          const u = this.getSky();
          let d = !1;
          if (!e && !u) return;
          if (e && !u) d = !0;
          else if (!e && u) d = !0;
          else for (const w in e) if (!o.aE(e[w], u[w])) {
            d = !0;
            break;
          }
          if (!d) return;
          const p = { now: j.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(p);
        }
        _validate(e, r, u, d, p = {}) {
          return (!p || p.validate !== !1) && Sr(this, e.call(o.u, o.e({ key: r, style: this.serialize(), value: u, styleSpec: o.v }, d)));
        }
        _remove(e = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), It().off(pt, this._rtlPluginLoaded);
          for (const r in this._layers) this._layers[r].setEventedParent(null);
          for (const r in this.sourceCaches) {
            const u = this.sourceCaches[r];
            u.setEventedParent(null), u.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
        }
        _clearSource(e) {
          this.sourceCaches[e].clearTiles();
        }
        _reloadSource(e) {
          this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
        }
        _updateSources(e) {
          for (const r in this.sourceCaches) this.sourceCaches[r].update(e, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const e in this.sourceCaches) this._reloadSource(e);
        }
        _updatePlacement(e, r, u, d, p = !1) {
          let w = !1, A = !1;
          const C = {};
          for (const P of this._order) {
            const F = this._layers[P];
            if (F.type !== "symbol") continue;
            if (!C[F.source]) {
              const Z = this.sourceCaches[F.source];
              C[F.source] = Z.getRenderableIds(!0).map((G) => Z.getTileByID(G)).sort((G, V) => V.tileID.overscaledZ - G.tileID.overscaledZ || (G.tileID.isLessThan(V.tileID) ? -1 : 1));
            }
            const N = this.crossTileSymbolIndex.addLayer(F, C[F.source], e.center.lng);
            w = w || N;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || u === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(j.now(), e.zoom)) && (this.pauseablePlacement = new rr(e, this.map.terrain, this._order, p, r, u, d, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, C), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(j.now()), A = !0), w && this.pauseablePlacement.placement.setStale()), A || w) for (const P of this._order) {
            const F = this._layers[P];
            F.type === "symbol" && this.placement.updateLayerOpacities(F, C[F.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(j.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
        }
        getImages(e, r) {
          return o._(this, void 0, void 0, function* () {
            const u = yield this.imageManager.getImages(r.icons);
            this._updateTilesForChangedImages();
            const d = this.sourceCaches[r.source];
            return d && d.setDependencies(r.tileID.key, r.type, r.icons), u;
          });
        }
        getGlyphs(e, r) {
          return o._(this, void 0, void 0, function* () {
            const u = yield this.glyphManager.getGlyphs(r.stacks), d = this.sourceCaches[r.source];
            return d && d.setDependencies(r.tileID.key, r.type, [""]), u;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e, r = {}) {
          this._checkLoaded(), e && this._validate(o.u.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
        }
        addSprite(e, r, u = {}, d) {
          this._checkLoaded();
          const p = [{ id: e, url: r }], w = [...me(this.stylesheet.sprite), ...p];
          this._validate(o.u.sprite, "sprite", w, null, u) || (this.stylesheet.sprite = w, this._loadSprite(p, !0, d));
        }
        removeSprite(e) {
          this._checkLoaded();
          const r = me(this.stylesheet.sprite);
          if (r.find((u) => u.id === e)) {
            if (this._spritesImagesIds[e]) for (const u of this._spritesImagesIds[e]) this.imageManager.removeImage(u), this._changedImages[u] = !0;
            r.splice(r.findIndex((u) => u.id === e), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
          } else this.fire(new o.j(new Error(`Sprite "${e}" doesn't exists on this map.`)));
        }
        getSprite() {
          return me(this.stylesheet.sprite);
        }
        setSprite(e, r = {}, u) {
          this._checkLoaded(), e && this._validate(o.u.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, u) : (this._unloadSprite(), u && u(null)));
        }
      }
      var as = o.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const os = { prelude: Ri(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Ri(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Ri(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ri(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ri("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ri(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Ri(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ri("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ri("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ri("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Ri(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Ri(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Ri(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ri(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ri(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ri(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Ri(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ri(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Ri(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ri(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ri(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ri("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ri("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ri("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Ri("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Ri(h, e) {
        const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, u = e.match(/attribute ([\w]+) ([\w]+)/g), d = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), p = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = p ? p.concat(d) : d, A = {};
        return { fragmentSource: h = h.replace(r, (C, P, F, N, Z) => (A[Z] = !0, P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
varying ${F} ${N} ${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : `
#ifdef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = u_${Z};
#endif
`)), vertexSource: e = e.replace(r, (C, P, F, N, Z) => {
          const G = N === "float" ? "vec2" : "vec4", V = Z.match(/color/) ? "color" : G;
          return A[Z] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
attribute ${F} ${G} a_${Z};
varying ${F} ${N} ${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = a_${Z};
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = unpack_mix_${V}(a_${Z}, u_${Z}_t);
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
attribute ${F} ${G} a_${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = a_${Z};
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = unpack_mix_${V}(a_${Z}, u_${Z}_t);
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
`;
        }), staticAttributes: u, staticUniforms: w };
      }
      class so {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e, r, u, d, p, w, A, C, P) {
          this.context = e;
          let F = this.boundPaintVertexBuffers.length !== d.length;
          for (let N = 0; !F && N < d.length; N++) this.boundPaintVertexBuffers[N] !== d[N] && (F = !0);
          !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== u || F || this.boundIndexBuffer !== p || this.boundVertexOffset !== w || this.boundDynamicVertexBuffer !== A || this.boundDynamicVertexBuffer2 !== C || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(r, u, d, p, w, A, C, P) : (e.bindVertexArray.set(this.vao), A && A.bind(), p && p.dynamicDraw && p.bind(), C && C.bind(), P && P.bind());
        }
        freshBind(e, r, u, d, p, w, A, C) {
          const P = e.numAttributes, F = this.context, N = F.gl;
          this.vao && this.destroy(), this.vao = F.createVertexArray(), F.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = u, this.boundIndexBuffer = d, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = A, this.boundDynamicVertexBuffer3 = C, r.enableAttributes(N, e);
          for (const Z of u) Z.enableAttributes(N, e);
          w && w.enableAttributes(N, e), A && A.enableAttributes(N, e), C && C.enableAttributes(N, e), r.bind(), r.setVertexAttribPointers(N, e, p);
          for (const Z of u) Z.bind(), Z.setVertexAttribPointers(N, e, p);
          w && (w.bind(), w.setVertexAttribPointers(N, e, p)), d && d.bind(), A && (A.bind(), A.setVertexAttribPointers(N, e, p)), C && (C.bind(), C.setVertexAttribPointers(N, e, p)), F.currentNumAttributes = P;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Qo = (h, e, r, u, d) => ({ u_matrix: h, u_texture: 0, u_ele_delta: e, u_fog_matrix: r, u_fog_color: u ? u.properties.get("fog-color") : o.aM.white, u_fog_ground_blend: u ? u.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: u ? u.calculateFogBlendOpacity(d) : 0, u_horizon_color: u ? u.properties.get("horizon-color") : o.aM.white, u_horizon_fog_blend: u ? u.properties.get("horizon-fog-blend") : 1 });
      function $s(h) {
        const e = [];
        for (let r = 0; r < h.length; r++) {
          if (h[r] === null) continue;
          const u = h[r].split(" ");
          e.push(u.pop());
        }
        return e;
      }
      class el {
        constructor(e, r, u, d, p, w) {
          const A = e.gl;
          this.program = A.createProgram();
          const C = $s(r.staticAttributes), P = u ? u.getBinderAttributes() : [], F = C.concat(P), N = os.prelude.staticUniforms ? $s(os.prelude.staticUniforms) : [], Z = r.staticUniforms ? $s(r.staticUniforms) : [], G = u ? u.getBinderUniforms() : [], V = N.concat(Z).concat(G), W = [];
          for (const Ie of V) W.indexOf(Ie) < 0 && W.push(Ie);
          const se = u ? u.defines() : [];
          p && se.push("#define OVERDRAW_INSPECTOR;"), w && se.push("#define TERRAIN3D;");
          const le = se.concat(os.prelude.fragmentSource, r.fragmentSource).join(`
`), de = se.concat(os.prelude.vertexSource, r.vertexSource).join(`
`), ce = A.createShader(A.FRAGMENT_SHADER);
          if (A.isContextLost()) return void (this.failedToCreate = !0);
          if (A.shaderSource(ce, le), A.compileShader(ce), !A.getShaderParameter(ce, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(ce)}`);
          A.attachShader(this.program, ce);
          const we = A.createShader(A.VERTEX_SHADER);
          if (A.isContextLost()) return void (this.failedToCreate = !0);
          if (A.shaderSource(we, de), A.compileShader(we), !A.getShaderParameter(we, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(we)}`);
          A.attachShader(this.program, we), this.attributes = {};
          const Le = {};
          this.numAttributes = F.length;
          for (let Ie = 0; Ie < this.numAttributes; Ie++) F[Ie] && (A.bindAttribLocation(this.program, Ie, F[Ie]), this.attributes[F[Ie]] = Ie);
          if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
          A.deleteShader(we), A.deleteShader(ce);
          for (let Ie = 0; Ie < W.length; Ie++) {
            const it = W[Ie];
            if (it && !Le[it]) {
              const ht = A.getUniformLocation(this.program, it);
              ht && (Le[it] = ht);
            }
          }
          this.fixedUniforms = d(e, Le), this.terrainUniforms = ((Ie, it) => ({ u_depth: new o.aH(Ie, it.u_depth), u_terrain: new o.aH(Ie, it.u_terrain), u_terrain_dim: new o.aI(Ie, it.u_terrain_dim), u_terrain_matrix: new o.aJ(Ie, it.u_terrain_matrix), u_terrain_unpack: new o.aK(Ie, it.u_terrain_unpack), u_terrain_exaggeration: new o.aI(Ie, it.u_terrain_exaggeration) }))(e, Le), this.binderUniforms = u ? u.getUniforms(e, Le) : [];
        }
        draw(e, r, u, d, p, w, A, C, P, F, N, Z, G, V, W, se, le, de) {
          const ce = e.gl;
          if (this.failedToCreate) return;
          if (e.program.set(this.program), e.setDepthMode(u), e.setStencilMode(d), e.setColorMode(p), e.setCullFace(w), C) {
            e.activeTexture.set(ce.TEXTURE2), ce.bindTexture(ce.TEXTURE_2D, C.depthTexture), e.activeTexture.set(ce.TEXTURE3), ce.bindTexture(ce.TEXTURE_2D, C.texture);
            for (const Le in this.terrainUniforms) this.terrainUniforms[Le].set(C[Le]);
          }
          for (const Le in this.fixedUniforms) this.fixedUniforms[Le].set(A[Le]);
          W && W.setUniforms(e, this.binderUniforms, G, { zoom: V });
          let we = 0;
          switch (r) {
            case ce.LINES:
              we = 2;
              break;
            case ce.TRIANGLES:
              we = 3;
              break;
            case ce.LINE_STRIP:
              we = 1;
          }
          for (const Le of Z.get()) {
            const Ie = Le.vaos || (Le.vaos = {});
            (Ie[P] || (Ie[P] = new so())).bind(e, this, F, W ? W.getPaintVertexBuffers() : [], N, Le.vertexOffset, se, le, de), ce.drawElements(r, Le.primitiveLength * we, ce.UNSIGNED_SHORT, Le.primitiveOffset * we * 2);
          }
        }
      }
      function da(h, e, r) {
        const u = 1 / fi(r, 1, e.transform.tileZoom), d = Math.pow(2, r.tileID.overscaledZ), p = r.tileSize * Math.pow(2, e.transform.tileZoom) / d, w = p * (r.tileID.canonical.x + r.tileID.wrap * d), A = p * r.tileID.canonical.y;
        return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [u, h.fromScale, h.toScale], u_fade: h.t, u_pixel_coord_upper: [w >> 16, A >> 16], u_pixel_coord_lower: [65535 & w, 65535 & A] };
      }
      const za = (h, e, r, u) => {
        const d = e.style.light, p = d.properties.get("position"), w = [p.x, p.y, p.z], A = function() {
          var P = new o.A(9);
          return o.A != Float32Array && (P[1] = 0, P[2] = 0, P[3] = 0, P[5] = 0, P[6] = 0, P[7] = 0), P[0] = 1, P[4] = 1, P[8] = 1, P;
        }();
        d.properties.get("anchor") === "viewport" && function(P, F) {
          var N = Math.sin(F), Z = Math.cos(F);
          P[0] = Z, P[1] = N, P[2] = 0, P[3] = -N, P[4] = Z, P[5] = 0, P[6] = 0, P[7] = 0, P[8] = 1;
        }(A, -e.transform.angle), function(P, F, N) {
          var Z = F[0], G = F[1], V = F[2];
          P[0] = Z * N[0] + G * N[3] + V * N[6], P[1] = Z * N[1] + G * N[4] + V * N[7], P[2] = Z * N[2] + G * N[5] + V * N[8];
        }(w, w, A);
        const C = d.properties.get("color");
        return { u_matrix: h, u_lightpos: w, u_lightintensity: d.properties.get("intensity"), u_lightcolor: [C.r, C.g, C.b], u_vertical_gradient: +r, u_opacity: u };
      }, ao = (h, e, r, u, d, p, w) => o.e(za(h, e, r, u), da(p, e, w), { u_height_factor: -Math.pow(2, d.overscaledZ) / w.tileSize / 8 }), pa = (h) => ({ u_matrix: h }), As = (h, e, r, u) => o.e(pa(h), da(r, e, u)), oo = (h, e) => ({ u_matrix: h, u_world: e }), Fa = (h, e, r, u, d) => o.e(As(h, e, r, u), { u_world: d }), Il = (h, e, r, u) => {
        const d = h.transform;
        let p, w;
        if (u.paint.get("circle-pitch-alignment") === "map") {
          const A = fi(r, 1, d.zoom);
          p = !0, w = [A, A];
        } else p = !1, w = d.pixelsToGLUnits;
        return { u_camera_to_center_distance: d.cameraToCenterDistance, u_scale_with_map: +(u.paint.get("circle-pitch-scale") === "map"), u_matrix: h.translatePosMatrix(e.posMatrix, r, u.paint.get("circle-translate"), u.paint.get("circle-translate-anchor")), u_pitch_with_map: +p, u_device_pixel_ratio: h.pixelRatio, u_extrude_scale: w };
      }, wr = (h, e, r) => ({ u_matrix: h, u_inv_matrix: e, u_camera_to_center_distance: r.cameraToCenterDistance, u_viewport_size: [r.width, r.height] }), Ba = (h, e, r = 1) => ({ u_matrix: h, u_color: e, u_overlay: 0, u_overlay_scale: r }), qr = (h) => ({ u_matrix: h }), ai = (h, e, r, u) => ({ u_matrix: h, u_extrude_scale: fi(e, 1, r), u_intensity: u }), lo = (h, e, r, u) => {
        const d = o.H();
        o.aP(d, 0, h.width, h.height, 0, 0, 1);
        const p = h.context.gl;
        return { u_matrix: d, u_world: [p.drawingBufferWidth, p.drawingBufferHeight], u_image: r, u_color_ramp: u, u_opacity: e.paint.get("heatmap-opacity") };
      };
      function uo(h, e) {
        const r = Math.pow(2, e.canonical.z), u = e.canonical.y;
        return [new o.Z(0, u / r).toLngLat().lat, new o.Z(0, (u + 1) / r).toLngLat().lat];
      }
      const Tn = (h, e, r, u) => {
        const d = h.transform;
        return { u_matrix: Pl(h, e, r, u), u_ratio: 1 / fi(e, 1, d.zoom), u_device_pixel_ratio: h.pixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
      }, tl = (h, e, r, u, d) => o.e(Tn(h, e, r, d), { u_image: 0, u_image_height: u }), Zs = (h, e, r, u, d) => {
        const p = h.transform, w = ho(e, p);
        return { u_matrix: Pl(h, e, r, d), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / fi(e, 1, p.zoom), u_device_pixel_ratio: h.pixelRatio, u_image: 0, u_scale: [w, u.fromScale, u.toScale], u_fade: u.t, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
      }, co = (h, e, r, u, d, p) => {
        const w = h.lineAtlas, A = ho(e, h.transform), C = r.layout.get("line-cap") === "round", P = w.getDash(u.from, C), F = w.getDash(u.to, C), N = P.width * d.fromScale, Z = F.width * d.toScale;
        return o.e(Tn(h, e, r, p), { u_patternscale_a: [A / N, -P.height / 2], u_patternscale_b: [A / Z, -F.height / 2], u_sdfgamma: w.width / (256 * Math.min(N, Z) * h.pixelRatio) / 2, u_image: 0, u_tex_y_a: P.y, u_tex_y_b: F.y, u_mix: d.t });
      };
      function ho(h, e) {
        return 1 / fi(h, 1, e.tileZoom);
      }
      function Pl(h, e, r, u) {
        return h.translatePosMatrix(u ? u.posMatrix : e.tileID.posMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
      }
      const au = (h, e, r, u, d) => {
        return { u_matrix: h, u_tl_parent: e, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: u.mix, u_opacity: u.opacity * d.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get("raster-brightness-min"), u_brightness_high: d.paint.get("raster-brightness-max"), u_saturation_factor: (w = d.paint.get("raster-saturation"), w > 0 ? 1 - 1 / (1.001 - w) : -w), u_contrast_factor: (p = d.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p), u_spin_weights: ou(d.paint.get("raster-hue-rotate")) };
        var p, w;
      };
      function ou(h) {
        h *= Math.PI / 180;
        const e = Math.sin(h), r = Math.cos(h);
        return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3];
      }
      const po = (h, e, r, u, d, p, w, A, C, P, F, N, Z, G) => {
        const V = w.transform;
        return { u_is_size_zoom_constant: +(h === "constant" || h === "source"), u_is_size_feature_constant: +(h === "constant" || h === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: V.cameraToCenterDistance, u_pitch: V.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: V.width / V.height, u_fade_change: w.options.fadeDuration ? w.symbolFadeChange : 1, u_matrix: A, u_label_plane_matrix: C, u_coord_matrix: P, u_is_text: +N, u_pitch_with_map: +u, u_is_along_line: d, u_is_variable_anchor: p, u_texsize: Z, u_texture: 0, u_translation: F, u_pitched_scale: G };
      }, ls = (h, e, r, u, d, p, w, A, C, P, F, N, Z, G, V) => {
        const W = w.transform;
        return o.e(po(h, e, r, u, d, p, w, A, C, P, F, N, Z, V), { u_gamma_scale: u ? Math.cos(W._pitch) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: w.pixelRatio, u_is_halo: +G });
      }, Ss = (h, e, r, u, d, p, w, A, C, P, F, N, Z, G) => o.e(ls(h, e, r, u, d, p, w, A, C, P, F, !0, N, !0, G), { u_texsize_icon: Z, u_texture_icon: 1 }), fo = (h, e, r) => ({ u_matrix: h, u_opacity: e, u_color: r }), Gs = (h, e, r, u, d, p) => o.e(function(w, A, C, P) {
        const F = C.imageManager.getPattern(w.from.toString()), N = C.imageManager.getPattern(w.to.toString()), { width: Z, height: G } = C.imageManager.getPixelSize(), V = Math.pow(2, P.tileID.overscaledZ), W = P.tileSize * Math.pow(2, C.transform.tileZoom) / V, se = W * (P.tileID.canonical.x + P.tileID.wrap * V), le = W * P.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: N.tl, u_pattern_br_b: N.br, u_texsize: [Z, G], u_mix: A.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: N.displaySize, u_scale_a: A.fromScale, u_scale_b: A.toScale, u_tile_units_to_pixels: 1 / fi(P, 1, C.transform.tileZoom), u_pixel_coord_upper: [se >> 16, le >> 16], u_pixel_coord_lower: [65535 & se, 65535 & le] };
      }(u, p, r, d), { u_matrix: h, u_opacity: e }), Ra = { fillExtrusion: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_lightpos: new o.aN(h, e.u_lightpos), u_lightintensity: new o.aI(h, e.u_lightintensity), u_lightcolor: new o.aN(h, e.u_lightcolor), u_vertical_gradient: new o.aI(h, e.u_vertical_gradient), u_opacity: new o.aI(h, e.u_opacity) }), fillExtrusionPattern: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_lightpos: new o.aN(h, e.u_lightpos), u_lightintensity: new o.aI(h, e.u_lightintensity), u_lightcolor: new o.aN(h, e.u_lightcolor), u_vertical_gradient: new o.aI(h, e.u_vertical_gradient), u_height_factor: new o.aI(h, e.u_height_factor), u_image: new o.aH(h, e.u_image), u_texsize: new o.aO(h, e.u_texsize), u_pixel_coord_upper: new o.aO(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.aO(h, e.u_pixel_coord_lower), u_scale: new o.aN(h, e.u_scale), u_fade: new o.aI(h, e.u_fade), u_opacity: new o.aI(h, e.u_opacity) }), fill: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix) }), fillPattern: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_image: new o.aH(h, e.u_image), u_texsize: new o.aO(h, e.u_texsize), u_pixel_coord_upper: new o.aO(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.aO(h, e.u_pixel_coord_lower), u_scale: new o.aN(h, e.u_scale), u_fade: new o.aI(h, e.u_fade) }), fillOutline: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_world: new o.aO(h, e.u_world) }), fillOutlinePattern: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_world: new o.aO(h, e.u_world), u_image: new o.aH(h, e.u_image), u_texsize: new o.aO(h, e.u_texsize), u_pixel_coord_upper: new o.aO(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.aO(h, e.u_pixel_coord_lower), u_scale: new o.aN(h, e.u_scale), u_fade: new o.aI(h, e.u_fade) }), circle: (h, e) => ({ u_camera_to_center_distance: new o.aI(h, e.u_camera_to_center_distance), u_scale_with_map: new o.aH(h, e.u_scale_with_map), u_pitch_with_map: new o.aH(h, e.u_pitch_with_map), u_extrude_scale: new o.aO(h, e.u_extrude_scale), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_matrix: new o.aJ(h, e.u_matrix) }), collisionBox: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_pixel_extrude_scale: new o.aO(h, e.u_pixel_extrude_scale) }), collisionCircle: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_inv_matrix: new o.aJ(h, e.u_inv_matrix), u_camera_to_center_distance: new o.aI(h, e.u_camera_to_center_distance), u_viewport_size: new o.aO(h, e.u_viewport_size) }), debug: (h, e) => ({ u_color: new o.aL(h, e.u_color), u_matrix: new o.aJ(h, e.u_matrix), u_overlay: new o.aH(h, e.u_overlay), u_overlay_scale: new o.aI(h, e.u_overlay_scale) }), clippingMask: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix) }), heatmap: (h, e) => ({ u_extrude_scale: new o.aI(h, e.u_extrude_scale), u_intensity: new o.aI(h, e.u_intensity), u_matrix: new o.aJ(h, e.u_matrix) }), heatmapTexture: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_world: new o.aO(h, e.u_world), u_image: new o.aH(h, e.u_image), u_color_ramp: new o.aH(h, e.u_color_ramp), u_opacity: new o.aI(h, e.u_opacity) }), hillshade: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_image: new o.aH(h, e.u_image), u_latrange: new o.aO(h, e.u_latrange), u_light: new o.aO(h, e.u_light), u_shadow: new o.aL(h, e.u_shadow), u_highlight: new o.aL(h, e.u_highlight), u_accent: new o.aL(h, e.u_accent) }), hillshadePrepare: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_image: new o.aH(h, e.u_image), u_dimension: new o.aO(h, e.u_dimension), u_zoom: new o.aI(h, e.u_zoom), u_unpack: new o.aK(h, e.u_unpack) }), line: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_ratio: new o.aI(h, e.u_ratio), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_units_to_pixels: new o.aO(h, e.u_units_to_pixels) }), lineGradient: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_ratio: new o.aI(h, e.u_ratio), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_units_to_pixels: new o.aO(h, e.u_units_to_pixels), u_image: new o.aH(h, e.u_image), u_image_height: new o.aI(h, e.u_image_height) }), linePattern: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_texsize: new o.aO(h, e.u_texsize), u_ratio: new o.aI(h, e.u_ratio), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_image: new o.aH(h, e.u_image), u_units_to_pixels: new o.aO(h, e.u_units_to_pixels), u_scale: new o.aN(h, e.u_scale), u_fade: new o.aI(h, e.u_fade) }), lineSDF: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_ratio: new o.aI(h, e.u_ratio), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_units_to_pixels: new o.aO(h, e.u_units_to_pixels), u_patternscale_a: new o.aO(h, e.u_patternscale_a), u_patternscale_b: new o.aO(h, e.u_patternscale_b), u_sdfgamma: new o.aI(h, e.u_sdfgamma), u_image: new o.aH(h, e.u_image), u_tex_y_a: new o.aI(h, e.u_tex_y_a), u_tex_y_b: new o.aI(h, e.u_tex_y_b), u_mix: new o.aI(h, e.u_mix) }), raster: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_tl_parent: new o.aO(h, e.u_tl_parent), u_scale_parent: new o.aI(h, e.u_scale_parent), u_buffer_scale: new o.aI(h, e.u_buffer_scale), u_fade_t: new o.aI(h, e.u_fade_t), u_opacity: new o.aI(h, e.u_opacity), u_image0: new o.aH(h, e.u_image0), u_image1: new o.aH(h, e.u_image1), u_brightness_low: new o.aI(h, e.u_brightness_low), u_brightness_high: new o.aI(h, e.u_brightness_high), u_saturation_factor: new o.aI(h, e.u_saturation_factor), u_contrast_factor: new o.aI(h, e.u_contrast_factor), u_spin_weights: new o.aN(h, e.u_spin_weights) }), symbolIcon: (h, e) => ({ u_is_size_zoom_constant: new o.aH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(h, e.u_is_size_feature_constant), u_size_t: new o.aI(h, e.u_size_t), u_size: new o.aI(h, e.u_size), u_camera_to_center_distance: new o.aI(h, e.u_camera_to_center_distance), u_pitch: new o.aI(h, e.u_pitch), u_rotate_symbol: new o.aH(h, e.u_rotate_symbol), u_aspect_ratio: new o.aI(h, e.u_aspect_ratio), u_fade_change: new o.aI(h, e.u_fade_change), u_matrix: new o.aJ(h, e.u_matrix), u_label_plane_matrix: new o.aJ(h, e.u_label_plane_matrix), u_coord_matrix: new o.aJ(h, e.u_coord_matrix), u_is_text: new o.aH(h, e.u_is_text), u_pitch_with_map: new o.aH(h, e.u_pitch_with_map), u_is_along_line: new o.aH(h, e.u_is_along_line), u_is_variable_anchor: new o.aH(h, e.u_is_variable_anchor), u_texsize: new o.aO(h, e.u_texsize), u_texture: new o.aH(h, e.u_texture), u_translation: new o.aO(h, e.u_translation), u_pitched_scale: new o.aI(h, e.u_pitched_scale) }), symbolSDF: (h, e) => ({ u_is_size_zoom_constant: new o.aH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(h, e.u_is_size_feature_constant), u_size_t: new o.aI(h, e.u_size_t), u_size: new o.aI(h, e.u_size), u_camera_to_center_distance: new o.aI(h, e.u_camera_to_center_distance), u_pitch: new o.aI(h, e.u_pitch), u_rotate_symbol: new o.aH(h, e.u_rotate_symbol), u_aspect_ratio: new o.aI(h, e.u_aspect_ratio), u_fade_change: new o.aI(h, e.u_fade_change), u_matrix: new o.aJ(h, e.u_matrix), u_label_plane_matrix: new o.aJ(h, e.u_label_plane_matrix), u_coord_matrix: new o.aJ(h, e.u_coord_matrix), u_is_text: new o.aH(h, e.u_is_text), u_pitch_with_map: new o.aH(h, e.u_pitch_with_map), u_is_along_line: new o.aH(h, e.u_is_along_line), u_is_variable_anchor: new o.aH(h, e.u_is_variable_anchor), u_texsize: new o.aO(h, e.u_texsize), u_texture: new o.aH(h, e.u_texture), u_gamma_scale: new o.aI(h, e.u_gamma_scale), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_is_halo: new o.aH(h, e.u_is_halo), u_translation: new o.aO(h, e.u_translation), u_pitched_scale: new o.aI(h, e.u_pitched_scale) }), symbolTextAndIcon: (h, e) => ({ u_is_size_zoom_constant: new o.aH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(h, e.u_is_size_feature_constant), u_size_t: new o.aI(h, e.u_size_t), u_size: new o.aI(h, e.u_size), u_camera_to_center_distance: new o.aI(h, e.u_camera_to_center_distance), u_pitch: new o.aI(h, e.u_pitch), u_rotate_symbol: new o.aH(h, e.u_rotate_symbol), u_aspect_ratio: new o.aI(h, e.u_aspect_ratio), u_fade_change: new o.aI(h, e.u_fade_change), u_matrix: new o.aJ(h, e.u_matrix), u_label_plane_matrix: new o.aJ(h, e.u_label_plane_matrix), u_coord_matrix: new o.aJ(h, e.u_coord_matrix), u_is_text: new o.aH(h, e.u_is_text), u_pitch_with_map: new o.aH(h, e.u_pitch_with_map), u_is_along_line: new o.aH(h, e.u_is_along_line), u_is_variable_anchor: new o.aH(h, e.u_is_variable_anchor), u_texsize: new o.aO(h, e.u_texsize), u_texsize_icon: new o.aO(h, e.u_texsize_icon), u_texture: new o.aH(h, e.u_texture), u_texture_icon: new o.aH(h, e.u_texture_icon), u_gamma_scale: new o.aI(h, e.u_gamma_scale), u_device_pixel_ratio: new o.aI(h, e.u_device_pixel_ratio), u_is_halo: new o.aH(h, e.u_is_halo), u_translation: new o.aO(h, e.u_translation), u_pitched_scale: new o.aI(h, e.u_pitched_scale) }), background: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_opacity: new o.aI(h, e.u_opacity), u_color: new o.aL(h, e.u_color) }), backgroundPattern: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_opacity: new o.aI(h, e.u_opacity), u_image: new o.aH(h, e.u_image), u_pattern_tl_a: new o.aO(h, e.u_pattern_tl_a), u_pattern_br_a: new o.aO(h, e.u_pattern_br_a), u_pattern_tl_b: new o.aO(h, e.u_pattern_tl_b), u_pattern_br_b: new o.aO(h, e.u_pattern_br_b), u_texsize: new o.aO(h, e.u_texsize), u_mix: new o.aI(h, e.u_mix), u_pattern_size_a: new o.aO(h, e.u_pattern_size_a), u_pattern_size_b: new o.aO(h, e.u_pattern_size_b), u_scale_a: new o.aI(h, e.u_scale_a), u_scale_b: new o.aI(h, e.u_scale_b), u_pixel_coord_upper: new o.aO(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.aO(h, e.u_pixel_coord_lower), u_tile_units_to_pixels: new o.aI(h, e.u_tile_units_to_pixels) }), terrain: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_texture: new o.aH(h, e.u_texture), u_ele_delta: new o.aI(h, e.u_ele_delta), u_fog_matrix: new o.aJ(h, e.u_fog_matrix), u_fog_color: new o.aL(h, e.u_fog_color), u_fog_ground_blend: new o.aI(h, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new o.aI(h, e.u_fog_ground_blend_opacity), u_horizon_color: new o.aL(h, e.u_horizon_color), u_horizon_fog_blend: new o.aI(h, e.u_horizon_fog_blend) }), terrainDepth: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_ele_delta: new o.aI(h, e.u_ele_delta) }), terrainCoords: (h, e) => ({ u_matrix: new o.aJ(h, e.u_matrix), u_texture: new o.aH(h, e.u_texture), u_terrain_coords_id: new o.aI(h, e.u_terrain_coords_id), u_ele_delta: new o.aI(h, e.u_ele_delta) }), sky: (h, e) => ({ u_sky_color: new o.aL(h, e.u_sky_color), u_horizon_color: new o.aL(h, e.u_horizon_color), u_horizon: new o.aI(h, e.u_horizon), u_sky_horizon_blend: new o.aI(h, e.u_sky_horizon_blend) }) };
      class un {
        constructor(e, r, u) {
          this.context = e;
          const d = e.gl;
          this.buffer = d.createBuffer(), this.dynamicDraw = !!u, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e) {
          const r = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Ll = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class mo {
        constructor(e, r, u, d) {
          this.length = r.length, this.attributes = u, this.itemSize = r.bytesPerElement, this.dynamicDraw = d, this.context = e;
          const p = e.gl;
          this.buffer = p.createBuffer(), e.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e) {
          if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
          const r = this.context.gl;
          this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        enableAttributes(e, r) {
          for (let u = 0; u < this.attributes.length; u++) {
            const d = r.attributes[this.attributes[u].name];
            d !== void 0 && e.enableVertexAttribArray(d);
          }
        }
        setVertexAttribPointers(e, r, u) {
          for (let d = 0; d < this.attributes.length; d++) {
            const p = this.attributes[d], w = r.attributes[p.name];
            w !== void 0 && e.vertexAttribPointer(w, p.components, e[Ll[p.type]], !1, this.itemSize, p.offset + this.itemSize * (u || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Es = /* @__PURE__ */ new WeakMap();
      function us(h) {
        var e;
        if (Es.has(h)) return Es.get(h);
        {
          const r = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
          return Es.set(h, r), r;
        }
      }
      class Di {
        constructor(e) {
          this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(e) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class cs extends Di {
        getDefault() {
          return o.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class lu extends Di {
        getDefault() {
          return 1;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
        }
      }
      class kn extends Di {
        getDefault() {
          return 0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
        }
      }
      class hs extends Di {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class go extends Di {
        getDefault() {
          return !0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
        }
      }
      class Oa extends Di {
        getDefault() {
          return 255;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
        }
      }
      class Ml extends Di {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e) {
          const r = this.current;
          (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
        }
      }
      class fa extends Di {
        getDefault() {
          const e = this.gl;
          return [e.KEEP, e.KEEP, e.KEEP];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
        }
      }
      class Nl extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1;
        }
      }
      class _o extends Di {
        getDefault() {
          return [0, 1];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class yo extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1;
        }
      }
      class il extends Di {
        getDefault() {
          return this.gl.LESS;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
        }
      }
      class jn extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1;
        }
      }
      class vo extends Di {
        getDefault() {
          const e = this.gl;
          return [e.ONE, e.ZERO];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class rl extends Di {
        getDefault() {
          return o.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class nl extends Di {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
        }
      }
      class ja extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1;
        }
      }
      class bo extends Di {
        getDefault() {
          return this.gl.BACK;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
        }
      }
      class Cs extends Di {
        getDefault() {
          return this.gl.CCW;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
        }
      }
      class sl extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
        }
      }
      class ma extends Di {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
        }
      }
      class xo extends Di {
        getDefault() {
          const e = this.gl;
          return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class I extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class K extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Ee extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1;
        }
      }
      class Re extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Ye extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          const r = this.gl;
          r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class ct extends Di {
        getDefault() {
          return null;
        }
        set(e) {
          var r;
          if (e === this.current && !this.dirty) return;
          const u = this.gl;
          us(u) ? u.bindVertexArray(e) : (r = u.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
        }
      }
      class Dt extends Di {
        getDefault() {
          return 4;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
        }
      }
      class Ut extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class ui extends Di {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class bi extends Di {
        constructor(e, r) {
          super(e), this.context = e, this.parent = r;
        }
        getDefault() {
          return null;
        }
      }
      class Ci extends bi {
        setDirty() {
          this.dirty = !0;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
        }
      }
      class Ii extends bi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class nr extends bi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Er {
        constructor(e, r, u, d, p) {
          this.context = e, this.width = r, this.height = u;
          const w = e.gl, A = this.framebuffer = w.createFramebuffer();
          if (this.colorAttachment = new Ci(e, A), d) this.depthAttachment = p ? new nr(e, A) : new Ii(e, A);
          else if (p) throw new Error("Stencil cannot be set without depth");
          if (w.checkFramebufferStatus(w.FRAMEBUFFER) !== w.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const e = this.context.gl, r = this.colorAttachment.get();
          if (r && e.deleteTexture(r), this.depthAttachment) {
            const u = this.depthAttachment.get();
            u && e.deleteRenderbuffer(u);
          }
          e.deleteFramebuffer(this.framebuffer);
        }
      }
      class Ti {
        constructor(e, r, u) {
          this.blendFunction = e, this.blendColor = r, this.mask = u;
        }
      }
      Ti.Replace = [1, 0], Ti.disabled = new Ti(Ti.Replace, o.aM.transparent, [!1, !1, !1, !1]), Ti.unblended = new Ti(Ti.Replace, o.aM.transparent, [!0, !0, !0, !0]), Ti.alphaBlended = new Ti([1, 771], o.aM.transparent, [!0, !0, !0, !0]);
      class Yr {
        constructor(e) {
          var r, u;
          if (this.gl = e, this.clearColor = new cs(this), this.clearDepth = new lu(this), this.clearStencil = new kn(this), this.colorMask = new hs(this), this.depthMask = new go(this), this.stencilMask = new Oa(this), this.stencilFunc = new Ml(this), this.stencilOp = new fa(this), this.stencilTest = new Nl(this), this.depthRange = new _o(this), this.depthTest = new yo(this), this.depthFunc = new il(this), this.blend = new jn(this), this.blendFunc = new vo(this), this.blendColor = new rl(this), this.blendEquation = new nl(this), this.cullFace = new ja(this), this.cullFaceSide = new bo(this), this.frontFace = new Cs(this), this.program = new sl(this), this.activeTexture = new ma(this), this.viewport = new xo(this), this.bindFramebuffer = new I(this), this.bindRenderbuffer = new K(this), this.bindTexture = new Ee(this), this.bindVertexBuffer = new Re(this), this.bindElementBuffer = new Ye(this), this.bindVertexArray = new ct(this), this.pixelStoreUnpack = new Dt(this), this.pixelStoreUnpackPremultiplyAlpha = new Ut(this), this.pixelStoreUnpackFlipY = new ui(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), us(e)) {
            this.HALF_FLOAT = e.HALF_FLOAT;
            const d = e.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : d == null ? void 0 : d.RGBA16F_EXT, this.RGB16F = (u = e.RGB16F) !== null && u !== void 0 ? u : d == null ? void 0 : d.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
          } else {
            e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
            const d = e.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = d == null ? void 0 : d.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(e, r) {
          return new un(this, e, r);
        }
        createVertexBuffer(e, r, u) {
          return new mo(this, e, r, u);
        }
        createRenderbuffer(e, r, u) {
          const d = this.gl, p = d.createRenderbuffer();
          return this.bindRenderbuffer.set(p), d.renderbufferStorage(d.RENDERBUFFER, e, r, u), this.bindRenderbuffer.set(null), p;
        }
        createFramebuffer(e, r, u, d) {
          return new Er(this, e, r, u, d);
        }
        clear({ color: e, depth: r, stencil: u }) {
          const d = this.gl;
          let p = 0;
          e && (p |= d.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (p |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), u !== void 0 && (p |= d.STENCIL_BUFFER_BIT, this.clearStencil.set(u), this.stencilMask.set(255)), d.clear(p);
        }
        setCullFace(e) {
          e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
        }
        setDepthMode(e) {
          e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
        }
        setStencilMode(e) {
          e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(e) {
          o.aE(e.blendFunction, Ti.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
        }
        createVertexArray() {
          var e;
          return us(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
        }
        deleteVertexArray(e) {
          var r;
          return us(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class oi {
        constructor(e, r, u) {
          this.func = e, this.mask = r, this.range = u;
        }
      }
      oi.ReadOnly = !1, oi.ReadWrite = !0, oi.disabled = new oi(519, oi.ReadOnly, [0, 1]);
      const yn = 7680;
      class Mi {
        constructor(e, r, u, d, p, w) {
          this.test = e, this.ref = r, this.mask = u, this.fail = d, this.depthFail = p, this.pass = w;
        }
      }
      Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, yn, yn, yn);
      class zi {
        constructor(e, r, u) {
          this.enable = e, this.mode = r, this.frontFace = u;
        }
      }
      let Ts;
      function Hs(h, e, r, u, d) {
        const p = h.context, w = p.gl, A = h.useProgram("collisionBox"), C = [];
        let P = 0, F = 0;
        for (let le = 0; le < u.length; le++) {
          const de = u[le], ce = e.getTile(de).getBucket(r);
          if (!ce) continue;
          const we = d ? ce.textCollisionBox : ce.iconCollisionBox, Le = ce.collisionCircleArray;
          if (Le.length > 0) {
            const Ie = o.H();
            o.aQ(Ie, ce.placementInvProjMatrix, h.transform.glCoordMatrix), o.aQ(Ie, Ie, ce.placementViewportMatrix), C.push({ circleArray: Le, circleOffset: F, transform: de.posMatrix, invTransform: Ie, coord: de }), P += Le.length / 4, F = P;
          }
          we && A.draw(p, w.LINES, oi.disabled, Mi.disabled, h.colorModeForRenderPass(), zi.disabled, { u_matrix: de.posMatrix, u_pixel_extrude_scale: [1 / (N = h.transform).width, 1 / N.height] }, h.style.map.terrain && h.style.map.terrain.getTerrainData(de), r.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, null, h.transform.zoom, null, null, we.collisionVertexBuffer);
        }
        var N;
        if (!d || !C.length) return;
        const Z = h.useProgram("collisionCircle"), G = new o.aR();
        G.resize(4 * P), G._trim();
        let V = 0;
        for (const le of C) for (let de = 0; de < le.circleArray.length / 4; de++) {
          const ce = 4 * de, we = le.circleArray[ce + 0], Le = le.circleArray[ce + 1], Ie = le.circleArray[ce + 2], it = le.circleArray[ce + 3];
          G.emplace(V++, we, Le, Ie, it, 0), G.emplace(V++, we, Le, Ie, it, 1), G.emplace(V++, we, Le, Ie, it, 2), G.emplace(V++, we, Le, Ie, it, 3);
        }
        (!Ts || Ts.length < 2 * P) && (Ts = function(le) {
          const de = 2 * le, ce = new o.aT();
          ce.resize(de), ce._trim();
          for (let we = 0; we < de; we++) {
            const Le = 6 * we;
            ce.uint16[Le + 0] = 4 * we + 0, ce.uint16[Le + 1] = 4 * we + 1, ce.uint16[Le + 2] = 4 * we + 2, ce.uint16[Le + 3] = 4 * we + 2, ce.uint16[Le + 4] = 4 * we + 3, ce.uint16[Le + 5] = 4 * we + 0;
          }
          return ce;
        }(P));
        const W = p.createIndexBuffer(Ts, !0), se = p.createVertexBuffer(G, o.aS.members, !0);
        for (const le of C) {
          const de = wr(le.transform, le.invTransform, h.transform);
          Z.draw(p, w.TRIANGLES, oi.disabled, Mi.disabled, h.colorModeForRenderPass(), zi.disabled, de, h.style.map.terrain && h.style.map.terrain.getTerrainData(le.coord), r.id, se, W, o.a0.simpleSegment(0, 2 * le.circleOffset, le.circleArray.length, le.circleArray.length / 2), null, h.transform.zoom, null, null, null);
        }
        se.destroy(), W.destroy();
      }
      zi.disabled = new zi(!1, 1029, 2305), zi.backCCW = new zi(!0, 1029, 2305);
      const Ws = o.an(new Float32Array(16));
      function ga(h, e, r, u, d, p) {
        const { horizontalAlign: w, verticalAlign: A } = o.au(h);
        return new o.P((-(w - 0.5) * e / d + u[0]) * p, (-(A - 0.5) * r / d + u[1]) * p);
      }
      function ds(h, e, r, u, d, p) {
        const w = e.tileAnchorPoint.add(new o.P(e.translation[0], e.translation[1]));
        if (e.pitchWithMap) {
          let A = u.mult(p);
          r || (A = A.rotate(-d));
          const C = w.add(A);
          return $(C.x, C.y, e.labelPlaneMatrix, e.getElevation).point;
        }
        if (r) {
          const A = tt(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h), C = Math.atan(A.y / A.x) + (A.x < 0 ? Math.PI : 0);
          return h.add(u.rotate(C));
        }
        return h.add(u);
      }
      function ks(h, e, r, u, d, p, w, A, C, P, F, N, Z, G) {
        const V = h.text.placedSymbolArray, W = h.text.dynamicLayoutVertexArray, se = h.icon.dynamicLayoutVertexArray, le = {};
        W.clear();
        for (let de = 0; de < V.length; de++) {
          const ce = V.get(de), we = ce.hidden || !ce.crossTileID || h.allowVerticalPlacement && !ce.placedOrientation ? null : u[ce.crossTileID];
          if (we) {
            const Le = new o.P(ce.anchorX, ce.anchorY), Ie = { getElevation: G, width: d.width, height: d.height, labelPlaneMatrix: p, lineVertexArray: null, pitchWithMap: r, projection: F, projectionCache: null, tileAnchorPoint: Le, translation: N, unwrappedTileID: Z }, it = r ? $(Le.x, Le.y, w, G) : tt(Le.x, Le.y, Ie), ht = B(d.cameraToCenterDistance, it.signedDistanceFromCamera);
            let _t = o.ai(h.textSizeData, C, ce) * ht / o.ap;
            r && (_t *= h.tilePixelRatio / A);
            const { width: wt, height: bt, anchor: yt, textOffset: St, textBoxScale: Zt } = we, Tt = ga(yt, wt, bt, St, Zt, _t), kt = F.getPitchedTextCorrection(d, Le.add(new o.P(N[0], N[1])), Z), Wt = ds(it.point, Ie, e, Tt, d.angle, kt), di = h.allowVerticalPlacement && ce.placedOrientation === o.ah.vertical ? Math.PI / 2 : 0;
            for (let ci = 0; ci < ce.numGlyphs; ci++) o.aj(W, Wt, di);
            P && ce.associatedIconIndex >= 0 && (le[ce.associatedIconIndex] = { shiftedAnchor: Wt, angle: di });
          } else $t(ce.numGlyphs, W);
        }
        if (P) {
          se.clear();
          const de = h.icon.placedSymbolArray;
          for (let ce = 0; ce < de.length; ce++) {
            const we = de.get(ce);
            if (we.hidden) $t(we.numGlyphs, se);
            else {
              const Le = le[ce];
              if (Le) for (let Ie = 0; Ie < we.numGlyphs; Ie++) o.aj(se, Le.shiftedAnchor, Le.angle);
              else $t(we.numGlyphs, se);
            }
          }
          h.icon.dynamicLayoutVertexBuffer.updateData(se);
        }
        h.text.dynamicLayoutVertexBuffer.updateData(W);
      }
      function Ur(h, e, r) {
        return r.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon";
      }
      function Jr(h, e, r, u, d, p, w, A, C, P, F, N) {
        const Z = h.context, G = Z.gl, V = h.transform, W = On(), se = A === "map", le = C === "map", de = A !== "viewport" && r.layout.get("symbol-placement") !== "point", ce = se && !le && !de, we = !le && de, Le = !r.layout.get("symbol-sort-key").isConstant();
        let Ie = !1;
        const it = h.depthModeForSublayer(0, oi.ReadOnly), ht = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), _t = [], wt = W.getCircleRadiusCorrection(V);
        for (const bt of u) {
          const yt = e.getTile(bt), St = yt.getBucket(r);
          if (!St) continue;
          const Zt = d ? St.text : St.icon;
          if (!Zt || !Zt.segments.get().length || !Zt.hasVisibleVertices) continue;
          const Tt = Zt.programConfigurations.get(r.id), kt = d || St.sdfIcons, Wt = d ? St.textSizeData : St.iconSizeData, di = le || V.pitch !== 0, ci = h.useProgram(Ur(kt, d, St), Tt), gi = o.ag(Wt, V.zoom), Ei = h.style.map.terrain && h.style.map.terrain.getTerrainData(bt);
          let qi, sr, Fi, yr, Ui = [0, 0], pr = null;
          if (d) sr = yt.glyphAtlasTexture, Fi = G.LINEAR, qi = yt.glyphAtlasTexture.size, St.iconsInText && (Ui = yt.imageAtlasTexture.size, pr = yt.imageAtlasTexture, yr = di || h.options.rotating || h.options.zooming || Wt.kind === "composite" || Wt.kind === "camera" ? G.LINEAR : G.NEAREST);
          else {
            const Li = r.layout.get("icon-size").constantOr(0) !== 1 || St.iconsNeedLinear;
            sr = yt.imageAtlasTexture, Fi = kt || h.options.rotating || h.options.zooming || Li || di ? G.LINEAR : G.NEAREST, qi = yt.imageAtlasTexture.size;
          }
          const kr = fi(yt, 1, h.transform.zoom), pn = we ? bt.posMatrix : Ws, Mn = ie(pn, le, se, h.transform, kr), ar = ue(pn, le, se, h.transform, kr), Ea = ue(bt.posMatrix, le, se, h.transform, kr), Nn = W.translatePosition(h.transform, yt, p, w), gl = ht && St.hasTextData(), Po = r.layout.get("icon-text-fit") !== "none" && gl && St.hasIconData();
          if (de) {
            const Li = h.style.map.terrain ? (Ca, ea) => h.style.map.terrain.getElevation(bt, Ca, ea) : null, zs = r.layout.get("text-rotation-alignment") === "map";
            te(St, bt.posMatrix, h, d, Mn, Ea, le, P, zs, W, bt.toUnwrapped(), V.width, V.height, Nn, Li);
          }
          const en = bt.posMatrix, fn = d && ht || Po, Rr = de || fn ? Ws : Mn, tn = ar, Ar = kt && r.paint.get(d ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Vr;
          Vr = kt ? St.iconsInText ? Ss(Wt.kind, gi, ce, le, de, fn, h, en, Rr, tn, Nn, qi, Ui, wt) : ls(Wt.kind, gi, ce, le, de, fn, h, en, Rr, tn, Nn, d, qi, !0, wt) : po(Wt.kind, gi, ce, le, de, fn, h, en, Rr, tn, Nn, d, qi, wt);
          const rn = { program: ci, buffers: Zt, uniformValues: Vr, atlasTexture: sr, atlasTextureIcon: pr, atlasInterpolation: Fi, atlasInterpolationIcon: yr, isSDF: kt, hasHalo: Ar };
          if (Le && St.canOverlap) {
            Ie = !0;
            const Li = Zt.segments.get();
            for (const zs of Li) _t.push({ segments: new o.a0([zs]), sortKey: zs.sortKey, state: rn, terrainData: Ei });
          } else _t.push({ segments: Zt.segments, sortKey: 0, state: rn, terrainData: Ei });
        }
        Ie && _t.sort((bt, yt) => bt.sortKey - yt.sortKey);
        for (const bt of _t) {
          const yt = bt.state;
          if (Z.activeTexture.set(G.TEXTURE0), yt.atlasTexture.bind(yt.atlasInterpolation, G.CLAMP_TO_EDGE), yt.atlasTextureIcon && (Z.activeTexture.set(G.TEXTURE1), yt.atlasTextureIcon && yt.atlasTextureIcon.bind(yt.atlasInterpolationIcon, G.CLAMP_TO_EDGE)), yt.isSDF) {
            const St = yt.uniformValues;
            yt.hasHalo && (St.u_is_halo = 1, _a(yt.buffers, bt.segments, r, h, yt.program, it, F, N, St, bt.terrainData)), St.u_is_halo = 0;
          }
          _a(yt.buffers, bt.segments, r, h, yt.program, it, F, N, yt.uniformValues, bt.terrainData);
        }
      }
      function _a(h, e, r, u, d, p, w, A, C, P) {
        const F = u.context;
        d.draw(F, F.gl.TRIANGLES, p, w, A, zi.disabled, C, P, r.id, h.layoutVertexBuffer, h.indexBuffer, e, r.paint, u.transform.zoom, h.programConfigurations.get(r.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer);
      }
      function ya(h, e, r, u) {
        const d = h.context, p = d.gl, w = Mi.disabled, A = new Ti([p.ONE, p.ONE], o.aM.transparent, [!0, !0, !0, !0]), C = e.getBucket(r);
        if (!C) return;
        const P = u.key;
        let F = r.heatmapFbos.get(P);
        F || (F = Xs(d, e.tileSize, e.tileSize), r.heatmapFbos.set(P, F)), d.bindFramebuffer.set(F.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({ color: o.aM.transparent });
        const N = C.programConfigurations.get(r.id), Z = h.useProgram("heatmap", N), G = h.style.map.terrain.getTerrainData(u);
        Z.draw(d, p.TRIANGLES, oi.disabled, w, A, zi.disabled, ai(u.posMatrix, e, h.transform.zoom, r.paint.get("heatmap-intensity")), G, r.id, C.layoutVertexBuffer, C.indexBuffer, C.segments, r.paint, h.transform.zoom, N);
      }
      function qn(h, e, r) {
        const u = h.context, d = u.gl;
        u.setColorMode(h.colorModeForRenderPass());
        const p = Fr(u, e), w = r.key, A = e.heatmapFbos.get(w);
        A && (u.activeTexture.set(d.TEXTURE0), d.bindTexture(d.TEXTURE_2D, A.colorAttachment.get()), u.activeTexture.set(d.TEXTURE1), p.bind(d.LINEAR, d.CLAMP_TO_EDGE), h.useProgram("heatmapTexture").draw(u, d.TRIANGLES, oi.disabled, Mi.disabled, h.colorModeForRenderPass(), zi.disabled, lo(h, e, 0, 1), null, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, h.transform.zoom), A.destroy(), e.heatmapFbos.delete(w));
      }
      function Xs(h, e, r) {
        var u, d;
        const p = h.gl, w = p.createTexture();
        p.bindTexture(p.TEXTURE_2D, w), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.LINEAR);
        const A = (u = h.HALF_FLOAT) !== null && u !== void 0 ? u : p.UNSIGNED_BYTE, C = (d = h.RGBA16F) !== null && d !== void 0 ? d : p.RGBA;
        p.texImage2D(p.TEXTURE_2D, 0, C, e, r, 0, p.RGBA, A, null);
        const P = h.createFramebuffer(e, r, !1, !1);
        return P.colorAttachment.set(w), P;
      }
      function Fr(h, e) {
        return e.colorRampTexture || (e.colorRampTexture = new X(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture;
      }
      function va(h, e, r, u, d) {
        if (!r || !u || !u.imageAtlas) return;
        const p = u.imageAtlas.patternPositions;
        let w = p[r.to.toString()], A = p[r.from.toString()];
        if (!w && A && (w = A), !A && w && (A = w), !w || !A) {
          const C = d.getPaintProperty(e);
          w = p[C], A = p[C];
        }
        w && A && h.setConstantPatternPositions(w, A);
      }
      function Ys(h, e, r, u, d, p, w) {
        const A = h.context.gl, C = "fill-pattern", P = r.paint.get(C), F = P && P.constantOr(1), N = r.getCrossfadeParameters();
        let Z, G, V, W, se;
        w ? (G = F && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Z = A.LINES) : (G = F ? "fillPattern" : "fill", Z = A.TRIANGLES);
        const le = P.constantOr(null);
        for (const de of u) {
          const ce = e.getTile(de);
          if (F && !ce.patternsLoaded()) continue;
          const we = ce.getBucket(r);
          if (!we) continue;
          const Le = we.programConfigurations.get(r.id), Ie = h.useProgram(G, Le), it = h.style.map.terrain && h.style.map.terrain.getTerrainData(de);
          F && (h.context.activeTexture.set(A.TEXTURE0), ce.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), Le.updatePaintBuffers(N)), va(Le, C, le, ce, r);
          const ht = it ? de : null, _t = h.translatePosMatrix(ht ? ht.posMatrix : de.posMatrix, ce, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
          if (w) {
            W = we.indexBuffer2, se = we.segments2;
            const wt = [A.drawingBufferWidth, A.drawingBufferHeight];
            V = G === "fillOutlinePattern" && F ? Fa(_t, h, N, ce, wt) : oo(_t, wt);
          } else W = we.indexBuffer, se = we.segments, V = F ? As(_t, h, N, ce) : pa(_t);
          Ie.draw(h.context, Z, d, h.stencilModeForClipping(de), p, zi.disabled, V, it, r.id, we.layoutVertexBuffer, W, se, r.paint, h.transform.zoom, Le);
        }
      }
      function qa(h, e, r, u, d, p, w) {
        const A = h.context, C = A.gl, P = "fill-extrusion-pattern", F = r.paint.get(P), N = F.constantOr(1), Z = r.getCrossfadeParameters(), G = r.paint.get("fill-extrusion-opacity"), V = F.constantOr(null);
        for (const W of u) {
          const se = e.getTile(W), le = se.getBucket(r);
          if (!le) continue;
          const de = h.style.map.terrain && h.style.map.terrain.getTerrainData(W), ce = le.programConfigurations.get(r.id), we = h.useProgram(N ? "fillExtrusionPattern" : "fillExtrusion", ce);
          N && (h.context.activeTexture.set(C.TEXTURE0), se.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), ce.updatePaintBuffers(Z)), va(ce, P, V, se, r);
          const Le = h.translatePosMatrix(W.posMatrix, se, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), Ie = r.paint.get("fill-extrusion-vertical-gradient"), it = N ? ao(Le, h, Ie, G, W, Z, se) : za(Le, h, Ie, G);
          we.draw(A, A.gl.TRIANGLES, d, p, w, zi.backCCW, it, de, r.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, r.paint, h.transform.zoom, ce, h.style.map.terrain && le.centroidVertexBuffer);
        }
      }
      function Kr(h, e, r, u, d, p, w) {
        const A = h.context, C = A.gl, P = r.fbo;
        if (!P) return;
        const F = h.useProgram("hillshade"), N = h.style.map.terrain && h.style.map.terrain.getTerrainData(e);
        A.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, P.colorAttachment.get()), F.draw(A, C.TRIANGLES, d, p, w, zi.disabled, ((Z, G, V, W) => {
          const se = V.paint.get("hillshade-shadow-color"), le = V.paint.get("hillshade-highlight-color"), de = V.paint.get("hillshade-accent-color");
          let ce = V.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          V.paint.get("hillshade-illumination-anchor") === "viewport" && (ce -= Z.transform.angle);
          const we = !Z.options.moving;
          return { u_matrix: W ? W.posMatrix : Z.transform.calculatePosMatrix(G.tileID.toUnwrapped(), we), u_image: 0, u_latrange: uo(0, G.tileID), u_light: [V.paint.get("hillshade-exaggeration"), ce], u_shadow: se, u_highlight: le, u_accent: de };
        })(h, r, u, N ? e : null), N, u.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments);
      }
      function Ds(h, e, r, u, d, p) {
        const w = h.context, A = w.gl, C = e.dem;
        if (C && C.data) {
          const P = C.dim, F = C.stride, N = C.getPixels();
          if (w.activeTexture.set(A.TEXTURE1), w.pixelStoreUnpackPremultiplyAlpha.set(!1), e.demTexture = e.demTexture || h.getTileTexture(F), e.demTexture) {
            const G = e.demTexture;
            G.update(N, { premultiply: !1 }), G.bind(A.NEAREST, A.CLAMP_TO_EDGE);
          } else e.demTexture = new X(w, N, A.RGBA, { premultiply: !1 }), e.demTexture.bind(A.NEAREST, A.CLAMP_TO_EDGE);
          w.activeTexture.set(A.TEXTURE0);
          let Z = e.fbo;
          if (!Z) {
            const G = new X(w, { width: P, height: P, data: null }, A.RGBA);
            G.bind(A.LINEAR, A.CLAMP_TO_EDGE), Z = e.fbo = w.createFramebuffer(P, P, !0, !1), Z.colorAttachment.set(G.texture);
          }
          w.bindFramebuffer.set(Z.framebuffer), w.viewport.set([0, 0, P, P]), h.useProgram("hillshadePrepare").draw(w, A.TRIANGLES, u, d, p, zi.disabled, ((G, V) => {
            const W = V.stride, se = o.H();
            return o.aP(se, 0, o.X, -o.X, 0, 0, 1), o.J(se, se, [0, -o.X, 0]), { u_matrix: se, u_image: 1, u_dimension: [W, W], u_zoom: G.overscaledZ, u_unpack: V.getUnpackVector() };
          })(e.tileID, C), null, r.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments), e.needsHillshadePrepare = !1;
        }
      }
      function zl(h, e, r, u, d, p) {
        const w = u.paint.get("raster-fade-duration");
        if (!p && w > 0) {
          const A = j.now(), C = (A - h.timeAdded) / w, P = e ? (A - e.timeAdded) / w : -1, F = r.getSource(), N = d.coveringZoomLevel({ tileSize: F.tileSize, roundZoom: F.roundZoom }), Z = !e || Math.abs(e.tileID.overscaledZ - N) > Math.abs(h.tileID.overscaledZ - N), G = Z && h.refreshedUponExpiration ? 1 : o.ac(Z ? C : 1 - P, 0, 1);
          return h.refreshedUponExpiration && C >= 1 && (h.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - G } : { opacity: G, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const al = new o.aM(1, 0, 0, 1), ki = new o.aM(0, 1, 0, 1), cn = new o.aM(0, 0, 1, 1), ps = new o.aM(1, 0, 1, 1), Js = new o.aM(0, 1, 1, 1);
      function hn(h, e, r, u) {
        Ks(h, 0, e + r / 2, h.transform.width, r, u);
      }
      function Is(h, e, r, u) {
        Ks(h, e - r / 2, 0, r, h.transform.height, u);
      }
      function Ks(h, e, r, u, d, p) {
        const w = h.context, A = w.gl;
        A.enable(A.SCISSOR_TEST), A.scissor(e * h.pixelRatio, r * h.pixelRatio, u * h.pixelRatio, d * h.pixelRatio), w.clear({ color: p }), A.disable(A.SCISSOR_TEST);
      }
      function Un(h, e, r) {
        const u = h.context, d = u.gl, p = r.posMatrix, w = h.useProgram("debug"), A = oi.disabled, C = Mi.disabled, P = h.colorModeForRenderPass(), F = "$debug", N = h.style.map.terrain && h.style.map.terrain.getTerrainData(r);
        u.activeTexture.set(d.TEXTURE0);
        const Z = e.getTileByID(r.key).latestRawTileData, G = Math.floor((Z && Z.byteLength || 0) / 1024), V = e.getTile(r).tileSize, W = 512 / Math.min(V, 512) * (r.overscaledZ / h.transform.zoom) * 0.5;
        let se = r.canonical.toString();
        r.overscaledZ !== r.canonical.z && (se += ` => ${r.overscaledZ}`), function(le, de) {
          le.initDebugOverlayCanvas();
          const ce = le.debugOverlayCanvas, we = le.context.gl, Le = le.debugOverlayCanvas.getContext("2d");
          Le.clearRect(0, 0, ce.width, ce.height), Le.shadowColor = "white", Le.shadowBlur = 2, Le.lineWidth = 1.5, Le.strokeStyle = "white", Le.textBaseline = "top", Le.font = "bold 36px Open Sans, sans-serif", Le.fillText(de, 5, 5), Le.strokeText(de, 5, 5), le.debugOverlayTexture.update(ce), le.debugOverlayTexture.bind(we.LINEAR, we.CLAMP_TO_EDGE);
        }(h, `${se} ${G}kB`), w.draw(u, d.TRIANGLES, A, C, Ti.alphaBlended, zi.disabled, Ba(p, o.aM.transparent, W), null, F, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), w.draw(u, d.LINE_STRIP, A, C, P, zi.disabled, Ba(p, o.aM.red), N, F, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments);
      }
      function Ua(h, e, r) {
        const u = h.context, d = u.gl, p = h.colorModeForRenderPass(), w = new oi(d.LEQUAL, oi.ReadWrite, h.depthRangeFor3D), A = h.useProgram("terrain"), C = e.getTerrainMesh();
        u.bindFramebuffer.set(null), u.viewport.set([0, 0, h.width, h.height]);
        for (const P of r) {
          const F = h.renderToTexture.getTexture(P), N = e.getTerrainData(P.tileID);
          u.activeTexture.set(d.TEXTURE0), d.bindTexture(d.TEXTURE_2D, F.texture);
          const Z = h.transform.calculatePosMatrix(P.tileID.toUnwrapped()), G = e.getMeshFrameDelta(h.transform.zoom), V = h.transform.calculateFogMatrix(P.tileID.toUnwrapped()), W = Qo(Z, G, V, h.style.sky, h.transform.pitch);
          A.draw(u, d.TRIANGLES, w, Mi.disabled, p, zi.backCCW, W, N, "terrain", C.vertexBuffer, C.indexBuffer, C.segments);
        }
      }
      class ba {
        constructor(e, r, u) {
          this.vertexBuffer = e, this.indexBuffer = r, this.segments = u;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class fs {
        constructor(e, r) {
          this.context = new Yr(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: o.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Lt.maxUnderzooming + Lt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ko();
        }
        resize(e, r, u) {
          if (this.width = Math.floor(e * u), this.height = Math.floor(r * u), this.pixelRatio = u, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const d of this.style._order) this.style._layers[d].resize();
        }
        setup() {
          const e = this.context, r = new o.aX();
          r.emplaceBack(0, 0), r.emplaceBack(o.X, 0), r.emplaceBack(0, o.X), r.emplaceBack(o.X, o.X), this.tileExtentBuffer = e.createVertexBuffer(r, as.members), this.tileExtentSegments = o.a0.simpleSegment(0, 0, 4, 2);
          const u = new o.aX();
          u.emplaceBack(0, 0), u.emplaceBack(o.X, 0), u.emplaceBack(0, o.X), u.emplaceBack(o.X, o.X), this.debugBuffer = e.createVertexBuffer(u, as.members), this.debugSegments = o.a0.simpleSegment(0, 0, 4, 5);
          const d = new o.$();
          d.emplaceBack(0, 0, 0, 0), d.emplaceBack(o.X, 0, o.X, 0), d.emplaceBack(0, o.X, 0, o.X), d.emplaceBack(o.X, o.X, o.X, o.X), this.rasterBoundsBuffer = e.createVertexBuffer(d, Et.members), this.rasterBoundsSegments = o.a0.simpleSegment(0, 0, 4, 2);
          const p = new o.aX();
          p.emplaceBack(0, 0), p.emplaceBack(1, 0), p.emplaceBack(0, 1), p.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(p, as.members), this.viewportSegments = o.a0.simpleSegment(0, 0, 4, 2);
          const w = new o.aZ();
          w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(w);
          const A = new o.aY();
          A.emplaceBack(0, 1, 2), A.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(A);
          const C = this.context.gl;
          this.stencilClearMode = new Mi({ func: C.ALWAYS, mask: 0 }, 0, 255, C.ZERO, C.ZERO, C.ZERO);
        }
        clearStencil() {
          const e = this.context, r = e.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const u = o.H();
          o.aP(u, 0, this.width, this.height, 0, 0, 1), o.K(u, u, [r.drawingBufferWidth, r.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, r.TRIANGLES, oi.disabled, this.stencilClearMode, Ti.disabled, zi.disabled, qr(u), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(e, r) {
          if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
          this.currentStencilSource = e.source;
          const u = this.context, d = u.gl;
          this.nextStencilID + r.length > 256 && this.clearStencil(), u.setColorMode(Ti.disabled), u.setDepthMode(oi.disabled);
          const p = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const w of r) {
            const A = this._tileClippingMaskIDs[w.key] = this.nextStencilID++, C = this.style.map.terrain && this.style.map.terrain.getTerrainData(w);
            p.draw(u, d.TRIANGLES, oi.disabled, new Mi({ func: d.ALWAYS, mask: 0 }, A, 255, d.KEEP, d.KEEP, d.REPLACE), Ti.disabled, zi.disabled, qr(w.posMatrix), C, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e = this.nextStencilID++, r = this.context.gl;
          return new Mi({ func: r.NOTEQUAL, mask: 255 }, e, 255, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilModeForClipping(e) {
          const r = this.context.gl;
          return new Mi({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilConfigForOverlap(e) {
          const r = this.context.gl, u = e.sort((w, A) => A.overscaledZ - w.overscaledZ), d = u[u.length - 1].overscaledZ, p = u[0].overscaledZ - d + 1;
          if (p > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
            const w = {};
            for (let A = 0; A < p; A++) w[A + d] = new Mi({ func: r.GEQUAL, mask: 255 }, A + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
            return this.nextStencilID += p, [w, u];
          }
          return [{ [d]: Mi.disabled }, u];
        }
        colorModeForRenderPass() {
          const e = this.context.gl;
          return this._showOverdrawInspector ? new Ti([e.CONSTANT_COLOR, e.ONE], new o.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ti.unblended : Ti.alphaBlended;
        }
        depthModeForSublayer(e, r, u) {
          if (!this.opaquePassEnabledForLayer()) return oi.disabled;
          const d = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
          return new oi(u || this.context.gl.LEQUAL, r, [d, d]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e, r) {
          this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(j.now()), this.imageManager.beginFrame();
          const u = this.style._order, d = this.style.sourceCaches, p = {}, w = {}, A = {};
          for (const C in d) {
            const P = d[C];
            P.used && P.prepare(this.context), p[C] = P.getVisibleCoordinates(), w[C] = p[C].slice().reverse(), A[C] = P.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let C = 0; C < u.length; C++) if (this.style._layers[u[C]].is3D()) {
            this.opaquePassCutoff = C;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const C of u) {
            const P = this.style._layers[C];
            if (!P.hasOffscreenPass() || P.isHidden(this.transform.zoom)) continue;
            const F = w[P.source];
            (P.type === "custom" || F.length) && this.renderLayer(this, d[P.source], P, F);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? o.aM.black : o.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(C, P) {
            const F = C.context, N = F.gl, Z = ((le, de, ce) => ({ u_sky_color: le.properties.get("sky-color"), u_horizon_color: le.properties.get("horizon-color"), u_horizon: (de.height / 2 + de.getHorizon()) * ce, u_sky_horizon_blend: le.properties.get("sky-horizon-blend") * de.height / 2 * ce }))(P, C.style.map.transform, C.pixelRatio), G = new oi(N.LEQUAL, oi.ReadWrite, [0, 1]), V = Mi.disabled, W = C.colorModeForRenderPass(), se = C.useProgram("sky");
            if (!P.mesh) {
              const le = new o.aX();
              le.emplaceBack(-1, -1), le.emplaceBack(1, -1), le.emplaceBack(1, 1), le.emplaceBack(-1, 1);
              const de = new o.aY();
              de.emplaceBack(0, 1, 2), de.emplaceBack(0, 2, 3), P.mesh = new ba(F.createVertexBuffer(le, as.members), F.createIndexBuffer(de), o.a0.simpleSegment(0, 0, le.length, de.length));
            }
            se.draw(F, N.TRIANGLES, G, V, W, zi.disabled, Z, void 0, "sky", P.mesh.vertexBuffer, P.mesh.indexBuffer, P.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = u.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const C = this.style._layers[u[this.currentLayer]], P = d[C.source], F = p[C.source];
            this._renderTileClippingMasks(C, F), this.renderLayer(this, P, C, F);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < u.length; this.currentLayer++) {
            const C = this.style._layers[u[this.currentLayer]], P = d[C.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(C)) continue;
            const F = (C.type === "symbol" ? A : w)[C.source];
            this._renderTileClippingMasks(C, p[C.source]), this.renderLayer(this, P, C, F);
          }
          if (this.options.showTileBoundaries) {
            const C = function(P, F) {
              let N = null;
              const Z = Object.values(P._layers).flatMap((se) => se.source && !se.isHidden(F) ? [P.sourceCaches[se.source]] : []), G = Z.filter((se) => se.getSource().type === "vector"), V = Z.filter((se) => se.getSource().type !== "vector"), W = (se) => {
                (!N || N.getSource().maxzoom < se.getSource().maxzoom) && (N = se);
              };
              return G.forEach((se) => W(se)), N || V.forEach((se) => W(se)), N;
            }(this.style, this.transform.zoom);
            C && function(P, F, N) {
              for (let Z = 0; Z < N.length; Z++) Un(P, F, N[Z]);
            }(this, C, C.getVisibleCoordinates());
          }
          this.options.showPadding && function(C) {
            const P = C.transform.padding;
            hn(C, C.transform.height - (P.top || 0), 3, al), hn(C, P.bottom || 0, 3, ki), Is(C, P.left || 0, 3, cn), Is(C, C.transform.width - (P.right || 0), 3, ps);
            const F = C.transform.centerPoint;
            (function(N, Z, G, V) {
              Ks(N, Z - 1, G - 10, 2, 20, V), Ks(N, Z - 10, G - 1, 20, 2, V);
            })(C, F.x, C.transform.height - F.y, Js);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(e) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const r = this.terrainFacilitator.matrix, u = this.transform.modelViewProjectionMatrix;
          let d = this.terrainFacilitator.dirty;
          d || (d = e ? !o.a_(r, u) : !o.a$(r, u)), d || (d = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), d && (o.b0(r, u), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(p, w) {
            const A = p.context, C = A.gl, P = Ti.unblended, F = new oi(C.LEQUAL, oi.ReadWrite, [0, 1]), N = w.getTerrainMesh(), Z = w.sourceCache.getRenderableTiles(), G = p.useProgram("terrainDepth");
            A.bindFramebuffer.set(w.getFramebuffer("depth").framebuffer), A.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), A.clear({ color: o.aM.transparent, depth: 1 });
            for (const V of Z) {
              const W = w.getTerrainData(V.tileID), se = { u_matrix: p.transform.calculatePosMatrix(V.tileID.toUnwrapped()), u_ele_delta: w.getMeshFrameDelta(p.transform.zoom) };
              G.draw(A, C.TRIANGLES, F, Mi.disabled, P, zi.backCCW, se, W, "terrain", N.vertexBuffer, N.indexBuffer, N.segments);
            }
            A.bindFramebuffer.set(null), A.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain), function(p, w) {
            const A = p.context, C = A.gl, P = Ti.unblended, F = new oi(C.LEQUAL, oi.ReadWrite, [0, 1]), N = w.getTerrainMesh(), Z = w.getCoordsTexture(), G = w.sourceCache.getRenderableTiles(), V = p.useProgram("terrainCoords");
            A.bindFramebuffer.set(w.getFramebuffer("coords").framebuffer), A.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), A.clear({ color: o.aM.transparent, depth: 1 }), w.coordsIndex = [];
            for (const W of G) {
              const se = w.getTerrainData(W.tileID);
              A.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, Z.texture);
              const le = { u_matrix: p.transform.calculatePosMatrix(W.tileID.toUnwrapped()), u_terrain_coords_id: (255 - w.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: w.getMeshFrameDelta(p.transform.zoom) };
              V.draw(A, C.TRIANGLES, F, Mi.disabled, P, zi.backCCW, le, se, "terrain", N.vertexBuffer, N.indexBuffer, N.segments), w.coordsIndex.push(W.tileID.key);
            }
            A.bindFramebuffer.set(null), A.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(e, r, u, d) {
          if (!u.isHidden(this.transform.zoom) && (u.type === "background" || u.type === "custom" || (d || []).length)) switch (this.id = u.id, u.type) {
            case "symbol":
              (function(p, w, A, C, P) {
                if (p.renderPass !== "translucent") return;
                const F = Mi.disabled, N = p.colorModeForRenderPass();
                (A._unevaluatedLayout.hasValue("text-variable-anchor") || A._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(Z, G, V, W, se, le, de, ce, we) {
                  const Le = G.transform, Ie = On(), it = se === "map", ht = le === "map";
                  for (const _t of Z) {
                    const wt = W.getTile(_t), bt = wt.getBucket(V);
                    if (!bt || !bt.text || !bt.text.segments.get().length) continue;
                    const yt = o.ag(bt.textSizeData, Le.zoom), St = fi(wt, 1, G.transform.zoom), Zt = ie(_t.posMatrix, ht, it, G.transform, St), Tt = V.layout.get("icon-text-fit") !== "none" && bt.hasIconData();
                    if (yt) {
                      const kt = Math.pow(2, Le.zoom - wt.tileID.overscaledZ), Wt = G.style.map.terrain ? (ci, gi) => G.style.map.terrain.getElevation(_t, ci, gi) : null, di = Ie.translatePosition(Le, wt, de, ce);
                      ks(bt, it, ht, we, Le, Zt, _t.posMatrix, kt, yt, Tt, Ie, di, _t.toUnwrapped(), Wt);
                    }
                  }
                }(C, p, A, w, A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), P), A.paint.get("icon-opacity").constantOr(1) !== 0 && Jr(p, w, A, C, !1, A.paint.get("icon-translate"), A.paint.get("icon-translate-anchor"), A.layout.get("icon-rotation-alignment"), A.layout.get("icon-pitch-alignment"), A.layout.get("icon-keep-upright"), F, N), A.paint.get("text-opacity").constantOr(1) !== 0 && Jr(p, w, A, C, !0, A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.layout.get("text-keep-upright"), F, N), w.map.showCollisionBoxes && (Hs(p, w, A, C, !0), Hs(p, w, A, C, !1));
              })(e, r, u, d, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(p, w, A, C) {
                if (p.renderPass !== "translucent") return;
                const P = A.paint.get("circle-opacity"), F = A.paint.get("circle-stroke-width"), N = A.paint.get("circle-stroke-opacity"), Z = !A.layout.get("circle-sort-key").isConstant();
                if (P.constantOr(1) === 0 && (F.constantOr(1) === 0 || N.constantOr(1) === 0)) return;
                const G = p.context, V = G.gl, W = p.depthModeForSublayer(0, oi.ReadOnly), se = Mi.disabled, le = p.colorModeForRenderPass(), de = [];
                for (let ce = 0; ce < C.length; ce++) {
                  const we = C[ce], Le = w.getTile(we), Ie = Le.getBucket(A);
                  if (!Ie) continue;
                  const it = Ie.programConfigurations.get(A.id), ht = p.useProgram("circle", it), _t = Ie.layoutVertexBuffer, wt = Ie.indexBuffer, bt = p.style.map.terrain && p.style.map.terrain.getTerrainData(we), yt = { programConfiguration: it, program: ht, layoutVertexBuffer: _t, indexBuffer: wt, uniformValues: Il(p, we, Le, A), terrainData: bt };
                  if (Z) {
                    const St = Ie.segments.get();
                    for (const Zt of St) de.push({ segments: new o.a0([Zt]), sortKey: Zt.sortKey, state: yt });
                  } else de.push({ segments: Ie.segments, sortKey: 0, state: yt });
                }
                Z && de.sort((ce, we) => ce.sortKey - we.sortKey);
                for (const ce of de) {
                  const { programConfiguration: we, program: Le, layoutVertexBuffer: Ie, indexBuffer: it, uniformValues: ht, terrainData: _t } = ce.state;
                  Le.draw(G, V.TRIANGLES, W, se, le, zi.disabled, ht, _t, A.id, Ie, it, ce.segments, A.paint, p.transform.zoom, we);
                }
              })(e, r, u, d);
              break;
            case "heatmap":
              (function(p, w, A, C) {
                if (A.paint.get("heatmap-opacity") === 0) return;
                const P = p.context;
                if (p.style.map.terrain) {
                  for (const F of C) {
                    const N = w.getTile(F);
                    w.hasRenderableParent(F) || (p.renderPass === "offscreen" ? ya(p, N, A, F) : p.renderPass === "translucent" && qn(p, A, F));
                  }
                  P.viewport.set([0, 0, p.width, p.height]);
                } else p.renderPass === "offscreen" ? function(F, N, Z, G) {
                  const V = F.context, W = V.gl, se = Mi.disabled, le = new Ti([W.ONE, W.ONE], o.aM.transparent, [!0, !0, !0, !0]);
                  (function(de, ce, we) {
                    const Le = de.gl;
                    de.activeTexture.set(Le.TEXTURE1), de.viewport.set([0, 0, ce.width / 4, ce.height / 4]);
                    let Ie = we.heatmapFbos.get(o.aU);
                    Ie ? (Le.bindTexture(Le.TEXTURE_2D, Ie.colorAttachment.get()), de.bindFramebuffer.set(Ie.framebuffer)) : (Ie = Xs(de, ce.width / 4, ce.height / 4), we.heatmapFbos.set(o.aU, Ie));
                  })(V, F, Z), V.clear({ color: o.aM.transparent });
                  for (let de = 0; de < G.length; de++) {
                    const ce = G[de];
                    if (N.hasRenderableParent(ce)) continue;
                    const we = N.getTile(ce), Le = we.getBucket(Z);
                    if (!Le) continue;
                    const Ie = Le.programConfigurations.get(Z.id), it = F.useProgram("heatmap", Ie), { zoom: ht } = F.transform;
                    it.draw(V, W.TRIANGLES, oi.disabled, se, le, zi.disabled, ai(ce.posMatrix, we, ht, Z.paint.get("heatmap-intensity")), null, Z.id, Le.layoutVertexBuffer, Le.indexBuffer, Le.segments, Z.paint, F.transform.zoom, Ie);
                  }
                  V.viewport.set([0, 0, F.width, F.height]);
                }(p, w, A, C) : p.renderPass === "translucent" && function(F, N) {
                  const Z = F.context, G = Z.gl;
                  Z.setColorMode(F.colorModeForRenderPass());
                  const V = N.heatmapFbos.get(o.aU);
                  V && (Z.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, V.colorAttachment.get()), Z.activeTexture.set(G.TEXTURE1), Fr(Z, N).bind(G.LINEAR, G.CLAMP_TO_EDGE), F.useProgram("heatmapTexture").draw(Z, G.TRIANGLES, oi.disabled, Mi.disabled, F.colorModeForRenderPass(), zi.disabled, lo(F, N, 0, 1), null, N.id, F.viewportBuffer, F.quadTriangleIndexBuffer, F.viewportSegments, N.paint, F.transform.zoom));
                }(p, A);
              })(e, r, u, d);
              break;
            case "line":
              (function(p, w, A, C) {
                if (p.renderPass !== "translucent") return;
                const P = A.paint.get("line-opacity"), F = A.paint.get("line-width");
                if (P.constantOr(1) === 0 || F.constantOr(1) === 0) return;
                const N = p.depthModeForSublayer(0, oi.ReadOnly), Z = p.colorModeForRenderPass(), G = A.paint.get("line-dasharray"), V = A.paint.get("line-pattern"), W = V.constantOr(1), se = A.paint.get("line-gradient"), le = A.getCrossfadeParameters(), de = W ? "linePattern" : G ? "lineSDF" : se ? "lineGradient" : "line", ce = p.context, we = ce.gl;
                let Le = !0;
                for (const Ie of C) {
                  const it = w.getTile(Ie);
                  if (W && !it.patternsLoaded()) continue;
                  const ht = it.getBucket(A);
                  if (!ht) continue;
                  const _t = ht.programConfigurations.get(A.id), wt = p.context.program.get(), bt = p.useProgram(de, _t), yt = Le || bt.program !== wt, St = p.style.map.terrain && p.style.map.terrain.getTerrainData(Ie), Zt = V.constantOr(null);
                  if (Zt && it.imageAtlas) {
                    const Wt = it.imageAtlas, di = Wt.patternPositions[Zt.to.toString()], ci = Wt.patternPositions[Zt.from.toString()];
                    di && ci && _t.setConstantPatternPositions(di, ci);
                  }
                  const Tt = St ? Ie : null, kt = W ? Zs(p, it, A, le, Tt) : G ? co(p, it, A, G, le, Tt) : se ? tl(p, it, A, ht.lineClipsArray.length, Tt) : Tn(p, it, A, Tt);
                  if (W) ce.activeTexture.set(we.TEXTURE0), it.imageAtlasTexture.bind(we.LINEAR, we.CLAMP_TO_EDGE), _t.updatePaintBuffers(le);
                  else if (G && (yt || p.lineAtlas.dirty)) ce.activeTexture.set(we.TEXTURE0), p.lineAtlas.bind(ce);
                  else if (se) {
                    const Wt = ht.gradients[A.id];
                    let di = Wt.texture;
                    if (A.gradientVersion !== Wt.version) {
                      let ci = 256;
                      if (A.stepInterpolant) {
                        const gi = w.getSource().maxzoom, Ei = Ie.canonical.z === gi ? Math.ceil(1 << p.transform.maxZoom - Ie.canonical.z) : 1;
                        ci = o.ac(o.aV(ht.maxLineLength / o.X * 1024 * Ei), 256, ce.maxTextureSize);
                      }
                      Wt.gradient = o.aW({ expression: A.gradientExpression(), evaluationKey: "lineProgress", resolution: ci, image: Wt.gradient || void 0, clips: ht.lineClipsArray }), Wt.texture ? Wt.texture.update(Wt.gradient) : Wt.texture = new X(ce, Wt.gradient, we.RGBA), Wt.version = A.gradientVersion, di = Wt.texture;
                    }
                    ce.activeTexture.set(we.TEXTURE0), di.bind(A.stepInterpolant ? we.NEAREST : we.LINEAR, we.CLAMP_TO_EDGE);
                  }
                  bt.draw(ce, we.TRIANGLES, N, p.stencilModeForClipping(Ie), Z, zi.disabled, kt, St, A.id, ht.layoutVertexBuffer, ht.indexBuffer, ht.segments, A.paint, p.transform.zoom, _t, ht.layoutVertexBuffer2), Le = !1;
                }
              })(e, r, u, d);
              break;
            case "fill":
              (function(p, w, A, C) {
                const P = A.paint.get("fill-color"), F = A.paint.get("fill-opacity");
                if (F.constantOr(1) === 0) return;
                const N = p.colorModeForRenderPass(), Z = A.paint.get("fill-pattern"), G = p.opaquePassEnabledForLayer() && !Z.constantOr(1) && P.constantOr(o.aM.transparent).a === 1 && F.constantOr(0) === 1 ? "opaque" : "translucent";
                if (p.renderPass === G) {
                  const V = p.depthModeForSublayer(1, p.renderPass === "opaque" ? oi.ReadWrite : oi.ReadOnly);
                  Ys(p, w, A, C, V, N, !1);
                }
                if (p.renderPass === "translucent" && A.paint.get("fill-antialias")) {
                  const V = p.depthModeForSublayer(A.getPaintProperty("fill-outline-color") ? 2 : 0, oi.ReadOnly);
                  Ys(p, w, A, C, V, N, !0);
                }
              })(e, r, u, d);
              break;
            case "fill-extrusion":
              (function(p, w, A, C) {
                const P = A.paint.get("fill-extrusion-opacity");
                if (P !== 0 && p.renderPass === "translucent") {
                  const F = new oi(p.context.gl.LEQUAL, oi.ReadWrite, p.depthRangeFor3D);
                  if (P !== 1 || A.paint.get("fill-extrusion-pattern").constantOr(1)) qa(p, w, A, C, F, Mi.disabled, Ti.disabled), qa(p, w, A, C, F, p.stencilModeFor3D(), p.colorModeForRenderPass());
                  else {
                    const N = p.colorModeForRenderPass();
                    qa(p, w, A, C, F, Mi.disabled, N);
                  }
                }
              })(e, r, u, d);
              break;
            case "hillshade":
              (function(p, w, A, C) {
                if (p.renderPass !== "offscreen" && p.renderPass !== "translucent") return;
                const P = p.context, F = p.depthModeForSublayer(0, oi.ReadOnly), N = p.colorModeForRenderPass(), [Z, G] = p.renderPass === "translucent" ? p.stencilConfigForOverlap(C) : [{}, C];
                for (const V of G) {
                  const W = w.getTile(V);
                  W.needsHillshadePrepare !== void 0 && W.needsHillshadePrepare && p.renderPass === "offscreen" ? Ds(p, W, A, F, Mi.disabled, N) : p.renderPass === "translucent" && Kr(p, V, W, A, F, Z[V.overscaledZ], N);
                }
                P.viewport.set([0, 0, p.width, p.height]);
              })(e, r, u, d);
              break;
            case "raster":
              (function(p, w, A, C) {
                if (p.renderPass !== "translucent" || A.paint.get("raster-opacity") === 0 || !C.length) return;
                const P = p.context, F = P.gl, N = w.getSource(), Z = p.useProgram("raster"), G = p.colorModeForRenderPass(), [V, W] = N instanceof jt ? [{}, C] : p.stencilConfigForOverlap(C), se = W[W.length - 1].overscaledZ, le = !p.options.moving;
                for (const de of W) {
                  const ce = p.depthModeForSublayer(de.overscaledZ - se, A.paint.get("raster-opacity") === 1 ? oi.ReadWrite : oi.ReadOnly, F.LESS), we = w.getTile(de);
                  we.registerFadeDuration(A.paint.get("raster-fade-duration"));
                  const Le = w.findLoadedParent(de, 0), Ie = w.findLoadedSibling(de), it = zl(we, Le || Ie || null, w, A, p.transform, p.style.map.terrain);
                  let ht, _t;
                  const wt = A.paint.get("raster-resampling") === "nearest" ? F.NEAREST : F.LINEAR;
                  P.activeTexture.set(F.TEXTURE0), we.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), P.activeTexture.set(F.TEXTURE1), Le ? (Le.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), ht = Math.pow(2, Le.tileID.overscaledZ - we.tileID.overscaledZ), _t = [we.tileID.canonical.x * ht % 1, we.tileID.canonical.y * ht % 1]) : we.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), we.texture.useMipmap && P.extTextureFilterAnisotropic && p.transform.pitch > 20 && F.texParameterf(F.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax);
                  const bt = p.style.map.terrain && p.style.map.terrain.getTerrainData(de), yt = bt ? de : null, St = yt ? yt.posMatrix : p.transform.calculatePosMatrix(de.toUnwrapped(), le), Zt = au(St, _t || [0, 0], ht || 1, it, A);
                  N instanceof jt ? Z.draw(P, F.TRIANGLES, ce, Mi.disabled, G, zi.disabled, Zt, bt, A.id, N.boundsBuffer, p.quadTriangleIndexBuffer, N.boundsSegments) : Z.draw(P, F.TRIANGLES, ce, V[de.overscaledZ], G, zi.disabled, Zt, bt, A.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments);
                }
              })(e, r, u, d);
              break;
            case "background":
              (function(p, w, A, C) {
                const P = A.paint.get("background-color"), F = A.paint.get("background-opacity");
                if (F === 0) return;
                const N = p.context, Z = N.gl, G = p.transform, V = G.tileSize, W = A.paint.get("background-pattern");
                if (p.isPatternMissing(W)) return;
                const se = !W && P.a === 1 && F === 1 && p.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (p.renderPass !== se) return;
                const le = Mi.disabled, de = p.depthModeForSublayer(0, se === "opaque" ? oi.ReadWrite : oi.ReadOnly), ce = p.colorModeForRenderPass(), we = p.useProgram(W ? "backgroundPattern" : "background"), Le = C || G.coveringTiles({ tileSize: V, terrain: p.style.map.terrain });
                W && (N.activeTexture.set(Z.TEXTURE0), p.imageManager.bind(p.context));
                const Ie = A.getCrossfadeParameters();
                for (const it of Le) {
                  const ht = C ? it.posMatrix : p.transform.calculatePosMatrix(it.toUnwrapped()), _t = W ? Gs(ht, F, p, W, { tileID: it, tileSize: V }, Ie) : fo(ht, F, P), wt = p.style.map.terrain && p.style.map.terrain.getTerrainData(it);
                  we.draw(N, Z.TRIANGLES, de, le, ce, zi.disabled, _t, wt, A.id, p.tileExtentBuffer, p.quadTriangleIndexBuffer, p.tileExtentSegments);
                }
              })(e, 0, u, d);
              break;
            case "custom":
              (function(p, w, A) {
                const C = p.context, P = A.implementation;
                if (p.renderPass === "offscreen") {
                  const F = P.prerender;
                  F && (p.setCustomLayerDefaults(), C.setColorMode(p.colorModeForRenderPass()), F.call(P, C.gl, p.transform.customLayerMatrix()), C.setDirty(), p.setBaseState());
                } else if (p.renderPass === "translucent") {
                  p.setCustomLayerDefaults(), C.setColorMode(p.colorModeForRenderPass()), C.setStencilMode(Mi.disabled);
                  const F = P.renderingMode === "3d" ? new oi(p.context.gl.LEQUAL, oi.ReadWrite, p.depthRangeFor3D) : p.depthModeForSublayer(0, oi.ReadOnly);
                  C.setDepthMode(F), P.render(C.gl, p.transform.customLayerMatrix(), { farZ: p.transform.farZ, nearZ: p.transform.nearZ, fov: p.transform._fov, modelViewProjectionMatrix: p.transform.modelViewProjectionMatrix, projectionMatrix: p.transform.projectionMatrix }), C.setDirty(), p.setBaseState(), C.bindFramebuffer.set(null);
                }
              })(e, 0, u);
          }
        }
        translatePosMatrix(e, r, u, d, p) {
          if (!u[0] && !u[1]) return e;
          const w = p ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
          if (w) {
            const P = Math.sin(w), F = Math.cos(w);
            u = [u[0] * F - u[1] * P, u[0] * P + u[1] * F];
          }
          const A = [p ? u[0] : fi(r, u[0], this.transform.zoom), p ? u[1] : fi(r, u[1], this.transform.zoom), 0], C = new Float32Array(16);
          return o.J(C, e, A), C;
        }
        saveTileTexture(e) {
          const r = this._tileTextures[e.size[0]];
          r ? r.push(e) : this._tileTextures[e.size[0]] = [e];
        }
        getTileTexture(e) {
          const r = this._tileTextures[e];
          return r && r.length > 0 ? r.pop() : null;
        }
        isPatternMissing(e) {
          if (!e) return !1;
          if (!e.from || !e.to) return !0;
          const r = this.imageManager.getPattern(e.from.toString()), u = this.imageManager.getPattern(e.to.toString());
          return !r || !u;
        }
        useProgram(e, r) {
          this.cache = this.cache || {};
          const u = e + (r ? r.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[u] || (this.cache[u] = new el(this.context, os[e], r, Ra[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[u];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new X(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: e, drawingBufferHeight: r } = this.context.gl;
          return this.width !== e || this.height !== r;
        }
      }
      class Qr {
        constructor(e, r) {
          this.points = e, this.planes = r;
        }
        static fromInvProjectionMatrix(e, r, u) {
          const d = Math.pow(2, u), p = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((A) => {
            const C = 1 / (A = o.af([], A, e))[3] / r * d;
            return o.b1(A, A, [C, C, 1 / A[3], C]);
          }), w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((A) => {
            const C = function(Z, G) {
              var V = G[0], W = G[1], se = G[2], le = V * V + W * W + se * se;
              return le > 0 && (le = 1 / Math.sqrt(le)), Z[0] = G[0] * le, Z[1] = G[1] * le, Z[2] = G[2] * le, Z;
            }([], function(Z, G, V) {
              var W = G[0], se = G[1], le = G[2], de = V[0], ce = V[1], we = V[2];
              return Z[0] = se * we - le * ce, Z[1] = le * de - W * we, Z[2] = W * ce - se * de, Z;
            }([], ke([], p[A[0]], p[A[1]]), ke([], p[A[2]], p[A[1]]))), P = -((F = C)[0] * (N = p[A[1]])[0] + F[1] * N[1] + F[2] * N[2]);
            var F, N;
            return C.concat(P);
          });
          return new Qr(p, w);
        }
      }
      class vn {
        constructor(e, r) {
          this.min = e, this.max = r, this.center = function(u, d, p) {
            return u[0] = 0.5 * d[0], u[1] = 0.5 * d[1], u[2] = 0.5 * d[2], u;
          }([], function(u, d, p) {
            return u[0] = d[0] + p[0], u[1] = d[1] + p[1], u[2] = d[2] + p[2], u;
          }([], this.min, this.max));
        }
        quadrant(e) {
          const r = [e % 2 == 0, e < 2], u = je(this.min), d = je(this.max);
          for (let p = 0; p < r.length; p++) u[p] = r[p] ? this.min[p] : this.center[p], d[p] = r[p] ? this.center[p] : this.max[p];
          return d[2] = this.max[2], new vn(u, d);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        intersects(e) {
          const r = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let u = !0;
          for (let d = 0; d < e.planes.length; d++) {
            const p = e.planes[d];
            let w = 0;
            for (let A = 0; A < r.length; A++) o.b2(p, r[A]) >= 0 && w++;
            if (w === 0) return 0;
            w !== r.length && (u = !1);
          }
          if (u) return 2;
          for (let d = 0; d < 3; d++) {
            let p = Number.MAX_VALUE, w = -Number.MAX_VALUE;
            for (let A = 0; A < e.points.length; A++) {
              const C = e.points[A][d] - this.min[d];
              p = Math.min(p, C), w = Math.max(w, C);
            }
            if (w < 0 || p > this.max[d] - this.min[d]) return 0;
          }
          return 1;
        }
      }
      class Vn {
        constructor(e = 0, r = 0, u = 0, d = 0) {
          if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(u) || u < 0 || isNaN(d) || d < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e, this.bottom = r, this.left = u, this.right = d;
        }
        interpolate(e, r, u) {
          return r.top != null && e.top != null && (this.top = o.y.number(e.top, r.top, u)), r.bottom != null && e.bottom != null && (this.bottom = o.y.number(e.bottom, r.bottom, u)), r.left != null && e.left != null && (this.left = o.y.number(e.left, r.left, u)), r.right != null && e.right != null && (this.right = o.y.number(e.right, r.right, u)), this;
        }
        getCenter(e, r) {
          const u = o.ac((this.left + e - this.right) / 2, 0, e), d = o.ac((this.top + r - this.bottom) / 2, 0, r);
          return new o.P(u, d);
        }
        equals(e) {
          return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
        }
        clone() {
          return new Vn(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const xa = 85.051129;
      class $n {
        constructor(e, r, u, d, p) {
          this.tileSize = 512, this._renderWorldCopies = p === void 0 || !!p, this._minZoom = e || 0, this._maxZoom = r || 22, this._minPitch = u ?? 0, this._maxPitch = d ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Vn(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const e = new $n(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return e.apply(this), e;
        }
        apply(e) {
          this.tileSize = e.tileSize, this.latRange = e.latRange, this.lngRange = e.lngRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e) {
          this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e) {
          this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e) {
          this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e) {
          this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(e) {
          e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new o.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(e) {
          const r = -o.b3(e, -180, 180) * Math.PI / 180;
          this.angle !== r && (this._unmodified = !1, this.angle = r, this._calcMatrices(), this.rotationMatrix = function() {
            var u = new o.A(4);
            return o.A != Float32Array && (u[1] = 0, u[2] = 0), u[0] = 1, u[3] = 1, u;
          }(), function(u, d, p) {
            var w = d[0], A = d[1], C = d[2], P = d[3], F = Math.sin(p), N = Math.cos(p);
            u[0] = w * N + C * F, u[1] = A * N + P * F, u[2] = w * -F + C * N, u[3] = A * -F + P * N;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e) {
          const r = o.ac(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== r && (this._unmodified = !1, this._pitch = r, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(e) {
          e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e) {
          const r = Math.min(Math.max(e, this.minZoom), this.maxZoom);
          this._zoom !== r && (this._unmodified = !1, this._zoom = r, this.tileZoom = Math.max(0, Math.floor(r)), this.scale = this.zoomScale(r), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(e) {
          e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e) {
          e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e) {
          this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(e) {
          return this._edgeInsets.equals(e);
        }
        interpolatePadding(e, r, u) {
          this._unmodified = !1, this._edgeInsets.interpolate(e, r, u), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
          return Math.max(0, r);
        }
        getVisibleUnwrappedCoordinates(e) {
          const r = [new o.b4(0, e)];
          if (this._renderWorldCopies) {
            const u = this.pointCoordinate(new o.P(0, 0)), d = this.pointCoordinate(new o.P(this.width, 0)), p = this.pointCoordinate(new o.P(this.width, this.height)), w = this.pointCoordinate(new o.P(0, this.height)), A = Math.floor(Math.min(u.x, d.x, p.x, w.x)), C = Math.floor(Math.max(u.x, d.x, p.x, w.x)), P = 1;
            for (let F = A - P; F <= C + P; F++) F !== 0 && r.push(new o.b4(F, e));
          }
          return r;
        }
        coveringTiles(e) {
          var r, u;
          let d = this.coveringZoomLevel(e);
          const p = d;
          if (e.minzoom !== void 0 && d < e.minzoom) return [];
          e.maxzoom !== void 0 && d > e.maxzoom && (d = e.maxzoom);
          const w = this.pointCoordinate(this.getCameraPoint()), A = o.Z.fromLngLat(this.center), C = Math.pow(2, d), P = [C * w.x, C * w.y, 0], F = [C * A.x, C * A.y, 0], N = Qr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, d);
          let Z = e.minzoom || 0;
          !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (Z = d);
          const G = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, V = (ce) => ({ aabb: new vn([ce * C, 0, 0], [(ce + 1) * C, C, 0]), zoom: 0, x: 0, y: 0, wrap: ce, fullyVisible: !1 }), W = [], se = [], le = d, de = e.reparseOverscaled ? p : d;
          if (this._renderWorldCopies) for (let ce = 1; ce <= 3; ce++) W.push(V(-ce)), W.push(V(ce));
          for (W.push(V(0)); W.length > 0; ) {
            const ce = W.pop(), we = ce.x, Le = ce.y;
            let Ie = ce.fullyVisible;
            if (!Ie) {
              const bt = ce.aabb.intersects(N);
              if (bt === 0) continue;
              Ie = bt === 2;
            }
            const it = e.terrain ? P : F, ht = ce.aabb.distanceX(it), _t = ce.aabb.distanceY(it), wt = Math.max(Math.abs(ht), Math.abs(_t));
            if (ce.zoom === le || wt > G + (1 << le - ce.zoom) - 2 && ce.zoom >= Z) {
              const bt = le - ce.zoom, yt = P[0] - 0.5 - (we << bt), St = P[1] - 0.5 - (Le << bt);
              se.push({ tileID: new o.S(ce.zoom === le ? de : ce.zoom, ce.wrap, ce.zoom, we, Le), distanceSq: Ae([F[0] - 0.5 - we, F[1] - 0.5 - Le]), tileDistanceToCamera: Math.sqrt(yt * yt + St * St) });
            } else for (let bt = 0; bt < 4; bt++) {
              const yt = (we << 1) + bt % 2, St = (Le << 1) + (bt >> 1), Zt = ce.zoom + 1;
              let Tt = ce.aabb.quadrant(bt);
              if (e.terrain) {
                const kt = new o.S(Zt, ce.wrap, Zt, yt, St), Wt = e.terrain.getMinMaxElevation(kt), di = (r = Wt.minElevation) !== null && r !== void 0 ? r : this.elevation, ci = (u = Wt.maxElevation) !== null && u !== void 0 ? u : this.elevation;
                Tt = new vn([Tt.min[0], Tt.min[1], di], [Tt.max[0], Tt.max[1], ci]);
              }
              W.push({ aabb: Tt, zoom: Zt, x: yt, y: St, wrap: ce.wrap, fullyVisible: Ie });
            }
          }
          return se.sort((ce, we) => ce.distanceSq - we.distanceSq).map((ce) => ce.tileID);
        }
        resize(e, r) {
          this.width = e, this.height = r, this.pixelsToGLUnits = [2 / e, -2 / r], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e) {
          return Math.pow(2, e);
        }
        scaleZoom(e) {
          return Math.log(e) / Math.LN2;
        }
        project(e) {
          const r = o.ac(e.lat, -85.051129, xa);
          return new o.P(o.O(e.lng) * this.worldSize, o.Q(r) * this.worldSize);
        }
        unproject(e) {
          return new o.Z(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(e) {
          const r = this.elevation, u = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, d = this.pointLocation(this.centerPoint, e), p = e.getElevationForLngLatZoom(d, this.tileZoom);
          if (!(this.elevation - p)) return;
          const w = u + r - p, A = Math.cos(this._pitch) * this.cameraToCenterDistance / w / o.b5(1, d.lat), C = this.scaleZoom(A / this.tileSize);
          this._elevation = p, this._center = d, this.zoom = C;
        }
        setLocationAtPoint(e, r) {
          const u = this.pointCoordinate(r), d = this.pointCoordinate(this.centerPoint), p = this.locationCoordinate(e), w = new o.Z(p.x - (u.x - d.x), p.y - (u.y - d.y));
          this.center = this.coordinateLocation(w), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(e, r) {
          return r ? this.coordinatePoint(this.locationCoordinate(e), r.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
        }
        pointLocation(e, r) {
          return this.coordinateLocation(this.pointCoordinate(e, r));
        }
        locationCoordinate(e) {
          return o.Z.fromLngLat(e);
        }
        coordinateLocation(e) {
          return e && e.toLngLat();
        }
        pointCoordinate(e, r) {
          if (r) {
            const Z = r.pointCoordinate(e);
            if (Z != null) return Z;
          }
          const u = [e.x, e.y, 0, 1], d = [e.x, e.y, 1, 1];
          o.af(u, u, this.pixelMatrixInverse), o.af(d, d, this.pixelMatrixInverse);
          const p = u[3], w = d[3], A = u[1] / p, C = d[1] / w, P = u[2] / p, F = d[2] / w, N = P === F ? 0 : (0 - P) / (F - P);
          return new o.Z(o.y.number(u[0] / p, d[0] / w, N) / this.worldSize, o.y.number(A, C, N) / this.worldSize);
        }
        coordinatePoint(e, r = 0, u = this.pixelMatrix) {
          const d = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
          return o.af(d, d, u), new o.P(d[0] / d[3], d[1] / d[3]);
        }
        getBounds() {
          const e = Math.max(0, this.height / 2 - this.getHorizon());
          return new Y().extend(this.pointLocation(new o.P(0, e))).extend(this.pointLocation(new o.P(this.width, e))).extend(this.pointLocation(new o.P(this.width, this.height))).extend(this.pointLocation(new o.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Y([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(e) {
          e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, xa]);
        }
        calculateTileMatrix(e) {
          const r = e.canonical, u = this.worldSize / this.zoomScale(r.z), d = r.x + Math.pow(2, r.z) * e.wrap, p = o.an(new Float64Array(16));
          return o.J(p, p, [d * u, r.y * u, 0]), o.K(p, p, [u / o.X, u / o.X, 1]), p;
        }
        calculatePosMatrix(e, r = !1) {
          const u = e.key, d = r ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (d[u]) return d[u];
          const p = this.calculateTileMatrix(e);
          return o.L(p, r ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, p), d[u] = new Float32Array(p), d[u];
        }
        calculateFogMatrix(e) {
          const r = e.key, u = this._fogMatrixCache;
          if (u[r]) return u[r];
          const d = this.calculateTileMatrix(e);
          return o.L(d, this.fogMatrix, d), u[r] = new Float32Array(d), u[r];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(e, r) {
          r = o.ac(+r, this.minZoom, this.maxZoom);
          const u = { center: new o.N(e.lng, e.lat), zoom: r };
          let d = this.lngRange;
          if (!this._renderWorldCopies && d === null) {
            const ce = 179.9999999999;
            d = [-ce, ce];
          }
          const p = this.tileSize * this.zoomScale(u.zoom);
          let w = 0, A = p, C = 0, P = p, F = 0, N = 0;
          const { x: Z, y: G } = this.size;
          if (this.latRange) {
            const ce = this.latRange;
            w = o.Q(ce[1]) * p, A = o.Q(ce[0]) * p, A - w < G && (F = G / (A - w));
          }
          d && (C = o.b3(o.O(d[0]) * p, 0, p), P = o.b3(o.O(d[1]) * p, 0, p), P < C && (P += p), P - C < Z && (N = Z / (P - C)));
          const { x: V, y: W } = this.project.call({ worldSize: p }, e);
          let se, le;
          const de = Math.max(N || 0, F || 0);
          if (de) {
            const ce = new o.P(N ? (P + C) / 2 : V, F ? (A + w) / 2 : W);
            return u.center = this.unproject.call({ worldSize: p }, ce).wrap(), u.zoom += this.scaleZoom(de), u;
          }
          if (this.latRange) {
            const ce = G / 2;
            W - ce < w && (le = w + ce), W + ce > A && (le = A - ce);
          }
          if (d) {
            const ce = (C + P) / 2;
            let we = V;
            this._renderWorldCopies && (we = o.b3(V, ce - p / 2, ce + p / 2));
            const Le = Z / 2;
            we - Le < C && (se = C + Le), we + Le > P && (se = P - Le);
          }
          if (se !== void 0 || le !== void 0) {
            const ce = new o.P(se ?? V, le ?? W);
            u.center = this.unproject.call({ worldSize: p }, ce).wrap();
          }
          return u;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const e = this._unmodified, { center: r, zoom: u } = this.getConstrained(this.center, this.zoom);
          this.center = r, this.zoom = u, this._unmodified = e, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const e = this.centerOffset, r = this.point.x, u = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = o.b5(1, this.center.lat) * this.worldSize;
          let d = o.an(new Float64Array(16));
          o.K(d, d, [this.width / 2, -this.height / 2, 1]), o.J(d, d, [1, -1, 0]), this.labelPlaneMatrix = d, d = o.an(new Float64Array(16)), o.K(d, d, [1, -1, 1]), o.J(d, d, [-1, -1, 0]), o.K(d, d, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = d;
          const p = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), w = Math.min(this.elevation, this.minElevationForCurrentTile), A = p - w * this._pixelPerMeter / Math.cos(this._pitch), C = w < 0 ? A : p, P = Math.PI / 2 + this._pitch, F = this._fov * (0.5 + e.y / this.height), N = Math.sin(F) * C / Math.sin(o.ac(Math.PI - P - F, 0.01, Math.PI - 0.01)), Z = this.getHorizon(), G = 2 * Math.atan(Z / this.cameraToCenterDistance) * (0.5 + e.y / (2 * Z)), V = Math.sin(G) * C / Math.sin(o.ac(Math.PI - P - G, 0.01, Math.PI - 0.01)), W = Math.min(N, V);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * W + C), this.nearZ = this.height / 50, d = new Float64Array(16), o.b6(d, this._fov, this.width / this.height, this.nearZ, this.farZ), d[8] = 2 * -e.x / this.width, d[9] = 2 * e.y / this.height, this.projectionMatrix = o.ae(d), o.K(d, d, [1, -1, 1]), o.J(d, d, [0, 0, -this.cameraToCenterDistance]), o.b7(d, d, this._pitch), o.ad(d, d, this.angle), o.J(d, d, [-r, -u, 0]), this.mercatorMatrix = o.K([], d, [this.worldSize, this.worldSize, this.worldSize]), o.K(d, d, [1, 1, this._pixelPerMeter]), this.pixelMatrix = o.L(new Float64Array(16), this.labelPlaneMatrix, d), o.J(d, d, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = d, this.invModelViewProjectionMatrix = o.as([], d), this.fogMatrix = new Float64Array(16), o.b6(this.fogMatrix, this._fov, this.width / this.height, p, this.farZ), this.fogMatrix[8] = 2 * -e.x / this.width, this.fogMatrix[9] = 2 * e.y / this.height, o.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), o.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b7(this.fogMatrix, this.fogMatrix, this._pitch), o.ad(this.fogMatrix, this.fogMatrix, this.angle), o.J(this.fogMatrix, this.fogMatrix, [-r, -u, 0]), o.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), o.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = o.L(new Float64Array(16), this.labelPlaneMatrix, d);
          const se = this.width % 2 / 2, le = this.height % 2 / 2, de = Math.cos(this.angle), ce = Math.sin(this.angle), we = r - Math.round(r) + de * se + ce * le, Le = u - Math.round(u) + de * le + ce * se, Ie = new Float64Array(d);
          if (o.J(Ie, Ie, [we > 0.5 ? we - 1 : we, Le > 0.5 ? Le - 1 : Le, 0]), this.alignedModelViewProjectionMatrix = Ie, d = o.as(new Float64Array(16), this.pixelMatrix), !d) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = d, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const e = this.pointCoordinate(new o.P(0, 0)), r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
          return o.af(r, r, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new o.P(0, e));
        }
        getCameraQueryGeometry(e) {
          const r = this.getCameraPoint();
          if (e.length === 1) return [e[0], r];
          {
            let u = r.x, d = r.y, p = r.x, w = r.y;
            for (const A of e) u = Math.min(u, A.x), d = Math.min(d, A.y), p = Math.max(p, A.x), w = Math.max(w, A.y);
            return [new o.P(u, d), new o.P(p, d), new o.P(p, w), new o.P(u, w), new o.P(u, d)];
          }
        }
        lngLatToCameraDepth(e, r) {
          const u = this.locationCoordinate(e), d = [u.x * this.worldSize, u.y * this.worldSize, r, 1];
          return o.af(d, d, this.modelViewProjectionMatrix), d[2] / d[3];
        }
      }
      function Zn(h, e) {
        let r, u = !1, d = null, p = null;
        const w = () => {
          d = null, u && (h.apply(p, r), d = setTimeout(w, e), u = !1);
        };
        return (...A) => (u = !0, p = this, r = A, d || w(), d);
      }
      class wa {
        constructor(e) {
          this._getCurrentHash = () => {
            const r = window.location.hash.replace("#", "");
            if (this._hashName) {
              let u;
              return r.split("&").map((d) => d.split("=")).forEach((d) => {
                d[0] === this._hashName && (u = d);
              }), (u && u[1] || "").split("/");
            }
            return r.split("/");
          }, this._onHashChange = () => {
            const r = this._getCurrentHash();
            if (r.length >= 3 && !r.some((u) => isNaN(u))) {
              const u = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: u, pitch: +(r[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, r);
          }, this._removeHash = () => {
            const r = this._getCurrentHash();
            if (r.length === 0) return;
            const u = r.join("/");
            let d = u;
            d.split("&").length > 0 && (d = d.split("&")[0]), this._hashName && (d = `${this._hashName}=${u}`);
            let p = window.location.hash.replace(d, "");
            p.startsWith("#&") ? p = p.slice(0, 1) + p.slice(2) : p === "#" && (p = "");
            let w = window.location.href.replace(/(#.+)?$/, p);
            w = w.replace("&&", "&"), window.history.replaceState(window.history.state, null, w);
          }, this._updateHash = Zn(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
        }
        addTo(e) {
          return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(e) {
          const r = this._map.getCenter(), u = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((u * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), p = Math.pow(10, d), w = Math.round(r.lng * p) / p, A = Math.round(r.lat * p) / p, C = this._map.getBearing(), P = this._map.getPitch();
          let F = "";
          if (F += e ? `/${w}/${A}/${u}` : `${u}/${A}/${w}`, (C || P) && (F += "/" + Math.round(10 * C) / 10), P && (F += `/${Math.round(P)}`), this._hashName) {
            const N = this._hashName;
            let Z = !1;
            const G = window.location.hash.slice(1).split("&").map((V) => {
              const W = V.split("=")[0];
              return W === N ? (Z = !0, `${W}=${F}`) : V;
            }).filter((V) => V);
            return Z || G.push(`${N}=${F}`), `#${G.join("&")}`;
          }
          return `#${F}`;
        }
      }
      const dn = { linearity: 0.3, easing: o.b8(0, 0, 0.3, 1) }, ms = o.e({ deceleration: 2500, maxSpeed: 1400 }, dn), tr = o.e({ deceleration: 20, maxSpeed: 1400 }, dn), Yi = o.e({ deceleration: 1e3, maxSpeed: 360 }, dn), dr = o.e({ deceleration: 1e3, maxSpeed: 90 }, dn);
      class Cr {
        constructor(e) {
          this._map = e, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: j.now(), settings: e });
        }
        _drainInertiaBuffer() {
          const e = this._inertiaBuffer, r = j.now();
          for (; e.length > 0 && r - e[0].time > 160; ) e.shift();
        }
        _onMoveEnd(e) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const r = { zoom: 0, bearing: 0, pitch: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: p } of this._inertiaBuffer) r.zoom += p.zoomDelta || 0, r.bearing += p.bearingDelta || 0, r.pitch += p.pitchDelta || 0, p.panDelta && r.pan._add(p.panDelta), p.around && (r.around = p.around), p.pinchAround && (r.pinchAround = p.pinchAround);
          const u = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, d = {};
          if (r.pan.mag()) {
            const p = Gn(r.pan.mag(), u, o.e({}, ms, e || {}));
            d.offset = r.pan.mult(p.amount / r.pan.mag()), d.center = this._map.transform.center, Dn(d, p);
          }
          if (r.zoom) {
            const p = Gn(r.zoom, u, tr);
            d.zoom = this._map.transform.zoom + p.amount, Dn(d, p);
          }
          if (r.bearing) {
            const p = Gn(r.bearing, u, Yi);
            d.bearing = this._map.transform.bearing + o.ac(p.amount, -179, 179), Dn(d, p);
          }
          if (r.pitch) {
            const p = Gn(r.pitch, u, dr);
            d.pitch = this._map.transform.pitch + p.amount, Dn(d, p);
          }
          if (d.zoom || d.bearing) {
            const p = r.pinchAround === void 0 ? r.around : r.pinchAround;
            d.around = p ? this._map.unproject(p) : this._map.getCenter();
          }
          return this.clear(), o.e(d, { noMoveStart: !0 });
        }
      }
      function Dn(h, e) {
        (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing);
      }
      function Gn(h, e, r) {
        const { maxSpeed: u, linearity: d, deceleration: p } = r, w = o.ac(h * d / (e / 1e3), -u, u), A = Math.abs(w) / (p * d);
        return { easing: r.easing, duration: 1e3 * A, amount: w * (A / 2) };
      }
      class Tr extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, u, d = {}) {
          const p = O.mousePos(r.getCanvas(), u), w = r.unproject(p);
          super(e, o.e({ point: p, lngLat: w, originalEvent: u }, d)), this._defaultPrevented = !1, this.target = r;
        }
      }
      class Ps extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, u) {
          const d = e === "touchend" ? u.changedTouches : u.touches, p = O.touchPos(r.getCanvasContainer(), d), w = p.map((C) => r.unproject(C)), A = p.reduce((C, P, F, N) => C.add(P.div(N.length)), new o.P(0, 0));
          super(e, { points: p, point: A, lngLats: w, lngLat: r.unproject(A), originalEvent: u }), this._defaultPrevented = !1;
        }
      }
      class uu extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, u) {
          super(e, { originalEvent: u }), this._defaultPrevented = !1;
        }
      }
      class cu {
        constructor(e, r) {
          this._map = e, this._clickTolerance = r.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e) {
          return this._firePreventable(new uu(e.type, this._map, e));
        }
        mousedown(e, r) {
          return this._mousedownPos = r, this._firePreventable(new Tr(e.type, this._map, e));
        }
        mouseup(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        click(e, r) {
          this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new Tr(e.type, this._map, e));
        }
        dblclick(e) {
          return this._firePreventable(new Tr(e.type, this._map, e));
        }
        mouseover(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        mouseout(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        touchstart(e) {
          return this._firePreventable(new Ps(e.type, this._map, e));
        }
        touchmove(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        touchend(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        touchcancel(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        _firePreventable(e) {
          if (this._map.fire(e), e.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class _r {
        constructor(e) {
          this._map = e;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Tr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e) {
          this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Tr(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Hn {
        constructor(e) {
          this._map = e;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e) {
          return this.transform.pointLocation(o.P.convert(e), this._map.terrain);
        }
      }
      class bn {
        constructor(e, r) {
          this._map = e, this._tr = new Hn(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(e, r) {
          this.isEnabled() && e.shiftKey && e.button === 0 && (O.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
        }
        mousemoveWindow(e, r) {
          if (!this._active) return;
          const u = r;
          if (this._lastPos.equals(u) || !this._box && u.dist(this._startPos) < this._clickTolerance) return;
          const d = this._startPos;
          this._lastPos = u, this._box || (this._box = O.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
          const p = Math.min(d.x, u.x), w = Math.max(d.x, u.x), A = Math.min(d.y, u.y), C = Math.max(d.y, u.y);
          O.setTransform(this._box, `translate(${p}px,${A}px)`), this._box.style.width = w - p + "px", this._box.style.height = C - A + "px";
        }
        mouseupWindow(e, r) {
          if (!this._active || e.button !== 0) return;
          const u = this._startPos, d = r;
          if (this.reset(), O.suppressClick(), u.x !== d.x || u.y !== d.y) return this._map.fire(new o.k("boxzoomend", { originalEvent: e })), { cameraAnimation: (p) => p.fitScreenCoordinates(u, d, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", e);
        }
        keydown(e) {
          this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (O.remove(this._box), this._box = null), O.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e, r) {
          return this._map.fire(new o.k(e, { originalEvent: r }));
        }
      }
      function wo(h, e) {
        if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
        const r = {};
        for (let u = 0; u < h.length; u++) r[h[u].identifier] = e[u];
        return r;
      }
      class ol {
        constructor(e) {
          this.reset(), this.numTouches = e.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(e, r, u) {
          (this.centroid || u.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), u.length === this.numTouches && (this.centroid = function(d) {
            const p = new o.P(0, 0);
            for (const w of d) p._add(w);
            return p.div(d.length);
          }(r), this.touches = wo(u, r)));
        }
        touchmove(e, r, u) {
          if (this.aborted || !this.centroid) return;
          const d = wo(u, r);
          for (const p in this.touches) {
            const w = d[p];
            (!w || w.dist(this.touches[p]) > 30) && (this.aborted = !0);
          }
        }
        touchend(e, r, u) {
          if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), u.length === 0) {
            const d = !this.aborted && this.centroid;
            if (this.reset(), d) return d;
          }
        }
      }
      class Va {
        constructor(e) {
          this.singleTap = new ol(e), this.numTaps = e.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e, r, u) {
          this.singleTap.touchstart(e, r, u);
        }
        touchmove(e, r, u) {
          this.singleTap.touchmove(e, r, u);
        }
        touchend(e, r, u) {
          const d = this.singleTap.touchend(e, r, u);
          if (d) {
            const p = e.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(d) < 30;
            if (p && w || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = d, this.count === this.numTaps) return this.reset(), d;
          }
        }
      }
      class Br {
        constructor(e) {
          this._tr = new Hn(e), this._zoomIn = new Va({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Va({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e, r, u) {
          this._zoomIn.touchstart(e, r, u), this._zoomOut.touchstart(e, r, u);
        }
        touchmove(e, r, u) {
          this._zoomIn.touchmove(e, r, u), this._zoomOut.touchmove(e, r, u);
        }
        touchend(e, r, u) {
          const d = this._zoomIn.touchend(e, r, u), p = this._zoomOut.touchend(e, r, u), w = this._tr;
          return d ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (A) => A.easeTo({ duration: 300, zoom: w.zoom + 1, around: w.unproject(d) }, { originalEvent: e }) }) : p ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (A) => A.easeTo({ duration: 300, zoom: w.zoom - 1, around: w.unproject(p) }, { originalEvent: e }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Lr {
        constructor(e) {
          this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
        }
        reset(e) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
        }
        _move(...e) {
          const r = this._moveFunction(...e);
          if (r.bearingDelta || r.pitchDelta || r.around || r.panDelta) return this._active = !0, r;
        }
        dragStart(e, r) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = r.length ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(e, r) {
          if (!this.isEnabled()) return;
          const u = this._lastPoint;
          if (!u) return;
          if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
          const d = r.length ? r[0] : r;
          return !this._moved && d.dist(u) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = d, this._move(u, d));
        }
        dragEnd(e) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && O.suppressClick(), this.reset(e));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const Ao = { 0: 1, 2: 2 };
      class $a {
        constructor(e) {
          this._correctEvent = e.checkCorrectEvent;
        }
        startMove(e) {
          const r = O.mouseButton(e);
          this._eventButton = r;
        }
        endMove(e) {
          delete this._eventButton;
        }
        isValidStartEvent(e) {
          return this._correctEvent(e);
        }
        isValidMoveEvent(e) {
          return !function(r, u) {
            const d = Ao[u];
            return r.buttons === void 0 || (r.buttons & d) !== d;
          }(e, this._eventButton);
        }
        isValidEndEvent(e) {
          return O.mouseButton(e) === this._eventButton;
        }
      }
      class Fl {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(e) {
          return e.targetTouches.length === 1;
        }
        _isSameTouchEvent(e) {
          return e.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(e) {
          this._firstTouch = e.targetTouches[0].identifier;
        }
        endMove(e) {
          delete this._firstTouch;
        }
        isValidStartEvent(e) {
          return this._isOneFingerTouch(e);
        }
        isValidMoveEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
        isValidEndEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
      }
      const Za = (h) => {
        h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = (e) => {
          e.preventDefault();
        };
      }, So = ({ enable: h, clickTolerance: e, bearingDegreesPerPixelMoved: r = 0.8 }) => {
        const u = new $a({ checkCorrectEvent: (d) => O.mouseButton(d) === 0 && d.ctrlKey || O.mouseButton(d) === 2 });
        return new Lr({ clickTolerance: e, move: (d, p) => ({ bearingDelta: (p.x - d.x) * r }), moveStateManager: u, enable: h, assignEvents: Za });
      }, ll = ({ enable: h, clickTolerance: e, pitchDegreesPerPixelMoved: r = -0.5 }) => {
        const u = new $a({ checkCorrectEvent: (d) => O.mouseButton(d) === 0 && d.ctrlKey || O.mouseButton(d) === 2 });
        return new Lr({ clickTolerance: e, move: (d, p) => ({ pitchDelta: (p.y - d.y) * r }), moveStateManager: u, enable: h, assignEvents: Za });
      };
      class Aa {
        constructor(e, r) {
          this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new o.P(0, 0);
        }
        _shouldBePrevented(e) {
          return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(e, r, u) {
          return this._calculateTransform(e, r, u);
        }
        touchmove(e, r, u) {
          if (this._active) {
            if (!this._shouldBePrevented(u.length)) return e.preventDefault(), this._calculateTransform(e, r, u);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
          }
        }
        touchend(e, r, u) {
          this._calculateTransform(e, r, u), this._active && this._shouldBePrevented(u.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e, r, u) {
          u.length > 0 && (this._active = !0);
          const d = wo(u, r), p = new o.P(0, 0), w = new o.P(0, 0);
          let A = 0;
          for (const P in d) {
            const F = d[P], N = this._touches[P];
            N && (p._add(F), w._add(F.sub(N)), A++, d[P] = F);
          }
          if (this._touches = d, this._shouldBePrevented(A) || !w.mag()) return;
          const C = w.div(A);
          return this._sum._add(C), this._sum.mag() < this._clickTolerance ? void 0 : { around: p.div(A), panDelta: C };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Eo {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(e, r, u) {
          this._firstTwoTouches || u.length < 2 || (this._firstTwoTouches = [u[0].identifier, u[1].identifier], this._start([r[0], r[1]]));
        }
        touchmove(e, r, u) {
          if (!this._firstTwoTouches) return;
          e.preventDefault();
          const [d, p] = this._firstTwoTouches, w = Ga(u, r, d), A = Ga(u, r, p);
          if (!w || !A) return;
          const C = this._aroundCenter ? null : w.add(A).div(2);
          return this._move([w, A], C, e);
        }
        touchend(e, r, u) {
          if (!this._firstTwoTouches) return;
          const [d, p] = this._firstTwoTouches, w = Ga(u, r, d), A = Ga(u, r, p);
          w && A || (this._active && O.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e) {
          this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Ga(h, e, r) {
        for (let u = 0; u < h.length; u++) if (h[u].identifier === r) return e[u];
      }
      function Co(h, e) {
        return Math.log(h / e) / Math.LN2;
      }
      class ul extends Eo {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e) {
          this._startDistance = this._distance = e[0].dist(e[1]);
        }
        _move(e, r) {
          const u = this._distance;
          if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Co(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Co(this._distance, u), pinchAround: r };
        }
      }
      function hu(h, e) {
        return 180 * h.angleWith(e) / Math.PI;
      }
      class du extends Eo {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e) {
          this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
        }
        _move(e, r, u) {
          const d = this._vector;
          if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: hu(this._vector, d), pinchAround: r };
        }
        _isBelowThreshold(e) {
          this._minDiameter = Math.min(this._minDiameter, e.mag());
          const r = 25 / (Math.PI * this._minDiameter) * 360, u = hu(e, this._startVector);
          return Math.abs(u) < r;
        }
      }
      function cl(h) {
        return Math.abs(h.y) > Math.abs(h.x);
      }
      class To extends Eo {
        constructor(e) {
          super(), this._currentTouchCount = 0, this._map = e;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(e, r, u) {
          super.touchstart(e, r, u), this._currentTouchCount = u.length;
        }
        _start(e) {
          this._lastPoints = e, cl(e[0].sub(e[1])) && (this._valid = !1);
        }
        _move(e, r, u) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const d = e[0].sub(this._lastPoints[0]), p = e[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(d, p, u.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (d.y + p.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(e, r, u) {
          if (this._valid !== void 0) return this._valid;
          const d = e.mag() >= 2, p = r.mag() >= 2;
          if (!d && !p) return;
          if (!d || !p) return this._firstMove === void 0 && (this._firstMove = u), u - this._firstMove < 100 && void 0;
          const w = e.y > 0 == r.y > 0;
          return cl(e) && cl(r) && w;
        }
      }
      const qu = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Wn {
        constructor(e) {
          this._tr = new Hn(e);
          const r = qu;
          this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) return;
          let r = 0, u = 0, d = 0, p = 0, w = 0;
          switch (e.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              r = 1;
              break;
            case 189:
            case 109:
            case 173:
              r = -1;
              break;
            case 37:
              e.shiftKey ? u = -1 : (e.preventDefault(), p = -1);
              break;
            case 39:
              e.shiftKey ? u = 1 : (e.preventDefault(), p = 1);
              break;
            case 38:
              e.shiftKey ? d = 1 : (e.preventDefault(), w = -1);
              break;
            case 40:
              e.shiftKey ? d = -1 : (e.preventDefault(), w = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (u = 0, d = 0), { cameraAnimation: (A) => {
            const C = this._tr;
            A.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Ls, zoom: r ? Math.round(C.zoom) + r * (e.shiftKey ? 2 : 1) : C.zoom, bearing: C.bearing + u * this._bearingStep, pitch: C.pitch + d * this._pitchStep, offset: [-p * this._panStep, -w * this._panStep], center: C.center }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Ls(h) {
        return h * (2 - h);
      }
      const pu = 4.000244140625;
      class In {
        constructor(e, r) {
          this._onTimeout = (u) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
          }, this._map = e, this._tr = new Hn(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(e) {
          this._defaultZoomRate = e;
        }
        setWheelZoomRate(e) {
          this._wheelZoomRate = e;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(e) {
          return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
        }
        wheel(e) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
          let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
          const u = j.now(), d = u - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = u, r !== 0 && r % pu == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(d * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault();
        }
        _start(e) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const r = O.mousePos(this._map.getCanvas(), e), u = this._tr;
          this._around = r.y > u.transform.height / 2 - u.transform.getHorizon() ? o.N.convert(this._aroundCenter ? u.center : u.unproject(r)) : o.N.convert(u.center), this._aroundPoint = u.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const e = this._tr.transform;
          if (this._delta !== 0) {
            const C = this._type === "wheel" && Math.abs(this._delta) > pu ? this._wheelZoomRate : this._defaultZoomRate;
            let P = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
            this._delta < 0 && P !== 0 && (P = 1 / P);
            const F = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
            this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(F * P))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const r = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, u = this._startZoom, d = this._easing;
          let p, w = !1;
          const A = j.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && u && d && A) {
            const C = Math.min(A / 200, 1), P = d(C);
            p = o.y.number(u, r, P), C < 1 ? this._frameId || (this._frameId = !0) : w = !0;
          } else p = r, w = !0;
          return this._active = !0, w && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !w, zoomDelta: p - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e) {
          let r = o.b9;
          if (this._prevEase) {
            const u = this._prevEase, d = (j.now() - u.start) / u.duration, p = u.easing(d + 0.01) - u.easing(d), w = 0.27 / Math.sqrt(p * p + 1e-4) * 0.01, A = Math.sqrt(0.0729 - w * w);
            r = o.b8(w, A, 0.25, 1);
          }
          return this._prevEase = { start: j.now(), duration: e, easing: r }, r;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Qs {
        constructor(e, r) {
          this._clickZoom = e, this._tapZoom = r;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class hl {
        constructor(e) {
          this._tr = new Hn(e), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(e, r) {
          return e.preventDefault(), { cameraAnimation: (u) => {
            u.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Dc {
        constructor() {
          this._tap = new Va({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(e, r, u) {
          if (!this._swipePoint) if (this._tapTime) {
            const d = r[0], p = e.timeStamp - this._tapTime < 500, w = this._tapPoint.dist(d) < 30;
            p && w ? u.length > 0 && (this._swipePoint = d, this._swipeTouch = u[0].identifier) : this.reset();
          } else this._tap.touchstart(e, r, u);
        }
        touchmove(e, r, u) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (u[0].identifier !== this._swipeTouch) return;
              const d = r[0], p = d.y - this._swipePoint.y;
              return this._swipePoint = d, e.preventDefault(), this._active = !0, { zoomDelta: p / 128 };
            }
          } else this._tap.touchmove(e, r, u);
        }
        touchend(e, r, u) {
          if (this._tapTime) this._swipePoint && u.length === 0 && this.reset();
          else {
            const d = this._tap.touchend(e, r, u);
            d && (this._tapTime = e.timeStamp, this._tapPoint = d);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Uu {
        constructor(e, r, u) {
          this._el = e, this._mousePan = r, this._touchPan = u;
        }
        enable(e) {
          this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class fu {
        constructor(e, r, u) {
          this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = r, this._mousePitch = u;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class mu {
        constructor(e, r, u, d) {
          this._el = e, this._touchZoom = r, this._touchRotate = u, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(e) {
          this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class ko {
        constructor(e, r) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const e = this._map.getCanvasContainer();
          e.classList.add("maplibregl-cooperative-gestures"), this._container = O.create("div", "maplibregl-cooperative-gesture-screen", e);
          let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const u = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), d = document.createElement("div");
          d.className = "maplibregl-desktop-message", d.textContent = r, this._container.appendChild(d);
          const p = document.createElement("div");
          p.className = "maplibregl-mobile-message", p.textContent = u, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (O.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(e) {
          return e[this._bypassKey];
        }
        notifyGestureBlocked(e, r) {
          this._enabled && (this._map.fire(new o.k("cooperativegestureprevented", { gestureType: e, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const Xn = (h) => h.zoom || h.drag || h.pitch || h.rotate;
      class Ot extends o.k {
      }
      function gs(h) {
        return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta;
      }
      class Pn {
        constructor(e, r) {
          this.handleWindowEvent = (d) => {
            this.handleEvent(d, `${d.type}Window`);
          }, this.handleEvent = (d, p) => {
            if (d.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const w = d.type === "renderFrame" ? void 0 : d, A = { needsRenderFrame: !1 }, C = {}, P = {}, F = d.touches, N = F ? this._getMapTouches(F) : void 0, Z = N ? O.touchPos(this._map.getCanvas(), N) : O.mousePos(this._map.getCanvas(), d);
            for (const { handlerName: W, handler: se, allowed: le } of this._handlers) {
              if (!se.isEnabled()) continue;
              let de;
              this._blockedByActive(P, le, W) ? se.reset() : se[p || d.type] && (de = se[p || d.type](d, Z, N), this.mergeHandlerResult(A, C, de, W, w), de && de.needsRenderFrame && this._triggerRenderFrame()), (de || se.isActive()) && (P[W] = se);
            }
            const G = {};
            for (const W in this._previousActiveHandlers) P[W] || (G[W] = w);
            this._previousActiveHandlers = P, (Object.keys(G).length || gs(A)) && (this._changes.push([A, C, G]), this._triggerRenderFrame()), (Object.keys(P).length || gs(A)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: V } = A;
            V && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], V(this._map));
          }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Cr(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
          const u = this._el;
          this._listeners = [[u, "touchstart", { passive: !0 }], [u, "touchmove", { passive: !1 }], [u, "touchend", void 0], [u, "touchcancel", void 0], [u, "mousedown", void 0], [u, "mousemove", void 0], [u, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [u, "mouseover", void 0], [u, "mouseout", void 0], [u, "dblclick", void 0], [u, "click", void 0], [u, "keydown", { capture: !1 }], [u, "keyup", void 0], [u, "wheel", { passive: !1 }], [u, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [d, p, w] of this._listeners) O.addEventListener(d, p, d === document ? this.handleWindowEvent : this.handleEvent, w);
        }
        destroy() {
          for (const [e, r, u] of this._listeners) O.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, u);
        }
        _addDefaultHandlers(e) {
          const r = this._map, u = r.getCanvasContainer();
          this._add("mapEvent", new cu(r, e));
          const d = r.boxZoom = new bn(r, e);
          this._add("boxZoom", d), e.interactive && e.boxZoom && d.enable();
          const p = r.cooperativeGestures = new ko(r, e.cooperativeGestures);
          this._add("cooperativeGestures", p), e.cooperativeGestures && p.enable();
          const w = new Br(r), A = new hl(r);
          r.doubleClickZoom = new Qs(A, w), this._add("tapZoom", w), this._add("clickZoom", A), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
          const C = new Dc();
          this._add("tapDragZoom", C);
          const P = r.touchPitch = new To(r);
          this._add("touchPitch", P), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
          const F = So(e), N = ll(e);
          r.dragRotate = new fu(e, F, N), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]), e.interactive && e.dragRotate && r.dragRotate.enable();
          const Z = (({ enable: de, clickTolerance: ce }) => {
            const we = new $a({ checkCorrectEvent: (Le) => O.mouseButton(Le) === 0 && !Le.ctrlKey });
            return new Lr({ clickTolerance: ce, move: (Le, Ie) => ({ around: Ie, panDelta: Ie.sub(Le) }), activateOnStart: !0, moveStateManager: we, enable: de, assignEvents: Za });
          })(e), G = new Aa(e, r);
          r.dragPan = new Uu(u, Z, G), this._add("mousePan", Z), this._add("touchPan", G, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
          const V = new du(), W = new ul();
          r.touchZoomRotate = new mu(u, W, V, C), this._add("touchRotate", V, ["touchPan", "touchZoom"]), this._add("touchZoom", W, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
          const se = r.scrollZoom = new In(r, () => this._triggerRenderFrame());
          this._add("scrollZoom", se, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
          const le = r.keyboard = new Wn(r);
          this._add("keyboard", le), e.interactive && e.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new _r(r));
        }
        _add(e, r, u) {
          this._handlers.push({ handlerName: e, handler: r, allowed: u }), this._handlersById[e] = r;
        }
        stop(e) {
          if (!this._updatingCamera) {
            for (const { handler: r } of this._handlers) r.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Xn(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(e, r, u) {
          for (const d in e) if (d !== u && (!r || r.indexOf(d) < 0)) return !0;
          return !1;
        }
        _getMapTouches(e) {
          const r = [];
          for (const u of e) this._el.contains(u.target) && r.push(u);
          return r;
        }
        mergeHandlerResult(e, r, u, d, p) {
          if (!u) return;
          o.e(e, u);
          const w = { handlerName: d, originalEvent: u.originalEvent || p };
          u.zoomDelta !== void 0 && (r.zoom = w), u.panDelta !== void 0 && (r.drag = w), u.pitchDelta !== void 0 && (r.pitch = w), u.bearingDelta !== void 0 && (r.rotate = w);
        }
        _applyChanges() {
          const e = {}, r = {}, u = {};
          for (const [d, p, w] of this._changes) d.panDelta && (e.panDelta = (e.panDelta || new o.P(0, 0))._add(d.panDelta)), d.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + d.zoomDelta), d.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + d.bearingDelta), d.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + d.pitchDelta), d.around !== void 0 && (e.around = d.around), d.pinchAround !== void 0 && (e.pinchAround = d.pinchAround), d.noInertia && (e.noInertia = d.noInertia), o.e(r, p), o.e(u, w);
          this._updateMapTransform(e, r, u), this._changes = [];
        }
        _updateMapTransform(e, r, u) {
          const d = this._map, p = d._getTransformForUpdate(), w = d.terrain;
          if (!(gs(e) || w && this._terrainMovement)) return this._fireEvents(r, u, !0);
          let { panDelta: A, zoomDelta: C, bearingDelta: P, pitchDelta: F, around: N, pinchAround: Z } = e;
          Z !== void 0 && (N = Z), d._stop(!0), N = N || d.transform.centerPoint;
          const G = p.pointLocation(A ? N.sub(A) : N);
          P && (p.bearing += P), F && (p.pitch += F), C && (p.zoom += C), w ? this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? p.center = p.pointLocation(p.centerPoint.sub(A)) : p.setLocationAtPoint(G, N) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, p.setLocationAtPoint(G, N)) : p.setLocationAtPoint(G, N), d._applyUpdatedTransform(p), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, u, !0);
        }
        _fireEvents(e, r, u) {
          const d = Xn(this._eventsInProgress), p = Xn(e), w = {};
          for (const N in e) {
            const { originalEvent: Z } = e[N];
            this._eventsInProgress[N] || (w[`${N}start`] = Z), this._eventsInProgress[N] = e[N];
          }
          !d && p && this._fireEvent("movestart", p.originalEvent);
          for (const N in w) this._fireEvent(N, w[N]);
          p && this._fireEvent("move", p.originalEvent);
          for (const N in e) {
            const { originalEvent: Z } = e[N];
            this._fireEvent(N, Z);
          }
          const A = {};
          let C;
          for (const N in this._eventsInProgress) {
            const { handlerName: Z, originalEvent: G } = this._eventsInProgress[N];
            this._handlersById[Z].isActive() || (delete this._eventsInProgress[N], C = r[Z] || G, A[`${N}end`] = C);
          }
          for (const N in A) this._fireEvent(N, A[N]);
          const P = Xn(this._eventsInProgress), F = (d || p) && !P;
          if (F && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const N = this._map._getTransformForUpdate();
            N.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(N);
          }
          if (u && F) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), Z = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
            !N || !N.essential && j.prefersReducedMotion ? (this._map.fire(new o.k("moveend", { originalEvent: C })), Z(this._map.getBearing()) && this._map.resetNorth()) : (Z(N.bearing || this._map.getBearing()) && (N.bearing = 0), N.freezeElevation = !0, this._map.easeTo(N, { originalEvent: C })), this._updatingCamera = !1;
          }
        }
        _fireEvent(e, r) {
          this._map.fire(new o.k(e, r ? { originalEvent: r } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
            delete this._frameId, this.handleEvent(new Ot("renderFrame", { timeStamp: e })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Ms extends o.E {
        constructor(e, r) {
          super(), this._renderFrameCallback = () => {
            const u = Math.min((j.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = r.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new o.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e, r) {
          return this.jumpTo({ center: e }, r);
        }
        panBy(e, r, u) {
          return e = o.P.convert(e).mult(-1), this.panTo(this.transform.center, o.e({ offset: e }, r), u);
        }
        panTo(e, r, u) {
          return this.easeTo(o.e({ center: e }, r), u);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e, r) {
          return this.jumpTo({ zoom: e }, r), this;
        }
        zoomTo(e, r, u) {
          return this.easeTo(o.e({ zoom: e }, r), u);
        }
        zoomIn(e, r) {
          return this.zoomTo(this.getZoom() + 1, e, r), this;
        }
        zoomOut(e, r) {
          return this.zoomTo(this.getZoom() - 1, e, r), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e, r) {
          return this.jumpTo({ bearing: e }, r), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e, r) {
          return this.jumpTo({ padding: e }, r), this;
        }
        rotateTo(e, r, u) {
          return this.easeTo(o.e({ bearing: e }, r), u);
        }
        resetNorth(e, r) {
          return this.rotateTo(0, o.e({ duration: 1e3 }, e), r), this;
        }
        resetNorthPitch(e, r) {
          return this.easeTo(o.e({ bearing: 0, pitch: 0, duration: 1e3 }, e), r), this;
        }
        snapToNorth(e, r) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e, r) {
          return this.jumpTo({ pitch: e }, r), this;
        }
        cameraForBounds(e, r) {
          e = Y.convert(e).adjustAntiMeridian();
          const u = r && r.bearing || 0;
          return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), u, r);
        }
        _cameraForBoxAndBearing(e, r, u, d) {
          const p = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (d = o.e({ padding: p, offset: [0, 0], maxZoom: this.transform.maxZoom }, d)).padding == "number") {
            const bt = d.padding;
            d.padding = { top: bt, bottom: bt, right: bt, left: bt };
          }
          d.padding = o.e(p, d.padding);
          const w = this.transform, A = w.padding, C = new Y(e, r), P = w.project(C.getNorthWest()), F = w.project(C.getNorthEast()), N = w.project(C.getSouthEast()), Z = w.project(C.getSouthWest()), G = o.ba(-u), V = P.rotate(G), W = F.rotate(G), se = N.rotate(G), le = Z.rotate(G), de = new o.P(Math.max(V.x, W.x, le.x, se.x), Math.max(V.y, W.y, le.y, se.y)), ce = new o.P(Math.min(V.x, W.x, le.x, se.x), Math.min(V.y, W.y, le.y, se.y)), we = de.sub(ce), Le = (w.width - (A.left + A.right + d.padding.left + d.padding.right)) / we.x, Ie = (w.height - (A.top + A.bottom + d.padding.top + d.padding.bottom)) / we.y;
          if (Ie < 0 || Le < 0) return void o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const it = Math.min(w.scaleZoom(w.scale * Math.min(Le, Ie)), d.maxZoom), ht = o.P.convert(d.offset), _t = new o.P((d.padding.left - d.padding.right) / 2, (d.padding.top - d.padding.bottom) / 2).rotate(o.ba(u)), wt = ht.add(_t).mult(w.scale / w.zoomScale(it));
          return { center: w.unproject(P.add(N).div(2).sub(wt)), zoom: it, bearing: u };
        }
        fitBounds(e, r, u) {
          return this._fitInternal(this.cameraForBounds(e, r), r, u);
        }
        fitScreenCoordinates(e, r, u, d, p) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.P.convert(e)), this.transform.pointLocation(o.P.convert(r)), u, d), d, p);
        }
        _fitInternal(e, r, u) {
          return e ? (delete (r = o.e(e, r)).padding, r.linear ? this.easeTo(r, u) : this.flyTo(r, u)) : this;
        }
        jumpTo(e, r) {
          this.stop();
          const u = this._getTransformForUpdate();
          let d = !1, p = !1, w = !1;
          return "zoom" in e && u.zoom !== +e.zoom && (d = !0, u.zoom = +e.zoom), e.center !== void 0 && (u.center = o.N.convert(e.center)), "bearing" in e && u.bearing !== +e.bearing && (p = !0, u.bearing = +e.bearing), "pitch" in e && u.pitch !== +e.pitch && (w = !0, u.pitch = +e.pitch), e.padding == null || u.isPaddingEqual(e.padding) || (u.padding = e.padding), this._applyUpdatedTransform(u), this.fire(new o.k("movestart", r)).fire(new o.k("move", r)), d && this.fire(new o.k("zoomstart", r)).fire(new o.k("zoom", r)).fire(new o.k("zoomend", r)), p && this.fire(new o.k("rotatestart", r)).fire(new o.k("rotate", r)).fire(new o.k("rotateend", r)), w && this.fire(new o.k("pitchstart", r)).fire(new o.k("pitch", r)).fire(new o.k("pitchend", r)), this.fire(new o.k("moveend", r));
        }
        calculateCameraOptionsFromTo(e, r, u, d = 0) {
          const p = o.Z.fromLngLat(e, r), w = o.Z.fromLngLat(u, d), A = w.x - p.x, C = w.y - p.y, P = w.z - p.z, F = Math.hypot(A, C, P);
          if (F === 0) throw new Error("Can't calculate camera options with same From and To");
          const N = Math.hypot(A, C), Z = this.transform.scaleZoom(this.transform.cameraToCenterDistance / F / this.transform.tileSize), G = 180 * Math.atan2(A, -C) / Math.PI;
          let V = 180 * Math.acos(N / F) / Math.PI;
          return V = P < 0 ? 90 - V : 90 + V, { center: w.toLngLat(), zoom: Z, pitch: V, bearing: G };
        }
        easeTo(e, r) {
          var u;
          this._stop(!1, e.easeId), ((e = o.e({ offset: [0, 0], duration: 500, easing: o.b9 }, e)).animate === !1 || !e.essential && j.prefersReducedMotion) && (e.duration = 0);
          const d = this._getTransformForUpdate(), p = d.zoom, w = d.bearing, A = d.pitch, C = d.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, w) : w, F = "pitch" in e ? +e.pitch : A, N = "padding" in e ? e.padding : d.padding, Z = o.P.convert(e.offset);
          let G = d.centerPoint.add(Z);
          const V = d.pointLocation(G), { center: W, zoom: se } = d.getConstrained(o.N.convert(e.center || V), (u = e.zoom) !== null && u !== void 0 ? u : p);
          this._normalizeCenter(W, d);
          const le = d.project(V), de = d.project(W).sub(le), ce = d.zoomScale(se - p);
          let we, Le;
          e.around && (we = o.N.convert(e.around), Le = d.locationPoint(we));
          const Ie = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || se !== p, this._rotating = this._rotating || w !== P, this._pitching = this._pitching || F !== A, this._padding = !d.isPaddingEqual(N), this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, Ie), this.terrain && this._prepareElevation(W), this._ease((it) => {
            if (this._zooming && (d.zoom = o.y.number(p, se, it)), this._rotating && (d.bearing = o.y.number(w, P, it)), this._pitching && (d.pitch = o.y.number(A, F, it)), this._padding && (d.interpolatePadding(C, N, it), G = d.centerPoint.add(Z)), this.terrain && !e.freezeElevation && this._updateElevation(it), we) d.setLocationAtPoint(we, Le);
            else {
              const ht = d.zoomScale(d.zoom - p), _t = se > p ? Math.min(2, ce) : Math.max(0.5, ce), wt = Math.pow(_t, 1 - it), bt = d.unproject(le.add(de.mult(it * wt)).mult(ht));
              d.setLocationAtPoint(d.renderWorldCopies ? bt.wrap() : bt, G);
            }
            this._applyUpdatedTransform(d), this._fireMoveEvents(r);
          }, (it) => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, it);
          }, e), this;
        }
        _prepareEase(e, r, u = {}) {
          this._moving = !0, r || u.moving || this.fire(new o.k("movestart", e)), this._zooming && !u.zooming && this.fire(new o.k("zoomstart", e)), this._rotating && !u.rotating && this.fire(new o.k("rotatestart", e)), this._pitching && !u.pitching && this.fire(new o.k("pitchstart", e));
        }
        _prepareElevation(e) {
          this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(e) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e < 1 && r !== this._elevationTarget) {
            const u = this._elevationTarget - this._elevationStart;
            this._elevationStart += e * (u - (r - (u * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r;
          }
          this.transform.elevation = o.y.number(this._elevationStart, this._elevationTarget, e);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(e) {
          const r = e.getCameraPosition(), u = this.terrain.getElevationForLngLatZoom(r.lngLat, e.zoom);
          if (r.altitude < u) {
            const d = this.calculateCameraOptionsFromTo(r.lngLat, u, e.center, e.elevation);
            return { pitch: d.pitch, zoom: d.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(e) {
          const r = [];
          if (this.terrain && r.push((d) => this._elevateCameraIfInsideTerrain(d)), this.transformCameraUpdate && r.push((d) => this.transformCameraUpdate(d)), !r.length) return;
          const u = e.clone();
          for (const d of r) {
            const p = u.clone(), { center: w, zoom: A, pitch: C, bearing: P, elevation: F } = d(p);
            w && (p.center = w), A !== void 0 && (p.zoom = A), C !== void 0 && (p.pitch = C), P !== void 0 && (p.bearing = P), F !== void 0 && (p.elevation = F), u.apply(p);
          }
          this.transform.apply(u);
        }
        _fireMoveEvents(e) {
          this.fire(new o.k("move", e)), this._zooming && this.fire(new o.k("zoom", e)), this._rotating && this.fire(new o.k("rotate", e)), this._pitching && this.fire(new o.k("pitch", e));
        }
        _afterEase(e, r) {
          if (this._easeId && r && this._easeId === r) return;
          delete this._easeId;
          const u = this._zooming, d = this._rotating, p = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, u && this.fire(new o.k("zoomend", e)), d && this.fire(new o.k("rotateend", e)), p && this.fire(new o.k("pitchend", e)), this.fire(new o.k("moveend", e));
        }
        flyTo(e, r) {
          var u;
          if (!e.essential && j.prefersReducedMotion) {
            const kt = o.M(e, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(kt, r);
          }
          this.stop(), e = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.b9 }, e);
          const d = this._getTransformForUpdate(), p = d.zoom, w = d.bearing, A = d.pitch, C = d.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, w) : w, F = "pitch" in e ? +e.pitch : A, N = "padding" in e ? e.padding : d.padding, Z = o.P.convert(e.offset);
          let G = d.centerPoint.add(Z);
          const V = d.pointLocation(G), { center: W, zoom: se } = d.getConstrained(o.N.convert(e.center || V), (u = e.zoom) !== null && u !== void 0 ? u : p);
          this._normalizeCenter(W, d);
          const le = d.zoomScale(se - p), de = d.project(V), ce = d.project(W).sub(de);
          let we = e.curve;
          const Le = Math.max(d.width, d.height), Ie = Le / le, it = ce.mag();
          if ("minZoom" in e) {
            const kt = o.ac(Math.min(e.minZoom, p, se), d.minZoom, d.maxZoom), Wt = Le / d.zoomScale(kt - p);
            we = Math.sqrt(Wt / it * 2);
          }
          const ht = we * we;
          function _t(kt) {
            const Wt = (Ie * Ie - Le * Le + (kt ? -1 : 1) * ht * ht * it * it) / (2 * (kt ? Ie : Le) * ht * it);
            return Math.log(Math.sqrt(Wt * Wt + 1) - Wt);
          }
          function wt(kt) {
            return (Math.exp(kt) - Math.exp(-kt)) / 2;
          }
          function bt(kt) {
            return (Math.exp(kt) + Math.exp(-kt)) / 2;
          }
          const yt = _t(!1);
          let St = function(kt) {
            return bt(yt) / bt(yt + we * kt);
          }, Zt = function(kt) {
            return Le * ((bt(yt) * (wt(Wt = yt + we * kt) / bt(Wt)) - wt(yt)) / ht) / it;
            var Wt;
          }, Tt = (_t(!0) - yt) / we;
          if (Math.abs(it) < 1e-6 || !isFinite(Tt)) {
            if (Math.abs(Le - Ie) < 1e-6) return this.easeTo(e, r);
            const kt = Ie < Le ? -1 : 1;
            Tt = Math.abs(Math.log(Ie / Le)) / we, Zt = () => 0, St = (Wt) => Math.exp(kt * we * Wt);
          }
          return e.duration = "duration" in e ? +e.duration : 1e3 * Tt / ("screenSpeed" in e ? +e.screenSpeed / we : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = w !== P, this._pitching = F !== A, this._padding = !d.isPaddingEqual(N), this._prepareEase(r, !1), this.terrain && this._prepareElevation(W), this._ease((kt) => {
            const Wt = kt * Tt, di = 1 / St(Wt);
            d.zoom = kt === 1 ? se : p + d.scaleZoom(di), this._rotating && (d.bearing = o.y.number(w, P, kt)), this._pitching && (d.pitch = o.y.number(A, F, kt)), this._padding && (d.interpolatePadding(C, N, kt), G = d.centerPoint.add(Z)), this.terrain && !e.freezeElevation && this._updateElevation(kt);
            const ci = kt === 1 ? W : d.unproject(de.add(ce.mult(Zt(Wt))).mult(di));
            d.setLocationAtPoint(d.renderWorldCopies ? ci.wrap() : ci, G), this._applyUpdatedTransform(d), this._fireMoveEvents(r);
          }, () => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r);
          }, e), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e, r) {
          var u;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const d = this._onEaseEnd;
            delete this._onEaseEnd, d.call(this, r);
          }
          return e || (u = this.handlers) === null || u === void 0 || u.stop(!1), this;
        }
        _ease(e, r, u) {
          u.animate === !1 || u.duration === 0 ? (e(1), r()) : (this._easeStart = j.now(), this._easeOptions = u, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e, r) {
          e = o.b3(e, -180, 180);
          const u = Math.abs(e - r);
          return Math.abs(e - 360 - r) < u && (e -= 360), Math.abs(e + 360 - r) < u && (e += 360), e;
        }
        _normalizeCenter(e, r) {
          if (!r.renderWorldCopies || r.lngRange) return;
          const u = e.lng - r.center.lng;
          e.lng += u > 180 ? -360 : u < -180 ? 360 : 0;
        }
        queryTerrainElevation(e) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(o.N.convert(e), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const Do = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Ha {
        constructor(e = Do) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (r) => {
            !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e) {
          return this._map = e, this._compact = this.options.compact, this._container = O.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = O.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = O.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e, r) {
          const u = this._map._getUIString(`AttributionControl.${r}`);
          e.title = u, e.setAttribute("aria-label", u);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let e = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((d) => typeof d != "string" ? "" : d)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const d = this._map.style.stylesheet;
            this.styleOwner = d.owner, this.styleId = d.id;
          }
          const r = this._map.style.sourceCaches;
          for (const d in r) {
            const p = r[d];
            if (p.used || p.usedForTerrain) {
              const w = p.getSource();
              w.attribution && e.indexOf(w.attribution) < 0 && e.push(w.attribution);
            }
          }
          e = e.filter((d) => String(d).trim()), e.sort((d, p) => d.length - p.length), e = e.filter((d, p) => {
            for (let w = p + 1; w < e.length; w++) if (e[w].indexOf(d) >= 0) return !1;
            return !0;
          });
          const u = e.join(" | ");
          u !== this._attribHTML && (this._attribHTML = u, e.length ? (this._innerContainer.innerHTML = u, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Ns {
        constructor(e = {}) {
          this._updateCompact = () => {
            const r = this._container.children;
            if (r.length) {
              const u = r[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && u.classList.add("maplibregl-compact") : u.classList.remove("maplibregl-compact");
            }
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(e) {
          this._map = e, this._compact = this.options && this.options.compact, this._container = O.create("div", "maplibregl-ctrl");
          const r = O.create("a", "maplibregl-ctrl-logo");
          return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class vi {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(e) {
          const r = ++this._id;
          return this._queue.push({ callback: e, id: r, cancelled: !1 }), r;
        }
        remove(e) {
          const r = this._currentlyRunning, u = r ? this._queue.concat(r) : this._queue;
          for (const d of u) if (d.id === e) return void (d.cancelled = !0);
        }
        run(e = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const r = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const u of r) if (!u.cancelled && (u.callback(e), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var gu = o.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Ic extends o.E {
        constructor(e) {
          super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = !0, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(e, r) {
          this.sourceCache.update(e, r), this._renderableTilesKeys = [];
          const u = {};
          for (const d of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r })) u[d.key] = !0, this._renderableTilesKeys.push(d.key), this._tiles[d.key] || (d.posMatrix = new Float64Array(16), o.aP(d.posMatrix, 0, o.X, 0, o.X, 0, 1), this._tiles[d.key] = new Zi(d, this.tileSize));
          for (const d in this._tiles) u[d] || delete this._tiles[d];
        }
        freeRtt(e) {
          for (const r in this._tiles) {
            const u = this._tiles[r];
            (!e || u.tileID.equals(e) || u.tileID.isChildOf(e) || e.isChildOf(u.tileID)) && (u.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((e) => this.getTileByID(e));
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        getTerrainCoords(e) {
          const r = {};
          for (const u of this._renderableTilesKeys) {
            const d = this._tiles[u].tileID;
            if (d.canonical.equals(e.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16), o.aP(p.posMatrix, 0, o.X, 0, o.X, 0, 1), r[u] = p;
            } else if (d.canonical.isChildOf(e.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16);
              const w = d.canonical.z - e.canonical.z, A = d.canonical.x - (d.canonical.x >> w << w), C = d.canonical.y - (d.canonical.y >> w << w), P = o.X >> w;
              o.aP(p.posMatrix, 0, P, 0, P, 0, 1), o.J(p.posMatrix, p.posMatrix, [-A * P, -C * P, 0]), r[u] = p;
            } else if (e.canonical.isChildOf(d.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16);
              const w = e.canonical.z - d.canonical.z, A = e.canonical.x - (e.canonical.x >> w << w), C = e.canonical.y - (e.canonical.y >> w << w), P = o.X >> w;
              o.aP(p.posMatrix, 0, o.X, 0, o.X, 0, 1), o.J(p.posMatrix, p.posMatrix, [A * P, C * P, 0]), o.K(p.posMatrix, p.posMatrix, [1 / 2 ** w, 1 / 2 ** w, 0]), r[u] = p;
            }
          }
          return r;
        }
        getSourceTile(e, r) {
          const u = this.sourceCache._source;
          let d = e.overscaledZ - this.deltaZoom;
          if (d > u.maxzoom && (d = u.maxzoom), d < u.minzoom) return null;
          this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(d).key);
          let p = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
          if ((!p || !p.dem) && r) for (; d >= u.minzoom && (!p || !p.dem); ) p = this.sourceCache.getTileByID(e.scaledTo(d--).key);
          return p;
        }
        tilesAfterTime(e = Date.now()) {
          return Object.values(this._tiles).filter((r) => r.timeAdded >= e);
        }
      }
      class Bl {
        constructor(e, r, u) {
          this.painter = e, this.sourceCache = new Ic(r), this.options = u, this.exaggeration = typeof u.exaggeration == "number" ? u.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e, r, u, d = o.X) {
          var p;
          if (!(r >= 0 && r < d && u >= 0 && u < d)) return 0;
          const w = this.getTerrainData(e), A = (p = w.tile) === null || p === void 0 ? void 0 : p.dem;
          if (!A) return 0;
          const C = function(V, W, se) {
            var le = W[0], de = W[1];
            return V[0] = se[0] * le + se[4] * de + se[12], V[1] = se[1] * le + se[5] * de + se[13], V;
          }([], [r / d * o.X, u / d * o.X], w.u_terrain_matrix), P = [C[0] * A.dim, C[1] * A.dim], F = Math.floor(P[0]), N = Math.floor(P[1]), Z = P[0] - F, G = P[1] - N;
          return A.get(F, N) * (1 - Z) * (1 - G) + A.get(F + 1, N) * Z * (1 - G) + A.get(F, N + 1) * (1 - Z) * G + A.get(F + 1, N + 1) * Z * G;
        }
        getElevationForLngLatZoom(e, r) {
          if (!o.bb(r, e.wrap())) return 0;
          const { tileID: u, mercatorX: d, mercatorY: p } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return this.getElevation(u, d % o.X, p % o.X, o.X);
        }
        getElevation(e, r, u, d = o.X) {
          return this.getDEMElevation(e, r, u, d) * this.exaggeration;
        }
        getTerrainData(e) {
          if (!this._emptyDemTexture) {
            const d = this.painter.context, p = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new X(d, p, d.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new X(d, new o.R({ width: 1, height: 1 }), d.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(d.gl.NEAREST, d.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.an([]);
          }
          const r = this.sourceCache.getSourceTile(e, !0);
          if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
            const d = this.painter.context;
            r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new X(d, r.dem.getPixels(), d.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(d.gl.NEAREST, d.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
          }
          const u = r && r + r.tileID.key + e.key;
          if (u && !this._demMatrixCache[u]) {
            const d = this.sourceCache.sourceCache._source.maxzoom;
            let p = e.canonical.z - r.tileID.canonical.z;
            e.overscaledZ > e.canonical.z && (e.canonical.z >= d ? p = e.canonical.z - d : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const w = e.canonical.x - (e.canonical.x >> p << p), A = e.canonical.y - (e.canonical.y >> p << p), C = o.bc(new Float64Array(16), [1 / (o.X << p), 1 / (o.X << p), 0]);
            o.J(C, C, [w * o.X, A * o.X, 0]), this._demMatrixCache[e.key] = { matrix: C, coord: e };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: u ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
        }
        getFramebuffer(e) {
          const r = this.painter, u = r.width / devicePixelRatio, d = r.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === u && this._fbo.height === d || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new X(r.context, { width: u, height: d, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new X(r.context, { width: u, height: d, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(u, d, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, u, d))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const e = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let p = 0, w = 0; p < this._coordsTextureSize; p++) for (let A = 0; A < this._coordsTextureSize; A++, w += 4) r[w + 0] = 255 & A, r[w + 1] = 255 & p, r[w + 2] = A >> 8 << 4 | p >> 8, r[w + 3] = 0;
          const u = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), d = new X(e, u, e.gl.RGBA, { premultiply: !1 });
          return d.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = d, d;
        }
        pointCoordinate(e) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const r = new Uint8Array(4), u = this.painter.context, d = u.gl, p = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), w = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), A = Math.round(this.painter.height / devicePixelRatio);
          u.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), d.readPixels(p, A - w - 1, 1, 1, d.RGBA, d.UNSIGNED_BYTE, r), u.bindFramebuffer.set(null);
          const C = r[0] + (r[2] >> 4 << 8), P = r[1] + ((15 & r[2]) << 8), F = this.coordsIndex[255 - r[3]], N = F && this.sourceCache.getTileByID(F);
          if (!N) return null;
          const Z = this._coordsTextureSize, G = (1 << N.tileID.canonical.z) * Z;
          return new o.Z((N.tileID.canonical.x * Z + C) / G + N.tileID.wrap, (N.tileID.canonical.y * Z + P) / G, this.getElevation(N.tileID, C, P, Z));
        }
        depthAtPoint(e) {
          const r = new Uint8Array(4), u = this.painter.context, d = u.gl;
          return u.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), d.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, d.RGBA, d.UNSIGNED_BYTE, r), u.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const e = this.painter.context, r = new o.bd(), u = new o.aY(), d = this.meshSize, p = o.X / d, w = d * d;
          for (let N = 0; N <= d; N++) for (let Z = 0; Z <= d; Z++) r.emplaceBack(Z * p, N * p, 0);
          for (let N = 0; N < w; N += d + 1) for (let Z = 0; Z < d; Z++) u.emplaceBack(Z + N, d + Z + N + 1, d + Z + N + 2), u.emplaceBack(Z + N, d + Z + N + 2, Z + N + 1);
          const A = r.length, C = A + 2 * (d + 1);
          for (const N of [0, 1]) for (let Z = 0; Z <= d; Z++) for (const G of [0, 1]) r.emplaceBack(Z * p, N * o.X, G);
          for (let N = 0; N < 2 * d; N += 2) u.emplaceBack(C + N, C + N + 1, C + N + 3), u.emplaceBack(C + N, C + N + 3, C + N + 2), u.emplaceBack(A + N, A + N + 3, A + N + 1), u.emplaceBack(A + N, A + N + 2, A + N + 3);
          const P = r.length, F = P + 2 * (d + 1);
          for (const N of [0, 1]) for (let Z = 0; Z <= d; Z++) for (const G of [0, 1]) r.emplaceBack(N * o.X, Z * p, G);
          for (let N = 0; N < 2 * d; N += 2) u.emplaceBack(P + N, P + N + 1, P + N + 3), u.emplaceBack(P + N, P + N + 3, P + N + 2), u.emplaceBack(F + N, F + N + 3, F + N + 1), u.emplaceBack(F + N, F + N + 2, F + N + 3);
          return this._mesh = new ba(e.createVertexBuffer(r, gu.members), e.createIndexBuffer(u), o.a0.simpleSegment(0, 0, r.length, u.length)), this._mesh;
        }
        getMeshFrameDelta(e) {
          return 2 * Math.PI * o.be / Math.pow(2, e) / 5;
        }
        getMinTileElevationForLngLatZoom(e, r) {
          var u;
          const { tileID: d } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return (u = this.getMinMaxElevation(d).minElevation) !== null && u !== void 0 ? u : 0;
        }
        getMinMaxElevation(e) {
          const r = this.getTerrainData(e).tile, u = { minElevation: null, maxElevation: null };
          return r && r.dem && (u.minElevation = r.dem.min * this.exaggeration, u.maxElevation = r.dem.max * this.exaggeration), u;
        }
        _getOverscaledTileIDFromLngLatZoom(e, r) {
          const u = o.Z.fromLngLat(e.wrap()), d = (1 << r) * o.X, p = u.x * d, w = u.y * d, A = Math.floor(p / o.X), C = Math.floor(w / o.X);
          return { tileID: new o.S(r, 0, r, A, C), mercatorX: p, mercatorY: w };
        }
      }
      class Vu {
        constructor(e, r, u) {
          this._context = e, this._size = r, this._tileSize = u, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
        }
        _createObject(e) {
          const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), u = new X(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return u.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(u.texture), { id: e, fbo: r, texture: u, stamp: -1, inUse: !1 };
        }
        getObjectForId(e) {
          return this._objects[e];
        }
        useObject(e) {
          e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((r) => e.id !== r), this._recentlyUsed.push(e.id);
        }
        stampObject(e) {
          e.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const e = this._createObject(this._objects.length);
          return this._objects.push(e), e;
        }
        freeObject(e) {
          e.inUse = !1;
        }
        freeAllObjects() {
          for (const e of this._objects) this.freeObject(e);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
        }
      }
      const Wa = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class _u {
        constructor(e, r) {
          this.painter = e, this.terrain = r, this.pool = new Vu(e.context, 30, r.sourceCache.tileSize * r.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(e) {
          return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(e, r) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((u) => !e._layers[u].isHidden(r)), this._coordsDescendingInv = {};
          for (const u in e.sourceCaches) {
            this._coordsDescendingInv[u] = {};
            const d = e.sourceCaches[u].getVisibleCoordinates();
            for (const p of d) {
              const w = this.terrain.sourceCache.getTerrainCoords(p);
              for (const A in w) this._coordsDescendingInv[u][A] || (this._coordsDescendingInv[u][A] = []), this._coordsDescendingInv[u][A].push(w[A]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const u of e._order) {
            const d = e._layers[u], p = d.source;
            if (Wa[d.type] && !this._coordsDescendingInvStr[p]) {
              this._coordsDescendingInvStr[p] = {};
              for (const w in this._coordsDescendingInv[p]) this._coordsDescendingInvStr[p][w] = this._coordsDescendingInv[p][w].map((A) => A.key).sort().join();
            }
          }
          for (const u of this._renderableTiles) for (const d in this._coordsDescendingInvStr) {
            const p = this._coordsDescendingInvStr[d][u.tileID.key];
            p && p !== u.rttCoords[d] && (u.rtt = []);
          }
        }
        renderLayer(e) {
          if (e.isHidden(this.painter.transform.zoom)) return !1;
          const r = e.type, u = this.painter, d = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
          if (Wa[r] && (this._prevType && Wa[this._prevType] || this._stacks.push([]), this._prevType = r, this._stacks[this._stacks.length - 1].push(e.id), !d)) return !0;
          if (Wa[this._prevType] || Wa[r] && d) {
            this._prevType = r;
            const p = this._stacks.length - 1, w = this._stacks[p] || [];
            for (const A of this._renderableTiles) {
              if (this.pool.isFull() && (Ua(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(A), A.rtt[p]) {
                const P = this.pool.getObjectForId(A.rtt[p].id);
                if (P.stamp === A.rtt[p].stamp) {
                  this.pool.useObject(P);
                  continue;
                }
              }
              const C = this.pool.getOrCreateFreeObject();
              this.pool.useObject(C), this.pool.stampObject(C), A.rtt[p] = { id: C.id, stamp: C.stamp }, u.context.bindFramebuffer.set(C.fbo.framebuffer), u.context.clear({ color: o.aM.transparent, stencil: 0 }), u.currentStencilSource = void 0;
              for (let P = 0; P < w.length; P++) {
                const F = u.style._layers[w[P]], N = F.source ? this._coordsDescendingInv[F.source][A.tileID.key] : [A.tileID];
                u.context.viewport.set([0, 0, C.fbo.width, C.fbo.height]), u._renderTileClippingMasks(F, N), u.renderLayer(u, u.style.sourceCaches[F.source], F, N), F.source && (A.rttCoords[F.source] = this._coordsDescendingInvStr[F.source][A.tileID.key]);
              }
            }
            return Ua(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Wa[r];
          }
          return !1;
        }
      }
      const yu = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, dl = k, Rl = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Do, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Xa = (h) => {
        h.touchstart = h.dragStart, h.touchmoveWindow = h.dragMove, h.touchend = h.dragEnd;
      }, vu = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class $u {
        constructor(e, r, u = !1) {
          this.mousedown = (w) => {
            this.startMouse(o.e({}, w, { ctrlKey: !0, preventDefault: () => w.preventDefault() }), O.mousePos(this.element, w)), O.addEventListener(window, "mousemove", this.mousemove), O.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (w) => {
            this.moveMouse(w, O.mousePos(this.element, w));
          }, this.mouseup = (w) => {
            this.mouseRotate.dragEnd(w), this.mousePitch && this.mousePitch.dragEnd(w), this.offTemp();
          }, this.touchstart = (w) => {
            w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = O.touchPos(this.element, w.targetTouches)[0], this.startTouch(w, this._startPos), O.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (w) => {
            w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = O.touchPos(this.element, w.targetTouches)[0], this.moveTouch(w, this._lastPos));
          }, this.touchend = (w) => {
            w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const d = e.dragRotate._mouseRotate.getClickTolerance(), p = e.dragRotate._mousePitch.getClickTolerance();
          this.element = r, this.mouseRotate = So({ clickTolerance: d, enable: !0 }), this.touchRotate = (({ enable: w, clickTolerance: A, bearingDegreesPerPixelMoved: C = 0.8 }) => {
            const P = new Fl();
            return new Lr({ clickTolerance: A, move: (F, N) => ({ bearingDelta: (N.x - F.x) * C }), moveStateManager: P, enable: w, assignEvents: Xa });
          })({ clickTolerance: d, enable: !0 }), this.map = e, u && (this.mousePitch = ll({ clickTolerance: p, enable: !0 }), this.touchPitch = (({ enable: w, clickTolerance: A, pitchDegreesPerPixelMoved: C = -0.5 }) => {
            const P = new Fl();
            return new Lr({ clickTolerance: A, move: (F, N) => ({ pitchDelta: (N.y - F.y) * C }), moveStateManager: P, enable: w, assignEvents: Xa });
          })({ clickTolerance: p, enable: !0 })), O.addEventListener(r, "mousedown", this.mousedown), O.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), O.addEventListener(r, "touchcancel", this.reset);
        }
        startMouse(e, r) {
          this.mouseRotate.dragStart(e, r), this.mousePitch && this.mousePitch.dragStart(e, r), O.disableDrag();
        }
        startTouch(e, r) {
          this.touchRotate.dragStart(e, r), this.touchPitch && this.touchPitch.dragStart(e, r), O.disableDrag();
        }
        moveMouse(e, r) {
          const u = this.map, { bearingDelta: d } = this.mouseRotate.dragMove(e, r) || {};
          if (d && u.setBearing(u.getBearing() + d), this.mousePitch) {
            const { pitchDelta: p } = this.mousePitch.dragMove(e, r) || {};
            p && u.setPitch(u.getPitch() + p);
          }
        }
        moveTouch(e, r) {
          const u = this.map, { bearingDelta: d } = this.touchRotate.dragMove(e, r) || {};
          if (d && u.setBearing(u.getBearing() + d), this.touchPitch) {
            const { pitchDelta: p } = this.touchPitch.dragMove(e, r) || {};
            p && u.setPitch(u.getPitch() + p);
          }
        }
        off() {
          const e = this.element;
          O.removeEventListener(e, "mousedown", this.mousedown), O.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), O.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.removeEventListener(window, "touchend", this.touchend), O.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          O.enableDrag(), O.removeEventListener(window, "mousemove", this.mousemove), O.removeEventListener(window, "mouseup", this.mouseup), O.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Ln;
      function Ji(h, e, r) {
        const u = new o.N(h.lng, h.lat);
        if (h = new o.N(h.lng, h.lat), e) {
          const d = new o.N(h.lng - 360, h.lat), p = new o.N(h.lng + 360, h.lat), w = r.locationPoint(h).distSqr(e);
          r.locationPoint(d).distSqr(e) < w ? h = d : r.locationPoint(p).distSqr(e) < w && (h = p);
        }
        for (; Math.abs(h.lng - r.center.lng) > 180; ) {
          const d = r.locationPoint(h);
          if (d.x >= 0 && d.y >= 0 && d.x <= r.width && d.y <= r.height) break;
          h.lng > r.center.lng ? h.lng -= 360 : h.lng += 360;
        }
        return h.lng !== u.lng && r.locationPoint(h).y > r.height / 2 - r.getHorizon() ? h : u;
      }
      const Io = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Ol(h, e, r) {
        const u = h.classList;
        for (const d in Io) u.remove(`maplibregl-${r}-anchor-${d}`);
        u.add(`maplibregl-${r}-anchor-${e}`);
      }
      class jl extends o.E {
        constructor(e) {
          if (super(), this._onKeyPress = (r) => {
            const u = r.code, d = r.charCode || r.keyCode;
            u !== "Space" && u !== "Enter" && d !== 32 && d !== 13 || this.togglePopup();
          }, this._onMapClick = (r) => {
            const u = r.originalEvent.target, d = this._element;
            this._popup && (u === d || d.contains(u)) && this.togglePopup();
          }, this._update = (r) => {
            var u;
            if (!this._map) return;
            const d = this._map.loaded() && !this._map.isMoving();
            ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !d) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Ji(this._lngLat, this._flatPos, this._map.transform) : (u = this._lngLat) === null || u === void 0 ? void 0 : u.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let p = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let w = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? w = "rotateX(0deg)" : this._pitchAlignment === "map" && (w = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), O.setTransform(this._element, `${Io[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${w} ${p}`), j.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(r && r.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (r) => {
            if (!this._isDragging) {
              const u = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = r.point.dist(this._pointerdownPos) >= u;
            }
            this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.k("dragstart"))), this.fire(new o.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (r) => {
            this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = o.P.convert(e && e.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = O.create("div");
            const r = O.createNS("http://www.w3.org/2000/svg", "svg"), u = 41, d = 27;
            r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${u}px`), r.setAttributeNS(null, "width", `${d}px`), r.setAttributeNS(null, "viewBox", `0 0 ${d} ${u}`);
            const p = O.createNS("http://www.w3.org/2000/svg", "g");
            p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
            const w = O.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "fill-rule", "nonzero");
            const A = O.createNS("http://www.w3.org/2000/svg", "g");
            A.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), A.setAttributeNS(null, "fill", "#000000");
            const C = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const le of C) {
              const de = O.createNS("http://www.w3.org/2000/svg", "ellipse");
              de.setAttributeNS(null, "opacity", "0.04"), de.setAttributeNS(null, "cx", "10.5"), de.setAttributeNS(null, "cy", "5.80029008"), de.setAttributeNS(null, "rx", le.rx), de.setAttributeNS(null, "ry", le.ry), A.appendChild(de);
            }
            const P = O.createNS("http://www.w3.org/2000/svg", "g");
            P.setAttributeNS(null, "fill", this._color);
            const F = O.createNS("http://www.w3.org/2000/svg", "path");
            F.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), P.appendChild(F);
            const N = O.createNS("http://www.w3.org/2000/svg", "g");
            N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "fill", "#000000");
            const Z = O.createNS("http://www.w3.org/2000/svg", "path");
            Z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), N.appendChild(Z);
            const G = O.createNS("http://www.w3.org/2000/svg", "g");
            G.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), G.setAttributeNS(null, "fill", "#FFFFFF");
            const V = O.createNS("http://www.w3.org/2000/svg", "g");
            V.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const W = O.createNS("http://www.w3.org/2000/svg", "circle");
            W.setAttributeNS(null, "fill", "#000000"), W.setAttributeNS(null, "opacity", "0.25"), W.setAttributeNS(null, "cx", "5.5"), W.setAttributeNS(null, "cy", "5.5"), W.setAttributeNS(null, "r", "5.4999962");
            const se = O.createNS("http://www.w3.org/2000/svg", "circle");
            se.setAttributeNS(null, "fill", "#FFFFFF"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962"), V.appendChild(W), V.appendChild(se), w.appendChild(A), w.appendChild(P), w.appendChild(N), w.appendChild(G), w.appendChild(V), r.appendChild(w), r.setAttributeNS(null, "height", u * this._scale + "px"), r.setAttributeNS(null, "width", d * this._scale + "px"), this._element.appendChild(r), this._offset = o.P.convert(e && e.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (r) => {
            r.preventDefault();
          }), this._element.addEventListener("mousedown", (r) => {
            r.preventDefault();
          }), Ol(this._element, this._anchor, "marker"), e && e.className) for (const r of e.className.split(" ")) this._element.classList.add(r);
          this._popup = null;
        }
        addTo(e) {
          return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), O.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e) {
          return this._lngLat = o.N.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
            if (!("offset" in e.options)) {
              const d = Math.abs(13.5) / Math.SQRT2;
              e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (38.1 - 13.5 + d)], "bottom-right": [-d, -1 * (38.1 - 13.5 + d)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(e) {
          return this._subpixelPositioning = e, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
        }
        _updateOpacity(e = !1) {
          var r, u;
          if (!(!((r = this._map) === null || r === void 0) && r.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (e) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const d = this._map, p = d.terrain.depthAtPoint(this._pos), w = d.terrain.getElevationForLngLatZoom(this._lngLat, d.transform.tileZoom);
          if (d.transform.lngLatToCameraDepth(this._lngLat, w) - p < 6e-3) return void (this._element.style.opacity = this._opacity);
          const A = -this._offset.y / d.transform._pixelPerMeter, C = Math.sin(d.getPitch() * Math.PI / 180) * A, P = d.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), F = d.transform.lngLatToCameraDepth(this._lngLat, w + C) - P > 6e-3;
          !((u = this._popup) === null || u === void 0) && u.isOpen() && F && this._popup.remove(), this._element.style.opacity = F ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e) {
          return this._offset = o.P.convert(e), this._update(), this;
        }
        addClassName(e) {
          this._element.classList.add(e);
        }
        removeClassName(e) {
          this._element.classList.remove(e);
        }
        toggleClassName(e) {
          return this._element.classList.toggle(e);
        }
        setDraggable(e) {
          return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e) {
          return this._rotation = e || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e) {
          return this._rotationAlignment = e || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e) {
          return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(e, r) {
          return e === void 0 && r === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
        }
      }
      const Zu = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let pl = 0, fl = !1;
      const _s = { maxWidth: 100, unit: "metric" };
      function Sa(h, e, r) {
        const u = r && r.maxWidth || 100, d = h._container.clientHeight / 2, p = h.unproject([0, d]), w = h.unproject([u, d]), A = p.distanceTo(w);
        if (r && r.unit === "imperial") {
          const C = 3.2808 * A;
          C > 5280 ? Gt(e, u, C / 5280, h._getUIString("ScaleControl.Miles")) : Gt(e, u, C, h._getUIString("ScaleControl.Feet"));
        } else r && r.unit === "nautical" ? Gt(e, u, A / 1852, h._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Gt(e, u, A / 1e3, h._getUIString("ScaleControl.Kilometers")) : Gt(e, u, A, h._getUIString("ScaleControl.Meters"));
      }
      function Gt(h, e, r, u) {
        const d = function(p) {
          const w = Math.pow(10, `${Math.floor(p)}`.length - 1);
          let A = p / w;
          return A = A >= 10 ? 10 : A >= 5 ? 5 : A >= 3 ? 3 : A >= 2 ? 2 : A >= 1 ? 1 : function(C) {
            const P = Math.pow(10, Math.ceil(-Math.log(C) / Math.LN10));
            return Math.round(C * P) / P;
          }(A), w * A;
        }(r);
        h.style.width = e * (d / r) + "px", h.innerHTML = `${d}&nbsp;${u}`;
      }
      const li = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, ml = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function b(h) {
        if (h) {
          if (typeof h == "number") {
            const e = Math.round(Math.abs(h) / Math.SQRT2);
            return { center: new o.P(0, 0), top: new o.P(0, h), "top-left": new o.P(e, e), "top-right": new o.P(-e, e), bottom: new o.P(0, -h), "bottom-left": new o.P(e, -e), "bottom-right": new o.P(-e, -e), left: new o.P(h, 0), right: new o.P(-h, 0) };
          }
          if (h instanceof o.P || Array.isArray(h)) {
            const e = o.P.convert(h);
            return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
          }
          return { center: o.P.convert(h.center || [0, 0]), top: o.P.convert(h.top || [0, 0]), "top-left": o.P.convert(h["top-left"] || [0, 0]), "top-right": o.P.convert(h["top-right"] || [0, 0]), bottom: o.P.convert(h.bottom || [0, 0]), "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]), left: o.P.convert(h.left || [0, 0]), right: o.P.convert(h.right || [0, 0]) };
        }
        return b(new o.P(0, 0));
      }
      const S = k;
      g.AJAXError = o.bh, g.Evented = o.E, g.LngLat = o.N, g.MercatorCoordinate = o.Z, g.Point = o.P, g.addProtocol = o.bi, g.config = o.a, g.removeProtocol = o.bj, g.AttributionControl = Ha, g.BoxZoomHandler = bn, g.CanvasSource = ii, g.CooperativeGesturesHandler = ko, g.DoubleClickZoomHandler = Qs, g.DragPanHandler = Uu, g.DragRotateHandler = fu, g.EdgeInsets = Vn, g.FullscreenControl = class extends o.E {
        constructor(h = {}) {
          super(), this._onFullscreenChange = () => {
            var e;
            let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((e = r == null ? void 0 : r.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
            r === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(h) {
          return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          O.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const h = this._fullscreenButton = O.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          O.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const h = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, g.GeoJSONSource = At, g.GeolocateControl = class extends o.E {
        constructor(h) {
          super(), this._onSuccess = (e) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new o.k("outofmaxbounds", e)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.k("geolocate", e)), this._finish();
            }
          }, this._updateCamera = (e) => {
            const r = new o.N(e.coords.longitude, e.coords.latitude), u = e.coords.accuracy, d = this._map.getBearing(), p = o.e({ bearing: d }, this.options.fitBoundsOptions), w = Y.fromLngLat(r, u);
            this._map.fitBounds(w, p, { geolocateSource: !0 });
          }, this._updateMarker = (e) => {
            if (e) {
              const r = new o.N(e.coords.longitude, e.coords.latitude);
              this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (e) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (e.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (e.code === 3 && fl) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.k("error", e)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = O.create("button", "maplibregl-ctrl-geolocate", this._container), O.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (e) => {
            if (this._map) {
              if (e === !1) {
                o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              } else {
                const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = O.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new jl({ element: this._dotElement }), this._circleElement = O.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new jl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r) => {
                r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.k("trackuserlocationend")), this.fire(new o.k("userlocationlostfocus")));
              });
            }
          }, this.options = o.e({}, Zu, h);
        }
        onAdd(h) {
          return this._map = h, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return o._(this, arguments, void 0, function* (e = !1) {
              if (Ln !== void 0 && !e) return Ln;
              if (window.navigator.permissions === void 0) return Ln = !!window.navigator.geolocation, Ln;
              try {
                Ln = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                Ln = !!window.navigator.geolocation;
              }
              return Ln;
            });
          }().then((e) => this._finishSetupUI(e)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), O.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, pl = 0, fl = !1;
        }
        _isOutOfMapMaxBounds(h) {
          const e = this._map.getMaxBounds(), r = h.coords;
          return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const h = this._map.getBounds(), e = h.getSouthEast(), r = h.getNorthEast(), u = e.distanceTo(r), d = Math.ceil(this._accuracy / (u / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${d}px`, this._circleElement.style.height = `${d}px`;
        }
        trigger() {
          if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new o.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                pl--, fl = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.k("trackuserlocationstart")), this.fire(new o.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let h;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), pl++, pl > 1 ? (h = { maximumAge: 6e5, timeout: 0 }, fl = !0) : (h = this.options.positionOptions, fl = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, g.Hash = wa, g.ImageSource = jt, g.KeyboardHandler = Wn, g.LngLatBounds = Y, g.LogoControl = Ns, g.Map = class extends Ms {
        constructor(h) {
          o.bf.mark(o.bg.create);
          const e = Object.assign(Object.assign({}, Rl), h);
          if (e.minZoom != null && e.maxZoom != null && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (e.minPitch != null && e.maxPitch != null && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (e.minPitch != null && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (e.maxPitch != null && e.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new $n(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), { bearingSnap: e.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new vi(), this._controls = [], this._mapId = o.a4(), this._contextLost = (r) => {
            r.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.k("webglcontextlost", { originalEvent: r }));
          }, this._contextRestored = (r) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new o.k("webglcontextrestored", { originalEvent: r }));
          }, this._onMapScroll = (r) => {
            if (r.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._maxTileCacheZoomLevels = e.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = e.preserveDrawingBuffer === !0, this._antialias = e.antialias === !0, this._trackResize = e.trackResize === !0, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles === !0, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions === !0, this._collectResourceTiming = e.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, yu), e.locale), this._clickTolerance = e.clickTolerance, this._overridePixelRatio = e.pixelRatio, this._maxCanvasSize = e.maxCanvasSize, this.transformCameraUpdate = e.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = e.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ce.addThrottleControl(() => this.isMoving()), this._requestManager = new ze(e.transformRequest), typeof e.container == "string") {
            if (this._container = document.getElementById(e.container), !this._container) throw new Error(`Container '${e.container}' not found.`);
          } else {
            if (!(e.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e.container;
          }
          if (e.maxBounds && this.setMaxBounds(e.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let r = !1;
            const u = Zn((d) => {
              this._trackResize && !this._removed && (this.resize(d), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((d) => {
              r ? u(d) : r = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Pn(this, e), this._hash = e.hash && new wa(typeof e.hash == "string" && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch }), e.bounds && (this.resize(), this.fitBounds(e.bounds, o.e({}, e.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, this._validateStyle = e.validateStyle, e.style && this.setStyle(e.style, { localIdeographFontFamily: e.localIdeographFontFamily }), e.attributionControl && this.addControl(new Ha(typeof e.attributionControl == "boolean" ? void 0 : e.attributionControl)), e.maplibreLogo && this.addControl(new Ns(), e.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (r) => {
            this._update(r.dataType === "style"), this.fire(new o.k(`${r.dataType}data`, r));
          }), this.on("dataloading", (r) => {
            this.fire(new o.k(`${r.dataType}dataloading`, r));
          }), this.on("dataabort", (r) => {
            this.fire(new o.k("sourcedataabort", r));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(h, e) {
          if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new o.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = h.onAdd(this);
          this._controls.push(h);
          const u = this._controlPositions[e];
          return e.indexOf("bottom") !== -1 ? u.insertBefore(r, u.firstChild) : u.appendChild(r), this;
        }
        removeControl(h) {
          if (!h || !h.onRemove) return this.fire(new o.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const e = this._controls.indexOf(h);
          return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this;
        }
        hasControl(h) {
          return this._controls.indexOf(h) > -1;
        }
        calculateCameraOptionsFromTo(h, e, r, u) {
          return u == null && this.terrain && (u = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, r, u);
        }
        resize(h) {
          var e;
          const r = this._containerDimensions(), u = r[0], d = r[1], p = this._getClampedPixelRatio(u, d);
          if (this._resizeCanvas(u, d, p), this.painter.resize(u, d, p), this.painter.overLimit()) {
            const A = this.painter.context.gl;
            this._maxCanvasSize = [A.drawingBufferWidth, A.drawingBufferHeight];
            const C = this._getClampedPixelRatio(u, d);
            this._resizeCanvas(u, d, C), this.painter.resize(u, d, C);
          }
          this.transform.resize(u, d), (e = this._requestedCameraState) === null || e === void 0 || e.resize(u, d);
          const w = !this._moving;
          return w && (this.stop(), this.fire(new o.k("movestart", h)).fire(new o.k("move", h))), this.fire(new o.k("resize", h)), w && this.fire(new o.k("moveend", h)), this;
        }
        _getClampedPixelRatio(h, e) {
          const { 0: r, 1: u } = this._maxCanvasSize, d = this.getPixelRatio(), p = h * d, w = e * d;
          return Math.min(p > r ? r / p : 1, w > u ? u / w : 1) * d;
        }
        getPixelRatio() {
          var h;
          return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio;
        }
        setPixelRatio(h) {
          this._overridePixelRatio = h, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(h) {
          return this.transform.setMaxBounds(Y.convert(h)), this._update();
        }
        setMinZoom(h) {
          if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.minZoom = h, this._update(), this.getZoom() < h && this.setZoom(h), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(h) {
          if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = h, this._update(), this.getZoom() > h && this.setZoom(h), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(h) {
          if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (h >= 0 && h <= this.transform.maxPitch) return this.transform.minPitch = h, this._update(), this.getPitch() < h && this.setPitch(h), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(h) {
          if ((h = h ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (h >= this.transform.minPitch) return this.transform.maxPitch = h, this._update(), this.getPitch() > h && this.setPitch(h), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(h) {
          return this.transform.renderWorldCopies = h, this._update();
        }
        project(h) {
          return this.transform.locationPoint(o.N.convert(h), this.style && this.terrain);
        }
        unproject(h) {
          return this.transform.pointLocation(o.P.convert(h), this.terrain);
        }
        isMoving() {
          var h;
          return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving());
        }
        isZooming() {
          var h;
          return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming());
        }
        isRotating() {
          var h;
          return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating());
        }
        _createDelegatedListener(h, e, r) {
          if (h === "mouseenter" || h === "mouseover") {
            let u = !1;
            return { layers: e, listener: r, delegates: { mousemove: (p) => {
              const w = e.filter((C) => this.getLayer(C)), A = w.length !== 0 ? this.queryRenderedFeatures(p.point, { layers: w }) : [];
              A.length ? u || (u = !0, r.call(this, new Tr(h, this, p.originalEvent, { features: A }))) : u = !1;
            }, mouseout: () => {
              u = !1;
            } } };
          }
          if (h === "mouseleave" || h === "mouseout") {
            let u = !1;
            return { layers: e, listener: r, delegates: { mousemove: (w) => {
              const A = e.filter((C) => this.getLayer(C));
              (A.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: A }) : []).length ? u = !0 : u && (u = !1, r.call(this, new Tr(h, this, w.originalEvent)));
            }, mouseout: (w) => {
              u && (u = !1, r.call(this, new Tr(h, this, w.originalEvent)));
            } } };
          }
          {
            const u = (d) => {
              const p = e.filter((A) => this.getLayer(A)), w = p.length !== 0 ? this.queryRenderedFeatures(d.point, { layers: p }) : [];
              w.length && (d.features = w, r.call(this, d), delete d.features);
            };
            return { layers: e, listener: r, delegates: { [h]: u } };
          }
        }
        _saveDelegatedListener(h, e) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e);
        }
        _removeDelegatedListener(h, e, r) {
          if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
          const u = this._delegatedListeners[h];
          for (let d = 0; d < u.length; d++) {
            const p = u[d];
            if (p.listener === r && p.layers.length === e.length && p.layers.every((w) => e.includes(w))) {
              for (const w in p.delegates) this.off(w, p.delegates[w]);
              return void u.splice(d, 1);
            }
          }
        }
        on(h, e, r) {
          if (r === void 0) return super.on(h, e);
          const u = this._createDelegatedListener(h, typeof e == "string" ? [e] : e, r);
          this._saveDelegatedListener(h, u);
          for (const d in u.delegates) this.on(d, u.delegates[d]);
          return this;
        }
        once(h, e, r) {
          if (r === void 0) return super.once(h, e);
          const u = typeof e == "string" ? [e] : e, d = this._createDelegatedListener(h, u, r);
          for (const p in d.delegates) {
            const w = d.delegates[p];
            d.delegates[p] = (...A) => {
              this._removeDelegatedListener(h, u, r), w(...A);
            };
          }
          this._saveDelegatedListener(h, d);
          for (const p in d.delegates) this.once(p, d.delegates[p]);
          return this;
        }
        off(h, e, r) {
          return r === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, r), this);
        }
        queryRenderedFeatures(h, e) {
          if (!this.style) return [];
          let r;
          const u = h instanceof o.P || Array.isArray(h), d = u ? h : [[0, 0], [this.transform.width, this.transform.height]];
          if (e = e || (u ? {} : h) || {}, d instanceof o.P || typeof d[0] == "number") r = [o.P.convert(d)];
          else {
            const p = o.P.convert(d[0]), w = o.P.convert(d[1]);
            r = [p, new o.P(w.x, p.y), w, new o.P(p.x, w.y), p];
          }
          return this.style.queryRenderedFeatures(r, e, this.transform);
        }
        querySourceFeatures(h, e) {
          return this.style.querySourceFeatures(h, e);
        }
        setStyle(h, e) {
          return (e = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e));
        }
        setTransformRequest(h) {
          return this._requestManager.setTransformRequest(h), this;
        }
        _getUIString(h) {
          const e = this._locale[h];
          if (e == null) throw new Error(`Missing UI string '${h}'`);
          return e;
        }
        _updateStyle(h, e) {
          if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(h, e));
          const r = this.style && e.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new jr(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof h == "string" ? this.style.loadURL(h, e, r) : this.style.loadJSON(h, e, r), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new jr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(h, e) {
          if (typeof h == "string") {
            const r = this._requestManager.transformRequest(h, "Style");
            o.h(r, new AbortController()).then((u) => {
              this._updateDiff(u.data, e);
            }).catch((u) => {
              u && this.fire(new o.j(u));
            });
          } else typeof h == "object" && this._updateDiff(h, e);
        }
        _updateDiff(h, e) {
          try {
            this.style.setState(h, e) && this._update(!0);
          } catch (r) {
            o.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(h, e);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
        }
        addSource(h, e) {
          return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0);
        }
        isSourceLoaded(h) {
          const e = this.style && this.style.sourceCaches[h];
          if (e !== void 0) return e.loaded();
          this.fire(new o.j(new Error(`There is no source with ID '${h}'`)));
        }
        setTerrain(h) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
            const e = this.style.sourceCaches[h.source];
            if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
            this.terrain === null && e.reload();
            for (const r in this.style._layers) {
              const u = this.style._layers[r];
              u.type === "hillshade" && u.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Bl(this.painter, e, h), this.painter.renderToTexture = new _u(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (r) => {
              r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== h.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(r.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new o.k("terrain", { terrain: h })), this;
        }
        getTerrain() {
          var h, e;
          return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null;
        }
        areTilesLoaded() {
          const h = this.style && this.style.sourceCaches;
          for (const e in h) {
            const r = h[e]._tiles;
            for (const u in r) {
              const d = r[u];
              if (d.state !== "loaded" && d.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(h) {
          return this.style.removeSource(h), this._update(!0);
        }
        getSource(h) {
          return this.style.getSource(h);
        }
        addImage(h, e, r = {}) {
          const { pixelRatio: u = 1, sdf: d = !1, stretchX: p, stretchY: w, content: A, textFitWidth: C, textFitHeight: P } = r;
          if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || o.b(e))) {
            if (e.width === void 0 || e.height === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: F, height: N, data: Z } = e, G = e;
              return this.style.addImage(h, { data: new o.R({ width: F, height: N }, new Uint8Array(Z)), pixelRatio: u, stretchX: p, stretchY: w, content: A, textFitWidth: C, textFitHeight: P, sdf: d, version: 0, userImage: G }), G.onAdd && G.onAdd(this, h), this;
            }
          }
          {
            const { width: F, height: N, data: Z } = j.getImageData(e);
            this.style.addImage(h, { data: new o.R({ width: F, height: N }, Z), pixelRatio: u, stretchX: p, stretchY: w, content: A, textFitWidth: C, textFitHeight: P, sdf: d, version: 0 });
          }
        }
        updateImage(h, e) {
          const r = this.style.getImage(h);
          if (!r) return this.fire(new o.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const u = e instanceof HTMLImageElement || o.b(e) ? j.getImageData(e) : e, { width: d, height: p, data: w } = u;
          if (d === void 0 || p === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (d !== r.data.width || p !== r.data.height) return this.fire(new o.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const A = !(e instanceof HTMLImageElement || o.b(e));
          return r.data.replace(w, A), this.style.updateImage(h, r), this;
        }
        getImage(h) {
          return this.style.getImage(h);
        }
        hasImage(h) {
          return h ? !!this.style.getImage(h) : (this.fire(new o.j(new Error("Missing required image id"))), !1);
        }
        removeImage(h) {
          this.style.removeImage(h);
        }
        loadImage(h) {
          return Ce.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(h, e) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0);
        }
        moveLayer(h, e) {
          return this.style.moveLayer(h, e), this._update(!0);
        }
        removeLayer(h) {
          return this.style.removeLayer(h), this._update(!0);
        }
        getLayer(h) {
          return this.style.getLayer(h);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(h, e, r) {
          return this.style.setLayerZoomRange(h, e, r), this._update(!0);
        }
        setFilter(h, e, r = {}) {
          return this.style.setFilter(h, e, r), this._update(!0);
        }
        getFilter(h) {
          return this.style.getFilter(h);
        }
        setPaintProperty(h, e, r, u = {}) {
          return this.style.setPaintProperty(h, e, r, u), this._update(!0);
        }
        getPaintProperty(h, e) {
          return this.style.getPaintProperty(h, e);
        }
        setLayoutProperty(h, e, r, u = {}) {
          return this.style.setLayoutProperty(h, e, r, u), this._update(!0);
        }
        getLayoutProperty(h, e) {
          return this.style.getLayoutProperty(h, e);
        }
        setGlyphs(h, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(h, e, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, r, (u) => {
            u || this._update(!0);
          }), this;
        }
        removeSprite(h) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(h, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (r) => {
            r || this._update(!0);
          }), this;
        }
        setLight(h, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(h) {
          return this._lazyInitEmptyStyle(), this.style.setSky(h), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(h, e) {
          return this.style.setFeatureState(h, e), this._update();
        }
        removeFeatureState(h, e) {
          return this.style.removeFeatureState(h, e), this._update();
        }
        getFeatureState(h) {
          return this.style.getFeatureState(h);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let h = 0, e = 0;
          return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e];
        }
        _setupContainer() {
          const h = this._container;
          h.classList.add("maplibregl-map");
          const e = this._canvasContainer = O.create("div", "maplibregl-canvas-container", h);
          this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = O.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const r = this._containerDimensions(), u = this._getClampedPixelRatio(r[0], r[1]);
          this._resizeCanvas(r[0], r[1], u);
          const d = this._controlContainer = O.create("div", "maplibregl-control-container", h), p = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((w) => {
            p[w] = O.create("div", `maplibregl-ctrl-${w} `, d);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(h, e, r) {
          this._canvas.width = Math.floor(r * h), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`;
        }
        _setupPainter() {
          const h = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let e = null;
          this._canvas.addEventListener("webglcontextcreationerror", (u) => {
            e = { requestedAttributes: h }, u && (e.statusMessage = u.statusMessage, e.type = u.type);
          }, { once: !0 });
          const r = this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h);
          if (!r) {
            const u = "Failed to initialize WebGL";
            throw e ? (e.message = u, new Error(JSON.stringify(e))) : new Error(u);
          }
          this.painter = new fs(r, this.transform), z.testSupport(r);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(h) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(h) {
          return this._update(), this._renderTaskQueue.add(h);
        }
        _cancelRenderFrame(h) {
          this._renderTaskQueue.remove(h);
        }
        _render(h) {
          const e = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
          let r = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const d = this.transform.zoom, p = j.now();
            this.style.zoomHistory.update(d, p);
            const w = new o.z(d, { now: p, fadeDuration: e, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), A = w.crossFadingFactor();
            A === 1 && A === this._crossFadingFactor || (r = !0, this._crossFadingFactor = A), this.style.update(w);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, e, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: e, showPadding: this.showPadding }), this.fire(new o.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.bf.mark(o.bg.load), this.fire(new o.k("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const u = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return u || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.k("idle")), !this._loaded || this._fullyLoaded || u || (this._fullyLoaded = !0, o.bf.mark(o.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var h;
          this._hash && this._hash.remove();
          for (const r of this._controls) r.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ce.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
          const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
          e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), O.remove(this._canvasContainer), O.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), o.bf.clearMetrics(), this._removed = !0, this.fire(new o.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), j.frameAsync(this._frameRequest).then((h) => {
            o.bf.frame(h), this._frameRequest = null, this._render(h);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(h) {
          this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(h) {
          this._showPadding !== h && (this._showPadding = h, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(h) {
          this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(h) {
          this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(h) {
          this._repaint !== h && (this._repaint = h, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(h) {
          this._vertices = h, this._update();
        }
        get version() {
          return dl;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, g.MapMouseEvent = Tr, g.MapTouchEvent = Ps, g.MapWheelEvent = uu, g.Marker = jl, g.NavigationControl = class {
        constructor(h) {
          this._updateZoomButtons = () => {
            const e = this._map.getZoom(), r = e === this._map.getMaxZoom(), u = e === this._map.getMinZoom();
            this._zoomInButton.disabled = r, this._zoomOutButton.disabled = u, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", u.toString());
          }, this._rotateCompassArrow = () => {
            const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = e;
          }, this._setButtonTitle = (e, r) => {
            const u = this._map._getUIString(`NavigationControl.${r}`);
            e.title = u, e.setAttribute("aria-label", u);
          }, this.options = o.e({}, vu, h), this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), O.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), O.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
          }), this._compassIcon = O.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(h) {
          return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new $u(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          O.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(h, e) {
          const r = O.create("button", h, this._container);
          return r.type = "button", r.addEventListener("click", e), r;
        }
      }, g.Popup = class extends o.E {
        constructor(h) {
          super(), this.remove = () => (this._content && O.remove(this._content), this._container && (O.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.k("close"))), this), this._onMouseUp = (e) => {
            this._update(e.point);
          }, this._onMouseMove = (e) => {
            this._update(e.point);
          }, this._onDrag = (e) => {
            this._update(e.point);
          }, this._update = (e) => {
            var r;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = O.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = O.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const A of this.options.className.split(" ")) this._container.classList.add(A);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Ji(this._lngLat, this._flatPos, this._map.transform) : (r = this._lngLat) === null || r === void 0 ? void 0 : r.wrap(), this._trackPointer && !e) return;
            const u = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationPoint(this._lngLat));
            let d = this.options.anchor;
            const p = b(this.options.offset);
            if (!d) {
              const A = this._container.offsetWidth, C = this._container.offsetHeight;
              let P;
              P = u.y + p.bottom.y < C ? ["top"] : u.y > this._map.transform.height - C ? ["bottom"] : [], u.x < A / 2 ? P.push("left") : u.x > this._map.transform.width - A / 2 && P.push("right"), d = P.length === 0 ? "bottom" : P.join("-");
            }
            let w = u.add(p[d]);
            this.options.subpixelPositioning || (w = w.round()), O.setTransform(this._container, `${Io[d]} translate(${w.x}px,${w.y}px)`), Ol(this._container, d, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = o.e(Object.create(li), h);
        }
        addTo(h) {
          return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(h) {
          return this._lngLat = o.N.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(h) {
          return this.setDOMContent(document.createTextNode(h));
        }
        setHTML(h) {
          const e = document.createDocumentFragment(), r = document.createElement("body");
          let u;
          for (r.innerHTML = h; u = r.firstChild, u; ) e.appendChild(u);
          return this.setDOMContent(e);
        }
        getMaxWidth() {
          var h;
          return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth;
        }
        setMaxWidth(h) {
          return this.options.maxWidth = h, this._update(), this;
        }
        setDOMContent(h) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = O.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(h) {
          return this._container && this._container.classList.add(h), this;
        }
        removeClassName(h) {
          return this._container && this._container.classList.remove(h), this;
        }
        setOffset(h) {
          return this.options.offset = h, this._update(), this;
        }
        toggleClassName(h) {
          if (this._container) return this._container.classList.toggle(h);
        }
        setSubpixelPositioning(h) {
          this.options.subpixelPositioning = h;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = O.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const h = this._container.querySelector(ml);
          h && h.focus();
        }
      }, g.RasterDEMTileSource = xt, g.RasterTileSource = lt, g.ScaleControl = class {
        constructor(h) {
          this._onMove = () => {
            Sa(this._map, this._container, this.options);
          }, this.setUnit = (e) => {
            this.options.unit = e, Sa(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, _s), h);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(h) {
          return this._map = h, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, g.ScrollZoomHandler = In, g.Style = jr, g.TerrainControl = class {
        constructor(h) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = h;
        }
        onAdd(h) {
          return this._map = h, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = O.create("button", "maplibregl-ctrl-terrain", this._container), O.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, g.TwoFingersTouchPitchHandler = To, g.TwoFingersTouchRotateHandler = du, g.TwoFingersTouchZoomHandler = ul, g.TwoFingersTouchZoomRotateHandler = mu, g.VectorTileSource = Rt, g.VideoSource = ni, g.addSourceType = (h, e) => o._(void 0, void 0, void 0, function* () {
        if (xi(h)) throw new Error(`A source type called "${h}" already exists.`);
        ((r, u) => {
          yi[r] = u;
        })(h, e);
      }), g.clearPrewarmedResources = function() {
        const h = $e;
        h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(be), $e = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, g.getMaxParallelImageRequests = function() {
        return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, g.getRTLTextPluginStatus = function() {
        return It().getRTLTextPluginStatus();
      }, g.getVersion = function() {
        return S;
      }, g.getWorkerCount = function() {
        return Te.workerCount;
      }, g.getWorkerUrl = function() {
        return o.a.WORKER_URL;
      }, g.importScriptInWorkers = function(h) {
        return ot().broadcast("IS", h);
      }, g.prewarm = function() {
        Ke().acquire(be);
      }, g.setMaxParallelImageRequests = function(h) {
        o.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
      }, g.setRTLTextPlugin = function(h, e) {
        return It().setRTLTextPlugin(h, e);
      }, g.setWorkerCount = function(h) {
        Te.workerCount = h;
      }, g.setWorkerUrl = function(h) {
        o.a.WORKER_URL = h;
      };
    });
    var _ = a;
    return _;
  });
})(g0);
var Ru = g0.exports;
(function(s) {
  if (s.TextEncoder && s.TextDecoder)
    return !1;
  function l(m = "utf-8") {
    if (m !== "utf-8")
      throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${m}') is invalid.`);
  }
  Object.defineProperty(l.prototype, "encoding", {
    value: "utf-8"
  }), l.prototype.encode = function(m, y = { stream: !1 }) {
    if (y.stream)
      throw new Error("Failed to encode: the 'stream' option is unsupported.");
    let _ = 0;
    const g = m.length;
    let o = 0, k = Math.max(32, g + (g >> 1) + 7), D = new Uint8Array(k >> 3 << 3);
    for (; _ < g; ) {
      let L = m.charCodeAt(_++);
      if (L >= 55296 && L <= 56319) {
        if (_ < g) {
          const j = m.charCodeAt(_);
          (j & 64512) === 56320 && (++_, L = ((L & 1023) << 10) + (j & 1023) + 65536);
        }
        if (L >= 55296 && L <= 56319)
          continue;
      }
      if (o + 4 > D.length) {
        k += 8, k *= 1 + _ / m.length * 2, k = k >> 3 << 3;
        const j = new Uint8Array(k);
        j.set(D), D = j;
      }
      if (L & 4294967168)
        if (!(L & 4294965248))
          D[o++] = L >> 6 & 31 | 192;
        else if (!(L & 4294901760))
          D[o++] = L >> 12 & 15 | 224, D[o++] = L >> 6 & 63 | 128;
        else if (!(L & 4292870144))
          D[o++] = L >> 18 & 7 | 240, D[o++] = L >> 12 & 63 | 128, D[o++] = L >> 6 & 63 | 128;
        else
          continue;
      else {
        D[o++] = L;
        continue;
      }
      D[o++] = L & 63 | 128;
    }
    return D.slice(0, o);
  };
  function a(m = "utf-8", y = { fatal: !1 }) {
    if (m !== "utf-8")
      throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${m}') is invalid.`);
    if (y.fatal)
      throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
  }
  Object.defineProperty(a.prototype, "encoding", {
    value: "utf-8"
  }), Object.defineProperty(a.prototype, "fatal", { value: !1 }), Object.defineProperty(a.prototype, "ignoreBOM", {
    value: !1
  }), a.prototype.decode = function(m, y = { stream: !1 }) {
    if (y.stream)
      throw new Error("Failed to decode: the 'stream' option is unsupported.");
    const _ = new Uint8Array(m);
    let g = 0;
    const o = _.length, k = [];
    for (; g < o; ) {
      const D = _[g++];
      if (D === 0)
        break;
      if (!(D & 128))
        k.push(D);
      else if ((D & 224) === 192) {
        const L = _[g++] & 63;
        k.push((D & 31) << 6 | L);
      } else if ((D & 240) === 224) {
        const L = _[g++] & 63, j = _[g++] & 63;
        k.push((D & 31) << 12 | L << 6 | j);
      } else if ((D & 248) === 240) {
        const L = _[g++] & 63, j = _[g++] & 63, O = _[g++] & 63;
        let z = (D & 7) << 18 | L << 12 | j << 6 | O;
        z > 65535 && (z -= 65536, k.push(z >>> 10 & 1023 | 55296), z = 56320 | z & 1023), k.push(z);
      }
    }
    return String.fromCharCode.apply(null, k);
  }, s.TextEncoder = l, s.TextDecoder = a;
})(typeof window < "u" ? window : typeof self < "u" ? self : void 0);
function Wm(s, l = "utf8") {
  return new TextDecoder(l).decode(s);
}
const v_ = new TextEncoder();
function b_(s) {
  return v_.encode(s);
}
const x_ = 1024 * 8, w_ = (() => {
  const s = new Uint8Array(4), l = new Uint32Array(s.buffer);
  return !((l[0] = 1) & s[0]);
})(), cp = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class ud {
  /**
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options
   */
  constructor(l = x_, a = {}) {
    let m = !1;
    typeof l == "number" ? l = new ArrayBuffer(l) : (m = !0, this.lastWrittenByte = l.byteLength);
    const y = a.offset ? a.offset >>> 0 : 0, _ = l.byteLength - y;
    let g = y;
    (ArrayBuffer.isView(l) || l instanceof ud) && (l.byteLength !== l.buffer.byteLength && (g = l.byteOffset + y), l = l.buffer), m ? this.lastWrittenByte = _ : this.lastWrittenByte = 0, this.buffer = l, this.length = _, this.byteLength = _, this.byteOffset = g, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, g, _), this._mark = 0, this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(l = 1) {
    return this.offset + l <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   */
  skip(l = 1) {
    return this.offset += l, this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   */
  back(l = 1) {
    return this.offset -= l, this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset
   */
  seek(l) {
    return this.offset = l, this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   */
  popMark() {
    const l = this._marks.pop();
    if (l === void 0)
      throw new Error("Mark stack empty");
    return this.seek(l), this;
  }
  /**
   * Move the pointer offset back to 0.
   */
  rewind() {
    return this.offset = 0, this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength
   */
  ensureAvailable(l = 1) {
    if (!this.available(l)) {
      const m = (this.offset + l) * 2, y = new Uint8Array(m);
      y.set(new Uint8Array(this.buffer)), this.buffer = y.buffer, this.length = this.byteLength = m, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   */
  readBytes(l = 1) {
    return this.readArray(l, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   */
  readArray(l, a) {
    const m = cp[a].BYTES_PER_ELEMENT * l, y = this.byteOffset + this.offset, _ = this.buffer.slice(y, y + m);
    if (this.littleEndian === w_ && a !== "uint8" && a !== "int8") {
      const o = new Uint8Array(this.buffer.slice(y, y + m));
      o.reverse();
      const k = new cp[a](o.buffer);
      return this.offset += m, k.reverse(), k;
    }
    const g = new cp[a](_);
    return this.offset += m, g;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   */
  readInt16() {
    const l = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, l;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   */
  readUint16() {
    const l = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, l;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   */
  readInt32() {
    const l = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, l;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   */
  readUint32() {
    const l = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, l;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   */
  readFloat32() {
    const l = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, l;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   */
  readFloat64() {
    const l = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, l;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   */
  readBigInt64() {
    const l = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, l;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   */
  readBigUint64() {
    const l = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, l;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   */
  readChars(l = 1) {
    let a = "";
    for (let m = 0; m < l; m++)
      a += this.readChar();
    return a;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   */
  readUtf8(l = 1) {
    return Wm(this.readBytes(l));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   */
  decodeText(l = 1, a = "utf-8") {
    return Wm(this.readBytes(l), a);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   */
  writeBoolean(l) {
    return this.writeUint8(l ? 255 : 0), this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   */
  writeInt8(l) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, l), this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   */
  writeUint8(l) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, l), this._updateLastWrittenByte(), this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   */
  writeByte(l) {
    return this.writeUint8(l);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   */
  writeBytes(l) {
    this.ensureAvailable(l.length);
    for (let a = 0; a < l.length; a++)
      this._data.setUint8(this.offset++, l[a]);
    return this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   */
  writeInt16(l) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, l, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   */
  writeUint16(l) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, l, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   */
  writeInt32(l) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, l, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   */
  writeUint32(l) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, l, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   */
  writeFloat32(l) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, l, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   */
  writeFloat64(l) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, l, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   */
  writeBigInt64(l) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, l, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   */
  writeBigUint64(l) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, l, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   */
  writeChar(l) {
    return this.writeUint8(l.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   */
  writeChars(l) {
    for (let a = 0; a < l.length; a++)
      this.writeUint8(l.charCodeAt(a));
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   */
  writeUtf8(l) {
    return this.writeBytes(b_(l));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const A_ = 4, Xm = 0, Ym = 1, S_ = 2;
function Cc(s) {
  let l = s.length;
  for (; --l >= 0; )
    s[l] = 0;
}
const E_ = 0, y0 = 1, C_ = 2, T_ = 3, k_ = 258, uf = 29, Sh = 256, fh = Sh + 1 + uf, gc = 30, cf = 19, v0 = 2 * fh + 1, Pu = 15, hp = 16, D_ = 7, hf = 256, b0 = 16, x0 = 17, w0 = 18, Fp = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), rd = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), I_ = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), A0 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), P_ = 512, Tl = new Array((fh + 2) * 2);
Cc(Tl);
const ch = new Array(gc * 2);
Cc(ch);
const mh = new Array(P_);
Cc(mh);
const gh = new Array(k_ - T_ + 1);
Cc(gh);
const df = new Array(uf);
Cc(df);
const cd = new Array(gc);
Cc(cd);
function dp(s, l, a, m, y) {
  this.static_tree = s, this.extra_bits = l, this.extra_base = a, this.elems = m, this.max_length = y, this.has_stree = s && s.length;
}
let S0, E0, C0;
function pp(s, l) {
  this.dyn_tree = s, this.max_code = 0, this.stat_desc = l;
}
const T0 = (s) => s < 256 ? mh[s] : mh[256 + (s >>> 7)], _h = (s, l) => {
  s.pending_buf[s.pending++] = l & 255, s.pending_buf[s.pending++] = l >>> 8 & 255;
}, Os = (s, l, a) => {
  s.bi_valid > hp - a ? (s.bi_buf |= l << s.bi_valid & 65535, _h(s, s.bi_buf), s.bi_buf = l >> hp - s.bi_valid, s.bi_valid += a - hp) : (s.bi_buf |= l << s.bi_valid & 65535, s.bi_valid += a);
}, $o = (s, l, a) => {
  Os(
    s,
    a[l * 2],
    a[l * 2 + 1]
    /*.Len*/
  );
}, k0 = (s, l) => {
  let a = 0;
  do
    a |= s & 1, s >>>= 1, a <<= 1;
  while (--l > 0);
  return a >>> 1;
}, L_ = (s) => {
  s.bi_valid === 16 ? (_h(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = s.bi_buf & 255, s.bi_buf >>= 8, s.bi_valid -= 8);
}, M_ = (s, l) => {
  const a = l.dyn_tree, m = l.max_code, y = l.stat_desc.static_tree, _ = l.stat_desc.has_stree, g = l.stat_desc.extra_bits, o = l.stat_desc.extra_base, k = l.stat_desc.max_length;
  let D, L, j, O, z, pe, oe = 0;
  for (O = 0; O <= Pu; O++)
    s.bl_count[O] = 0;
  for (a[s.heap[s.heap_max] * 2 + 1] = 0, D = s.heap_max + 1; D < v0; D++)
    L = s.heap[D], O = a[a[L * 2 + 1] * 2 + 1] + 1, O > k && (O = k, oe++), a[L * 2 + 1] = O, !(L > m) && (s.bl_count[O]++, z = 0, L >= o && (z = g[L - o]), pe = a[L * 2], s.opt_len += pe * (O + z), _ && (s.static_len += pe * (y[L * 2 + 1] + z)));
  if (oe !== 0) {
    do {
      for (O = k - 1; s.bl_count[O] === 0; )
        O--;
      s.bl_count[O]--, s.bl_count[O + 1] += 2, s.bl_count[k]--, oe -= 2;
    } while (oe > 0);
    for (O = k; O !== 0; O--)
      for (L = s.bl_count[O]; L !== 0; )
        j = s.heap[--D], !(j > m) && (a[j * 2 + 1] !== O && (s.opt_len += (O - a[j * 2 + 1]) * a[j * 2], a[j * 2 + 1] = O), L--);
  }
}, D0 = (s, l, a) => {
  const m = new Array(Pu + 1);
  let y = 0, _, g;
  for (_ = 1; _ <= Pu; _++)
    y = y + a[_ - 1] << 1, m[_] = y;
  for (g = 0; g <= l; g++) {
    let o = s[g * 2 + 1];
    o !== 0 && (s[g * 2] = k0(m[o]++, o));
  }
}, N_ = () => {
  let s, l, a, m, y;
  const _ = new Array(Pu + 1);
  for (a = 0, m = 0; m < uf - 1; m++)
    for (df[m] = a, s = 0; s < 1 << Fp[m]; s++)
      gh[a++] = m;
  for (gh[a - 1] = m, y = 0, m = 0; m < 16; m++)
    for (cd[m] = y, s = 0; s < 1 << rd[m]; s++)
      mh[y++] = m;
  for (y >>= 7; m < gc; m++)
    for (cd[m] = y << 7, s = 0; s < 1 << rd[m] - 7; s++)
      mh[256 + y++] = m;
  for (l = 0; l <= Pu; l++)
    _[l] = 0;
  for (s = 0; s <= 143; )
    Tl[s * 2 + 1] = 8, s++, _[8]++;
  for (; s <= 255; )
    Tl[s * 2 + 1] = 9, s++, _[9]++;
  for (; s <= 279; )
    Tl[s * 2 + 1] = 7, s++, _[7]++;
  for (; s <= 287; )
    Tl[s * 2 + 1] = 8, s++, _[8]++;
  for (D0(Tl, fh + 1, _), s = 0; s < gc; s++)
    ch[s * 2 + 1] = 5, ch[s * 2] = k0(s, 5);
  S0 = new dp(Tl, Fp, Sh + 1, fh, Pu), E0 = new dp(ch, rd, 0, gc, Pu), C0 = new dp(new Array(0), I_, 0, cf, D_);
}, I0 = (s) => {
  let l;
  for (l = 0; l < fh; l++)
    s.dyn_ltree[l * 2] = 0;
  for (l = 0; l < gc; l++)
    s.dyn_dtree[l * 2] = 0;
  for (l = 0; l < cf; l++)
    s.bl_tree[l * 2] = 0;
  s.dyn_ltree[hf * 2] = 1, s.opt_len = s.static_len = 0, s.sym_next = s.matches = 0;
}, P0 = (s) => {
  s.bi_valid > 8 ? _h(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), s.bi_buf = 0, s.bi_valid = 0;
}, Jm = (s, l, a, m) => {
  const y = l * 2, _ = a * 2;
  return s[y] < s[_] || s[y] === s[_] && m[l] <= m[a];
}, fp = (s, l, a) => {
  const m = s.heap[a];
  let y = a << 1;
  for (; y <= s.heap_len && (y < s.heap_len && Jm(l, s.heap[y + 1], s.heap[y], s.depth) && y++, !Jm(l, m, s.heap[y], s.depth)); )
    s.heap[a] = s.heap[y], a = y, y <<= 1;
  s.heap[a] = m;
}, Km = (s, l, a) => {
  let m, y, _ = 0, g, o;
  if (s.sym_next !== 0)
    do
      m = s.pending_buf[s.sym_buf + _++] & 255, m += (s.pending_buf[s.sym_buf + _++] & 255) << 8, y = s.pending_buf[s.sym_buf + _++], m === 0 ? $o(s, y, l) : (g = gh[y], $o(s, g + Sh + 1, l), o = Fp[g], o !== 0 && (y -= df[g], Os(s, y, o)), m--, g = T0(m), $o(s, g, a), o = rd[g], o !== 0 && (m -= cd[g], Os(s, m, o)));
    while (_ < s.sym_next);
  $o(s, hf, l);
}, Bp = (s, l) => {
  const a = l.dyn_tree, m = l.stat_desc.static_tree, y = l.stat_desc.has_stree, _ = l.stat_desc.elems;
  let g, o, k = -1, D;
  for (s.heap_len = 0, s.heap_max = v0, g = 0; g < _; g++)
    a[g * 2] !== 0 ? (s.heap[++s.heap_len] = k = g, s.depth[g] = 0) : a[g * 2 + 1] = 0;
  for (; s.heap_len < 2; )
    D = s.heap[++s.heap_len] = k < 2 ? ++k : 0, a[D * 2] = 1, s.depth[D] = 0, s.opt_len--, y && (s.static_len -= m[D * 2 + 1]);
  for (l.max_code = k, g = s.heap_len >> 1; g >= 1; g--)
    fp(s, a, g);
  D = _;
  do
    g = s.heap[
      1
      /*SMALLEST*/
    ], s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--], fp(
      s,
      a,
      1
      /*SMALLEST*/
    ), o = s.heap[
      1
      /*SMALLEST*/
    ], s.heap[--s.heap_max] = g, s.heap[--s.heap_max] = o, a[D * 2] = a[g * 2] + a[o * 2], s.depth[D] = (s.depth[g] >= s.depth[o] ? s.depth[g] : s.depth[o]) + 1, a[g * 2 + 1] = a[o * 2 + 1] = D, s.heap[
      1
      /*SMALLEST*/
    ] = D++, fp(
      s,
      a,
      1
      /*SMALLEST*/
    );
  while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ], M_(s, l), D0(a, k, s.bl_count);
}, Qm = (s, l, a) => {
  let m, y = -1, _, g = l[0 * 2 + 1], o = 0, k = 7, D = 4;
  for (g === 0 && (k = 138, D = 3), l[(a + 1) * 2 + 1] = 65535, m = 0; m <= a; m++)
    _ = g, g = l[(m + 1) * 2 + 1], !(++o < k && _ === g) && (o < D ? s.bl_tree[_ * 2] += o : _ !== 0 ? (_ !== y && s.bl_tree[_ * 2]++, s.bl_tree[b0 * 2]++) : o <= 10 ? s.bl_tree[x0 * 2]++ : s.bl_tree[w0 * 2]++, o = 0, y = _, g === 0 ? (k = 138, D = 3) : _ === g ? (k = 6, D = 3) : (k = 7, D = 4));
}, eg = (s, l, a) => {
  let m, y = -1, _, g = l[0 * 2 + 1], o = 0, k = 7, D = 4;
  for (g === 0 && (k = 138, D = 3), m = 0; m <= a; m++)
    if (_ = g, g = l[(m + 1) * 2 + 1], !(++o < k && _ === g)) {
      if (o < D)
        do
          $o(s, _, s.bl_tree);
        while (--o !== 0);
      else _ !== 0 ? (_ !== y && ($o(s, _, s.bl_tree), o--), $o(s, b0, s.bl_tree), Os(s, o - 3, 2)) : o <= 10 ? ($o(s, x0, s.bl_tree), Os(s, o - 3, 3)) : ($o(s, w0, s.bl_tree), Os(s, o - 11, 7));
      o = 0, y = _, g === 0 ? (k = 138, D = 3) : _ === g ? (k = 6, D = 3) : (k = 7, D = 4);
    }
}, z_ = (s) => {
  let l;
  for (Qm(s, s.dyn_ltree, s.l_desc.max_code), Qm(s, s.dyn_dtree, s.d_desc.max_code), Bp(s, s.bl_desc), l = cf - 1; l >= 3 && s.bl_tree[A0[l] * 2 + 1] === 0; l--)
    ;
  return s.opt_len += 3 * (l + 1) + 5 + 5 + 4, l;
}, F_ = (s, l, a, m) => {
  let y;
  for (Os(s, l - 257, 5), Os(s, a - 1, 5), Os(s, m - 4, 4), y = 0; y < m; y++)
    Os(s, s.bl_tree[A0[y] * 2 + 1], 3);
  eg(s, s.dyn_ltree, l - 1), eg(s, s.dyn_dtree, a - 1);
}, B_ = (s) => {
  let l = 4093624447, a;
  for (a = 0; a <= 31; a++, l >>>= 1)
    if (l & 1 && s.dyn_ltree[a * 2] !== 0)
      return Xm;
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0)
    return Ym;
  for (a = 32; a < Sh; a++)
    if (s.dyn_ltree[a * 2] !== 0)
      return Ym;
  return Xm;
};
let tg = !1;
const R_ = (s) => {
  tg || (N_(), tg = !0), s.l_desc = new pp(s.dyn_ltree, S0), s.d_desc = new pp(s.dyn_dtree, E0), s.bl_desc = new pp(s.bl_tree, C0), s.bi_buf = 0, s.bi_valid = 0, I0(s);
}, L0 = (s, l, a, m) => {
  Os(s, (E_ << 1) + (m ? 1 : 0), 3), P0(s), _h(s, a), _h(s, ~a), a && s.pending_buf.set(s.window.subarray(l, l + a), s.pending), s.pending += a;
}, O_ = (s) => {
  Os(s, y0 << 1, 3), $o(s, hf, Tl), L_(s);
}, j_ = (s, l, a, m) => {
  let y, _, g = 0;
  s.level > 0 ? (s.strm.data_type === S_ && (s.strm.data_type = B_(s)), Bp(s, s.l_desc), Bp(s, s.d_desc), g = z_(s), y = s.opt_len + 3 + 7 >>> 3, _ = s.static_len + 3 + 7 >>> 3, _ <= y && (y = _)) : y = _ = a + 5, a + 4 <= y && l !== -1 ? L0(s, l, a, m) : s.strategy === A_ || _ === y ? (Os(s, (y0 << 1) + (m ? 1 : 0), 3), Km(s, Tl, ch)) : (Os(s, (C_ << 1) + (m ? 1 : 0), 3), F_(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, g + 1), Km(s, s.dyn_ltree, s.dyn_dtree)), I0(s), m && P0(s);
}, q_ = (s, l, a) => (s.pending_buf[s.sym_buf + s.sym_next++] = l, s.pending_buf[s.sym_buf + s.sym_next++] = l >> 8, s.pending_buf[s.sym_buf + s.sym_next++] = a, l === 0 ? s.dyn_ltree[a * 2]++ : (s.matches++, l--, s.dyn_ltree[(gh[a] + Sh + 1) * 2]++, s.dyn_dtree[T0(l) * 2]++), s.sym_next === s.sym_end);
var U_ = R_, V_ = L0, $_ = j_, Z_ = q_, G_ = O_, H_ = {
  _tr_init: U_,
  _tr_stored_block: V_,
  _tr_flush_block: $_,
  _tr_tally: Z_,
  _tr_align: G_
};
const W_ = (s, l, a, m) => {
  let y = s & 65535 | 0, _ = s >>> 16 & 65535 | 0, g = 0;
  for (; a !== 0; ) {
    g = a > 2e3 ? 2e3 : a, a -= g;
    do
      y = y + l[m++] | 0, _ = _ + y | 0;
    while (--g);
    y %= 65521, _ %= 65521;
  }
  return y | _ << 16 | 0;
};
var yh = W_;
const X_ = () => {
  let s, l = [];
  for (var a = 0; a < 256; a++) {
    s = a;
    for (var m = 0; m < 8; m++)
      s = s & 1 ? 3988292384 ^ s >>> 1 : s >>> 1;
    l[a] = s;
  }
  return l;
}, Y_ = new Uint32Array(X_()), J_ = (s, l, a, m) => {
  const y = Y_, _ = m + a;
  s ^= -1;
  for (let g = m; g < _; g++)
    s = s >>> 8 ^ y[(s ^ l[g]) & 255];
  return s ^ -1;
};
var En = J_, wc = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, Eh = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: K_, _tr_stored_block: Rp, _tr_flush_block: Q_, _tr_tally: tu, _tr_align: ey } = H_, {
  Z_NO_FLUSH: iu,
  Z_PARTIAL_FLUSH: ty,
  Z_FULL_FLUSH: iy,
  Z_FINISH: La,
  Z_BLOCK: ig,
  Z_OK: Rn,
  Z_STREAM_END: rg,
  Z_STREAM_ERROR: Go,
  Z_DATA_ERROR: ry,
  Z_BUF_ERROR: mp,
  Z_DEFAULT_COMPRESSION: ny,
  Z_FILTERED: sy,
  Z_HUFFMAN_ONLY: Hh,
  Z_RLE: ay,
  Z_FIXED: oy,
  Z_DEFAULT_STRATEGY: ly,
  Z_UNKNOWN: uy,
  Z_DEFLATED: _d
} = Eh, cy = 9, hy = 15, dy = 8, py = 29, fy = 256, Op = fy + 1 + py, my = 30, gy = 19, _y = 2 * Op + 1, yy = 15, $i = 3, Ql = 258, Ho = Ql + $i + 1, vy = 32, Ac = 42, pf = 57, jp = 69, qp = 73, Up = 91, Vp = 103, Lu = 113, ah = 666, xs = 1, Tc = 2, Fu = 3, kc = 4, by = 3, Mu = (s, l) => (s.msg = wc[l], l), ng = (s) => s * 2 - (s > 4 ? 9 : 0), Jl = (s) => {
  let l = s.length;
  for (; --l >= 0; )
    s[l] = 0;
}, xy = (s) => {
  let l, a, m, y = s.w_size;
  l = s.hash_size, m = l;
  do
    a = s.head[--m], s.head[m] = a >= y ? a - y : 0;
  while (--l);
  l = y, m = l;
  do
    a = s.prev[--m], s.prev[m] = a >= y ? a - y : 0;
  while (--l);
};
let wy = (s, l, a) => (l << s.hash_shift ^ a) & s.hash_mask, ru = wy;
const la = (s) => {
  const l = s.state;
  let a = l.pending;
  a > s.avail_out && (a = s.avail_out), a !== 0 && (s.output.set(l.pending_buf.subarray(l.pending_out, l.pending_out + a), s.next_out), s.next_out += a, l.pending_out += a, s.total_out += a, s.avail_out -= a, l.pending -= a, l.pending === 0 && (l.pending_out = 0));
}, ua = (s, l) => {
  Q_(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, l), s.block_start = s.strstart, la(s.strm);
}, er = (s, l) => {
  s.pending_buf[s.pending++] = l;
}, th = (s, l) => {
  s.pending_buf[s.pending++] = l >>> 8 & 255, s.pending_buf[s.pending++] = l & 255;
}, $p = (s, l, a, m) => {
  let y = s.avail_in;
  return y > m && (y = m), y === 0 ? 0 : (s.avail_in -= y, l.set(s.input.subarray(s.next_in, s.next_in + y), a), s.state.wrap === 1 ? s.adler = yh(s.adler, l, y, a) : s.state.wrap === 2 && (s.adler = En(s.adler, l, y, a)), s.next_in += y, s.total_in += y, y);
}, M0 = (s, l) => {
  let a = s.max_chain_length, m = s.strstart, y, _, g = s.prev_length, o = s.nice_match;
  const k = s.strstart > s.w_size - Ho ? s.strstart - (s.w_size - Ho) : 0, D = s.window, L = s.w_mask, j = s.prev, O = s.strstart + Ql;
  let z = D[m + g - 1], pe = D[m + g];
  s.prev_length >= s.good_match && (a >>= 2), o > s.lookahead && (o = s.lookahead);
  do
    if (y = l, !(D[y + g] !== pe || D[y + g - 1] !== z || D[y] !== D[m] || D[++y] !== D[m + 1])) {
      m += 2, y++;
      do
        ;
      while (D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && D[++m] === D[++y] && m < O);
      if (_ = Ql - (O - m), m = O - Ql, _ > g) {
        if (s.match_start = l, g = _, _ >= o)
          break;
        z = D[m + g - 1], pe = D[m + g];
      }
    }
  while ((l = j[l & L]) > k && --a !== 0);
  return g <= s.lookahead ? g : s.lookahead;
}, Sc = (s) => {
  const l = s.w_size;
  let a, m, y;
  do {
    if (m = s.window_size - s.lookahead - s.strstart, s.strstart >= l + (l - Ho) && (s.window.set(s.window.subarray(l, l + l - m), 0), s.match_start -= l, s.strstart -= l, s.block_start -= l, s.insert > s.strstart && (s.insert = s.strstart), xy(s), m += l), s.strm.avail_in === 0)
      break;
    if (a = $p(s.strm, s.window, s.strstart + s.lookahead, m), s.lookahead += a, s.lookahead + s.insert >= $i)
      for (y = s.strstart - s.insert, s.ins_h = s.window[y], s.ins_h = ru(s, s.ins_h, s.window[y + 1]); s.insert && (s.ins_h = ru(s, s.ins_h, s.window[y + $i - 1]), s.prev[y & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = y, y++, s.insert--, !(s.lookahead + s.insert < $i)); )
        ;
  } while (s.lookahead < Ho && s.strm.avail_in !== 0);
}, N0 = (s, l) => {
  let a = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5, m, y, _, g = 0, o = s.strm.avail_in;
  do {
    if (m = 65535, _ = s.bi_valid + 42 >> 3, s.strm.avail_out < _ || (_ = s.strm.avail_out - _, y = s.strstart - s.block_start, m > y + s.strm.avail_in && (m = y + s.strm.avail_in), m > _ && (m = _), m < a && (m === 0 && l !== La || l === iu || m !== y + s.strm.avail_in)))
      break;
    g = l === La && m === y + s.strm.avail_in ? 1 : 0, Rp(s, 0, 0, g), s.pending_buf[s.pending - 4] = m, s.pending_buf[s.pending - 3] = m >> 8, s.pending_buf[s.pending - 2] = ~m, s.pending_buf[s.pending - 1] = ~m >> 8, la(s.strm), y && (y > m && (y = m), s.strm.output.set(s.window.subarray(s.block_start, s.block_start + y), s.strm.next_out), s.strm.next_out += y, s.strm.avail_out -= y, s.strm.total_out += y, s.block_start += y, m -= y), m && ($p(s.strm, s.strm.output, s.strm.next_out, m), s.strm.next_out += m, s.strm.avail_out -= m, s.strm.total_out += m);
  } while (g === 0);
  return o -= s.strm.avail_in, o && (o >= s.w_size ? (s.matches = 2, s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0), s.strstart = s.w_size, s.insert = s.strstart) : (s.window_size - s.strstart <= o && (s.strstart -= s.w_size, s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0), s.matches < 2 && s.matches++, s.insert > s.strstart && (s.insert = s.strstart)), s.window.set(s.strm.input.subarray(s.strm.next_in - o, s.strm.next_in), s.strstart), s.strstart += o, s.insert += o > s.w_size - s.insert ? s.w_size - s.insert : o), s.block_start = s.strstart), s.high_water < s.strstart && (s.high_water = s.strstart), g ? kc : l !== iu && l !== La && s.strm.avail_in === 0 && s.strstart === s.block_start ? Tc : (_ = s.window_size - s.strstart, s.strm.avail_in > _ && s.block_start >= s.w_size && (s.block_start -= s.w_size, s.strstart -= s.w_size, s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0), s.matches < 2 && s.matches++, _ += s.w_size, s.insert > s.strstart && (s.insert = s.strstart)), _ > s.strm.avail_in && (_ = s.strm.avail_in), _ && ($p(s.strm, s.window, s.strstart, _), s.strstart += _, s.insert += _ > s.w_size - s.insert ? s.w_size - s.insert : _), s.high_water < s.strstart && (s.high_water = s.strstart), _ = s.bi_valid + 42 >> 3, _ = s.pending_buf_size - _ > 65535 ? 65535 : s.pending_buf_size - _, a = _ > s.w_size ? s.w_size : _, y = s.strstart - s.block_start, (y >= a || (y || l === La) && l !== iu && s.strm.avail_in === 0 && y <= _) && (m = y > _ ? _ : y, g = l === La && s.strm.avail_in === 0 && m === y ? 1 : 0, Rp(s, s.block_start, m, g), s.block_start += m, la(s.strm)), g ? Fu : xs);
}, gp = (s, l) => {
  let a, m;
  for (; ; ) {
    if (s.lookahead < Ho) {
      if (Sc(s), s.lookahead < Ho && l === iu)
        return xs;
      if (s.lookahead === 0)
        break;
    }
    if (a = 0, s.lookahead >= $i && (s.ins_h = ru(s, s.ins_h, s.window[s.strstart + $i - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), a !== 0 && s.strstart - a <= s.w_size - Ho && (s.match_length = M0(s, a)), s.match_length >= $i)
      if (m = tu(s, s.strstart - s.match_start, s.match_length - $i), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= $i) {
        s.match_length--;
        do
          s.strstart++, s.ins_h = ru(s, s.ins_h, s.window[s.strstart + $i - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;
        while (--s.match_length !== 0);
        s.strstart++;
      } else
        s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = ru(s, s.ins_h, s.window[s.strstart + 1]);
    else
      m = tu(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;
    if (m && (ua(s, !1), s.strm.avail_out === 0))
      return xs;
  }
  return s.insert = s.strstart < $i - 1 ? s.strstart : $i - 1, l === La ? (ua(s, !0), s.strm.avail_out === 0 ? Fu : kc) : s.sym_next && (ua(s, !1), s.strm.avail_out === 0) ? xs : Tc;
}, uc = (s, l) => {
  let a, m, y;
  for (; ; ) {
    if (s.lookahead < Ho) {
      if (Sc(s), s.lookahead < Ho && l === iu)
        return xs;
      if (s.lookahead === 0)
        break;
    }
    if (a = 0, s.lookahead >= $i && (s.ins_h = ru(s, s.ins_h, s.window[s.strstart + $i - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = $i - 1, a !== 0 && s.prev_length < s.max_lazy_match && s.strstart - a <= s.w_size - Ho && (s.match_length = M0(s, a), s.match_length <= 5 && (s.strategy === sy || s.match_length === $i && s.strstart - s.match_start > 4096) && (s.match_length = $i - 1)), s.prev_length >= $i && s.match_length <= s.prev_length) {
      y = s.strstart + s.lookahead - $i, m = tu(s, s.strstart - 1 - s.prev_match, s.prev_length - $i), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
      do
        ++s.strstart <= y && (s.ins_h = ru(s, s.ins_h, s.window[s.strstart + $i - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart);
      while (--s.prev_length !== 0);
      if (s.match_available = 0, s.match_length = $i - 1, s.strstart++, m && (ua(s, !1), s.strm.avail_out === 0))
        return xs;
    } else if (s.match_available) {
      if (m = tu(s, 0, s.window[s.strstart - 1]), m && ua(s, !1), s.strstart++, s.lookahead--, s.strm.avail_out === 0)
        return xs;
    } else
      s.match_available = 1, s.strstart++, s.lookahead--;
  }
  return s.match_available && (m = tu(s, 0, s.window[s.strstart - 1]), s.match_available = 0), s.insert = s.strstart < $i - 1 ? s.strstart : $i - 1, l === La ? (ua(s, !0), s.strm.avail_out === 0 ? Fu : kc) : s.sym_next && (ua(s, !1), s.strm.avail_out === 0) ? xs : Tc;
}, Ay = (s, l) => {
  let a, m, y, _;
  const g = s.window;
  for (; ; ) {
    if (s.lookahead <= Ql) {
      if (Sc(s), s.lookahead <= Ql && l === iu)
        return xs;
      if (s.lookahead === 0)
        break;
    }
    if (s.match_length = 0, s.lookahead >= $i && s.strstart > 0 && (y = s.strstart - 1, m = g[y], m === g[++y] && m === g[++y] && m === g[++y])) {
      _ = s.strstart + Ql;
      do
        ;
      while (m === g[++y] && m === g[++y] && m === g[++y] && m === g[++y] && m === g[++y] && m === g[++y] && m === g[++y] && m === g[++y] && y < _);
      s.match_length = Ql - (_ - y), s.match_length > s.lookahead && (s.match_length = s.lookahead);
    }
    if (s.match_length >= $i ? (a = tu(s, 1, s.match_length - $i), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0) : (a = tu(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++), a && (ua(s, !1), s.strm.avail_out === 0))
      return xs;
  }
  return s.insert = 0, l === La ? (ua(s, !0), s.strm.avail_out === 0 ? Fu : kc) : s.sym_next && (ua(s, !1), s.strm.avail_out === 0) ? xs : Tc;
}, Sy = (s, l) => {
  let a;
  for (; ; ) {
    if (s.lookahead === 0 && (Sc(s), s.lookahead === 0)) {
      if (l === iu)
        return xs;
      break;
    }
    if (s.match_length = 0, a = tu(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, a && (ua(s, !1), s.strm.avail_out === 0))
      return xs;
  }
  return s.insert = 0, l === La ? (ua(s, !0), s.strm.avail_out === 0 ? Fu : kc) : s.sym_next && (ua(s, !1), s.strm.avail_out === 0) ? xs : Tc;
};
function Uo(s, l, a, m, y) {
  this.good_length = s, this.max_lazy = l, this.nice_length = a, this.max_chain = m, this.func = y;
}
const oh = [
  /*      good lazy nice chain */
  new Uo(0, 0, 0, 0, N0),
  /* 0 store only */
  new Uo(4, 4, 8, 4, gp),
  /* 1 max speed, no lazy matches */
  new Uo(4, 5, 16, 8, gp),
  /* 2 */
  new Uo(4, 6, 32, 32, gp),
  /* 3 */
  new Uo(4, 4, 16, 16, uc),
  /* 4 lazy matches */
  new Uo(8, 16, 32, 32, uc),
  /* 5 */
  new Uo(8, 16, 128, 128, uc),
  /* 6 */
  new Uo(8, 32, 128, 256, uc),
  /* 7 */
  new Uo(32, 128, 258, 1024, uc),
  /* 8 */
  new Uo(32, 258, 258, 4096, uc)
  /* 9 max compression */
], Ey = (s) => {
  s.window_size = 2 * s.w_size, Jl(s.head), s.max_lazy_match = oh[s.level].max_lazy, s.good_match = oh[s.level].good_length, s.nice_match = oh[s.level].nice_length, s.max_chain_length = oh[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = $i - 1, s.match_available = 0, s.ins_h = 0;
};
function Cy() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = _d, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(_y * 2), this.dyn_dtree = new Uint16Array((2 * my + 1) * 2), this.bl_tree = new Uint16Array((2 * gy + 1) * 2), Jl(this.dyn_ltree), Jl(this.dyn_dtree), Jl(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(yy + 1), this.heap = new Uint16Array(2 * Op + 1), Jl(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Op + 1), Jl(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Ch = (s) => {
  if (!s)
    return 1;
  const l = s.state;
  return !l || l.strm !== s || l.status !== Ac && //#ifdef GZIP
  l.status !== pf && //#endif
  l.status !== jp && l.status !== qp && l.status !== Up && l.status !== Vp && l.status !== Lu && l.status !== ah ? 1 : 0;
}, z0 = (s) => {
  if (Ch(s))
    return Mu(s, Go);
  s.total_in = s.total_out = 0, s.data_type = uy;
  const l = s.state;
  return l.pending = 0, l.pending_out = 0, l.wrap < 0 && (l.wrap = -l.wrap), l.status = //#ifdef GZIP
  l.wrap === 2 ? pf : (
    //#endif
    l.wrap ? Ac : Lu
  ), s.adler = l.wrap === 2 ? 0 : 1, l.last_flush = -2, K_(l), Rn;
}, F0 = (s) => {
  const l = z0(s);
  return l === Rn && Ey(s.state), l;
}, Ty = (s, l) => Ch(s) || s.state.wrap !== 2 ? Go : (s.state.gzhead = l, Rn), B0 = (s, l, a, m, y, _) => {
  if (!s)
    return Go;
  let g = 1;
  if (l === ny && (l = 6), m < 0 ? (g = 0, m = -m) : m > 15 && (g = 2, m -= 16), y < 1 || y > cy || a !== _d || m < 8 || m > 15 || l < 0 || l > 9 || _ < 0 || _ > oy || m === 8 && g !== 1)
    return Mu(s, Go);
  m === 8 && (m = 9);
  const o = new Cy();
  return s.state = o, o.strm = s, o.status = Ac, o.wrap = g, o.gzhead = null, o.w_bits = m, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = y + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + $i - 1) / $i), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << y + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = l, o.strategy = _, o.method = a, F0(s);
}, ky = (s, l) => B0(s, l, _d, hy, dy, ly), Dy = (s, l) => {
  if (Ch(s) || l > ig || l < 0)
    return s ? Mu(s, Go) : Go;
  const a = s.state;
  if (!s.output || s.avail_in !== 0 && !s.input || a.status === ah && l !== La)
    return Mu(s, s.avail_out === 0 ? mp : Go);
  const m = a.last_flush;
  if (a.last_flush = l, a.pending !== 0) {
    if (la(s), s.avail_out === 0)
      return a.last_flush = -1, Rn;
  } else if (s.avail_in === 0 && ng(l) <= ng(m) && l !== La)
    return Mu(s, mp);
  if (a.status === ah && s.avail_in !== 0)
    return Mu(s, mp);
  if (a.status === Ac && a.wrap === 0 && (a.status = Lu), a.status === Ac) {
    let y = _d + (a.w_bits - 8 << 4) << 8, _ = -1;
    if (a.strategy >= Hh || a.level < 2 ? _ = 0 : a.level < 6 ? _ = 1 : a.level === 6 ? _ = 2 : _ = 3, y |= _ << 6, a.strstart !== 0 && (y |= vy), y += 31 - y % 31, th(a, y), a.strstart !== 0 && (th(a, s.adler >>> 16), th(a, s.adler & 65535)), s.adler = 1, a.status = Lu, la(s), a.pending !== 0)
      return a.last_flush = -1, Rn;
  }
  if (a.status === pf) {
    if (s.adler = 0, er(a, 31), er(a, 139), er(a, 8), a.gzhead)
      er(
        a,
        (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)
      ), er(a, a.gzhead.time & 255), er(a, a.gzhead.time >> 8 & 255), er(a, a.gzhead.time >> 16 & 255), er(a, a.gzhead.time >> 24 & 255), er(a, a.level === 9 ? 2 : a.strategy >= Hh || a.level < 2 ? 4 : 0), er(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (er(a, a.gzhead.extra.length & 255), er(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (s.adler = En(s.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = jp;
    else if (er(a, 0), er(a, 0), er(a, 0), er(a, 0), er(a, 0), er(a, a.level === 9 ? 2 : a.strategy >= Hh || a.level < 2 ? 4 : 0), er(a, by), a.status = Lu, la(s), a.pending !== 0)
      return a.last_flush = -1, Rn;
  }
  if (a.status === jp) {
    if (a.gzhead.extra) {
      let y = a.pending, _ = (a.gzhead.extra.length & 65535) - a.gzindex;
      for (; a.pending + _ > a.pending_buf_size; ) {
        let o = a.pending_buf_size - a.pending;
        if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + o), a.pending), a.pending = a.pending_buf_size, a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y)), a.gzindex += o, la(s), a.pending !== 0)
          return a.last_flush = -1, Rn;
        y = 0, _ -= o;
      }
      let g = new Uint8Array(a.gzhead.extra);
      a.pending_buf.set(g.subarray(a.gzindex, a.gzindex + _), a.pending), a.pending += _, a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y)), a.gzindex = 0;
    }
    a.status = qp;
  }
  if (a.status === qp) {
    if (a.gzhead.name) {
      let y = a.pending, _;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y)), la(s), a.pending !== 0)
            return a.last_flush = -1, Rn;
          y = 0;
        }
        a.gzindex < a.gzhead.name.length ? _ = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : _ = 0, er(a, _);
      } while (_ !== 0);
      a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y)), a.gzindex = 0;
    }
    a.status = Up;
  }
  if (a.status === Up) {
    if (a.gzhead.comment) {
      let y = a.pending, _;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y)), la(s), a.pending !== 0)
            return a.last_flush = -1, Rn;
          y = 0;
        }
        a.gzindex < a.gzhead.comment.length ? _ = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : _ = 0, er(a, _);
      } while (_ !== 0);
      a.gzhead.hcrc && a.pending > y && (s.adler = En(s.adler, a.pending_buf, a.pending - y, y));
    }
    a.status = Vp;
  }
  if (a.status === Vp) {
    if (a.gzhead.hcrc) {
      if (a.pending + 2 > a.pending_buf_size && (la(s), a.pending !== 0))
        return a.last_flush = -1, Rn;
      er(a, s.adler & 255), er(a, s.adler >> 8 & 255), s.adler = 0;
    }
    if (a.status = Lu, la(s), a.pending !== 0)
      return a.last_flush = -1, Rn;
  }
  if (s.avail_in !== 0 || a.lookahead !== 0 || l !== iu && a.status !== ah) {
    let y = a.level === 0 ? N0(a, l) : a.strategy === Hh ? Sy(a, l) : a.strategy === ay ? Ay(a, l) : oh[a.level].func(a, l);
    if ((y === Fu || y === kc) && (a.status = ah), y === xs || y === Fu)
      return s.avail_out === 0 && (a.last_flush = -1), Rn;
    if (y === Tc && (l === ty ? ey(a) : l !== ig && (Rp(a, 0, 0, !1), l === iy && (Jl(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), la(s), s.avail_out === 0))
      return a.last_flush = -1, Rn;
  }
  return l !== La ? Rn : a.wrap <= 0 ? rg : (a.wrap === 2 ? (er(a, s.adler & 255), er(a, s.adler >> 8 & 255), er(a, s.adler >> 16 & 255), er(a, s.adler >> 24 & 255), er(a, s.total_in & 255), er(a, s.total_in >> 8 & 255), er(a, s.total_in >> 16 & 255), er(a, s.total_in >> 24 & 255)) : (th(a, s.adler >>> 16), th(a, s.adler & 65535)), la(s), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? Rn : rg);
}, Iy = (s) => {
  if (Ch(s))
    return Go;
  const l = s.state.status;
  return s.state = null, l === Lu ? Mu(s, ry) : Rn;
}, Py = (s, l) => {
  let a = l.length;
  if (Ch(s))
    return Go;
  const m = s.state, y = m.wrap;
  if (y === 2 || y === 1 && m.status !== Ac || m.lookahead)
    return Go;
  if (y === 1 && (s.adler = yh(s.adler, l, a, 0)), m.wrap = 0, a >= m.w_size) {
    y === 0 && (Jl(m.head), m.strstart = 0, m.block_start = 0, m.insert = 0);
    let k = new Uint8Array(m.w_size);
    k.set(l.subarray(a - m.w_size, a), 0), l = k, a = m.w_size;
  }
  const _ = s.avail_in, g = s.next_in, o = s.input;
  for (s.avail_in = a, s.next_in = 0, s.input = l, Sc(m); m.lookahead >= $i; ) {
    let k = m.strstart, D = m.lookahead - ($i - 1);
    do
      m.ins_h = ru(m, m.ins_h, m.window[k + $i - 1]), m.prev[k & m.w_mask] = m.head[m.ins_h], m.head[m.ins_h] = k, k++;
    while (--D);
    m.strstart = k, m.lookahead = $i - 1, Sc(m);
  }
  return m.strstart += m.lookahead, m.block_start = m.strstart, m.insert = m.lookahead, m.lookahead = 0, m.match_length = m.prev_length = $i - 1, m.match_available = 0, s.next_in = g, s.input = o, s.avail_in = _, m.wrap = y, Rn;
};
var Ly = ky, My = B0, Ny = F0, zy = z0, Fy = Ty, By = Dy, Ry = Iy, Oy = Py, jy = "pako deflate (from Nodeca project)", hh = {
  deflateInit: Ly,
  deflateInit2: My,
  deflateReset: Ny,
  deflateResetKeep: zy,
  deflateSetHeader: Fy,
  deflate: By,
  deflateEnd: Ry,
  deflateSetDictionary: Oy,
  deflateInfo: jy
};
const qy = (s, l) => Object.prototype.hasOwnProperty.call(s, l);
var Uy = function(s) {
  const l = Array.prototype.slice.call(arguments, 1);
  for (; l.length; ) {
    const a = l.shift();
    if (a) {
      if (typeof a != "object")
        throw new TypeError(a + "must be non-object");
      for (const m in a)
        qy(a, m) && (s[m] = a[m]);
    }
  }
  return s;
}, Vy = (s) => {
  let l = 0;
  for (let m = 0, y = s.length; m < y; m++)
    l += s[m].length;
  const a = new Uint8Array(l);
  for (let m = 0, y = 0, _ = s.length; m < _; m++) {
    let g = s[m];
    a.set(g, y), y += g.length;
  }
  return a;
}, yd = {
  assign: Uy,
  flattenChunks: Vy
};
let R0 = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  R0 = !1;
}
const vh = new Uint8Array(256);
for (let s = 0; s < 256; s++)
  vh[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;
vh[254] = vh[254] = 1;
var $y = (s) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(s);
  let l, a, m, y, _, g = s.length, o = 0;
  for (y = 0; y < g; y++)
    a = s.charCodeAt(y), (a & 64512) === 55296 && y + 1 < g && (m = s.charCodeAt(y + 1), (m & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (m - 56320), y++)), o += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
  for (l = new Uint8Array(o), _ = 0, y = 0; _ < o; y++)
    a = s.charCodeAt(y), (a & 64512) === 55296 && y + 1 < g && (m = s.charCodeAt(y + 1), (m & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (m - 56320), y++)), a < 128 ? l[_++] = a : a < 2048 ? (l[_++] = 192 | a >>> 6, l[_++] = 128 | a & 63) : a < 65536 ? (l[_++] = 224 | a >>> 12, l[_++] = 128 | a >>> 6 & 63, l[_++] = 128 | a & 63) : (l[_++] = 240 | a >>> 18, l[_++] = 128 | a >>> 12 & 63, l[_++] = 128 | a >>> 6 & 63, l[_++] = 128 | a & 63);
  return l;
};
const Zy = (s, l) => {
  if (l < 65534 && s.subarray && R0)
    return String.fromCharCode.apply(null, s.length === l ? s : s.subarray(0, l));
  let a = "";
  for (let m = 0; m < l; m++)
    a += String.fromCharCode(s[m]);
  return a;
};
var Gy = (s, l) => {
  const a = l || s.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(s.subarray(0, l));
  let m, y;
  const _ = new Array(a * 2);
  for (y = 0, m = 0; m < a; ) {
    let g = s[m++];
    if (g < 128) {
      _[y++] = g;
      continue;
    }
    let o = vh[g];
    if (o > 4) {
      _[y++] = 65533, m += o - 1;
      continue;
    }
    for (g &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && m < a; )
      g = g << 6 | s[m++] & 63, o--;
    if (o > 1) {
      _[y++] = 65533;
      continue;
    }
    g < 65536 ? _[y++] = g : (g -= 65536, _[y++] = 55296 | g >> 10 & 1023, _[y++] = 56320 | g & 1023);
  }
  return Zy(_, y);
}, Hy = (s, l) => {
  l = l || s.length, l > s.length && (l = s.length);
  let a = l - 1;
  for (; a >= 0 && (s[a] & 192) === 128; )
    a--;
  return a < 0 || a === 0 ? l : a + vh[s[a]] > l ? a : l;
}, bh = {
  string2buf: $y,
  buf2string: Gy,
  utf8border: Hy
};
function Wy() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var O0 = Wy;
const j0 = Object.prototype.toString, {
  Z_NO_FLUSH: Xy,
  Z_SYNC_FLUSH: Yy,
  Z_FULL_FLUSH: Jy,
  Z_FINISH: Ky,
  Z_OK: hd,
  Z_STREAM_END: Qy,
  Z_DEFAULT_COMPRESSION: ev,
  Z_DEFAULT_STRATEGY: tv,
  Z_DEFLATED: iv
} = Eh;
function Th(s) {
  this.options = yd.assign({
    level: ev,
    method: iv,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: tv
  }, s || {});
  let l = this.options;
  l.raw && l.windowBits > 0 ? l.windowBits = -l.windowBits : l.gzip && l.windowBits > 0 && l.windowBits < 16 && (l.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new O0(), this.strm.avail_out = 0;
  let a = hh.deflateInit2(
    this.strm,
    l.level,
    l.method,
    l.windowBits,
    l.memLevel,
    l.strategy
  );
  if (a !== hd)
    throw new Error(wc[a]);
  if (l.header && hh.deflateSetHeader(this.strm, l.header), l.dictionary) {
    let m;
    if (typeof l.dictionary == "string" ? m = bh.string2buf(l.dictionary) : j0.call(l.dictionary) === "[object ArrayBuffer]" ? m = new Uint8Array(l.dictionary) : m = l.dictionary, a = hh.deflateSetDictionary(this.strm, m), a !== hd)
      throw new Error(wc[a]);
    this._dict_set = !0;
  }
}
Th.prototype.push = function(s, l) {
  const a = this.strm, m = this.options.chunkSize;
  let y, _;
  if (this.ended)
    return !1;
  for (l === ~~l ? _ = l : _ = l === !0 ? Ky : Xy, typeof s == "string" ? a.input = bh.string2buf(s) : j0.call(s) === "[object ArrayBuffer]" ? a.input = new Uint8Array(s) : a.input = s, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    if (a.avail_out === 0 && (a.output = new Uint8Array(m), a.next_out = 0, a.avail_out = m), (_ === Yy || _ === Jy) && a.avail_out <= 6) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (y = hh.deflate(a, _), y === Qy)
      return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)), y = hh.deflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === hd;
    if (a.avail_out === 0) {
      this.onData(a.output);
      continue;
    }
    if (_ > 0 && a.next_out > 0) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (a.avail_in === 0) break;
  }
  return !0;
};
Th.prototype.onData = function(s) {
  this.chunks.push(s);
};
Th.prototype.onEnd = function(s) {
  s === hd && (this.result = yd.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg;
};
function ff(s, l) {
  const a = new Th(l);
  if (a.push(s, !0), a.err)
    throw a.msg || wc[a.err];
  return a.result;
}
function rv(s, l) {
  return l = l || {}, l.raw = !0, ff(s, l);
}
function nv(s, l) {
  return l = l || {}, l.gzip = !0, ff(s, l);
}
var sv = Th, av = ff, ov = rv, lv = nv, uv = Eh, cv = {
  Deflate: sv,
  deflate: av,
  deflateRaw: ov,
  gzip: lv,
  constants: uv
};
const Wh = 16209, hv = 16191;
var dv = function(l, a) {
  let m, y, _, g, o, k, D, L, j, O, z, pe, oe, ae, Q, fe, Ce, ze, je, Qe, ke, Ae, me, ve;
  const X = l.state;
  m = l.next_in, me = l.input, y = m + (l.avail_in - 5), _ = l.next_out, ve = l.output, g = _ - (a - l.avail_out), o = _ + (l.avail_out - 257), k = X.dmax, D = X.wsize, L = X.whave, j = X.wnext, O = X.window, z = X.hold, pe = X.bits, oe = X.lencode, ae = X.distcode, Q = (1 << X.lenbits) - 1, fe = (1 << X.distbits) - 1;
  e:
    do {
      pe < 15 && (z += me[m++] << pe, pe += 8, z += me[m++] << pe, pe += 8), Ce = oe[z & Q];
      t:
        for (; ; ) {
          if (ze = Ce >>> 24, z >>>= ze, pe -= ze, ze = Ce >>> 16 & 255, ze === 0)
            ve[_++] = Ce & 65535;
          else if (ze & 16) {
            je = Ce & 65535, ze &= 15, ze && (pe < ze && (z += me[m++] << pe, pe += 8), je += z & (1 << ze) - 1, z >>>= ze, pe -= ze), pe < 15 && (z += me[m++] << pe, pe += 8, z += me[m++] << pe, pe += 8), Ce = ae[z & fe];
            i:
              for (; ; ) {
                if (ze = Ce >>> 24, z >>>= ze, pe -= ze, ze = Ce >>> 16 & 255, ze & 16) {
                  if (Qe = Ce & 65535, ze &= 15, pe < ze && (z += me[m++] << pe, pe += 8, pe < ze && (z += me[m++] << pe, pe += 8)), Qe += z & (1 << ze) - 1, Qe > k) {
                    l.msg = "invalid distance too far back", X.mode = Wh;
                    break e;
                  }
                  if (z >>>= ze, pe -= ze, ze = _ - g, Qe > ze) {
                    if (ze = Qe - ze, ze > L && X.sane) {
                      l.msg = "invalid distance too far back", X.mode = Wh;
                      break e;
                    }
                    if (ke = 0, Ae = O, j === 0) {
                      if (ke += D - ze, ze < je) {
                        je -= ze;
                        do
                          ve[_++] = O[ke++];
                        while (--ze);
                        ke = _ - Qe, Ae = ve;
                      }
                    } else if (j < ze) {
                      if (ke += D + j - ze, ze -= j, ze < je) {
                        je -= ze;
                        do
                          ve[_++] = O[ke++];
                        while (--ze);
                        if (ke = 0, j < je) {
                          ze = j, je -= ze;
                          do
                            ve[_++] = O[ke++];
                          while (--ze);
                          ke = _ - Qe, Ae = ve;
                        }
                      }
                    } else if (ke += j - ze, ze < je) {
                      je -= ze;
                      do
                        ve[_++] = O[ke++];
                      while (--ze);
                      ke = _ - Qe, Ae = ve;
                    }
                    for (; je > 2; )
                      ve[_++] = Ae[ke++], ve[_++] = Ae[ke++], ve[_++] = Ae[ke++], je -= 3;
                    je && (ve[_++] = Ae[ke++], je > 1 && (ve[_++] = Ae[ke++]));
                  } else {
                    ke = _ - Qe;
                    do
                      ve[_++] = ve[ke++], ve[_++] = ve[ke++], ve[_++] = ve[ke++], je -= 3;
                    while (je > 2);
                    je && (ve[_++] = ve[ke++], je > 1 && (ve[_++] = ve[ke++]));
                  }
                } else if (ze & 64) {
                  l.msg = "invalid distance code", X.mode = Wh;
                  break e;
                } else {
                  Ce = ae[(Ce & 65535) + (z & (1 << ze) - 1)];
                  continue i;
                }
                break;
              }
          } else if (ze & 64)
            if (ze & 32) {
              X.mode = hv;
              break e;
            } else {
              l.msg = "invalid literal/length code", X.mode = Wh;
              break e;
            }
          else {
            Ce = oe[(Ce & 65535) + (z & (1 << ze) - 1)];
            continue t;
          }
          break;
        }
    } while (m < y && _ < o);
  je = pe >> 3, m -= je, pe -= je << 3, z &= (1 << pe) - 1, l.next_in = m, l.next_out = _, l.avail_in = m < y ? 5 + (y - m) : 5 - (m - y), l.avail_out = _ < o ? 257 + (o - _) : 257 - (_ - o), X.hold = z, X.bits = pe;
};
const cc = 15, sg = 852, ag = 592, og = 0, _p = 1, lg = 2, pv = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), fv = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), mv = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), gv = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), _v = (s, l, a, m, y, _, g, o) => {
  const k = o.bits;
  let D = 0, L = 0, j = 0, O = 0, z = 0, pe = 0, oe = 0, ae = 0, Q = 0, fe = 0, Ce, ze, je, Qe, ke, Ae = null, me;
  const ve = new Uint16Array(cc + 1), X = new Uint16Array(cc + 1);
  let re = null, xe, ye, Ve;
  for (D = 0; D <= cc; D++)
    ve[D] = 0;
  for (L = 0; L < m; L++)
    ve[l[a + L]]++;
  for (z = k, O = cc; O >= 1 && ve[O] === 0; O--)
    ;
  if (z > O && (z = O), O === 0)
    return y[_++] = 1 << 24 | 64 << 16 | 0, y[_++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (j = 1; j < O && ve[j] === 0; j++)
    ;
  for (z < j && (z = j), ae = 1, D = 1; D <= cc; D++)
    if (ae <<= 1, ae -= ve[D], ae < 0)
      return -1;
  if (ae > 0 && (s === og || O !== 1))
    return -1;
  for (X[1] = 0, D = 1; D < cc; D++)
    X[D + 1] = X[D] + ve[D];
  for (L = 0; L < m; L++)
    l[a + L] !== 0 && (g[X[l[a + L]]++] = L);
  if (s === og ? (Ae = re = g, me = 20) : s === _p ? (Ae = pv, re = fv, me = 257) : (Ae = mv, re = gv, me = 0), fe = 0, L = 0, D = j, ke = _, pe = z, oe = 0, je = -1, Q = 1 << z, Qe = Q - 1, s === _p && Q > sg || s === lg && Q > ag)
    return 1;
  for (; ; ) {
    xe = D - oe, g[L] + 1 < me ? (ye = 0, Ve = g[L]) : g[L] >= me ? (ye = re[g[L] - me], Ve = Ae[g[L] - me]) : (ye = 96, Ve = 0), Ce = 1 << D - oe, ze = 1 << pe, j = ze;
    do
      ze -= Ce, y[ke + (fe >> oe) + ze] = xe << 24 | ye << 16 | Ve | 0;
    while (ze !== 0);
    for (Ce = 1 << D - 1; fe & Ce; )
      Ce >>= 1;
    if (Ce !== 0 ? (fe &= Ce - 1, fe += Ce) : fe = 0, L++, --ve[D] === 0) {
      if (D === O)
        break;
      D = l[a + g[L]];
    }
    if (D > z && (fe & Qe) !== je) {
      for (oe === 0 && (oe = z), ke += j, pe = D - oe, ae = 1 << pe; pe + oe < O && (ae -= ve[pe + oe], !(ae <= 0)); )
        pe++, ae <<= 1;
      if (Q += 1 << pe, s === _p && Q > sg || s === lg && Q > ag)
        return 1;
      je = fe & Qe, y[je] = z << 24 | pe << 16 | ke - _ | 0;
    }
  }
  return fe !== 0 && (y[ke + fe] = D - oe << 24 | 64 << 16 | 0), o.bits = z, 0;
};
var dh = _v;
const yv = 0, q0 = 1, U0 = 2, {
  Z_FINISH: ug,
  Z_BLOCK: vv,
  Z_TREES: Xh,
  Z_OK: Bu,
  Z_STREAM_END: bv,
  Z_NEED_DICT: xv,
  Z_STREAM_ERROR: Ma,
  Z_DATA_ERROR: V0,
  Z_MEM_ERROR: $0,
  Z_BUF_ERROR: wv,
  Z_DEFLATED: cg
} = Eh, vd = 16180, hg = 16181, dg = 16182, pg = 16183, fg = 16184, mg = 16185, gg = 16186, _g = 16187, yg = 16188, vg = 16189, dd = 16190, Sl = 16191, yp = 16192, bg = 16193, vp = 16194, xg = 16195, wg = 16196, Ag = 16197, Sg = 16198, Yh = 16199, Jh = 16200, Eg = 16201, Cg = 16202, Tg = 16203, kg = 16204, Dg = 16205, bp = 16206, Ig = 16207, Pg = 16208, Nr = 16209, Z0 = 16210, G0 = 16211, Av = 852, Sv = 592, Ev = 15, Cv = Ev, Lg = (s) => (s >>> 24 & 255) + (s >>> 8 & 65280) + ((s & 65280) << 8) + ((s & 255) << 24);
function Tv() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Ou = (s) => {
  if (!s)
    return 1;
  const l = s.state;
  return !l || l.strm !== s || l.mode < vd || l.mode > G0 ? 1 : 0;
}, H0 = (s) => {
  if (Ou(s))
    return Ma;
  const l = s.state;
  return s.total_in = s.total_out = l.total = 0, s.msg = "", l.wrap && (s.adler = l.wrap & 1), l.mode = vd, l.last = 0, l.havedict = 0, l.flags = -1, l.dmax = 32768, l.head = null, l.hold = 0, l.bits = 0, l.lencode = l.lendyn = new Int32Array(Av), l.distcode = l.distdyn = new Int32Array(Sv), l.sane = 1, l.back = -1, Bu;
}, W0 = (s) => {
  if (Ou(s))
    return Ma;
  const l = s.state;
  return l.wsize = 0, l.whave = 0, l.wnext = 0, H0(s);
}, X0 = (s, l) => {
  let a;
  if (Ou(s))
    return Ma;
  const m = s.state;
  return l < 0 ? (a = 0, l = -l) : (a = (l >> 4) + 5, l < 48 && (l &= 15)), l && (l < 8 || l > 15) ? Ma : (m.window !== null && m.wbits !== l && (m.window = null), m.wrap = a, m.wbits = l, W0(s));
}, Y0 = (s, l) => {
  if (!s)
    return Ma;
  const a = new Tv();
  s.state = a, a.strm = s, a.window = null, a.mode = vd;
  const m = X0(s, l);
  return m !== Bu && (s.state = null), m;
}, kv = (s) => Y0(s, Cv);
let Mg = !0, xp, wp;
const Dv = (s) => {
  if (Mg) {
    xp = new Int32Array(512), wp = new Int32Array(32);
    let l = 0;
    for (; l < 144; )
      s.lens[l++] = 8;
    for (; l < 256; )
      s.lens[l++] = 9;
    for (; l < 280; )
      s.lens[l++] = 7;
    for (; l < 288; )
      s.lens[l++] = 8;
    for (dh(q0, s.lens, 0, 288, xp, 0, s.work, { bits: 9 }), l = 0; l < 32; )
      s.lens[l++] = 5;
    dh(U0, s.lens, 0, 32, wp, 0, s.work, { bits: 5 }), Mg = !1;
  }
  s.lencode = xp, s.lenbits = 9, s.distcode = wp, s.distbits = 5;
}, J0 = (s, l, a, m) => {
  let y;
  const _ = s.state;
  return _.window === null && (_.wsize = 1 << _.wbits, _.wnext = 0, _.whave = 0, _.window = new Uint8Array(_.wsize)), m >= _.wsize ? (_.window.set(l.subarray(a - _.wsize, a), 0), _.wnext = 0, _.whave = _.wsize) : (y = _.wsize - _.wnext, y > m && (y = m), _.window.set(l.subarray(a - m, a - m + y), _.wnext), m -= y, m ? (_.window.set(l.subarray(a - m, a), 0), _.wnext = m, _.whave = _.wsize) : (_.wnext += y, _.wnext === _.wsize && (_.wnext = 0), _.whave < _.wsize && (_.whave += y))), 0;
}, Iv = (s, l) => {
  let a, m, y, _, g, o, k, D, L, j, O, z, pe, oe, ae = 0, Q, fe, Ce, ze, je, Qe, ke, Ae;
  const me = new Uint8Array(4);
  let ve, X;
  const re = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Ou(s) || !s.output || !s.input && s.avail_in !== 0)
    return Ma;
  a = s.state, a.mode === Sl && (a.mode = yp), g = s.next_out, y = s.output, k = s.avail_out, _ = s.next_in, m = s.input, o = s.avail_in, D = a.hold, L = a.bits, j = o, O = k, Ae = Bu;
  e:
    for (; ; )
      switch (a.mode) {
        case vd:
          if (a.wrap === 0) {
            a.mode = yp;
            break;
          }
          for (; L < 16; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if (a.wrap & 2 && D === 35615) {
            a.wbits === 0 && (a.wbits = 15), a.check = 0, me[0] = D & 255, me[1] = D >>> 8 & 255, a.check = En(a.check, me, 2, 0), D = 0, L = 0, a.mode = hg;
            break;
          }
          if (a.head && (a.head.done = !1), !(a.wrap & 1) || /* check if zlib header allowed */
          (((D & 255) << 8) + (D >> 8)) % 31) {
            s.msg = "incorrect header check", a.mode = Nr;
            break;
          }
          if ((D & 15) !== cg) {
            s.msg = "unknown compression method", a.mode = Nr;
            break;
          }
          if (D >>>= 4, L -= 4, ke = (D & 15) + 8, a.wbits === 0 && (a.wbits = ke), ke > 15 || ke > a.wbits) {
            s.msg = "invalid window size", a.mode = Nr;
            break;
          }
          a.dmax = 1 << a.wbits, a.flags = 0, s.adler = a.check = 1, a.mode = D & 512 ? vg : Sl, D = 0, L = 0;
          break;
        case hg:
          for (; L < 16; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if (a.flags = D, (a.flags & 255) !== cg) {
            s.msg = "unknown compression method", a.mode = Nr;
            break;
          }
          if (a.flags & 57344) {
            s.msg = "unknown header flags set", a.mode = Nr;
            break;
          }
          a.head && (a.head.text = D >> 8 & 1), a.flags & 512 && a.wrap & 4 && (me[0] = D & 255, me[1] = D >>> 8 & 255, a.check = En(a.check, me, 2, 0)), D = 0, L = 0, a.mode = dg;
        case dg:
          for (; L < 32; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          a.head && (a.head.time = D), a.flags & 512 && a.wrap & 4 && (me[0] = D & 255, me[1] = D >>> 8 & 255, me[2] = D >>> 16 & 255, me[3] = D >>> 24 & 255, a.check = En(a.check, me, 4, 0)), D = 0, L = 0, a.mode = pg;
        case pg:
          for (; L < 16; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          a.head && (a.head.xflags = D & 255, a.head.os = D >> 8), a.flags & 512 && a.wrap & 4 && (me[0] = D & 255, me[1] = D >>> 8 & 255, a.check = En(a.check, me, 2, 0)), D = 0, L = 0, a.mode = fg;
        case fg:
          if (a.flags & 1024) {
            for (; L < 16; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            a.length = D, a.head && (a.head.extra_len = D), a.flags & 512 && a.wrap & 4 && (me[0] = D & 255, me[1] = D >>> 8 & 255, a.check = En(a.check, me, 2, 0)), D = 0, L = 0;
          } else a.head && (a.head.extra = null);
          a.mode = mg;
        case mg:
          if (a.flags & 1024 && (z = a.length, z > o && (z = o), z && (a.head && (ke = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Uint8Array(a.head.extra_len)), a.head.extra.set(
            m.subarray(
              _,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              _ + z
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            ke
          )), a.flags & 512 && a.wrap & 4 && (a.check = En(a.check, m, z, _)), o -= z, _ += z, a.length -= z), a.length))
            break e;
          a.length = 0, a.mode = gg;
        case gg:
          if (a.flags & 2048) {
            if (o === 0)
              break e;
            z = 0;
            do
              ke = m[_ + z++], a.head && ke && a.length < 65536 && (a.head.name += String.fromCharCode(ke));
            while (ke && z < o);
            if (a.flags & 512 && a.wrap & 4 && (a.check = En(a.check, m, z, _)), o -= z, _ += z, ke)
              break e;
          } else a.head && (a.head.name = null);
          a.length = 0, a.mode = _g;
        case _g:
          if (a.flags & 4096) {
            if (o === 0)
              break e;
            z = 0;
            do
              ke = m[_ + z++], a.head && ke && a.length < 65536 && (a.head.comment += String.fromCharCode(ke));
            while (ke && z < o);
            if (a.flags & 512 && a.wrap & 4 && (a.check = En(a.check, m, z, _)), o -= z, _ += z, ke)
              break e;
          } else a.head && (a.head.comment = null);
          a.mode = yg;
        case yg:
          if (a.flags & 512) {
            for (; L < 16; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            if (a.wrap & 4 && D !== (a.check & 65535)) {
              s.msg = "header crc mismatch", a.mode = Nr;
              break;
            }
            D = 0, L = 0;
          }
          a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), s.adler = a.check = 0, a.mode = Sl;
          break;
        case vg:
          for (; L < 32; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          s.adler = a.check = Lg(D), D = 0, L = 0, a.mode = dd;
        case dd:
          if (a.havedict === 0)
            return s.next_out = g, s.avail_out = k, s.next_in = _, s.avail_in = o, a.hold = D, a.bits = L, xv;
          s.adler = a.check = 1, a.mode = Sl;
        case Sl:
          if (l === vv || l === Xh)
            break e;
        case yp:
          if (a.last) {
            D >>>= L & 7, L -= L & 7, a.mode = bp;
            break;
          }
          for (; L < 3; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          switch (a.last = D & 1, D >>>= 1, L -= 1, D & 3) {
            case 0:
              a.mode = bg;
              break;
            case 1:
              if (Dv(a), a.mode = Yh, l === Xh) {
                D >>>= 2, L -= 2;
                break e;
              }
              break;
            case 2:
              a.mode = wg;
              break;
            case 3:
              s.msg = "invalid block type", a.mode = Nr;
          }
          D >>>= 2, L -= 2;
          break;
        case bg:
          for (D >>>= L & 7, L -= L & 7; L < 32; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if ((D & 65535) !== (D >>> 16 ^ 65535)) {
            s.msg = "invalid stored block lengths", a.mode = Nr;
            break;
          }
          if (a.length = D & 65535, D = 0, L = 0, a.mode = vp, l === Xh)
            break e;
        case vp:
          a.mode = xg;
        case xg:
          if (z = a.length, z) {
            if (z > o && (z = o), z > k && (z = k), z === 0)
              break e;
            y.set(m.subarray(_, _ + z), g), o -= z, _ += z, k -= z, g += z, a.length -= z;
            break;
          }
          a.mode = Sl;
          break;
        case wg:
          for (; L < 14; ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if (a.nlen = (D & 31) + 257, D >>>= 5, L -= 5, a.ndist = (D & 31) + 1, D >>>= 5, L -= 5, a.ncode = (D & 15) + 4, D >>>= 4, L -= 4, a.nlen > 286 || a.ndist > 30) {
            s.msg = "too many length or distance symbols", a.mode = Nr;
            break;
          }
          a.have = 0, a.mode = Ag;
        case Ag:
          for (; a.have < a.ncode; ) {
            for (; L < 3; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            a.lens[re[a.have++]] = D & 7, D >>>= 3, L -= 3;
          }
          for (; a.have < 19; )
            a.lens[re[a.have++]] = 0;
          if (a.lencode = a.lendyn, a.lenbits = 7, ve = { bits: a.lenbits }, Ae = dh(yv, a.lens, 0, 19, a.lencode, 0, a.work, ve), a.lenbits = ve.bits, Ae) {
            s.msg = "invalid code lengths set", a.mode = Nr;
            break;
          }
          a.have = 0, a.mode = Sg;
        case Sg:
          for (; a.have < a.nlen + a.ndist; ) {
            for (; ae = a.lencode[D & (1 << a.lenbits) - 1], Q = ae >>> 24, fe = ae >>> 16 & 255, Ce = ae & 65535, !(Q <= L); ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            if (Ce < 16)
              D >>>= Q, L -= Q, a.lens[a.have++] = Ce;
            else {
              if (Ce === 16) {
                for (X = Q + 2; L < X; ) {
                  if (o === 0)
                    break e;
                  o--, D += m[_++] << L, L += 8;
                }
                if (D >>>= Q, L -= Q, a.have === 0) {
                  s.msg = "invalid bit length repeat", a.mode = Nr;
                  break;
                }
                ke = a.lens[a.have - 1], z = 3 + (D & 3), D >>>= 2, L -= 2;
              } else if (Ce === 17) {
                for (X = Q + 3; L < X; ) {
                  if (o === 0)
                    break e;
                  o--, D += m[_++] << L, L += 8;
                }
                D >>>= Q, L -= Q, ke = 0, z = 3 + (D & 7), D >>>= 3, L -= 3;
              } else {
                for (X = Q + 7; L < X; ) {
                  if (o === 0)
                    break e;
                  o--, D += m[_++] << L, L += 8;
                }
                D >>>= Q, L -= Q, ke = 0, z = 11 + (D & 127), D >>>= 7, L -= 7;
              }
              if (a.have + z > a.nlen + a.ndist) {
                s.msg = "invalid bit length repeat", a.mode = Nr;
                break;
              }
              for (; z--; )
                a.lens[a.have++] = ke;
            }
          }
          if (a.mode === Nr)
            break;
          if (a.lens[256] === 0) {
            s.msg = "invalid code -- missing end-of-block", a.mode = Nr;
            break;
          }
          if (a.lenbits = 9, ve = { bits: a.lenbits }, Ae = dh(q0, a.lens, 0, a.nlen, a.lencode, 0, a.work, ve), a.lenbits = ve.bits, Ae) {
            s.msg = "invalid literal/lengths set", a.mode = Nr;
            break;
          }
          if (a.distbits = 6, a.distcode = a.distdyn, ve = { bits: a.distbits }, Ae = dh(U0, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, ve), a.distbits = ve.bits, Ae) {
            s.msg = "invalid distances set", a.mode = Nr;
            break;
          }
          if (a.mode = Yh, l === Xh)
            break e;
        case Yh:
          a.mode = Jh;
        case Jh:
          if (o >= 6 && k >= 258) {
            s.next_out = g, s.avail_out = k, s.next_in = _, s.avail_in = o, a.hold = D, a.bits = L, dv(s, O), g = s.next_out, y = s.output, k = s.avail_out, _ = s.next_in, m = s.input, o = s.avail_in, D = a.hold, L = a.bits, a.mode === Sl && (a.back = -1);
            break;
          }
          for (a.back = 0; ae = a.lencode[D & (1 << a.lenbits) - 1], Q = ae >>> 24, fe = ae >>> 16 & 255, Ce = ae & 65535, !(Q <= L); ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if (fe && !(fe & 240)) {
            for (ze = Q, je = fe, Qe = Ce; ae = a.lencode[Qe + ((D & (1 << ze + je) - 1) >> ze)], Q = ae >>> 24, fe = ae >>> 16 & 255, Ce = ae & 65535, !(ze + Q <= L); ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            D >>>= ze, L -= ze, a.back += ze;
          }
          if (D >>>= Q, L -= Q, a.back += Q, a.length = Ce, fe === 0) {
            a.mode = Dg;
            break;
          }
          if (fe & 32) {
            a.back = -1, a.mode = Sl;
            break;
          }
          if (fe & 64) {
            s.msg = "invalid literal/length code", a.mode = Nr;
            break;
          }
          a.extra = fe & 15, a.mode = Eg;
        case Eg:
          if (a.extra) {
            for (X = a.extra; L < X; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            a.length += D & (1 << a.extra) - 1, D >>>= a.extra, L -= a.extra, a.back += a.extra;
          }
          a.was = a.length, a.mode = Cg;
        case Cg:
          for (; ae = a.distcode[D & (1 << a.distbits) - 1], Q = ae >>> 24, fe = ae >>> 16 & 255, Ce = ae & 65535, !(Q <= L); ) {
            if (o === 0)
              break e;
            o--, D += m[_++] << L, L += 8;
          }
          if (!(fe & 240)) {
            for (ze = Q, je = fe, Qe = Ce; ae = a.distcode[Qe + ((D & (1 << ze + je) - 1) >> ze)], Q = ae >>> 24, fe = ae >>> 16 & 255, Ce = ae & 65535, !(ze + Q <= L); ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            D >>>= ze, L -= ze, a.back += ze;
          }
          if (D >>>= Q, L -= Q, a.back += Q, fe & 64) {
            s.msg = "invalid distance code", a.mode = Nr;
            break;
          }
          a.offset = Ce, a.extra = fe & 15, a.mode = Tg;
        case Tg:
          if (a.extra) {
            for (X = a.extra; L < X; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            a.offset += D & (1 << a.extra) - 1, D >>>= a.extra, L -= a.extra, a.back += a.extra;
          }
          if (a.offset > a.dmax) {
            s.msg = "invalid distance too far back", a.mode = Nr;
            break;
          }
          a.mode = kg;
        case kg:
          if (k === 0)
            break e;
          if (z = O - k, a.offset > z) {
            if (z = a.offset - z, z > a.whave && a.sane) {
              s.msg = "invalid distance too far back", a.mode = Nr;
              break;
            }
            z > a.wnext ? (z -= a.wnext, pe = a.wsize - z) : pe = a.wnext - z, z > a.length && (z = a.length), oe = a.window;
          } else
            oe = y, pe = g - a.offset, z = a.length;
          z > k && (z = k), k -= z, a.length -= z;
          do
            y[g++] = oe[pe++];
          while (--z);
          a.length === 0 && (a.mode = Jh);
          break;
        case Dg:
          if (k === 0)
            break e;
          y[g++] = a.length, k--, a.mode = Jh;
          break;
        case bp:
          if (a.wrap) {
            for (; L < 32; ) {
              if (o === 0)
                break e;
              o--, D |= m[_++] << L, L += 8;
            }
            if (O -= k, s.total_out += O, a.total += O, a.wrap & 4 && O && (s.adler = a.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            a.flags ? En(a.check, y, O, g - O) : yh(a.check, y, O, g - O)), O = k, a.wrap & 4 && (a.flags ? D : Lg(D)) !== a.check) {
              s.msg = "incorrect data check", a.mode = Nr;
              break;
            }
            D = 0, L = 0;
          }
          a.mode = Ig;
        case Ig:
          if (a.wrap && a.flags) {
            for (; L < 32; ) {
              if (o === 0)
                break e;
              o--, D += m[_++] << L, L += 8;
            }
            if (a.wrap & 4 && D !== (a.total & 4294967295)) {
              s.msg = "incorrect length check", a.mode = Nr;
              break;
            }
            D = 0, L = 0;
          }
          a.mode = Pg;
        case Pg:
          Ae = bv;
          break e;
        case Nr:
          Ae = V0;
          break e;
        case Z0:
          return $0;
        case G0:
        default:
          return Ma;
      }
  return s.next_out = g, s.avail_out = k, s.next_in = _, s.avail_in = o, a.hold = D, a.bits = L, (a.wsize || O !== s.avail_out && a.mode < Nr && (a.mode < bp || l !== ug)) && J0(s, s.output, s.next_out, O - s.avail_out), j -= s.avail_in, O -= s.avail_out, s.total_in += j, s.total_out += O, a.total += O, a.wrap & 4 && O && (s.adler = a.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  a.flags ? En(a.check, y, O, s.next_out - O) : yh(a.check, y, O, s.next_out - O)), s.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === Sl ? 128 : 0) + (a.mode === Yh || a.mode === vp ? 256 : 0), (j === 0 && O === 0 || l === ug) && Ae === Bu && (Ae = wv), Ae;
}, Pv = (s) => {
  if (Ou(s))
    return Ma;
  let l = s.state;
  return l.window && (l.window = null), s.state = null, Bu;
}, Lv = (s, l) => {
  if (Ou(s))
    return Ma;
  const a = s.state;
  return a.wrap & 2 ? (a.head = l, l.done = !1, Bu) : Ma;
}, Mv = (s, l) => {
  const a = l.length;
  let m, y, _;
  return Ou(s) || (m = s.state, m.wrap !== 0 && m.mode !== dd) ? Ma : m.mode === dd && (y = 1, y = yh(y, l, a, 0), y !== m.check) ? V0 : (_ = J0(s, l, a, a), _ ? (m.mode = Z0, $0) : (m.havedict = 1, Bu));
};
var Nv = W0, zv = X0, Fv = H0, Bv = kv, Rv = Y0, Ov = Iv, jv = Pv, qv = Lv, Uv = Mv, Vv = "pako inflate (from Nodeca project)", kl = {
  inflateReset: Nv,
  inflateReset2: zv,
  inflateResetKeep: Fv,
  inflateInit: Bv,
  inflateInit2: Rv,
  inflate: Ov,
  inflateEnd: jv,
  inflateGetHeader: qv,
  inflateSetDictionary: Uv,
  inflateInfo: Vv
};
function $v() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Zv = $v;
const K0 = Object.prototype.toString, {
  Z_NO_FLUSH: Gv,
  Z_FINISH: Hv,
  Z_OK: xh,
  Z_STREAM_END: Ap,
  Z_NEED_DICT: Sp,
  Z_STREAM_ERROR: Wv,
  Z_DATA_ERROR: Ng,
  Z_MEM_ERROR: Xv
} = Eh;
function mf(s) {
  this.options = yd.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, s || {});
  const l = this.options;
  l.raw && l.windowBits >= 0 && l.windowBits < 16 && (l.windowBits = -l.windowBits, l.windowBits === 0 && (l.windowBits = -15)), l.windowBits >= 0 && l.windowBits < 16 && !(s && s.windowBits) && (l.windowBits += 32), l.windowBits > 15 && l.windowBits < 48 && (l.windowBits & 15 || (l.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new O0(), this.strm.avail_out = 0;
  let a = kl.inflateInit2(
    this.strm,
    l.windowBits
  );
  if (a !== xh)
    throw new Error(wc[a]);
  if (this.header = new Zv(), kl.inflateGetHeader(this.strm, this.header), l.dictionary && (typeof l.dictionary == "string" ? l.dictionary = bh.string2buf(l.dictionary) : K0.call(l.dictionary) === "[object ArrayBuffer]" && (l.dictionary = new Uint8Array(l.dictionary)), l.raw && (a = kl.inflateSetDictionary(this.strm, l.dictionary), a !== xh)))
    throw new Error(wc[a]);
}
mf.prototype.push = function(s, l) {
  const a = this.strm, m = this.options.chunkSize, y = this.options.dictionary;
  let _, g, o;
  if (this.ended) return !1;
  for (l === ~~l ? g = l : g = l === !0 ? Hv : Gv, K0.call(s) === "[object ArrayBuffer]" ? a.input = new Uint8Array(s) : a.input = s, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    for (a.avail_out === 0 && (a.output = new Uint8Array(m), a.next_out = 0, a.avail_out = m), _ = kl.inflate(a, g), _ === Sp && y && (_ = kl.inflateSetDictionary(a, y), _ === xh ? _ = kl.inflate(a, g) : _ === Ng && (_ = Sp)); a.avail_in > 0 && _ === Ap && a.state.wrap > 0 && s[a.next_in] !== 0; )
      kl.inflateReset(a), _ = kl.inflate(a, g);
    switch (_) {
      case Wv:
      case Ng:
      case Sp:
      case Xv:
        return this.onEnd(_), this.ended = !0, !1;
    }
    if (o = a.avail_out, a.next_out && (a.avail_out === 0 || _ === Ap))
      if (this.options.to === "string") {
        let k = bh.utf8border(a.output, a.next_out), D = a.next_out - k, L = bh.buf2string(a.output, k);
        a.next_out = D, a.avail_out = m - D, D && a.output.set(a.output.subarray(k, k + D), 0), this.onData(L);
      } else
        this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));
    if (!(_ === xh && o === 0)) {
      if (_ === Ap)
        return _ = kl.inflateEnd(this.strm), this.onEnd(_), this.ended = !0, !0;
      if (a.avail_in === 0) break;
    }
  }
  return !0;
};
mf.prototype.onData = function(s) {
  this.chunks.push(s);
};
mf.prototype.onEnd = function(s) {
  s === xh && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = yd.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg;
};
const { Deflate: Sw, deflate: Yv, deflateRaw: Ew, gzip: Cw } = cv;
var Jv = Yv;
const Kv = [137, 80, 78, 71, 13, 10, 26, 10], Q0 = [];
for (let s = 0; s < 256; s++) {
  let l = s;
  for (let a = 0; a < 8; a++)
    l & 1 ? l = 3988292384 ^ l >>> 1 : l = l >>> 1;
  Q0[s] = l;
}
const zg = 4294967295;
function Qv(s, l, a) {
  let m = s;
  for (let y = 0; y < a; y++)
    m = Q0[(m ^ l[y]) & 255] ^ m >>> 8;
  return m;
}
function eb(s, l) {
  return (Qv(zg, s, l) ^ zg) >>> 0;
}
var Kl;
(function(s) {
  s[s.UNKNOWN = -1] = "UNKNOWN", s[s.GREYSCALE = 0] = "GREYSCALE", s[s.TRUECOLOUR = 2] = "TRUECOLOUR", s[s.INDEXED_COLOUR = 3] = "INDEXED_COLOUR", s[s.GREYSCALE_ALPHA = 4] = "GREYSCALE_ALPHA", s[s.TRUECOLOUR_ALPHA = 6] = "TRUECOLOUR_ALPHA";
})(Kl || (Kl = {}));
var Zp;
(function(s) {
  s[s.UNKNOWN = -1] = "UNKNOWN", s[s.DEFLATE = 0] = "DEFLATE";
})(Zp || (Zp = {}));
var Gp;
(function(s) {
  s[s.UNKNOWN = -1] = "UNKNOWN", s[s.ADAPTIVE = 0] = "ADAPTIVE";
})(Gp || (Gp = {}));
var Hp;
(function(s) {
  s[s.UNKNOWN = -1] = "UNKNOWN", s[s.NO_INTERLACE = 0] = "NO_INTERLACE", s[s.ADAM7 = 1] = "ADAM7";
})(Hp || (Hp = {}));
const tb = new Uint16Array([255]), ib = new Uint8Array(tb.buffer);
ib[0];
const rb = {
  level: 3
};
class nb extends ud {
  constructor(l, a = {}) {
    super(), this._colorType = Kl.UNKNOWN, this._zlibOptions = { ...rb, ...a.zlib }, this._png = this._checkData(l), this.setBigEndian();
  }
  encode() {
    return this.encodeSignature(), this.encodeIHDR(), this.encodeData(), this.encodeIEND(), this.toArray();
  }
  // https://www.w3.org/TR/PNG/#5PNG-file-signature
  encodeSignature() {
    this.writeBytes(Kv);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  encodeIHDR() {
    this.writeUint32(13), this.writeChars("IHDR"), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(Zp.DEFLATE), this.writeByte(Gp.ADAPTIVE), this.writeByte(Hp.NO_INTERLACE), this.writeCrc(17);
  }
  // https://www.w3.org/TR/PNG/#11IEND
  encodeIEND() {
    this.writeUint32(0), this.writeChars("IEND"), this.writeCrc(4);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  encodeIDAT(l) {
    this.writeUint32(l.length), this.writeChars("IDAT"), this.writeBytes(l), this.writeCrc(l.length + 4);
  }
  encodeData() {
    const { width: l, height: a, channels: m, depth: y, data: _ } = this._png, g = m * l, o = new ud().setBigEndian();
    let k = 0;
    for (let j = 0; j < a; j++)
      if (o.writeByte(0), y === 8)
        k = ab(_, o, g, k);
      else if (y === 16)
        k = ob(_, o, g, k);
      else
        throw new Error("unreachable");
    const D = o.toArray(), L = Jv(D, this._zlibOptions);
    this.encodeIDAT(L);
  }
  _checkData(l) {
    const { colorType: a, channels: m, depth: y } = sb(l), _ = {
      width: Fg(l.width, "width"),
      height: Fg(l.height, "height"),
      channels: m,
      data: l.data,
      depth: y,
      text: {}
    };
    this._colorType = a;
    const g = _.width * _.height * m;
    if (_.data.length !== g)
      throw new RangeError(`wrong data size. Found ${_.data.length}, expected ${g}`);
    return _;
  }
  writeCrc(l) {
    this.writeUint32(eb(new Uint8Array(this.buffer, this.byteOffset + this.offset - l, l), l));
  }
}
function Fg(s, l) {
  if (Number.isInteger(s) && s > 0)
    return s;
  throw new TypeError(`${l} must be a positive integer`);
}
function sb(s) {
  const { channels: l = 4, depth: a = 8 } = s;
  if (l !== 4 && l !== 3 && l !== 2 && l !== 1)
    throw new RangeError(`unsupported number of channels: ${l}`);
  if (a !== 8 && a !== 16)
    throw new RangeError(`unsupported bit depth: ${a}`);
  const m = { channels: l, depth: a, colorType: Kl.UNKNOWN };
  switch (l) {
    case 4:
      m.colorType = Kl.TRUECOLOUR_ALPHA;
      break;
    case 3:
      m.colorType = Kl.TRUECOLOUR;
      break;
    case 1:
      m.colorType = Kl.GREYSCALE;
      break;
    case 2:
      m.colorType = Kl.GREYSCALE_ALPHA;
      break;
    default:
      throw new Error("unsupported number of channels");
  }
  return m;
}
function ab(s, l, a, m) {
  for (let y = 0; y < a; y++)
    l.writeByte(s[m++]);
  return m;
}
function ob(s, l, a, m) {
  for (let y = 0; y < a; y++)
    l.writeUint16(s[m++]);
  return m;
}
var Bg;
(function(s) {
  s[s.UNKNOWN = 0] = "UNKNOWN", s[s.METRE = 1] = "METRE";
})(Bg || (Bg = {}));
function lb(s, l) {
  return new nb(s, l).encode();
}
function ub(s, l, a) {
  let m = (s << 16) + (l << 8) + a, y = 0;
  m < 8388608 ? y = m * 0.01 : m > 8388608 && (y = (m - Math.pow(2, 24)) * 0.01), m = Math.floor((y + 1e4) / 0.1);
  const _ = (m & 16711680) >> 16, g = (m & 65280) >> 8, o = m & 255;
  return [_, g, o];
}
function cb(s) {
  return new Promise((l, a) => {
    const m = new Image();
    m.crossOrigin = "", m.onload = () => {
      const y = document.createElement("canvas");
      y.width = m.width, y.height = m.height;
      const _ = y.getContext("2d", {
        willReadFrequently: !0
      });
      _.fillStyle = "rgb(128,0,0)", _.fillRect(0, 0, y.width, y.height), _.drawImage(m, 0, 0);
      const g = _.getImageData(0, 0, y.width, y.height);
      for (let k = 0; k < g.data.length / 4; k++) {
        const D = ub(g.data[k * 4], g.data[k * 4 + 1], g.data[k * 4 + 2]);
        g.data[k * 4] = D[0], g.data[k * 4 + 1] = D[1], g.data[k * 4 + 2] = D[2];
      }
      const o = lb(g);
      l(o);
    }, m.onerror = (y) => {
      a(y);
    }, m.src = s;
  });
}
const hb = (s, l = {}) => (s("gsidem", async (m, y) => {
  const _ = m.url.replace("gsidem://", "");
  return { data: await cb(_).catch((o) => {
    throw y.abort(), o.message;
  }) };
}), {
  type: "raster-dem",
  tiles: [`gsidem://${l.tileUrl ?? "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png"}`],
  tileSize: 256,
  minzoom: l.minzoom ?? 1,
  maxzoom: l.maxzoom ?? 14,
  attribution: l.attribution ?? '<a href="https://maps.gsi.go.jp/development/ichiran.html"></a>'
});
var db = Object.defineProperty, pb = (s, l, a) => l in s ? db(s, l, { enumerable: !0, configurable: !0, writable: !0, value: a }) : s[l] = a, Xi = (s, l, a) => pb(s, typeof l != "symbol" ? l + "" : l, a);
class fb {
  constructor(l) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "svgCanvas"), Xi(this, "xLine"), Xi(this, "yLine"), Xi(this, "color", "#535353"), this.map = l, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var l, a;
    this.width = (l = this.map) == null ? void 0 : l.getCanvas().clientWidth, this.height = (a = this.map) == null ? void 0 : a.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const l = this.width / 2, a = this.height / 2;
      this.yLine.setAttribute("x1", `${l}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${l}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${a}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${a}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(l) {
    if (this.width !== void 0 && this.height !== void 0) {
      const a = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      a.style.position = "relative", a.setAttribute("width", `${this.width}px`), a.setAttribute("height", `${this.height}px`);
      const m = this.width / 2, y = this.height / 2;
      this.yLine = a.appendChild(
        this.createLine(m, 0, m, this.height, this.color, "2px")
      ), this.xLine = a.appendChild(
        this.createLine(0, y, this.width, y, this.color, "2px")
      ), l == null || l.appendChild(a), this.svgCanvas = a;
    }
  }
  createLine(l, a, m, y, _, g) {
    const o = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return o.setAttribute("x1", l), o.setAttribute("y1", a), o.setAttribute("x2", m), o.setAttribute("y2", y), o.setAttribute("stroke-dasharray", "5,5"), o.setAttribute("stroke", _), o.setAttribute("stroke-width", g), o;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Wp = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, Dl = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, lh = {
  Landscape: "landscape",
  Portrait: "portrait"
}, Nu = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, Ec = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class mb {
  constructor(l) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "unit"), Xi(this, "svgCanvas"), Xi(this, "svgPath");
    var a, m, y;
    if (this.map = l, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const _ = (a = this.map) == null ? void 0 : a.getCanvas().clientWidth, g = (m = this.map) == null ? void 0 : m.getCanvas().clientHeight, o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.setAttribute("width", `${_}px`), o.setAttribute("height", `${g}px`);
    const k = document.createElementNS("http://www.w3.org/2000/svg", "path");
    k.setAttribute("style", "fill:#888888;stroke-width:0"), k.setAttribute("fill-opacity", "0.5"), o.append(k), (y = this.map) == null || y.getCanvasContainer().appendChild(o), this.svgCanvas = o, this.svgPath = k;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(l, a) {
    this.width = l, this.height = a, this.unit = Ec.mm, this.generateCutOut();
  }
  generateCutOut() {
    var l, a;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const m = this.toPixels(this.width), y = this.toPixels(this.height), _ = (l = this.map) == null ? void 0 : l.getCanvas().clientWidth, g = (a = this.map) == null ? void 0 : a.getCanvas().clientHeight, o = _ / 2 - m / 2, k = o + m, D = g / 2 - y / 2, L = D + y;
    this.svgCanvas.setAttribute("width", `${_}px`), this.svgCanvas.setAttribute("height", `${g}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${_} 0 L ${_} ${g} L 0 ${g} M ${o} ${D} L ${o} ${L} L ${k} ${L} L ${k} ${D}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(l, a = 96) {
    return this.unit === Ec.mm && (a /= 25.4), a * l;
  }
}
const e1 = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, gb = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Gnrer",
  LanguageName: "Franais",
  LanguageCode: "fr"
}, _b = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, yb = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflsung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, vb = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, bb = {
  PageSize: "Tamao de pgina",
  PageOrientation: "Orientacin de pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Espaola",
  LanguageCode: "es"
}, xb = {
  PageSize: "Mida",
  PageOrientation: "Orientaci",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, wb = {
  PageSize: "Kch thc trang",
  PageOrientation: "Loi trang",
  Format: "nh dng",
  DPI: "Mt  im nh (DPI)",
  Generate: "To",
  LanguageName: "Ting Vit",
  LanguageCode: "vi"
}, Ab = {
  PageSize: " ",
  PageOrientation: " ",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "uk"
}, Sb = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHans"
}, Eb = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHant"
}, Cb = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "ja"
}, Tb = {
  PageSize: "Tamanho da pgina",
  PageOrientation: "Orientao da pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Portugus",
  LanguageCode: "pt"
}, kb = [
  e1,
  gb,
  _b,
  yb,
  vb,
  bb,
  xb,
  wb,
  Ab,
  Sb,
  Eb,
  Cb,
  Tb
], Db = (s) => kb.find((l) => l.LanguageCode === s) ?? e1;
(function(s) {
  var l = {};
  function a(m) {
    if (l[m]) return l[m].exports;
    var y = l[m] = { i: m, l: !1, exports: {} };
    return s[m].call(y.exports, y, y.exports, a), y.l = !0, y.exports;
  }
  a.m = s, a.c = l, a.d = function(m, y, _) {
    a.o(m, y) || Object.defineProperty(m, y, { enumerable: !0, get: _ });
  }, a.r = function(m) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(m, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(m, "__esModule", { value: !0 });
  }, a.t = function(m, y) {
    if (1 & y && (m = a(m)), 8 & y || 4 & y && typeof m == "object" && m && m.__esModule) return m;
    var _ = /* @__PURE__ */ Object.create(null);
    if (a.r(_), Object.defineProperty(_, "default", { enumerable: !0, value: m }), 2 & y && typeof m != "string") for (var g in m) a.d(_, g, (function(o) {
      return m[o];
    }).bind(null, g));
    return _;
  }, a.n = function(m) {
    var y = m && m.__esModule ? function() {
      return m.default;
    } : function() {
      return m;
    };
    return a.d(y, "a", y), y;
  }, a.o = function(m, y) {
    return Object.prototype.hasOwnProperty.call(m, y);
  }, a.p = "", a(a.s = 0);
})([function(s, l, a) {
  s.exports = a(1);
}, function(s, l) {
  function a(y, _) {
    for (var g = 0; g < _.length; g++) {
      var o = _[g];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(y, o.key, o);
    }
  }
  var m = function() {
    function y() {
      (function(o, k) {
        if (!(o instanceof k)) throw new TypeError("Cannot call a class as a function");
      })(this, y), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var _, g;
    return _ = y, (g = [{ key: "show", value: function(o) {
      this.setOptions(o), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var o = document.getElementById("loading-overlay-stylesheet");
      o && (o.disabled = !0, o.parentNode.removeChild(o), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(o) {
      if (o !== void 0) for (var k in o) this.options[k] = o[k];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var o = "50%";
      this.options.offsetX !== 0 && (o = "calc(50% + " + this.options.offsetX + ")");
      var k = "50%";
      if (this.options.offsetY !== 0 && (k = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var D = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(k, "; left: ").concat(o, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), L = document.getElementById(this.options.containerID);
        return L.style.position = "relative", void L.insertAdjacentHTML("beforeend", D);
      }
      var j = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(k, "; left: ").concat(o, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", j);
    } }, { key: "generateSpinnerElement", value: function() {
      var o = this, k = Object.keys(this.numberOfEmptyDivForSpinner).find(function(L) {
        return L === o.options.spinnerIcon;
      }), D = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[k]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(D, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var o = document.createElement("link");
      o.setAttribute("id", "loading-overlay-stylesheet"), o.setAttribute("rel", "stylesheet"), o.setAttribute("type", "text/css"), o.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(o);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(o) {
      for (var k = "", D = 1; D <= o; D++) k += "<div></div>";
      return k;
    } }]) && a(_.prototype, g), y;
  }();
  window.JsLoadingOverlay = new m(), s.exports = JsLoadingOverlay;
}]);
function ur(s) {
  "@babel/helpers - typeof";
  return ur = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
    return typeof l;
  } : function(l) {
    return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
  }, ur(s);
}
var js = Uint8Array, ws = Uint16Array, wh = Uint32Array, bd = new js([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), xd = new js([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Xp = new js([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), t1 = function(s, l) {
  for (var a = new ws(31), m = 0; m < 31; ++m)
    a[m] = l += 1 << s[m - 1];
  for (var y = new wh(a[30]), m = 1; m < 30; ++m)
    for (var _ = a[m]; _ < a[m + 1]; ++_)
      y[_] = _ - a[m] << 5 | m;
  return [a, y];
}, i1 = t1(bd, 2), r1 = i1[0], Yp = i1[1];
r1[28] = 258, Yp[258] = 28;
var n1 = t1(xd, 0), Ib = n1[0], Rg = n1[1], Jp = new ws(32768);
for (var Ir = 0; Ir < 32768; ++Ir) {
  var Xl = (Ir & 43690) >>> 1 | (Ir & 21845) << 1;
  Xl = (Xl & 52428) >>> 2 | (Xl & 13107) << 2, Xl = (Xl & 61680) >>> 4 | (Xl & 3855) << 4, Jp[Ir] = ((Xl & 65280) >>> 8 | (Xl & 255) << 8) >>> 1;
}
var Wo = function(s, l, a) {
  for (var m = s.length, y = 0, _ = new ws(l); y < m; ++y)
    ++_[s[y] - 1];
  var g = new ws(l);
  for (y = 0; y < l; ++y)
    g[y] = g[y - 1] + _[y - 1] << 1;
  var o;
  if (a) {
    o = new ws(1 << l);
    var k = 15 - l;
    for (y = 0; y < m; ++y)
      if (s[y])
        for (var D = y << 4 | s[y], L = l - s[y], j = g[s[y] - 1]++ << L, O = j | (1 << L) - 1; j <= O; ++j)
          o[Jp[j] >>> k] = D;
  } else
    for (o = new ws(m), y = 0; y < m; ++y)
      o[y] = Jp[g[s[y] - 1]++] >>> 15 - s[y];
  return o;
}, nu = new js(288);
for (var Ir = 0; Ir < 144; ++Ir)
  nu[Ir] = 8;
for (var Ir = 144; Ir < 256; ++Ir)
  nu[Ir] = 9;
for (var Ir = 256; Ir < 280; ++Ir)
  nu[Ir] = 7;
for (var Ir = 280; Ir < 288; ++Ir)
  nu[Ir] = 8;
var Ah = new js(32);
for (var Ir = 0; Ir < 32; ++Ir)
  Ah[Ir] = 5;
var Pb = /* @__PURE__ */ Wo(nu, 9, 0), Lb = /* @__PURE__ */ Wo(nu, 9, 1), Mb = /* @__PURE__ */ Wo(Ah, 5, 0), Nb = /* @__PURE__ */ Wo(Ah, 5, 1), Ep = function(s) {
  for (var l = s[0], a = 1; a < s.length; ++a)
    s[a] > l && (l = s[a]);
  return l;
}, Qa = function(s, l, a) {
  var m = l / 8 >> 0;
  return (s[m] | s[m + 1] << 8) >>> (l & 7) & a;
}, Cp = function(s, l) {
  var a = l / 8 >> 0;
  return (s[a] | s[a + 1] << 8 | s[a + 2] << 16) >>> (l & 7);
}, gf = function(s) {
  return (s / 8 >> 0) + (s & 7 && 1);
}, s1 = function(s, l, a) {
  (a == null || a > s.length) && (a = s.length);
  var m = new (s instanceof ws ? ws : s instanceof wh ? wh : js)(a - l);
  return m.set(s.subarray(l, a)), m;
}, zb = function(s, l, a) {
  var m = s.length, y = !l || a, _ = !a || a.i;
  a || (a = {}), l || (l = new js(m * 3));
  var g = function(Oe) {
    var $e = l.length;
    if (Oe > $e) {
      var Ue = new js(Math.max($e * 2, Oe));
      Ue.set(l), l = Ue;
    }
  }, o = a.f || 0, k = a.p || 0, D = a.b || 0, L = a.l, j = a.d, O = a.m, z = a.n, pe = m * 8;
  do {
    if (!L) {
      a.f = o = Qa(s, k, 1);
      var oe = Qa(s, k + 1, 3);
      if (k += 3, oe)
        if (oe == 1)
          L = Lb, j = Nb, O = 9, z = 5;
        else if (oe == 2) {
          var ae = Qa(s, k, 31) + 257, Q = Qa(s, k + 10, 15) + 4, fe = ae + Qa(s, k + 5, 31) + 1;
          k += 14;
          for (var Ce = new js(fe), ze = new js(19), je = 0; je < Q; ++je)
            ze[Xp[je]] = Qa(s, k + je * 3, 7);
          k += Q * 3;
          var Qe = Ep(ze), ke = (1 << Qe) - 1;
          if (!_ && k + fe * (Qe + 7) > pe)
            break;
          for (var Ae = Wo(ze, Qe, 1), je = 0; je < fe; ) {
            var me = Ae[Qa(s, k, ke)];
            k += me & 15;
            var ve = me >>> 4;
            if (ve < 16)
              Ce[je++] = ve;
            else {
              var X = 0, re = 0;
              for (ve == 16 ? (re = 3 + Qa(s, k, 3), k += 2, X = Ce[je - 1]) : ve == 17 ? (re = 3 + Qa(s, k, 7), k += 3) : ve == 18 && (re = 11 + Qa(s, k, 127), k += 7); re--; )
                Ce[je++] = X;
            }
          }
          var xe = Ce.subarray(0, ae), ye = Ce.subarray(ae);
          O = Ep(xe), z = Ep(ye), L = Wo(xe, O, 1), j = Wo(ye, z, 1);
        } else
          throw "invalid block type";
      else {
        var ve = gf(k) + 4, Ve = s[ve - 4] | s[ve - 3] << 8, He = ve + Ve;
        if (He > m) {
          if (_)
            throw "unexpected EOF";
          break;
        }
        y && g(D + Ve), l.set(s.subarray(ve, He), D), a.b = D += Ve, a.p = k = He * 8;
        continue;
      }
      if (k > pe)
        throw "unexpected EOF";
    }
    y && g(D + 131072);
    for (var Ze = (1 << O) - 1, qe = (1 << z) - 1, Je = O + z + 18; _ || k + Je < pe; ) {
      var X = L[Cp(s, k) & Ze], et = X >>> 4;
      if (k += X & 15, k > pe)
        throw "unexpected EOF";
      if (!X)
        throw "invalid length/literal";
      if (et < 256)
        l[D++] = et;
      else if (et == 256) {
        L = null;
        break;
      } else {
        var st = et - 254;
        if (et > 264) {
          var je = et - 257, ee = bd[je];
          st = Qa(s, k, (1 << ee) - 1) + r1[je], k += ee;
        }
        var _e = j[Cp(s, k) & qe], be = _e >>> 4;
        if (!_e)
          throw "invalid distance";
        k += _e & 15;
        var ye = Ib[be];
        if (be > 3) {
          var ee = xd[be];
          ye += Cp(s, k) & (1 << ee) - 1, k += ee;
        }
        if (k > pe)
          throw "unexpected EOF";
        y && g(D + 131072);
        for (var Te = D + st; D < Te; D += 4)
          l[D] = l[D - ye], l[D + 1] = l[D + 1 - ye], l[D + 2] = l[D + 2 - ye], l[D + 3] = l[D + 3 - ye];
        D = Te;
      }
    }
    a.l = L, a.p = k, a.b = D, L && (o = 1, a.m = O, a.d = j, a.n = z);
  } while (!o);
  return D == l.length ? l : s1(l, 0, D);
}, El = function(s, l, a) {
  a <<= l & 7;
  var m = l / 8 >> 0;
  s[m] |= a, s[m + 1] |= a >>> 8;
}, ih = function(s, l, a) {
  a <<= l & 7;
  var m = l / 8 >> 0;
  s[m] |= a, s[m + 1] |= a >>> 8, s[m + 2] |= a >>> 16;
}, Tp = function(s, l) {
  for (var a = [], m = 0; m < s.length; ++m)
    s[m] && a.push({ s: m, f: s[m] });
  var y = a.length, _ = a.slice();
  if (!y)
    return [new js(0), 0];
  if (y == 1) {
    var g = new js(a[0].s + 1);
    return g[a[0].s] = 1, [g, 1];
  }
  a.sort(function(je, Qe) {
    return je.f - Qe.f;
  }), a.push({ s: -1, f: 25001 });
  var o = a[0], k = a[1], D = 0, L = 1, j = 2;
  for (a[0] = { s: -1, f: o.f + k.f, l: o, r: k }; L != y - 1; )
    o = a[a[D].f < a[j].f ? D++ : j++], k = a[D != L && a[D].f < a[j].f ? D++ : j++], a[L++] = { s: -1, f: o.f + k.f, l: o, r: k };
  for (var O = _[0].s, m = 1; m < y; ++m)
    _[m].s > O && (O = _[m].s);
  var z = new ws(O + 1), pe = Kp(a[L - 1], z, 0);
  if (pe > l) {
    var m = 0, oe = 0, ae = pe - l, Q = 1 << ae;
    for (_.sort(function(Qe, ke) {
      return z[ke.s] - z[Qe.s] || Qe.f - ke.f;
    }); m < y; ++m) {
      var fe = _[m].s;
      if (z[fe] > l)
        oe += Q - (1 << pe - z[fe]), z[fe] = l;
      else
        break;
    }
    for (oe >>>= ae; oe > 0; ) {
      var Ce = _[m].s;
      z[Ce] < l ? oe -= 1 << l - z[Ce]++ - 1 : ++m;
    }
    for (; m >= 0 && oe; --m) {
      var ze = _[m].s;
      z[ze] == l && (--z[ze], ++oe);
    }
    pe = l;
  }
  return [new js(z), pe];
}, Kp = function(s, l, a) {
  return s.s == -1 ? Math.max(Kp(s.l, l, a + 1), Kp(s.r, l, a + 1)) : l[s.s] = a;
}, Og = function(s) {
  for (var l = s.length; l && !s[--l]; )
    ;
  for (var a = new ws(++l), m = 0, y = s[0], _ = 1, g = function(k) {
    a[m++] = k;
  }, o = 1; o <= l; ++o)
    if (s[o] == y && o != l)
      ++_;
    else {
      if (!y && _ > 2) {
        for (; _ > 138; _ -= 138)
          g(32754);
        _ > 2 && (g(_ > 10 ? _ - 11 << 5 | 28690 : _ - 3 << 5 | 12305), _ = 0);
      } else if (_ > 3) {
        for (g(y), --_; _ > 6; _ -= 6)
          g(8304);
        _ > 2 && (g(_ - 3 << 5 | 8208), _ = 0);
      }
      for (; _--; )
        g(y);
      _ = 1, y = s[o];
    }
  return [a.subarray(0, m), l];
}, rh = function(s, l) {
  for (var a = 0, m = 0; m < l.length; ++m)
    a += s[m] * l[m];
  return a;
}, Qp = function(s, l, a) {
  var m = a.length, y = gf(l + 2);
  s[y] = m & 255, s[y + 1] = m >>> 8, s[y + 2] = s[y] ^ 255, s[y + 3] = s[y + 1] ^ 255;
  for (var _ = 0; _ < m; ++_)
    s[y + _ + 4] = a[_];
  return (y + 4 + m) * 8;
}, jg = function(s, l, a, m, y, _, g, o, k, D, L) {
  El(l, L++, a), ++y[256];
  for (var j = Tp(y, 15), O = j[0], z = j[1], pe = Tp(_, 15), oe = pe[0], ae = pe[1], Q = Og(O), fe = Q[0], Ce = Q[1], ze = Og(oe), je = ze[0], Qe = ze[1], ke = new ws(19), Ae = 0; Ae < fe.length; ++Ae)
    ke[fe[Ae] & 31]++;
  for (var Ae = 0; Ae < je.length; ++Ae)
    ke[je[Ae] & 31]++;
  for (var me = Tp(ke, 7), ve = me[0], X = me[1], re = 19; re > 4 && !ve[Xp[re - 1]]; --re)
    ;
  var xe = D + 5 << 3, ye = rh(y, nu) + rh(_, Ah) + g, Ve = rh(y, O) + rh(_, oe) + g + 14 + 3 * re + rh(ke, ve) + (2 * ke[16] + 3 * ke[17] + 7 * ke[18]);
  if (xe <= ye && xe <= Ve)
    return Qp(l, L, s.subarray(k, k + D));
  var He, Ze, qe, Je;
  if (El(l, L, 1 + (Ve < ye)), L += 2, Ve < ye) {
    He = Wo(O, z, 0), Ze = O, qe = Wo(oe, ae, 0), Je = oe;
    var et = Wo(ve, X, 0);
    El(l, L, Ce - 257), El(l, L + 5, Qe - 1), El(l, L + 10, re - 4), L += 14;
    for (var Ae = 0; Ae < re; ++Ae)
      El(l, L + 3 * Ae, ve[Xp[Ae]]);
    L += 3 * re;
    for (var st = [fe, je], ee = 0; ee < 2; ++ee)
      for (var _e = st[ee], Ae = 0; Ae < _e.length; ++Ae) {
        var be = _e[Ae] & 31;
        El(l, L, et[be]), L += ve[be], be > 15 && (El(l, L, _e[Ae] >>> 5 & 127), L += _e[Ae] >>> 12);
      }
  } else
    He = Pb, Ze = nu, qe = Mb, Je = Ah;
  for (var Ae = 0; Ae < o; ++Ae)
    if (m[Ae] > 255) {
      var be = m[Ae] >>> 18 & 31;
      ih(l, L, He[be + 257]), L += Ze[be + 257], be > 7 && (El(l, L, m[Ae] >>> 23 & 31), L += bd[be]);
      var Te = m[Ae] & 31;
      ih(l, L, qe[Te]), L += Je[Te], Te > 3 && (ih(l, L, m[Ae] >>> 5 & 8191), L += xd[Te]);
    } else
      ih(l, L, He[m[Ae]]), L += Ze[m[Ae]];
  return ih(l, L, He[256]), L + Ze[256];
}, Fb = /* @__PURE__ */ new wh([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Bb = function(s, l, a, m, y, _) {
  var g = s.length, o = new js(m + g + 5 * (1 + Math.floor(g / 7e3)) + y), k = o.subarray(m, o.length - y), D = 0;
  if (!l || g < 8)
    for (var L = 0; L <= g; L += 65535) {
      var j = L + 65535;
      j < g ? D = Qp(k, D, s.subarray(L, j)) : (k[L] = _, D = Qp(k, D, s.subarray(L, g)));
    }
  else {
    for (var O = Fb[l - 1], z = O >>> 13, pe = O & 8191, oe = (1 << a) - 1, ae = new ws(32768), Q = new ws(oe + 1), fe = Math.ceil(a / 3), Ce = 2 * fe, ze = function(Pt) {
      return (s[Pt] ^ s[Pt + 1] << fe ^ s[Pt + 2] << Ce) & oe;
    }, je = new wh(25e3), Qe = new ws(288), ke = new ws(32), Ae = 0, me = 0, L = 0, ve = 0, X = 0, re = 0; L < g; ++L) {
      var xe = ze(L), ye = L & 32767, Ve = Q[xe];
      if (ae[ye] = Ve, Q[xe] = ye, X <= L) {
        var He = g - L;
        if ((Ae > 7e3 || ve > 24576) && He > 423) {
          D = jg(s, k, 0, je, Qe, ke, me, ve, re, L - re, D), ve = Ae = me = 0, re = L;
          for (var Ze = 0; Ze < 286; ++Ze)
            Qe[Ze] = 0;
          for (var Ze = 0; Ze < 30; ++Ze)
            ke[Ze] = 0;
        }
        var qe = 2, Je = 0, et = pe, st = ye - Ve & 32767;
        if (He > 2 && xe == ze(L - st))
          for (var ee = Math.min(z, He) - 1, _e = Math.min(32767, L), be = Math.min(258, He); st <= _e && --et && ye != Ve; ) {
            if (s[L + qe] == s[L + qe - st]) {
              for (var Te = 0; Te < be && s[L + Te] == s[L + Te - st]; ++Te)
                ;
              if (Te > qe) {
                if (qe = Te, Je = st, Te > ee)
                  break;
                for (var Oe = Math.min(st, Te - 2), $e = 0, Ze = 0; Ze < Oe; ++Ze) {
                  var Ue = L - st + Ze + 32768 & 32767, Ke = ae[Ue], nt = Ue - Ke + 32768 & 32767;
                  nt > $e && ($e = nt, Ve = Ue);
                }
              }
            }
            ye = Ve, Ve = ae[ye], st += ye - Ve + 32768 & 32767;
          }
        if (Je) {
          je[ve++] = 268435456 | Yp[qe] << 18 | Rg[Je];
          var ot = Yp[qe] & 31, vt = Rg[Je] & 31;
          me += bd[ot] + xd[vt], ++Qe[257 + ot], ++ke[vt], X = L + qe, ++Ae;
        } else
          je[ve++] = s[L], ++Qe[s[L]];
      }
    }
    D = jg(s, k, _, je, Qe, ke, me, ve, re, L - re, D);
  }
  return s1(o, 0, m + gf(D) + y);
}, Rb = function() {
  var s = 1, l = 0;
  return {
    p: function(a) {
      for (var m = s, y = l, _ = a.length, g = 0; g != _; ) {
        for (var o = Math.min(g + 5552, _); g < o; ++g)
          m += a[g], y += m;
        m %= 65521, y %= 65521;
      }
      s = m, l = y;
    },
    d: function() {
      return (s >>> 8 << 16 | (l & 255) << 8 | l >>> 8) + ((s & 255) << 23) * 2;
    }
  };
}, Ob = function(s, l, a, m, y) {
  return Bb(s, l.level == null ? 6 : l.level, l.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(s.length))) * 1.5) : 12 + l.mem, a, m, !y);
}, jb = function(s, l, a) {
  for (; a; ++l)
    s[l] = a, a >>>= 8;
}, qb = function(s, l) {
  var a = l.level, m = a == 0 ? 0 : a < 6 ? 1 : a == 9 ? 3 : 2;
  s[0] = 120, s[1] = m << 6 | (m ? 32 - 2 * m : 1);
}, Ub = function(s) {
  if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || (s[0] << 8 | s[1]) % 31)
    throw "invalid zlib data";
  if (s[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function ef(s, l) {
  l === void 0 && (l = {});
  var a = Rb();
  a.p(s);
  var m = Ob(s, l, 2, 4);
  return qb(m, l), jb(m, m.length - 4, a.d()), m;
}
function Vb(s, l) {
  return zb((Ub(s), s.subarray(2, -4)), l);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var Ai = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function kp() {
  Ai.console && typeof Ai.console.log == "function" && Ai.console.log.apply(Ai.console, arguments);
}
var vr = { log: kp, warn: function(s) {
  Ai.console && (typeof Ai.console.warn == "function" ? Ai.console.warn.apply(Ai.console, arguments) : kp.call(null, arguments));
}, error: function(s) {
  Ai.console && (typeof Ai.console.error == "function" ? Ai.console.error.apply(Ai.console, arguments) : kp(s));
} };
function Dp(s, l, a) {
  var m = new XMLHttpRequest();
  m.open("GET", s), m.responseType = "blob", m.onload = function() {
    Du(m.response, l, a);
  }, m.onerror = function() {
    vr.error("could not download file");
  }, m.send();
}
function qg(s) {
  var l = new XMLHttpRequest();
  l.open("HEAD", s, !1);
  try {
    l.send();
  } catch {
  }
  return l.status >= 200 && l.status <= 299;
}
function Kh(s) {
  try {
    s.dispatchEvent(new MouseEvent("click"));
  } catch {
    var l = document.createEvent("MouseEvents");
    l.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), s.dispatchEvent(l);
  }
}
var ph, tf, Du = Ai.saveAs || ((typeof window > "u" ? "undefined" : ur(window)) !== "object" || window !== Ai ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(s, l, a) {
  var m = Ai.URL || Ai.webkitURL, y = document.createElement("a");
  l = l || s.name || "download", y.download = l, y.rel = "noopener", typeof s == "string" ? (y.href = s, y.origin !== location.origin ? qg(y.href) ? Dp(s, l, a) : Kh(y, y.target = "_blank") : Kh(y)) : (y.href = m.createObjectURL(s), setTimeout(function() {
    m.revokeObjectURL(y.href);
  }, 4e4), setTimeout(function() {
    Kh(y);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(s, l, a) {
  if (l = l || s.name || "download", typeof s == "string") if (qg(s)) Dp(s, l, a);
  else {
    var m = document.createElement("a");
    m.href = s, m.target = "_blank", setTimeout(function() {
      Kh(m);
    });
  }
  else navigator.msSaveOrOpenBlob(function(y, _) {
    return _ === void 0 ? _ = { autoBom: !1 } : ur(_) !== "object" && (vr.warn("Deprecated: Expected third argument to be a object"), _ = { autoBom: !_ }), _.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(y.type) ? new Blob(["\uFEFF", y], { type: y.type }) : y;
  }(s, a), l);
} : function(s, l, a, m) {
  if ((m = m || open("", "_blank")) && (m.document.title = m.document.body.innerText = "downloading..."), typeof s == "string") return Dp(s, l, a);
  var y = s.type === "application/octet-stream", _ = /constructor/i.test(Ai.HTMLElement) || Ai.safari, g = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((g || y && _) && (typeof FileReader > "u" ? "undefined" : ur(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var L = o.result;
      L = g ? L : L.replace(/^data:[^;]*;/, "data:attachment/file;"), m ? m.location.href = L : location = L, m = null;
    }, o.readAsDataURL(s);
  } else {
    var k = Ai.URL || Ai.webkitURL, D = k.createObjectURL(s);
    m ? m.location = D : location.href = D, m = null, setTimeout(function() {
      k.revokeObjectURL(D);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function a1(s) {
  var l;
  s = s || "", this.ok = !1, s.charAt(0) == "#" && (s = s.substr(1, 6)), s = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[s = (s = s.replace(/ /g, "")).toLowerCase()] || s;
  for (var a = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], m = 0; m < a.length; m++) {
    var y = a[m].re, _ = a[m].process, g = y.exec(s);
    g && (l = _(g), this.r = l[0], this.g = l[1], this.b = l[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), k = this.g.toString(16), D = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), k.length == 1 && (k = "0" + k), D.length == 1 && (D = "0" + D), "#" + o + k + D;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ip(s, l) {
  var a = s[0], m = s[1], y = s[2], _ = s[3];
  a = ts(a, m, y, _, l[0], 7, -680876936), _ = ts(_, a, m, y, l[1], 12, -389564586), y = ts(y, _, a, m, l[2], 17, 606105819), m = ts(m, y, _, a, l[3], 22, -1044525330), a = ts(a, m, y, _, l[4], 7, -176418897), _ = ts(_, a, m, y, l[5], 12, 1200080426), y = ts(y, _, a, m, l[6], 17, -1473231341), m = ts(m, y, _, a, l[7], 22, -45705983), a = ts(a, m, y, _, l[8], 7, 1770035416), _ = ts(_, a, m, y, l[9], 12, -1958414417), y = ts(y, _, a, m, l[10], 17, -42063), m = ts(m, y, _, a, l[11], 22, -1990404162), a = ts(a, m, y, _, l[12], 7, 1804603682), _ = ts(_, a, m, y, l[13], 12, -40341101), y = ts(y, _, a, m, l[14], 17, -1502002290), a = is(a, m = ts(m, y, _, a, l[15], 22, 1236535329), y, _, l[1], 5, -165796510), _ = is(_, a, m, y, l[6], 9, -1069501632), y = is(y, _, a, m, l[11], 14, 643717713), m = is(m, y, _, a, l[0], 20, -373897302), a = is(a, m, y, _, l[5], 5, -701558691), _ = is(_, a, m, y, l[10], 9, 38016083), y = is(y, _, a, m, l[15], 14, -660478335), m = is(m, y, _, a, l[4], 20, -405537848), a = is(a, m, y, _, l[9], 5, 568446438), _ = is(_, a, m, y, l[14], 9, -1019803690), y = is(y, _, a, m, l[3], 14, -187363961), m = is(m, y, _, a, l[8], 20, 1163531501), a = is(a, m, y, _, l[13], 5, -1444681467), _ = is(_, a, m, y, l[2], 9, -51403784), y = is(y, _, a, m, l[7], 14, 1735328473), a = rs(a, m = is(m, y, _, a, l[12], 20, -1926607734), y, _, l[5], 4, -378558), _ = rs(_, a, m, y, l[8], 11, -2022574463), y = rs(y, _, a, m, l[11], 16, 1839030562), m = rs(m, y, _, a, l[14], 23, -35309556), a = rs(a, m, y, _, l[1], 4, -1530992060), _ = rs(_, a, m, y, l[4], 11, 1272893353), y = rs(y, _, a, m, l[7], 16, -155497632), m = rs(m, y, _, a, l[10], 23, -1094730640), a = rs(a, m, y, _, l[13], 4, 681279174), _ = rs(_, a, m, y, l[0], 11, -358537222), y = rs(y, _, a, m, l[3], 16, -722521979), m = rs(m, y, _, a, l[6], 23, 76029189), a = rs(a, m, y, _, l[9], 4, -640364487), _ = rs(_, a, m, y, l[12], 11, -421815835), y = rs(y, _, a, m, l[15], 16, 530742520), a = ns(a, m = rs(m, y, _, a, l[2], 23, -995338651), y, _, l[0], 6, -198630844), _ = ns(_, a, m, y, l[7], 10, 1126891415), y = ns(y, _, a, m, l[14], 15, -1416354905), m = ns(m, y, _, a, l[5], 21, -57434055), a = ns(a, m, y, _, l[12], 6, 1700485571), _ = ns(_, a, m, y, l[3], 10, -1894986606), y = ns(y, _, a, m, l[10], 15, -1051523), m = ns(m, y, _, a, l[1], 21, -2054922799), a = ns(a, m, y, _, l[8], 6, 1873313359), _ = ns(_, a, m, y, l[15], 10, -30611744), y = ns(y, _, a, m, l[6], 15, -1560198380), m = ns(m, y, _, a, l[13], 21, 1309151649), a = ns(a, m, y, _, l[4], 6, -145523070), _ = ns(_, a, m, y, l[11], 10, -1120210379), y = ns(y, _, a, m, l[2], 15, 718787259), m = ns(m, y, _, a, l[9], 21, -343485551), s[0] = eu(a, s[0]), s[1] = eu(m, s[1]), s[2] = eu(y, s[2]), s[3] = eu(_, s[3]);
}
function wd(s, l, a, m, y, _) {
  return l = eu(eu(l, s), eu(m, _)), eu(l << y | l >>> 32 - y, a);
}
function ts(s, l, a, m, y, _, g) {
  return wd(l & a | ~l & m, s, l, y, _, g);
}
function is(s, l, a, m, y, _, g) {
  return wd(l & m | a & ~m, s, l, y, _, g);
}
function rs(s, l, a, m, y, _, g) {
  return wd(l ^ a ^ m, s, l, y, _, g);
}
function ns(s, l, a, m, y, _, g) {
  return wd(a ^ (l | ~m), s, l, y, _, g);
}
function o1(s) {
  var l, a = s.length, m = [1732584193, -271733879, -1732584194, 271733878];
  for (l = 64; l <= s.length; l += 64) Ip(m, $b(s.substring(l - 64, l)));
  s = s.substring(l - 64);
  var y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (l = 0; l < s.length; l++) y[l >> 2] |= s.charCodeAt(l) << (l % 4 << 3);
  if (y[l >> 2] |= 128 << (l % 4 << 3), l > 55) for (Ip(m, y), l = 0; l < 16; l++) y[l] = 0;
  return y[14] = 8 * a, Ip(m, y), m;
}
function $b(s) {
  var l, a = [];
  for (l = 0; l < 64; l += 4) a[l >> 2] = s.charCodeAt(l) + (s.charCodeAt(l + 1) << 8) + (s.charCodeAt(l + 2) << 16) + (s.charCodeAt(l + 3) << 24);
  return a;
}
ph = Ai.atob.bind(Ai), tf = Ai.btoa.bind(Ai);
var Ug = "0123456789abcdef".split("");
function Zb(s) {
  for (var l = "", a = 0; a < 4; a++) l += Ug[s >> 8 * a + 4 & 15] + Ug[s >> 8 * a & 15];
  return l;
}
function Gb(s) {
  return String.fromCharCode((255 & s) >> 0, (65280 & s) >> 8, (16711680 & s) >> 16, (4278190080 & s) >> 24);
}
function rf(s) {
  return o1(s).map(Gb).join("");
}
var Hb = function(s) {
  for (var l = 0; l < s.length; l++) s[l] = Zb(s[l]);
  return s.join("");
}(o1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function eu(s, l) {
  if (Hb) {
    var a = (65535 & s) + (65535 & l);
    return (s >> 16) + (l >> 16) + (a >> 16) << 16 | 65535 & a;
  }
  return s + l & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function nf(s, l) {
  var a, m, y, _;
  if (s !== a) {
    for (var g = (y = s, _ = 1 + (256 / s.length >> 0), new Array(_ + 1).join(y)), o = [], k = 0; k < 256; k++) o[k] = k;
    var D = 0;
    for (k = 0; k < 256; k++) {
      var L = o[k];
      D = (D + L + g.charCodeAt(k)) % 256, o[k] = o[D], o[D] = L;
    }
    a = s, m = o;
  } else o = m;
  var j = l.length, O = 0, z = 0, pe = "";
  for (k = 0; k < j; k++) z = (z + (L = o[O = (O + 1) % 256])) % 256, o[O] = o[z], o[z] = L, g = o[(o[O] + o[z]) % 256], pe += String.fromCharCode(l.charCodeAt(k) ^ g);
  return pe;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Vg = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function pc(s, l, a, m) {
  this.v = 1, this.r = 2;
  var y = 192;
  s.forEach(function(o) {
    if (Vg.perm !== void 0) throw new Error("Invalid permission: " + o);
    y += Vg[o];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var _ = (l + this.padding).substr(0, 32), g = (a + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(_, g), this.P = -(1 + (255 ^ y)), this.encryptionKey = rf(_ + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(m)).substr(0, 5), this.U = nf(this.encryptionKey, this.padding);
}
function fc(s) {
  if (/[^\u0000-\u00ff]/.test(s)) throw new Error("Invalid PDF Name Object: " + s + ", Only accept ASCII characters.");
  for (var l = "", a = s.length, m = 0; m < a; m++) {
    var y = s.charCodeAt(m);
    y < 33 || y === 35 || y === 37 || y === 40 || y === 41 || y === 47 || y === 60 || y === 62 || y === 91 || y === 93 || y === 123 || y === 125 || y > 126 ? l += "#" + ("0" + y.toString(16)).slice(-2) : l += s[m];
  }
  return l;
}
function $g(s) {
  if (ur(s) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var l = {};
  this.subscribe = function(a, m, y) {
    if (y = y || !1, typeof a != "string" || typeof m != "function" || typeof y != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    l.hasOwnProperty(a) || (l[a] = {});
    var _ = Math.random().toString(35);
    return l[a][_] = [m, !!y], _;
  }, this.unsubscribe = function(a) {
    for (var m in l) if (l[m][a]) return delete l[m][a], Object.keys(l[m]).length === 0 && delete l[m], !0;
    return !1;
  }, this.publish = function(a) {
    if (l.hasOwnProperty(a)) {
      var m = Array.prototype.slice.call(arguments, 1), y = [];
      for (var _ in l[a]) {
        var g = l[a][_];
        try {
          g[0].apply(s, m);
        } catch (o) {
          Ai.console && vr.error("jsPDF PubSub Error", o.message, o);
        }
        g[1] && y.push(_);
      }
      y.length && y.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return l;
  };
}
function pd(s) {
  if (!(this instanceof pd)) return new pd(s);
  var l = "opacity,stroke-opacity".split(",");
  for (var a in s) s.hasOwnProperty(a) && l.indexOf(a) >= 0 && (this[a] = s[a]);
  this.id = "", this.objectNumber = -1;
}
function l1(s, l) {
  this.gState = s, this.matrix = l, this.id = "", this.objectNumber = -1;
}
function Iu(s, l, a, m, y) {
  if (!(this instanceof Iu)) return new Iu(s, l, a, m, y);
  this.type = s === "axial" ? 2 : 3, this.coords = l, this.colors = a, l1.call(this, m, y);
}
function mc(s, l, a, m, y) {
  if (!(this instanceof mc)) return new mc(s, l, a, m, y);
  this.boundingBox = s, this.xStep = l, this.yStep = a, this.stream = "", this.cloneIndex = 0, l1.call(this, m, y);
}
function wi(s) {
  var l, a = typeof arguments[0] == "string" ? arguments[0] : "p", m = arguments[1], y = arguments[2], _ = arguments[3], g = [], o = 1, k = 16, D = "S", L = null;
  ur(s = s || {}) === "object" && (a = s.orientation, m = s.unit || m, y = s.format || y, _ = s.compress || s.compressPdf || _, (L = s.encryption || null) !== null && (L.userPassword = L.userPassword || "", L.ownerPassword = L.ownerPassword || "", L.userPermissions = L.userPermissions || []), o = typeof s.userUnit == "number" ? Math.abs(s.userUnit) : 1, s.precision !== void 0 && (l = s.precision), s.floatPrecision !== void 0 && (k = s.floatPrecision), D = s.defaultPathOperation || "S"), g = s.filters || (_ === !0 ? ["FlateEncode"] : g), m = m || "mm", a = ("" + (a || "P")).toLowerCase();
  var j = s.putOnlyUsedFonts || !1, O = {}, z = { internal: {}, __private__: {} };
  z.__private__.PubSub = $g;
  var pe = "1.3", oe = z.__private__.getPdfVersion = function() {
    return pe;
  };
  z.__private__.setPdfVersion = function(I) {
    pe = I;
  };
  var ae = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  z.__private__.getPageFormats = function() {
    return ae;
  };
  var Q = z.__private__.getPageFormat = function(I) {
    return ae[I];
  };
  y = y || "a4";
  var fe = { COMPAT: "compat", ADVANCED: "advanced" }, Ce = fe.COMPAT;
  function ze() {
    this.saveGraphicsState(), Y(new Ne(It, 0, 0, -It, 0, ma() * It).toString() + " cm"), this.setFontSize(this.getFontSize() / It), D = "n", Ce = fe.ADVANCED;
  }
  function je() {
    this.restoreGraphicsState(), D = "S", Ce = fe.COMPAT;
  }
  var Qe = z.__private__.combineFontStyleAndFontWeight = function(I, K) {
    if (I == "bold" && K == "normal" || I == "bold" && K == 400 || I == "normal" && K == "italic" || I == "bold" && K == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return K && (I = K == 400 || K === "normal" ? I === "italic" ? "italic" : "normal" : K != 700 && K !== "bold" || I !== "normal" ? (K == 700 ? "bold" : K) + "" + I : "bold"), I;
  };
  z.advancedAPI = function(I) {
    var K = Ce === fe.COMPAT;
    return K && ze.call(this), typeof I != "function" || (I(this), K && je.call(this)), this;
  }, z.compatAPI = function(I) {
    var K = Ce === fe.ADVANCED;
    return K && je.call(this), typeof I != "function" || (I(this), K && ze.call(this)), this;
  }, z.isAdvancedAPI = function() {
    return Ce === fe.ADVANCED;
  };
  var ke, Ae = function(I) {
    if (Ce !== fe.ADVANCED) throw new Error(I + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, me = z.roundToPrecision = z.__private__.roundToPrecision = function(I, K) {
    var Ee = l || K;
    if (isNaN(I) || isNaN(Ee)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return I.toFixed(Ee).replace(/0+$/, "");
  };
  ke = z.hpf = z.__private__.hpf = typeof k == "number" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, k);
  } : k === "smart" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, I > -1 && I < 1 ? 16 : 5);
  } : function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, 16);
  };
  var ve = z.f2 = z.__private__.f2 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f2");
    return me(I, 2);
  }, X = z.__private__.f3 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f3");
    return me(I, 3);
  }, re = z.scale = z.__private__.scale = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.scale");
    return Ce === fe.COMPAT ? I * It : Ce === fe.ADVANCED ? I : void 0;
  }, xe = function(I) {
    return Ce === fe.COMPAT ? ma() - I : Ce === fe.ADVANCED ? I : void 0;
  }, ye = function(I) {
    return re(xe(I));
  };
  z.__private__.setPrecision = z.setPrecision = function(I) {
    typeof parseInt(I, 10) == "number" && (l = parseInt(I, 10));
  };
  var Ve, He = "00000000000000000000000000000000", Ze = z.__private__.getFileId = function() {
    return He;
  }, qe = z.__private__.setFileId = function(I) {
    return He = I !== void 0 && /^[a-fA-F0-9]{32}$/.test(I) ? I.toUpperCase() : He.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), L !== null && (wr = new pc(L.userPermissions, L.userPassword, L.ownerPassword, He)), He;
  };
  z.setFileId = function(I) {
    return qe(I), this;
  }, z.getFileId = function() {
    return Ze();
  };
  var Je = z.__private__.convertDateToPDFDate = function(I) {
    var K = I.getTimezoneOffset(), Ee = K < 0 ? "+" : "-", Re = Math.floor(Math.abs(K / 60)), Ye = Math.abs(K % 60), ct = [Ee, be(Re), "'", be(Ye), "'"].join("");
    return ["D:", I.getFullYear(), be(I.getMonth() + 1), be(I.getDate()), be(I.getHours()), be(I.getMinutes()), be(I.getSeconds()), ct].join("");
  }, et = z.__private__.convertPDFDateToDate = function(I) {
    var K = parseInt(I.substr(2, 4), 10), Ee = parseInt(I.substr(6, 2), 10) - 1, Re = parseInt(I.substr(8, 2), 10), Ye = parseInt(I.substr(10, 2), 10), ct = parseInt(I.substr(12, 2), 10), Dt = parseInt(I.substr(14, 2), 10);
    return new Date(K, Ee, Re, Ye, ct, Dt, 0);
  }, st = z.__private__.setCreationDate = function(I) {
    var K;
    if (I === void 0 && (I = /* @__PURE__ */ new Date()), I instanceof Date) K = Je(I);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(I)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      K = I;
    }
    return Ve = K;
  }, ee = z.__private__.getCreationDate = function(I) {
    var K = Ve;
    return I === "jsDate" && (K = et(Ve)), K;
  };
  z.setCreationDate = function(I) {
    return st(I), this;
  }, z.getCreationDate = function(I) {
    return ee(I);
  };
  var _e, be = z.__private__.padd2 = function(I) {
    return ("0" + parseInt(I)).slice(-2);
  }, Te = z.__private__.padd2Hex = function(I) {
    return ("00" + (I = I.toString())).substr(I.length);
  }, Oe = 0, $e = [], Ue = [], Ke = 0, nt = [], ot = [], vt = !1, mt = Ue, Pt = function() {
    Oe = 0, Ke = 0, Ue = [], $e = [], nt = [], Qt = gt(), ei = gt();
  };
  z.__private__.setCustomOutputDestination = function(I) {
    vt = !0, mt = I;
  };
  var rt = function(I) {
    vt || (mt = I);
  };
  z.__private__.resetCustomOutputDestination = function() {
    vt = !1, mt = Ue;
  };
  var Y = z.__private__.out = function(I) {
    return I = I.toString(), Ke += I.length + 1, mt.push(I), mt;
  }, Kt = z.__private__.write = function(I) {
    return Y(arguments.length === 1 ? I.toString() : Array.prototype.join.call(arguments, " "));
  }, Rt = z.__private__.getArrayBuffer = function(I) {
    for (var K = I.length, Ee = new ArrayBuffer(K), Re = new Uint8Array(Ee); K--; ) Re[K] = I.charCodeAt(K);
    return Ee;
  }, lt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  z.__private__.getStandardFonts = function() {
    return lt;
  };
  var xt = s.fontSize || 16;
  z.__private__.setFontSize = z.setFontSize = function(I) {
    return xt = Ce === fe.ADVANCED ? I / It : I, this;
  };
  var At, Et = z.__private__.getFontSize = z.getFontSize = function() {
    return Ce === fe.COMPAT ? xt : xt * It;
  }, jt = s.R2L || !1;
  z.__private__.setR2L = z.setR2L = function(I) {
    return jt = I, this;
  }, z.__private__.getR2L = z.getR2L = function() {
    return jt;
  };
  var ni, ii = z.__private__.setZoomMode = function(I) {
    var K = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(I)) At = I;
    else if (isNaN(I)) {
      if (K.indexOf(I) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + I + '" is not recognized.');
      At = I;
    } else At = parseInt(I, 10);
  };
  z.__private__.getZoomMode = function() {
    return At;
  };
  var yi, xi = z.__private__.setPageMode = function(I) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(I) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + I + '" is not recognized.');
    ni = I;
  };
  z.__private__.getPageMode = function() {
    return ni;
  };
  var pt = z.__private__.setLayoutMode = function(I) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(I) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + I + '" is not recognized.');
    yi = I;
  };
  z.__private__.getLayoutMode = function() {
    return yi;
  }, z.__private__.setDisplayMode = z.setDisplayMode = function(I, K, Ee) {
    return ii(I), pt(K), xi(Ee), this;
  };
  var Jt = { title: "", subject: "", author: "", keywords: "", creator: "" };
  z.__private__.getDocumentProperty = function(I) {
    if (Object.keys(Jt).indexOf(I) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Jt[I];
  }, z.__private__.getDocumentProperties = function() {
    return Jt;
  }, z.__private__.setDocumentProperties = z.setProperties = z.setDocumentProperties = function(I) {
    for (var K in Jt) Jt.hasOwnProperty(K) && I[K] && (Jt[K] = I[K]);
    return this;
  }, z.__private__.setDocumentProperty = function(I, K) {
    if (Object.keys(Jt).indexOf(I) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Jt[I] = K;
  };
  var si, It, Zi, ft, ri, Lt = {}, Si = {}, Gi = [], zt = {}, cr = {}, Ni = {}, ie = {}, ue = null, $ = 0, B = [], q = new $g(z), te = s.hotfixes || [], ge = {}, Me = {}, Fe = [], Ne = function I(K, Ee, Re, Ye, ct, Dt) {
    if (!(this instanceof I)) return new I(K, Ee, Re, Ye, ct, Dt);
    isNaN(K) && (K = 1), isNaN(Ee) && (Ee = 0), isNaN(Re) && (Re = 0), isNaN(Ye) && (Ye = 1), isNaN(ct) && (ct = 0), isNaN(Dt) && (Dt = 0), this._matrix = [K, Ee, Re, Ye, ct, Dt];
  };
  Object.defineProperty(Ne.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ne.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ne.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ne.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ne.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ne.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ne.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ne.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ne.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ne.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ne.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ne.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ne.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Ne.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Ne.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Ne.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Ne.prototype.join = function(I) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(ke).join(I);
  }, Ne.prototype.multiply = function(I) {
    var K = I.sx * this.sx + I.shy * this.shx, Ee = I.sx * this.shy + I.shy * this.sy, Re = I.shx * this.sx + I.sy * this.shx, Ye = I.shx * this.shy + I.sy * this.sy, ct = I.tx * this.sx + I.ty * this.shx + this.tx, Dt = I.tx * this.shy + I.ty * this.sy + this.ty;
    return new Ne(K, Ee, Re, Ye, ct, Dt);
  }, Ne.prototype.decompose = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty, Dt = Math.sqrt(I * I + K * K), Ut = (I /= Dt) * Ee + (K /= Dt) * Re;
    Ee -= I * Ut, Re -= K * Ut;
    var ui = Math.sqrt(Ee * Ee + Re * Re);
    return Ut /= ui, I * (Re /= ui) < K * (Ee /= ui) && (I = -I, K = -K, Ut = -Ut, Dt = -Dt), { scale: new Ne(Dt, 0, 0, ui, 0, 0), translate: new Ne(1, 0, 0, 1, Ye, ct), rotate: new Ne(I, K, -K, I, 0, 0), skew: new Ne(1, 0, Ut, 1, 0, 0) };
  }, Ne.prototype.toString = function(I) {
    return this.join(" ");
  }, Ne.prototype.inversed = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty, Dt = 1 / (I * Re - K * Ee), Ut = Re * Dt, ui = -K * Dt, bi = -Ee * Dt, Ci = I * Dt;
    return new Ne(Ut, ui, bi, Ci, -Ut * Ye - bi * ct, -ui * Ye - Ci * ct);
  }, Ne.prototype.applyToPoint = function(I) {
    var K = I.x * this.sx + I.y * this.shx + this.tx, Ee = I.x * this.shy + I.y * this.sy + this.ty;
    return new jn(K, Ee);
  }, Ne.prototype.applyToRectangle = function(I) {
    var K = this.applyToPoint(I), Ee = this.applyToPoint(new jn(I.x + I.w, I.y + I.h));
    return new vo(K.x, K.y, Ee.x - K.x, Ee.y - K.y);
  }, Ne.prototype.clone = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty;
    return new Ne(I, K, Ee, Re, Ye, ct);
  }, z.Matrix = Ne;
  var De = z.matrixMult = function(I, K) {
    return K.multiply(I);
  }, tt = new Ne(1, 0, 0, 1, 0, 0);
  z.unitMatrix = z.identityMatrix = tt;
  var ut = function(I, K) {
    if (!cr[I]) {
      var Ee = (K instanceof Iu ? "Sh" : "P") + (Object.keys(zt).length + 1).toString(10);
      K.id = Ee, cr[I] = Ee, zt[Ee] = K, q.publish("addPattern", K);
    }
  };
  z.ShadingPattern = Iu, z.TilingPattern = mc, z.addShadingPattern = function(I, K) {
    return Ae("addShadingPattern()"), ut(I, K), this;
  }, z.beginTilingPattern = function(I) {
    Ae("beginTilingPattern()"), nl(I.boundingBox[0], I.boundingBox[1], I.boundingBox[2] - I.boundingBox[0], I.boundingBox[3] - I.boundingBox[1], I.matrix);
  }, z.endTilingPattern = function(I, K) {
    Ae("endTilingPattern()"), K.stream = ot[_e].join(`
`), ut(I, K), q.publish("endTilingPattern", K), Fe.pop().restore();
  };
  var We = z.__private__.newObject = function() {
    var I = gt();
    return Mt(I, !0), I;
  }, gt = z.__private__.newObjectDeferred = function() {
    return Oe++, $e[Oe] = function() {
      return Ke;
    }, Oe;
  }, Mt = function(I, K) {
    return K = typeof K == "boolean" && K, $e[I] = Ke, K && Y(I + " 0 obj"), I;
  }, $t = z.__private__.newAdditionalObject = function() {
    var I = { objId: gt(), content: "" };
    return nt.push(I), I;
  }, Qt = gt(), ei = gt(), pi = z.__private__.decodeColorString = function(I) {
    var K = I.split(" ");
    if (K.length !== 2 || K[1] !== "g" && K[1] !== "G")
      K.length === 5 && (K[4] === "k" || K[4] === "K") && (K = [(1 - K[0]) * (1 - K[3]), (1 - K[1]) * (1 - K[3]), (1 - K[2]) * (1 - K[3]), "r"]);
    else {
      var Ee = parseFloat(K[0]);
      K = [Ee, Ee, Ee, "r"];
    }
    for (var Re = "#", Ye = 0; Ye < 3; Ye++) Re += ("0" + Math.floor(255 * parseFloat(K[Ye])).toString(16)).slice(-2);
    return Re;
  }, fi = z.__private__.encodeColorString = function(I) {
    var K;
    typeof I == "string" && (I = { ch1: I });
    var Ee = I.ch1, Re = I.ch2, Ye = I.ch3, ct = I.ch4, Dt = I.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ee == "string" && Ee.charAt(0) !== "#") {
      var Ut = new a1(Ee);
      if (Ut.ok) Ee = Ut.toHex();
      else if (!/^\d*\.?\d*$/.test(Ee)) throw new Error('Invalid color "' + Ee + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ee == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ee) && (Ee = "#" + Ee[1] + Ee[1] + Ee[2] + Ee[2] + Ee[3] + Ee[3]), typeof Ee == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ee)) {
      var ui = parseInt(Ee.substr(1), 16);
      Ee = ui >> 16 & 255, Re = ui >> 8 & 255, Ye = 255 & ui;
    }
    if (Re === void 0 || ct === void 0 && Ee === Re && Re === Ye) if (typeof Ee == "string") K = Ee + " " + Dt[0];
    else switch (I.precision) {
      case 2:
        K = ve(Ee / 255) + " " + Dt[0];
        break;
      case 3:
      default:
        K = X(Ee / 255) + " " + Dt[0];
    }
    else if (ct === void 0 || ur(ct) === "object") {
      if (ct && !isNaN(ct.a) && ct.a === 0) return K = ["1.", "1.", "1.", Dt[1]].join(" ");
      if (typeof Ee == "string") K = [Ee, Re, Ye, Dt[1]].join(" ");
      else switch (I.precision) {
        case 2:
          K = [ve(Ee / 255), ve(Re / 255), ve(Ye / 255), Dt[1]].join(" ");
          break;
        default:
        case 3:
          K = [X(Ee / 255), X(Re / 255), X(Ye / 255), Dt[1]].join(" ");
      }
    } else if (typeof Ee == "string") K = [Ee, Re, Ye, ct, Dt[2]].join(" ");
    else switch (I.precision) {
      case 2:
        K = [ve(Ee), ve(Re), ve(Ye), ve(ct), Dt[2]].join(" ");
        break;
      case 3:
      default:
        K = [X(Ee), X(Re), X(Ye), X(ct), Dt[2]].join(" ");
    }
    return K;
  }, Wi = z.__private__.getFilters = function() {
    return g;
  }, Oi = z.__private__.putStream = function(I) {
    var K = (I = I || {}).data || "", Ee = I.filters || Wi(), Re = I.alreadyAppliedFilters || [], Ye = I.addLength1 || !1, ct = K.length, Dt = I.objectId, Ut = function(Yr) {
      return Yr;
    };
    if (L !== null && Dt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    L !== null && (Ut = wr.encryptor(Dt, 0));
    var ui = {};
    Ee === !0 && (Ee = ["FlateEncode"]);
    var bi = I.additionalKeyValues || [], Ci = (ui = wi.API.processDataByFilters !== void 0 ? wi.API.processDataByFilters(K, Ee) : { data: K, reverseChain: [] }).reverseChain + (Array.isArray(Re) ? Re.join(" ") : Re.toString());
    if (ui.data.length !== 0 && (bi.push({ key: "Length", value: ui.data.length }), Ye === !0 && bi.push({ key: "Length1", value: ct })), Ci.length != 0) if (Ci.split("/").length - 1 == 1) bi.push({ key: "Filter", value: Ci });
    else {
      bi.push({ key: "Filter", value: "[" + Ci + "]" });
      for (var Ii = 0; Ii < bi.length; Ii += 1) if (bi[Ii].key === "DecodeParms") {
        for (var nr = [], Er = 0; Er < ui.reverseChain.split("/").length - 1; Er += 1) nr.push("null");
        nr.push(bi[Ii].value), bi[Ii].value = "[" + nr.join(" ") + "]";
      }
    }
    Y("<<");
    for (var Ti = 0; Ti < bi.length; Ti++) Y("/" + bi[Ti].key + " " + bi[Ti].value);
    Y(">>"), ui.data.length !== 0 && (Y("stream"), Y(Ut(ui.data)), Y("endstream"));
  }, mi = z.__private__.putPage = function(I) {
    var K = I.number, Ee = I.data, Re = I.objId, Ye = I.contentsObjId;
    Mt(Re, !0), Y("<</Type /Page"), Y("/Parent " + I.rootDictionaryObjId + " 0 R"), Y("/Resources " + I.resourceDictionaryObjId + " 0 R"), Y("/MediaBox [" + parseFloat(ke(I.mediaBox.bottomLeftX)) + " " + parseFloat(ke(I.mediaBox.bottomLeftY)) + " " + ke(I.mediaBox.topRightX) + " " + ke(I.mediaBox.topRightY) + "]"), I.cropBox !== null && Y("/CropBox [" + ke(I.cropBox.bottomLeftX) + " " + ke(I.cropBox.bottomLeftY) + " " + ke(I.cropBox.topRightX) + " " + ke(I.cropBox.topRightY) + "]"), I.bleedBox !== null && Y("/BleedBox [" + ke(I.bleedBox.bottomLeftX) + " " + ke(I.bleedBox.bottomLeftY) + " " + ke(I.bleedBox.topRightX) + " " + ke(I.bleedBox.topRightY) + "]"), I.trimBox !== null && Y("/TrimBox [" + ke(I.trimBox.bottomLeftX) + " " + ke(I.trimBox.bottomLeftY) + " " + ke(I.trimBox.topRightX) + " " + ke(I.trimBox.topRightY) + "]"), I.artBox !== null && Y("/ArtBox [" + ke(I.artBox.bottomLeftX) + " " + ke(I.artBox.bottomLeftY) + " " + ke(I.artBox.topRightX) + " " + ke(I.artBox.topRightY) + "]"), typeof I.userUnit == "number" && I.userUnit !== 1 && Y("/UserUnit " + I.userUnit), q.publish("putPage", { objId: Re, pageContext: B[K], pageNumber: K, page: Ee }), Y("/Contents " + Ye + " 0 R"), Y(">>"), Y("endobj");
    var ct = Ee.join(`
`);
    return Ce === fe.ADVANCED && (ct += `
Q`), Mt(Ye, !0), Oi({ data: ct, filters: Wi(), objectId: Ye }), Y("endobj"), Re;
  }, Bi = z.__private__.putPages = function() {
    var I, K, Ee = [];
    for (I = 1; I <= $; I++) B[I].objId = gt(), B[I].contentsObjId = gt();
    for (I = 1; I <= $; I++) Ee.push(mi({ number: I, data: ot[I], objId: B[I].objId, contentsObjId: B[I].contentsObjId, mediaBox: B[I].mediaBox, cropBox: B[I].cropBox, bleedBox: B[I].bleedBox, trimBox: B[I].trimBox, artBox: B[I].artBox, userUnit: B[I].userUnit, rootDictionaryObjId: Qt, resourceDictionaryObjId: ei }));
    Mt(Qt, !0), Y("<</Type /Pages");
    var Re = "/Kids [";
    for (K = 0; K < $; K++) Re += Ee[K] + " 0 R ";
    Y(Re + "]"), Y("/Count " + $), Y(">>"), Y("endobj"), q.publish("postPutPages");
  }, Hi = function(I) {
    q.publish("putFont", { font: I, out: Y, newObject: We, putStream: Oi }), I.isAlreadyPutted !== !0 && (I.objectNumber = We(), Y("<<"), Y("/Type /Font"), Y("/BaseFont /" + fc(I.postScriptName)), Y("/Subtype /Type1"), typeof I.encoding == "string" && Y("/Encoding /" + I.encoding), Y("/FirstChar 32"), Y("/LastChar 255"), Y(">>"), Y("endobj"));
  }, gr = function() {
    for (var I in Lt) Lt.hasOwnProperty(I) && (j === !1 || j === !0 && O.hasOwnProperty(I)) && Hi(Lt[I]);
  }, br = function(I) {
    I.objectNumber = We();
    var K = [];
    K.push({ key: "Type", value: "/XObject" }), K.push({ key: "Subtype", value: "/Form" }), K.push({ key: "BBox", value: "[" + [ke(I.x), ke(I.y), ke(I.x + I.width), ke(I.y + I.height)].join(" ") + "]" }), K.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" });
    var Ee = I.pages[1].join(`
`);
    Oi({ data: Ee, additionalKeyValues: K, objectId: I.objectNumber }), Y("endobj");
  }, Pr = function() {
    for (var I in ge) ge.hasOwnProperty(I) && br(ge[I]);
  }, Vs = function(I, K) {
    var Ee, Re = [], Ye = 1 / (K - 1);
    for (Ee = 0; Ee < 1; Ee += Ye) Re.push(Ee);
    if (Re.push(1), I[0].offset != 0) {
      var ct = { offset: 0, color: I[0].color };
      I.unshift(ct);
    }
    if (I[I.length - 1].offset != 1) {
      var Dt = { offset: 1, color: I[I.length - 1].color };
      I.push(Dt);
    }
    for (var Ut = "", ui = 0, bi = 0; bi < Re.length; bi++) {
      for (Ee = Re[bi]; Ee > I[ui + 1].offset; ) ui++;
      var Ci = I[ui].offset, Ii = (Ee - Ci) / (I[ui + 1].offset - Ci), nr = I[ui].color, Er = I[ui + 1].color;
      Ut += Te(Math.round((1 - Ii) * nr[0] + Ii * Er[0]).toString(16)) + Te(Math.round((1 - Ii) * nr[1] + Ii * Er[1]).toString(16)) + Te(Math.round((1 - Ii) * nr[2] + Ii * Er[2]).toString(16));
    }
    return Ut.trim();
  }, ji = function(I, K) {
    K || (K = 21);
    var Ee = We(), Re = Vs(I.colors, K), Ye = [];
    Ye.push({ key: "FunctionType", value: "0" }), Ye.push({ key: "Domain", value: "[0.0 1.0]" }), Ye.push({ key: "Size", value: "[" + K + "]" }), Ye.push({ key: "BitsPerSample", value: "8" }), Ye.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ye.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Oi({ data: Re, additionalKeyValues: Ye, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ee }), Y("endobj"), I.objectNumber = We(), Y("<< /ShadingType " + I.type), Y("/ColorSpace /DeviceRGB");
    var ct = "/Coords [" + ke(parseFloat(I.coords[0])) + " " + ke(parseFloat(I.coords[1])) + " ";
    I.type === 2 ? ct += ke(parseFloat(I.coords[2])) + " " + ke(parseFloat(I.coords[3])) : ct += ke(parseFloat(I.coords[2])) + " " + ke(parseFloat(I.coords[3])) + " " + ke(parseFloat(I.coords[4])) + " " + ke(parseFloat(I.coords[5])), Y(ct += "]"), I.matrix && Y("/Matrix [" + I.matrix.toString() + "]"), Y("/Function " + Ee + " 0 R"), Y("/Extend [true true]"), Y(">>"), Y("endobj");
  }, Yo = function(I, K) {
    var Ee = gt(), Re = We();
    K.push({ resourcesOid: Ee, objectOid: Re }), I.objectNumber = Re;
    var Ye = [];
    Ye.push({ key: "Type", value: "/Pattern" }), Ye.push({ key: "PatternType", value: "1" }), Ye.push({ key: "PaintType", value: "1" }), Ye.push({ key: "TilingType", value: "1" }), Ye.push({ key: "BBox", value: "[" + I.boundingBox.map(ke).join(" ") + "]" }), Ye.push({ key: "XStep", value: ke(I.xStep) }), Ye.push({ key: "YStep", value: ke(I.yStep) }), Ye.push({ key: "Resources", value: Ee + " 0 R" }), I.matrix && Ye.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" }), Oi({ data: I.stream, additionalKeyValues: Ye, objectId: I.objectNumber }), Y("endobj");
  }, ca = function(I) {
    var K;
    for (K in zt) zt.hasOwnProperty(K) && (zt[K] instanceof Iu ? ji(zt[K]) : zt[K] instanceof mc && Yo(zt[K], I));
  }, Wr = function(I) {
    for (var K in I.objectNumber = We(), Y("<<"), I) switch (K) {
      case "opacity":
        Y("/ca " + ve(I[K]));
        break;
      case "stroke-opacity":
        Y("/CA " + ve(I[K]));
    }
    Y(">>"), Y("endobj");
  }, on = function() {
    var I;
    for (I in Ni) Ni.hasOwnProperty(I) && Wr(Ni[I]);
  }, Jo = function() {
    for (var I in Y("/XObject <<"), ge) ge.hasOwnProperty(I) && ge[I].objectNumber >= 0 && Y("/" + I + " " + ge[I].objectNumber + " 0 R");
    q.publish("putXobjectDict"), Y(">>");
  }, gn = function() {
    wr.oid = We(), Y("<<"), Y("/Filter /Standard"), Y("/V " + wr.v), Y("/R " + wr.r), Y("/U <" + wr.toHexString(wr.U) + ">"), Y("/O <" + wr.toHexString(wr.O) + ">"), Y("/P " + wr.P), Y(">>"), Y("endobj");
  }, Xr = function() {
    for (var I in Y("/Font <<"), Lt) Lt.hasOwnProperty(I) && (j === !1 || j === !0 && O.hasOwnProperty(I)) && Y("/" + I + " " + Lt[I].objectNumber + " 0 R");
    Y(">>");
  }, ha = function() {
    if (Object.keys(zt).length > 0) {
      for (var I in Y("/Shading <<"), zt) zt.hasOwnProperty(I) && zt[I] instanceof Iu && zt[I].objectNumber >= 0 && Y("/" + I + " " + zt[I].objectNumber + " 0 R");
      q.publish("putShadingPatternDict"), Y(">>");
    }
  }, On = function(I) {
    if (Object.keys(zt).length > 0) {
      for (var K in Y("/Pattern <<"), zt) zt.hasOwnProperty(K) && zt[K] instanceof z.TilingPattern && zt[K].objectNumber >= 0 && zt[K].objectNumber < I && Y("/" + K + " " + zt[K].objectNumber + " 0 R");
      q.publish("putTilingPatternDict"), Y(">>");
    }
  }, xr = function() {
    if (Object.keys(Ni).length > 0) {
      var I;
      for (I in Y("/ExtGState <<"), Ni) Ni.hasOwnProperty(I) && Ni[I].objectNumber >= 0 && Y("/" + I + " " + Ni[I].objectNumber + " 0 R");
      q.publish("putGStateDict"), Y(">>");
    }
  }, rr = function(I) {
    Mt(I.resourcesOid, !0), Y("<<"), Y("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Xr(), ha(), On(I.objectOid), xr(), Jo(), Y(">>"), Y("endobj");
  }, _n = function() {
    var I = [];
    gr(), on(), Pr(), ca(I), q.publish("putResources"), I.forEach(rr), rr({ resourcesOid: ei, objectOid: Number.MAX_SAFE_INTEGER }), q.publish("postPutResources");
  }, hr = function() {
    q.publish("putAdditionalObjects");
    for (var I = 0; I < nt.length; I++) {
      var K = nt[I];
      Mt(K.objId, !0), Y(K.content), Y("endobj");
    }
    q.publish("postPutAdditionalObjects");
  }, Na = function(I) {
    Si[I.fontName] = Si[I.fontName] || {}, Si[I.fontName][I.fontStyle] = I.id;
  }, ln = function(I, K, Ee, Re, Ye) {
    var ct = { id: "F" + (Object.keys(Lt).length + 1).toString(10), postScriptName: I, fontName: K, fontStyle: Ee, encoding: Re, isStandardFont: Ye || !1, metadata: {} };
    return q.publish("addFont", { font: ct, instance: this }), Lt[ct.id] = ct, Na(ct), ct.id;
  }, Ko = function(I) {
    for (var K = 0, Ee = lt.length; K < Ee; K++) {
      var Re = ln.call(this, I[K][0], I[K][1], I[K][2], lt[K][3], !0);
      j === !1 && (O[Re] = !0);
      var Ye = I[K][0].split("-");
      Na({ id: Re, fontName: Ye[0], fontStyle: Ye[1] || "" });
    }
    q.publish("addFonts", { fonts: Lt, dictionary: Si });
  }, Sr = function(I) {
    return I.foo = function() {
      try {
        return I.apply(this, arguments);
      } catch (Re) {
        var K = Re.stack || "";
        ~K.indexOf(" at ") && (K = K.split(" at ")[1]);
        var Ee = "Error in function " + K.split(`
`)[0].split("<")[0] + ": " + Re.message;
        if (!Ai.console) throw new Error(Ee);
        Ai.console.error(Ee, Re), Ai.alert && alert(Ee);
      }
    }, I.foo.bar = I, I.foo;
  }, no = function(I, K) {
    var Ee, Re, Ye, ct, Dt, Ut, ui, bi, Ci;
    if (Ye = (K = K || {}).sourceEncoding || "Unicode", Dt = K.outputEncoding, (K.autoencode || Dt) && Lt[si].metadata && Lt[si].metadata[Ye] && Lt[si].metadata[Ye].encoding && (ct = Lt[si].metadata[Ye].encoding, !Dt && Lt[si].encoding && (Dt = Lt[si].encoding), !Dt && ct.codePages && (Dt = ct.codePages[0]), typeof Dt == "string" && (Dt = ct[Dt]), Dt)) {
      for (ui = !1, Ut = [], Ee = 0, Re = I.length; Ee < Re; Ee++) (bi = Dt[I.charCodeAt(Ee)]) ? Ut.push(String.fromCharCode(bi)) : Ut.push(I[Ee]), Ut[Ee].charCodeAt(0) >> 8 && (ui = !0);
      I = Ut.join("");
    }
    for (Ee = I.length; ui === void 0 && Ee !== 0; ) I.charCodeAt(Ee - 1) >> 8 && (ui = !0), Ee--;
    if (!ui) return I;
    for (Ut = K.noBOM ? [] : [254, 255], Ee = 0, Re = I.length; Ee < Re; Ee++) {
      if ((Ci = (bi = I.charCodeAt(Ee)) >> 8) >> 8) throw new Error("Character at position " + Ee + " of string '" + I + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Ut.push(Ci), Ut.push(bi - (Ci << 8));
    }
    return String.fromCharCode.apply(void 0, Ut);
  }, jr = z.__private__.pdfEscape = z.pdfEscape = function(I, K) {
    return no(I, K).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, as = z.__private__.beginPage = function(I) {
    ot[++$] = [], B[$] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(I[0]), topRightY: Number(I[1]) } }, so($), rt(ot[_e]);
  }, os = function(I, K) {
    var Ee, Re, Ye;
    switch (a = K || a, typeof I == "string" && (Ee = Q(I.toLowerCase()), Array.isArray(Ee) && (Re = Ee[0], Ye = Ee[1])), Array.isArray(I) && (Re = I[0] * It, Ye = I[1] * It), isNaN(Re) && (Re = y[0], Ye = y[1]), (Re > 14400 || Ye > 14400) && (vr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Re = Math.min(14400, Re), Ye = Math.min(14400, Ye)), y = [Re, Ye], a.substr(0, 1)) {
      case "l":
        Ye > Re && (y = [Ye, Re]);
        break;
      case "p":
        Re > Ye && (y = [Ye, Re]);
    }
    as(y), Ll(Ra), Y(hs), _o !== 0 && Y(_o + " J"), yo !== 0 && Y(yo + " j"), q.publish("addPage", { pageNumber: $ });
  }, Ri = function(I) {
    I > 0 && I <= $ && (ot.splice(I, 1), B.splice(I, 1), $--, _e > $ && (_e = $), this.setPage(_e));
  }, so = function(I) {
    I > 0 && I <= $ && (_e = I);
  }, Qo = z.__private__.getNumberOfPages = z.getNumberOfPages = function() {
    return ot.length - 1;
  }, $s = function(I, K, Ee) {
    var Re, Ye = void 0;
    return Ee = Ee || {}, I = I !== void 0 ? I : Lt[si].fontName, K = K !== void 0 ? K : Lt[si].fontStyle, Re = I.toLowerCase(), Si[Re] !== void 0 && Si[Re][K] !== void 0 ? Ye = Si[Re][K] : Si[I] !== void 0 && Si[I][K] !== void 0 ? Ye = Si[I][K] : Ee.disableWarning === !1 && vr.warn("Unable to look up font label for font '" + I + "', '" + K + "'. Refer to getFontList() for available fonts."), Ye || Ee.noFallback || (Ye = Si.times[K]) == null && (Ye = Si.times.normal), Ye;
  }, el = z.__private__.putInfo = function() {
    var I = We(), K = function(Re) {
      return Re;
    };
    for (var Ee in L !== null && (K = wr.encryptor(I, 0)), Y("<<"), Y("/Producer (" + jr(K("jsPDF " + wi.version)) + ")"), Jt) Jt.hasOwnProperty(Ee) && Jt[Ee] && Y("/" + Ee.substr(0, 1).toUpperCase() + Ee.substr(1) + " (" + jr(K(Jt[Ee])) + ")");
    Y("/CreationDate (" + jr(K(Ve)) + ")"), Y(">>"), Y("endobj");
  }, da = z.__private__.putCatalog = function(I) {
    var K = (I = I || {}).rootDictionaryObjId || Qt;
    switch (We(), Y("<<"), Y("/Type /Catalog"), Y("/Pages " + K + " 0 R"), At || (At = "fullwidth"), At) {
      case "fullwidth":
        Y("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Y("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Y("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Y("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ee = "" + At;
        Ee.substr(Ee.length - 1) === "%" && (At = parseInt(At) / 100), typeof At == "number" && Y("/OpenAction [3 0 R /XYZ null null " + ve(At) + "]");
    }
    switch (yi || (yi = "continuous"), yi) {
      case "continuous":
        Y("/PageLayout /OneColumn");
        break;
      case "single":
        Y("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Y("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Y("/PageLayout /TwoColumnRight");
    }
    ni && Y("/PageMode /" + ni), q.publish("putCatalog"), Y(">>"), Y("endobj");
  }, za = z.__private__.putTrailer = function() {
    Y("trailer"), Y("<<"), Y("/Size " + (Oe + 1)), Y("/Root " + Oe + " 0 R"), Y("/Info " + (Oe - 1) + " 0 R"), L !== null && Y("/Encrypt " + wr.oid + " 0 R"), Y("/ID [ <" + He + "> <" + He + "> ]"), Y(">>");
  }, ao = z.__private__.putHeader = function() {
    Y("%PDF-" + pe), Y("%");
  }, pa = z.__private__.putXRef = function() {
    var I = "0000000000";
    Y("xref"), Y("0 " + (Oe + 1)), Y("0000000000 65535 f ");
    for (var K = 1; K <= Oe; K++)
      typeof $e[K] == "function" ? Y((I + $e[K]()).slice(-10) + " 00000 n ") : $e[K] !== void 0 ? Y((I + $e[K]).slice(-10) + " 00000 n ") : Y("0000000000 00000 n ");
  }, As = z.__private__.buildDocument = function() {
    Pt(), rt(Ue), q.publish("buildDocument"), ao(), Bi(), hr(), _n(), L !== null && gn(), el(), da();
    var I = Ke;
    return pa(), za(), Y("startxref"), Y("" + I), Y("%%EOF"), rt(ot[_e]), Ue.join(`
`);
  }, oo = z.__private__.getBlob = function(I) {
    return new Blob([Rt(I)], { type: "application/pdf" });
  }, Fa = z.output = z.__private__.output = Sr(function(I, K) {
    switch (typeof (K = K || {}) == "string" ? K = { filename: K } : K.filename = K.filename || "generated.pdf", I) {
      case void 0:
        return As();
      case "save":
        z.save(K.filename);
        break;
      case "arraybuffer":
        return Rt(As());
      case "blob":
        return oo(As());
      case "bloburi":
      case "bloburl":
        if (Ai.URL !== void 0 && typeof Ai.URL.createObjectURL == "function") return Ai.URL && Ai.URL.createObjectURL(oo(As())) || void 0;
        vr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ee = "", Re = As();
        try {
          Ee = tf(Re);
        } catch {
          Ee = tf(unescape(encodeURIComponent(Re)));
        }
        return "data:application/pdf;filename=" + K.filename + ";base64," + Ee;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Ai) === "[object Window]") {
          var Ye = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", ct = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          K.pdfObjectUrl && (Ye = K.pdfObjectUrl, ct = "");
          var Dt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ye + '"' + ct + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(K) + ");<\/script></body></html>", Ut = Ai.open();
          return Ut !== null && Ut.document.write(Dt), Ut;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Ai) === "[object Window]") {
          var ui = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (K.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + K.filename + '" width="500px" height="400px" /></body></html>', bi = Ai.open();
          if (bi !== null) {
            bi.document.write(ui);
            var Ci = this;
            bi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              bi.document.title = K.filename, bi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Ci.output("bloburl"));
            };
          }
          return bi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Ai) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Ii = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", K) + '"></iframe></body></html>', nr = Ai.open();
        if (nr !== null && (nr.document.write(Ii), nr.document.title = K.filename), nr || typeof safari > "u") return nr;
        break;
      case "datauri":
      case "dataurl":
        return Ai.document.location.href = this.output("datauristring", K);
      default:
        return null;
    }
  }), Il = function(I) {
    return Array.isArray(te) === !0 && te.indexOf(I) > -1;
  };
  switch (m) {
    case "pt":
      It = 1;
      break;
    case "mm":
      It = 72 / 25.4;
      break;
    case "cm":
      It = 72 / 2.54;
      break;
    case "in":
      It = 72;
      break;
    case "px":
      It = Il("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      It = 12;
      break;
    case "ex":
      It = 6;
      break;
    default:
      if (typeof m != "number") throw new Error("Invalid unit: " + m);
      It = m;
  }
  var wr = null;
  st(), qe();
  var Ba = function(I) {
    return L !== null ? wr.encryptor(I, 0) : function(K) {
      return K;
    };
  }, qr = z.__private__.getPageInfo = z.getPageInfo = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: B[I].objId, pageNumber: I, pageContext: B[I] };
  }, ai = z.__private__.getPageInfoByObjId = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var K in B) if (B[K].objId === I) break;
    return qr(K);
  }, lo = z.__private__.getCurrentPageInfo = z.getCurrentPageInfo = function() {
    return { objId: B[_e].objId, pageNumber: _e, pageContext: B[_e] };
  };
  z.addPage = function() {
    return os.apply(this, arguments), this;
  }, z.setPage = function() {
    return so.apply(this, arguments), rt.call(this, ot[_e]), this;
  }, z.insertPage = function(I) {
    return this.addPage(), this.movePage(_e, I), this;
  }, z.movePage = function(I, K) {
    var Ee, Re;
    if (I > K) {
      Ee = ot[I], Re = B[I];
      for (var Ye = I; Ye > K; Ye--) ot[Ye] = ot[Ye - 1], B[Ye] = B[Ye - 1];
      ot[K] = Ee, B[K] = Re, this.setPage(K);
    } else if (I < K) {
      Ee = ot[I], Re = B[I];
      for (var ct = I; ct < K; ct++) ot[ct] = ot[ct + 1], B[ct] = B[ct + 1];
      ot[K] = Ee, B[K] = Re, this.setPage(K);
    }
    return this;
  }, z.deletePage = function() {
    return Ri.apply(this, arguments), this;
  }, z.__private__.text = z.text = function(I, K, Ee, Re, Ye) {
    var ct, Dt, Ut, ui, bi, Ci, Ii, nr, Er, Ti = (Re = Re || {}).scope || this;
    if (typeof I == "number" && typeof K == "number" && (typeof Ee == "string" || Array.isArray(Ee))) {
      var Yr = Ee;
      Ee = K, K = I, I = Yr;
    }
    if (arguments[3] instanceof Ne ? (Ae("The transform parameter of text() with a Matrix value"), Er = Ye) : (Ut = arguments[4], ui = arguments[5], ur(Ii = arguments[3]) === "object" && Ii !== null || (typeof Ut == "string" && (ui = Ut, Ut = null), typeof Ii == "string" && (ui = Ii, Ii = null), typeof Ii == "number" && (Ut = Ii, Ii = null), Re = { flags: Ii, angle: Ut, align: ui })), isNaN(K) || isNaN(Ee) || I == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (I.length === 0) return Ti;
    var oi = "", yn = !1, Mi = typeof Re.lineHeightFactor == "number" ? Re.lineHeightFactor : Gs, zi = Ti.internal.scaleFactor;
    function Ts(tr) {
      return tr = tr.split("	").join(Array(Re.TabLen || 9).join(" ")), jr(tr, Ii);
    }
    function Hs(tr) {
      for (var Yi, dr = tr.concat(), Cr = [], Dn = dr.length; Dn--; ) typeof (Yi = dr.shift()) == "string" ? Cr.push(Yi) : Array.isArray(tr) && (Yi.length === 1 || Yi[1] === void 0 && Yi[2] === void 0) ? Cr.push(Yi[0]) : Cr.push([Yi[0], Yi[1], Yi[2]]);
      return Cr;
    }
    function Ws(tr, Yi) {
      var dr;
      if (typeof tr == "string") dr = Yi(tr)[0];
      else if (Array.isArray(tr)) {
        for (var Cr, Dn, Gn = tr.concat(), Tr = [], Ps = Gn.length; Ps--; ) typeof (Cr = Gn.shift()) == "string" ? Tr.push(Yi(Cr)[0]) : Array.isArray(Cr) && typeof Cr[0] == "string" && (Dn = Yi(Cr[0], Cr[1], Cr[2]), Tr.push([Dn[0], Dn[1], Dn[2]]));
        dr = Tr;
      }
      return dr;
    }
    var ga = !1, ds = !0;
    if (typeof I == "string") ga = !0;
    else if (Array.isArray(I)) {
      var ks = I.concat();
      Dt = [];
      for (var Ur, Jr = ks.length; Jr--; ) (typeof (Ur = ks.shift()) != "string" || Array.isArray(Ur) && typeof Ur[0] != "string") && (ds = !1);
      ga = ds;
    }
    if (ga === !1) throw new Error('Type of text must be string or Array. "' + I + '" is not recognized.');
    typeof I == "string" && (I = I.match(/[\r?\n]/) ? I.split(/\r\n|\r|\n/g) : [I]);
    var _a = xt / Ti.internal.scaleFactor, ya = _a * (Mi - 1);
    switch (Re.baseline) {
      case "bottom":
        Ee -= ya;
        break;
      case "top":
        Ee += _a - ya;
        break;
      case "hanging":
        Ee += _a - 2 * ya;
        break;
      case "middle":
        Ee += _a / 2 - ya;
    }
    if ((Ci = Re.maxWidth || 0) > 0 && (typeof I == "string" ? I = Ti.splitTextToSize(I, Ci) : Object.prototype.toString.call(I) === "[object Array]" && (I = I.reduce(function(tr, Yi) {
      return tr.concat(Ti.splitTextToSize(Yi, Ci));
    }, []))), ct = { text: I, x: K, y: Ee, options: Re, mutex: { pdfEscape: jr, activeFontKey: si, fonts: Lt, activeFontSize: xt } }, q.publish("preProcessText", ct), I = ct.text, Ut = (Re = ct.options).angle, !(Er instanceof Ne) && Ut && typeof Ut == "number") {
      Ut *= Math.PI / 180, Re.rotationDirection === 0 && (Ut = -Ut), Ce === fe.ADVANCED && (Ut = -Ut);
      var qn = Math.cos(Ut), Xs = Math.sin(Ut);
      Er = new Ne(qn, Xs, -Xs, qn, 0, 0);
    } else Ut && Ut instanceof Ne && (Er = Ut);
    Ce !== fe.ADVANCED || Er || (Er = tt), (bi = Re.charSpace || fa) !== void 0 && (oi += ke(re(bi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (nr = Re.horizontalScale) !== void 0 && (oi += ke(100 * nr) + ` Tz
`), Re.lang;
    var Fr = -1, va = Re.renderingMode !== void 0 ? Re.renderingMode : Re.stroke, Ys = Ti.internal.getCurrentPageInfo().pageContext;
    switch (va) {
      case 0:
      case !1:
      case "fill":
        Fr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Fr = 1;
        break;
      case 2:
      case "fillThenStroke":
        Fr = 2;
        break;
      case 3:
      case "invisible":
        Fr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Fr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Fr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Fr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Fr = 7;
    }
    var qa = Ys.usedRenderingMode !== void 0 ? Ys.usedRenderingMode : -1;
    Fr !== -1 ? oi += Fr + ` Tr
` : qa !== -1 && (oi += `0 Tr
`), Fr !== -1 && (Ys.usedRenderingMode = Fr), ui = Re.align || "left";
    var Kr, Ds = xt * Mi, zl = Ti.internal.pageSize.getWidth(), al = Lt[si];
    bi = Re.charSpace || fa, Ci = Re.maxWidth || 0, Ii = Object.assign({ autoencode: !0, noBOM: !0 }, Re.flags);
    var ki = [];
    if (Object.prototype.toString.call(I) === "[object Array]") {
      var cn;
      Dt = Hs(I), ui !== "left" && (Kr = Dt.map(function(tr) {
        return Ti.getStringUnitWidth(tr, { font: al, charSpace: bi, fontSize: xt, doKerning: !1 }) * xt / zi;
      }));
      var ps, Js = 0;
      if (ui === "right") {
        K -= Kr[0], I = [], Jr = Dt.length;
        for (var hn = 0; hn < Jr; hn++) hn === 0 ? (ps = Di(K), cn = cs(Ee)) : (ps = re(Js - Kr[hn]), cn = -Ds), I.push([Dt[hn], ps, cn]), Js = Kr[hn];
      } else if (ui === "center") {
        K -= Kr[0] / 2, I = [], Jr = Dt.length;
        for (var Is = 0; Is < Jr; Is++) Is === 0 ? (ps = Di(K), cn = cs(Ee)) : (ps = re((Js - Kr[Is]) / 2), cn = -Ds), I.push([Dt[Is], ps, cn]), Js = Kr[Is];
      } else if (ui === "left") {
        I = [], Jr = Dt.length;
        for (var Ks = 0; Ks < Jr; Ks++) I.push(Dt[Ks]);
      } else {
        if (ui !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        I = [], Jr = Dt.length, Ci = Ci !== 0 ? Ci : zl;
        for (var Un = 0; Un < Jr; Un++) cn = Un === 0 ? cs(Ee) : -Ds, ps = Un === 0 ? Di(K) : 0, Un < Jr - 1 ? ki.push(ke(re((Ci - Kr[Un]) / (Dt[Un].split(" ").length - 1)))) : ki.push(0), I.push([Dt[Un], ps, cn]);
      }
    }
    var Ua = typeof Re.R2L == "boolean" ? Re.R2L : jt;
    Ua === !0 && (I = Ws(I, function(tr, Yi, dr) {
      return [tr.split("").reverse().join(""), Yi, dr];
    })), ct = { text: I, x: K, y: Ee, options: Re, mutex: { pdfEscape: jr, activeFontKey: si, fonts: Lt, activeFontSize: xt } }, q.publish("postProcessText", ct), I = ct.text, yn = ct.mutex.isHex || !1;
    var ba = Lt[si].encoding;
    ba !== "WinAnsiEncoding" && ba !== "StandardEncoding" || (I = Ws(I, function(tr, Yi, dr) {
      return [Ts(tr), Yi, dr];
    })), Dt = Hs(I), I = [];
    for (var fs, Qr, vn, Vn = 0, xa = 1, $n = Array.isArray(Dt[0]) ? xa : Vn, Zn = "", wa = function(tr, Yi, dr) {
      var Cr = "";
      return dr instanceof Ne ? (dr = typeof Re.angle == "number" ? De(dr, new Ne(1, 0, 0, 1, tr, Yi)) : De(new Ne(1, 0, 0, 1, tr, Yi), dr), Ce === fe.ADVANCED && (dr = De(new Ne(1, 0, 0, -1, 0, 0), dr)), Cr = dr.join(" ") + ` Tm
`) : Cr = ke(tr) + " " + ke(Yi) + ` Td
`, Cr;
    }, dn = 0; dn < Dt.length; dn++) {
      switch (Zn = "", $n) {
        case xa:
          vn = (yn ? "<" : "(") + Dt[dn][0] + (yn ? ">" : ")"), fs = parseFloat(Dt[dn][1]), Qr = parseFloat(Dt[dn][2]);
          break;
        case Vn:
          vn = (yn ? "<" : "(") + Dt[dn] + (yn ? ">" : ")"), fs = Di(K), Qr = cs(Ee);
      }
      ki !== void 0 && ki[dn] !== void 0 && (Zn = ki[dn] + ` Tw
`), dn === 0 ? I.push(Zn + wa(fs, Qr, Er) + vn) : $n === Vn ? I.push(Zn + vn) : $n === xa && I.push(Zn + wa(fs, Qr, Er) + vn);
    }
    I = $n === Vn ? I.join(` Tj
T* `) : I.join(` Tj
`), I += ` Tj
`;
    var ms = `BT
/`;
    return ms += si + " " + xt + ` Tf
`, ms += ke(xt * Mi) + ` TL
`, ms += Oa + `
`, ms += oi, ms += I, Y(ms += "ET"), O[si] = !0, Ti;
  };
  var uo = z.__private__.clip = z.clip = function(I) {
    return Y(I === "evenodd" ? "W*" : "W"), this;
  };
  z.clipEvenOdd = function() {
    return uo("evenodd");
  }, z.__private__.discardPath = z.discardPath = function() {
    return Y("n"), this;
  };
  var Tn = z.__private__.isValidStyle = function(I) {
    var K = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(I) !== -1 && (K = !0), K;
  };
  z.__private__.setDefaultPathOperation = z.setDefaultPathOperation = function(I) {
    return Tn(I) && (D = I), this;
  };
  var tl = z.__private__.getStyle = z.getStyle = function(I) {
    var K = D;
    switch (I) {
      case "D":
      case "S":
        K = "S";
        break;
      case "F":
        K = "f";
        break;
      case "FD":
      case "DF":
        K = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        K = I;
    }
    return K;
  }, Zs = z.close = function() {
    return Y("h"), this;
  };
  z.stroke = function() {
    return Y("S"), this;
  }, z.fill = function(I) {
    return co("f", I), this;
  }, z.fillEvenOdd = function(I) {
    return co("f*", I), this;
  }, z.fillStroke = function(I) {
    return co("B", I), this;
  }, z.fillStrokeEvenOdd = function(I) {
    return co("B*", I), this;
  };
  var co = function(I, K) {
    ur(K) === "object" ? au(K, I) : Y(I);
  }, ho = function(I) {
    I === null || Ce === fe.ADVANCED && I === void 0 || (I = tl(I), Y(I));
  };
  function Pl(I, K, Ee, Re, Ye) {
    var ct = new mc(K || this.boundingBox, Ee || this.xStep, Re || this.yStep, this.gState, Ye || this.matrix);
    ct.stream = this.stream;
    var Dt = I + "$$" + this.cloneIndex++ + "$$";
    return ut(Dt, ct), ct;
  }
  var au = function(I, K) {
    var Ee = cr[I.key], Re = zt[Ee];
    if (Re instanceof Iu) Y("q"), Y(ou(K)), Re.gState && z.setGState(Re.gState), Y(I.matrix.toString() + " cm"), Y("/" + Ee + " sh"), Y("Q");
    else if (Re instanceof mc) {
      var Ye = new Ne(1, 0, 0, -1, 0, ma());
      I.matrix && (Ye = Ye.multiply(I.matrix || tt), Ee = Pl.call(Re, I.key, I.boundingBox, I.xStep, I.yStep, Ye).id), Y("q"), Y("/Pattern cs"), Y("/" + Ee + " scn"), Re.gState && z.setGState(Re.gState), Y(K), Y("Q");
    }
  }, ou = function(I) {
    switch (I) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, po = z.moveTo = function(I, K) {
    return Y(ke(re(I)) + " " + ke(ye(K)) + " m"), this;
  }, ls = z.lineTo = function(I, K) {
    return Y(ke(re(I)) + " " + ke(ye(K)) + " l"), this;
  }, Ss = z.curveTo = function(I, K, Ee, Re, Ye, ct) {
    return Y([ke(re(I)), ke(ye(K)), ke(re(Ee)), ke(ye(Re)), ke(re(Ye)), ke(ye(ct)), "c"].join(" ")), this;
  };
  z.__private__.line = z.line = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.line");
    return Ce === fe.COMPAT ? this.lines([[Ee - I, Re - K]], I, K, [1, 1], Ye || "S") : this.lines([[Ee - I, Re - K]], I, K, [1, 1]).stroke();
  }, z.__private__.lines = z.lines = function(I, K, Ee, Re, Ye, ct) {
    var Dt, Ut, ui, bi, Ci, Ii, nr, Er, Ti, Yr, oi, yn;
    if (typeof I == "number" && (yn = Ee, Ee = K, K = I, I = yn), Re = Re || [1, 1], ct = ct || !1, isNaN(K) || isNaN(Ee) || !Array.isArray(I) || !Array.isArray(Re) || !Tn(Ye) || typeof ct != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (po(K, Ee), Dt = Re[0], Ut = Re[1], bi = I.length, Yr = K, oi = Ee, ui = 0; ui < bi; ui++) (Ci = I[ui]).length === 2 ? (Yr = Ci[0] * Dt + Yr, oi = Ci[1] * Ut + oi, ls(Yr, oi)) : (Ii = Ci[0] * Dt + Yr, nr = Ci[1] * Ut + oi, Er = Ci[2] * Dt + Yr, Ti = Ci[3] * Ut + oi, Yr = Ci[4] * Dt + Yr, oi = Ci[5] * Ut + oi, Ss(Ii, nr, Er, Ti, Yr, oi));
    return ct && Zs(), ho(Ye), this;
  }, z.path = function(I) {
    for (var K = 0; K < I.length; K++) {
      var Ee = I[K], Re = Ee.c;
      switch (Ee.op) {
        case "m":
          po(Re[0], Re[1]);
          break;
        case "l":
          ls(Re[0], Re[1]);
          break;
        case "c":
          Ss.apply(this, Re);
          break;
        case "h":
          Zs();
      }
    }
    return this;
  }, z.__private__.rect = z.rect = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return Ce === fe.COMPAT && (Re = -Re), Y([ke(re(I)), ke(ye(K)), ke(re(Ee)), ke(re(Re)), "re"].join(" ")), ho(Ye), this;
  }, z.__private__.triangle = z.triangle = function(I, K, Ee, Re, Ye, ct, Dt) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || isNaN(Ye) || isNaN(ct) || !Tn(Dt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ee - I, Re - K], [Ye - Ee, ct - Re], [I - Ye, K - ct]], I, K, [1, 1], Dt, !0), this;
  }, z.__private__.roundedRect = z.roundedRect = function(I, K, Ee, Re, Ye, ct, Dt) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || isNaN(Ye) || isNaN(ct) || !Tn(Dt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Ut = 4 / 3 * (Math.SQRT2 - 1);
    return Ye = Math.min(Ye, 0.5 * Ee), ct = Math.min(ct, 0.5 * Re), this.lines([[Ee - 2 * Ye, 0], [Ye * Ut, 0, Ye, ct - ct * Ut, Ye, ct], [0, Re - 2 * ct], [0, ct * Ut, -Ye * Ut, ct, -Ye, ct], [2 * Ye - Ee, 0], [-Ye * Ut, 0, -Ye, -ct * Ut, -Ye, -ct], [0, 2 * ct - Re], [0, -ct * Ut, Ye * Ut, -ct, Ye, -ct]], I + Ye, K, [1, 1], Dt, !0), this;
  }, z.__private__.ellipse = z.ellipse = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var ct = 4 / 3 * (Math.SQRT2 - 1) * Ee, Dt = 4 / 3 * (Math.SQRT2 - 1) * Re;
    return po(I + Ee, K), Ss(I + Ee, K - Dt, I + ct, K - Re, I, K - Re), Ss(I - ct, K - Re, I - Ee, K - Dt, I - Ee, K), Ss(I - Ee, K + Dt, I - ct, K + Re, I, K + Re), Ss(I + ct, K + Re, I + Ee, K + Dt, I + Ee, K), ho(Ye), this;
  }, z.__private__.circle = z.circle = function(I, K, Ee, Re) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || !Tn(Re)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(I, K, Ee, Ee, Re);
  }, z.setFont = function(I, K, Ee) {
    return Ee && (K = Qe(K, Ee)), si = $s(I, K, { disableWarning: !1 }), this;
  };
  var fo = z.__private__.getFont = z.getFont = function() {
    return Lt[$s.apply(z, arguments)];
  };
  z.__private__.getFontList = z.getFontList = function() {
    var I, K, Ee = {};
    for (I in Si) if (Si.hasOwnProperty(I)) for (K in Ee[I] = [], Si[I]) Si[I].hasOwnProperty(K) && Ee[I].push(K);
    return Ee;
  }, z.addFont = function(I, K, Ee, Re, Ye) {
    var ct = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && ct.indexOf(arguments[3]) !== -1 ? Ye = arguments[3] : arguments[3] && ct.indexOf(arguments[3]) == -1 && (Ee = Qe(Ee, Re)), Ye = Ye || "Identity-H", ln.call(this, I, K, Ee, Ye);
  };
  var Gs, Ra = s.lineWidth || 0.200025, un = z.__private__.getLineWidth = z.getLineWidth = function() {
    return Ra;
  }, Ll = z.__private__.setLineWidth = z.setLineWidth = function(I) {
    return Ra = I, Y(ke(re(I)) + " w"), this;
  };
  z.__private__.setLineDash = wi.API.setLineDash = wi.API.setLineDashPattern = function(I, K) {
    if (I = I || [], K = K || 0, isNaN(K) || !Array.isArray(I)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return I = I.map(function(Ee) {
      return ke(re(Ee));
    }).join(" "), K = ke(re(K)), Y("[" + I + "] " + K + " d"), this;
  };
  var mo = z.__private__.getLineHeight = z.getLineHeight = function() {
    return xt * Gs;
  };
  z.__private__.getLineHeight = z.getLineHeight = function() {
    return xt * Gs;
  };
  var Es = z.__private__.setLineHeightFactor = z.setLineHeightFactor = function(I) {
    return typeof (I = I || 1.15) == "number" && (Gs = I), this;
  }, us = z.__private__.getLineHeightFactor = z.getLineHeightFactor = function() {
    return Gs;
  };
  Es(s.lineHeight);
  var Di = z.__private__.getHorizontalCoordinate = function(I) {
    return re(I);
  }, cs = z.__private__.getVerticalCoordinate = function(I) {
    return Ce === fe.ADVANCED ? I : B[_e].mediaBox.topRightY - B[_e].mediaBox.bottomLeftY - re(I);
  }, lu = z.__private__.getHorizontalCoordinateString = z.getHorizontalCoordinateString = function(I) {
    return ke(Di(I));
  }, kn = z.__private__.getVerticalCoordinateString = z.getVerticalCoordinateString = function(I) {
    return ke(cs(I));
  }, hs = s.strokeColor || "0 G";
  z.__private__.getStrokeColor = z.getDrawColor = function() {
    return pi(hs);
  }, z.__private__.setStrokeColor = z.setDrawColor = function(I, K, Ee, Re) {
    return hs = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "draw", precision: 2 }), Y(hs), this;
  };
  var go = s.fillColor || "0 g";
  z.__private__.getFillColor = z.getFillColor = function() {
    return pi(go);
  }, z.__private__.setFillColor = z.setFillColor = function(I, K, Ee, Re) {
    return go = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "fill", precision: 2 }), Y(go), this;
  };
  var Oa = s.textColor || "0 g", Ml = z.__private__.getTextColor = z.getTextColor = function() {
    return pi(Oa);
  };
  z.__private__.setTextColor = z.setTextColor = function(I, K, Ee, Re) {
    return Oa = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "text", precision: 3 }), this;
  };
  var fa = s.charSpace, Nl = z.__private__.getCharSpace = z.getCharSpace = function() {
    return parseFloat(fa || 0);
  };
  z.__private__.setCharSpace = z.setCharSpace = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return fa = I, this;
  };
  var _o = 0;
  z.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, z.__private__.setLineCap = z.setLineCap = function(I) {
    var K = z.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line cap style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return _o = K, Y(K + " J"), this;
  };
  var yo = 0;
  z.__private__.setLineJoin = z.setLineJoin = function(I) {
    var K = z.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line join style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return yo = K, Y(K + " j"), this;
  }, z.__private__.setLineMiterLimit = z.__private__.setMiterLimit = z.setLineMiterLimit = z.setMiterLimit = function(I) {
    if (I = I || 0, isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Y(ke(re(I)) + " M"), this;
  }, z.GState = pd, z.setGState = function(I) {
    (I = typeof I == "string" ? Ni[ie[I]] : il(null, I)).equals(ue) || (Y("/" + I.id + " gs"), ue = I);
  };
  var il = function(I, K) {
    if (!I || !ie[I]) {
      var Ee = !1;
      for (var Re in Ni) if (Ni.hasOwnProperty(Re) && Ni[Re].equals(K)) {
        Ee = !0;
        break;
      }
      if (Ee) K = Ni[Re];
      else {
        var Ye = "GS" + (Object.keys(Ni).length + 1).toString(10);
        Ni[Ye] = K, K.id = Ye;
      }
      return I && (ie[I] = K.id), q.publish("addGState", K), K;
    }
  };
  z.addGState = function(I, K) {
    return il(I, K), this;
  }, z.saveGraphicsState = function() {
    return Y("q"), Gi.push({ key: si, size: xt, color: Oa }), this;
  }, z.restoreGraphicsState = function() {
    Y("Q");
    var I = Gi.pop();
    return si = I.key, xt = I.size, Oa = I.color, ue = null, this;
  }, z.setCurrentTransformationMatrix = function(I) {
    return Y(I.toString() + " cm"), this;
  }, z.comment = function(I) {
    return Y("#" + I), this;
  };
  var jn = function(I, K) {
    var Ee = I || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ee;
    }, set: function(ct) {
      isNaN(ct) || (Ee = parseFloat(ct));
    } });
    var Re = K || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Re;
    }, set: function(ct) {
      isNaN(ct) || (Re = parseFloat(ct));
    } });
    var Ye = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ye;
    }, set: function(ct) {
      Ye = ct.toString();
    } }), this;
  }, vo = function(I, K, Ee, Re) {
    jn.call(this, I, K), this.type = "rect";
    var Ye = Ee || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ye;
    }, set: function(Dt) {
      isNaN(Dt) || (Ye = parseFloat(Dt));
    } });
    var ct = Re || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return ct;
    }, set: function(Dt) {
      isNaN(Dt) || (ct = parseFloat(Dt));
    } }), this;
  }, rl = function() {
    this.page = $, this.currentPage = _e, this.pages = ot.slice(0), this.pagesContext = B.slice(0), this.x = Zi, this.y = ft, this.matrix = ri, this.width = Cs(_e), this.height = ma(_e), this.outputDestination = mt, this.id = "", this.objectNumber = -1;
  };
  rl.prototype.restore = function() {
    $ = this.page, _e = this.currentPage, B = this.pagesContext, ot = this.pages, Zi = this.x, ft = this.y, ri = this.matrix, sl(_e, this.width), xo(_e, this.height), mt = this.outputDestination;
  };
  var nl = function(I, K, Ee, Re, Ye) {
    Fe.push(new rl()), $ = _e = 0, ot = [], Zi = I, ft = K, ri = Ye, as([Ee, Re]);
  }, ja = function(I) {
    if (Me[I]) Fe.pop().restore();
    else {
      var K = new rl(), Ee = "Xo" + (Object.keys(ge).length + 1).toString(10);
      K.id = Ee, Me[I] = Ee, ge[Ee] = K, q.publish("addFormObject", K), Fe.pop().restore();
    }
  };
  for (var bo in z.beginFormObject = function(I, K, Ee, Re, Ye) {
    return nl(I, K, Ee, Re, Ye), this;
  }, z.endFormObject = function(I) {
    return ja(I), this;
  }, z.doFormObject = function(I, K) {
    var Ee = ge[Me[I]];
    return Y("q"), Y(K.toString() + " cm"), Y("/" + Ee.id + " Do"), Y("Q"), this;
  }, z.getFormObject = function(I) {
    var K = ge[Me[I]];
    return { x: K.x, y: K.y, width: K.width, height: K.height, matrix: K.matrix };
  }, z.save = function(I, K) {
    return I = I || "generated.pdf", (K = K || {}).returnPromise = K.returnPromise || !1, K.returnPromise === !1 ? (Du(oo(As()), I), typeof Du.unload == "function" && Ai.setTimeout && setTimeout(Du.unload, 911), this) : new Promise(function(Ee, Re) {
      try {
        var Ye = Du(oo(As()), I);
        typeof Du.unload == "function" && Ai.setTimeout && setTimeout(Du.unload, 911), Ee(Ye);
      } catch (ct) {
        Re(ct.message);
      }
    });
  }, wi.API) wi.API.hasOwnProperty(bo) && (bo === "events" && wi.API.events.length ? function(I, K) {
    var Ee, Re, Ye;
    for (Ye = K.length - 1; Ye !== -1; Ye--) Ee = K[Ye][0], Re = K[Ye][1], I.subscribe.apply(I, [Ee].concat(typeof Re == "function" ? [Re] : Re));
  }(q, wi.API.events) : z[bo] = wi.API[bo]);
  var Cs = z.getPageWidth = function(I) {
    return (B[I = I || _e].mediaBox.topRightX - B[I].mediaBox.bottomLeftX) / It;
  }, sl = z.setPageWidth = function(I, K) {
    B[I].mediaBox.topRightX = K * It + B[I].mediaBox.bottomLeftX;
  }, ma = z.getPageHeight = function(I) {
    return (B[I = I || _e].mediaBox.topRightY - B[I].mediaBox.bottomLeftY) / It;
  }, xo = z.setPageHeight = function(I, K) {
    B[I].mediaBox.topRightY = K * It + B[I].mediaBox.bottomLeftY;
  };
  return z.internal = { pdfEscape: jr, getStyle: tl, getFont: fo, getFontSize: Et, getCharSpace: Nl, getTextColor: Ml, getLineHeight: mo, getLineHeightFactor: us, getLineWidth: un, write: Kt, getHorizontalCoordinate: Di, getVerticalCoordinate: cs, getCoordinateString: lu, getVerticalCoordinateString: kn, collections: {}, newObject: We, newAdditionalObject: $t, newObjectDeferred: gt, newObjectDeferredBegin: Mt, getFilters: Wi, putStream: Oi, events: q, scaleFactor: It, pageSize: { getWidth: function() {
    return Cs(_e);
  }, setWidth: function(I) {
    sl(_e, I);
  }, getHeight: function() {
    return ma(_e);
  }, setHeight: function(I) {
    xo(_e, I);
  } }, encryptionOptions: L, encryption: wr, getEncryptor: Ba, output: Fa, getNumberOfPages: Qo, pages: ot, out: Y, f2: ve, f3: X, getPageInfo: qr, getPageInfoByObjId: ai, getCurrentPageInfo: lo, getPDFVersion: oe, Point: jn, Rectangle: vo, Matrix: Ne, hasHotfix: Il }, Object.defineProperty(z.internal.pageSize, "width", { get: function() {
    return Cs(_e);
  }, set: function(I) {
    sl(_e, I);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(z.internal.pageSize, "height", { get: function() {
    return ma(_e);
  }, set: function(I) {
    xo(_e, I);
  }, enumerable: !0, configurable: !0 }), Ko.call(z, lt), si = "F1", os(y, a), q.publish("initialized"), z;
}
pc.prototype.lsbFirstWord = function(s) {
  return String.fromCharCode(s >> 0 & 255, s >> 8 & 255, s >> 16 & 255, s >> 24 & 255);
}, pc.prototype.toHexString = function(s) {
  return s.split("").map(function(l) {
    return ("0" + (255 & l.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, pc.prototype.hexToBytes = function(s) {
  for (var l = [], a = 0; a < s.length; a += 2) l.push(String.fromCharCode(parseInt(s.substr(a, 2), 16)));
  return l.join("");
}, pc.prototype.processOwnerPassword = function(s, l) {
  return nf(rf(l).substr(0, 5), s);
}, pc.prototype.encryptor = function(s, l) {
  var a = rf(this.encryptionKey + String.fromCharCode(255 & s, s >> 8 & 255, s >> 16 & 255, 255 & l, l >> 8 & 255)).substr(0, 10);
  return function(m) {
    return nf(a, m);
  };
}, pd.prototype.equals = function(s) {
  var l, a = "id,objectNumber,equals";
  if (!s || ur(s) !== ur(this)) return !1;
  var m = 0;
  for (l in this) if (!(a.indexOf(l) >= 0)) {
    if (this.hasOwnProperty(l) && !s.hasOwnProperty(l) || this[l] !== s[l]) return !1;
    m++;
  }
  for (l in s) s.hasOwnProperty(l) && a.indexOf(l) < 0 && m--;
  return m === 0;
}, wi.API = { events: [] }, wi.version = "2.5.1";
var Or = wi.API, _f = 1, ju = function(s) {
  return s.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, hc = function(s) {
  return s.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Pi = function(s) {
  return s.toFixed(2);
}, Yl = function(s) {
  return s.toFixed(5);
};
Or.__acroform__ = {};
var qs = function(s, l) {
  s.prototype = Object.create(l.prototype), s.prototype.constructor = s;
}, Zg = function(s) {
  return s * _f;
}, Vo = function(s) {
  var l = new c1(), a = ti.internal.getHeight(s) || 0, m = ti.internal.getWidth(s) || 0;
  return l.BBox = [0, 0, Number(Pi(m)), Number(Pi(a))], l;
}, Wb = Or.__acroform__.setBit = function(s, l) {
  if (s = s || 0, l = l || 0, isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return s |= 1 << l;
}, Xb = Or.__acroform__.clearBit = function(s, l) {
  if (s = s || 0, l = l || 0, isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return s &= ~(1 << l);
}, Yb = Or.__acroform__.getBit = function(s, l) {
  if (isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return s & 1 << l ? 1 : 0;
}, Zr = Or.__acroform__.getBitForPdf = function(s, l) {
  if (isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return Yb(s, l - 1);
}, Gr = Or.__acroform__.setBitForPdf = function(s, l) {
  if (isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return Wb(s, l - 1);
}, Hr = Or.__acroform__.clearBitForPdf = function(s, l) {
  if (isNaN(s) || isNaN(l)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Xb(s, l - 1);
}, Jb = Or.__acroform__.calculateCoordinates = function(s, l) {
  var a = l.internal.getHorizontalCoordinate, m = l.internal.getVerticalCoordinate, y = s[0], _ = s[1], g = s[2], o = s[3], k = {};
  return k.lowerLeft_X = a(y) || 0, k.lowerLeft_Y = m(_ + o) || 0, k.upperRight_X = a(y + g) || 0, k.upperRight_Y = m(_) || 0, [Number(Pi(k.lowerLeft_X)), Number(Pi(k.lowerLeft_Y)), Number(Pi(k.upperRight_X)), Number(Pi(k.upperRight_Y))];
}, Kb = function(s) {
  if (s.appearanceStreamContent) return s.appearanceStreamContent;
  if (s.V || s.DV) {
    var l = [], a = s._V || s.DV, m = sf(s, a), y = s.scope.internal.getFont(s.fontName, s.fontStyle).id;
    l.push("/Tx BMC"), l.push("q"), l.push("BT"), l.push(s.scope.__private__.encodeColorString(s.color)), l.push("/" + y + " " + Pi(m.fontSize) + " Tf"), l.push("1 0 0 1 0 0 Tm"), l.push(m.text), l.push("ET"), l.push("Q"), l.push("EMC");
    var _ = Vo(s);
    return _.scope = s.scope, _.stream = l.join(`
`), _;
  }
}, sf = function(s, l) {
  var a = s.fontSize === 0 ? s.maxFontSize : s.fontSize, m = { text: "", fontSize: "" }, y = (l = (l = l.substr(0, 1) == "(" ? l.substr(1) : l).substr(l.length - 1) == ")" ? l.substr(0, l.length - 1) : l).split(" ");
  y = s.multiline ? y.map(function(X) {
    return X.split(`
`);
  }) : y.map(function(X) {
    return [X];
  });
  var _ = a, g = ti.internal.getHeight(s) || 0;
  g = g < 0 ? -g : g;
  var o = ti.internal.getWidth(s) || 0;
  o = o < 0 ? -o : o;
  var k = function(X, re, xe) {
    if (X + 1 < y.length) {
      var ye = re + " " + y[X + 1][0];
      return Qh(ye, s, xe).width <= o - 4;
    }
    return !1;
  };
  _++;
  e: for (; _ > 0; ) {
    l = "", _--;
    var D, L, j = Qh("3", s, _).height, O = s.multiline ? g - _ : (g - j) / 2, z = O += 2, pe = 0, oe = 0, ae = 0;
    if (_ <= 0) {
      l = `(...) Tj
`, l += "% Width of Text: " + Qh(l, s, _ = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var Q = "", fe = 0, Ce = 0; Ce < y.length; Ce++) if (y.hasOwnProperty(Ce)) {
      var ze = !1;
      if (y[Ce].length !== 1 && ae !== y[Ce].length - 1) {
        if ((j + 2) * (fe + 2) + 2 > g) continue e;
        Q += y[Ce][ae], ze = !0, oe = Ce, Ce--;
      } else {
        Q = (Q += y[Ce][ae] + " ").substr(Q.length - 1) == " " ? Q.substr(0, Q.length - 1) : Q;
        var je = parseInt(Ce), Qe = k(je, Q, _), ke = Ce >= y.length - 1;
        if (Qe && !ke) {
          Q += " ", ae = 0;
          continue;
        }
        if (Qe || ke) {
          if (ke) oe = je;
          else if (s.multiline && (j + 2) * (fe + 2) + 2 > g) continue e;
        } else {
          if (!s.multiline || (j + 2) * (fe + 2) + 2 > g) continue e;
          oe = je;
        }
      }
      for (var Ae = "", me = pe; me <= oe; me++) {
        var ve = y[me];
        if (s.multiline) {
          if (me === oe) {
            Ae += ve[ae] + " ", ae = (ae + 1) % ve.length;
            continue;
          }
          if (me === pe) {
            Ae += ve[ve.length - 1] + " ";
            continue;
          }
        }
        Ae += ve[0] + " ";
      }
      switch (Ae = Ae.substr(Ae.length - 1) == " " ? Ae.substr(0, Ae.length - 1) : Ae, L = Qh(Ae, s, _).width, s.textAlign) {
        case "right":
          D = o - L - 2;
          break;
        case "center":
          D = (o - L) / 2;
          break;
        case "left":
        default:
          D = 2;
      }
      l += Pi(D) + " " + Pi(z) + ` Td
`, l += "(" + ju(Ae) + `) Tj
`, l += -Pi(D) + ` 0 Td
`, z = -(_ + 2), L = 0, pe = ze ? oe : oe + 1, fe++, Q = "";
    }
    break;
  }
  return m.text = l, m.fontSize = _, m;
}, Qh = function(s, l, a) {
  var m = l.scope.internal.getFont(l.fontName, l.fontStyle), y = l.scope.getStringUnitWidth(s, { font: m, fontSize: parseFloat(a), charSpace: 0 }) * parseFloat(a);
  return { height: l.scope.getStringUnitWidth("3", { font: m, fontSize: parseFloat(a), charSpace: 0 }) * parseFloat(a) * 1.5, width: y };
}, Qb = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, ex = function(s, l) {
  var a = { type: "reference", object: s };
  l.internal.getPageInfo(s.page).pageContext.annotations.find(function(m) {
    return m.type === a.type && m.object === a.object;
  }) === void 0 && l.internal.getPageInfo(s.page).pageContext.annotations.push(a);
}, tx = function(s, l) {
  for (var a in s) if (s.hasOwnProperty(a)) {
    var m = a, y = s[a];
    l.internal.newObjectDeferredBegin(y.objId, !0), ur(y) === "object" && typeof y.putStream == "function" && y.putStream(), delete s[m];
  }
}, ix = function(s, l) {
  if (l.scope = s, s.internal !== void 0 && (s.internal.acroformPlugin === void 0 || s.internal.acroformPlugin.isInitialized === !1)) {
    if (io.FieldNum = 0, s.internal.acroformPlugin = JSON.parse(JSON.stringify(Qb)), s.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    _f = s.internal.scaleFactor, s.internal.acroformPlugin.acroFormDictionaryRoot = new h1(), s.internal.acroformPlugin.acroFormDictionaryRoot.scope = s, s.internal.acroformPlugin.acroFormDictionaryRoot._eventID = s.internal.events.subscribe("postPutResources", function() {
      (function(a) {
        a.internal.events.unsubscribe(a.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete a.internal.acroformPlugin.acroFormDictionaryRoot._eventID, a.internal.acroformPlugin.printedOut = !0;
      })(s);
    }), s.internal.events.subscribe("buildDocument", function() {
      (function(a) {
        a.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var m = a.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var y in m) if (m.hasOwnProperty(y)) {
          var _ = m[y];
          _.objId = void 0, _.hasAnnotation && ex(_, a);
        }
      })(s);
    }), s.internal.events.subscribe("putCatalog", function() {
      (function(a) {
        if (a.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        a.internal.write("/AcroForm " + a.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(s);
    }), s.internal.events.subscribe("postPutPages", function(a) {
      (function(m, y) {
        var _ = !m;
        for (var g in m || (y.internal.newObjectDeferredBegin(y.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), y.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), m = m || y.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (m.hasOwnProperty(g)) {
          var o = m[g], k = [], D = o.Rect;
          if (o.Rect && (o.Rect = Jb(o.Rect, y)), y.internal.newObjectDeferredBegin(o.objId, !0), o.DA = ti.createDefaultAppearanceStream(o), ur(o) === "object" && typeof o.getKeyValueListForStream == "function" && (k = o.getKeyValueListForStream()), o.Rect = D, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var L = Kb(o);
            k.push({ key: "AP", value: "<</N " + L + ">>" }), y.internal.acroformPlugin.xForms.push(L);
          }
          if (o.appearanceStreamContent) {
            var j = "";
            for (var O in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(O)) {
              var z = o.appearanceStreamContent[O];
              if (j += "/" + O + " ", j += "<<", Object.keys(z).length >= 1 || Array.isArray(z)) {
                for (var g in z) if (z.hasOwnProperty(g)) {
                  var pe = z[g];
                  typeof pe == "function" && (pe = pe.call(y, o)), j += "/" + g + " " + pe + " ", y.internal.acroformPlugin.xForms.indexOf(pe) >= 0 || y.internal.acroformPlugin.xForms.push(pe);
                }
              } else typeof (pe = z) == "function" && (pe = pe.call(y, o)), j += "/" + g + " " + pe, y.internal.acroformPlugin.xForms.indexOf(pe) >= 0 || y.internal.acroformPlugin.xForms.push(pe);
              j += ">>";
            }
            k.push({ key: "AP", value: `<<
` + j + ">>" });
          }
          y.internal.putStream({ additionalKeyValues: k, objectId: o.objId }), y.internal.out("endobj");
        }
        _ && tx(y.internal.acroformPlugin.xForms, y);
      })(a, s);
    }), s.internal.acroformPlugin.isInitialized = !0;
  }
}, u1 = Or.__acroform__.arrayToPdfArray = function(s, l, a) {
  var m = function(g) {
    return g;
  };
  if (Array.isArray(s)) {
    for (var y = "[", _ = 0; _ < s.length; _++) switch (_ !== 0 && (y += " "), ur(s[_])) {
      case "boolean":
      case "number":
      case "object":
        y += s[_].toString();
        break;
      case "string":
        s[_].substr(0, 1) !== "/" ? (l !== void 0 && a && (m = a.internal.getEncryptor(l)), y += "(" + ju(m(s[_].toString())) + ")") : y += s[_].toString();
    }
    return y += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Pp = function(s, l, a) {
  var m = function(y) {
    return y;
  };
  return l !== void 0 && a && (m = a.internal.getEncryptor(l)), (s = s || "").toString(), s = "(" + ju(m(s)) + ")";
}, Zo = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(s) {
    this._objId = s;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Zo.prototype.toString = function() {
  return this.objId + " 0 R";
}, Zo.prototype.putStream = function() {
  var s = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: s, objectId: this.objId }), this.scope.internal.out("endobj");
}, Zo.prototype.getKeyValueListForStream = function() {
  var s = [], l = Object.getOwnPropertyNames(this).filter(function(_) {
    return _ != "content" && _ != "appearanceStreamContent" && _ != "scope" && _ != "objId" && _.substring(0, 1) != "_";
  });
  for (var a in l) if (Object.getOwnPropertyDescriptor(this, l[a]).configurable === !1) {
    var m = l[a], y = this[m];
    y && (Array.isArray(y) ? s.push({ key: m, value: u1(y, this.objId, this.scope) }) : y instanceof Zo ? (y.scope = this.scope, s.push({ key: m, value: y.objId + " 0 R" })) : typeof y != "function" && s.push({ key: m, value: y }));
  }
  return s;
};
var c1 = function() {
  Zo.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var s, l = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return l;
  }, set: function(a) {
    l = a;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(a) {
    s = a.trim();
  }, get: function() {
    return s || null;
  } });
};
qs(c1, Zo);
var h1 = function() {
  Zo.call(this);
  var s, l = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return l.length > 0 ? l : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return l;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (s) {
      var a = function(m) {
        return m;
      };
      return this.scope && (a = this.scope.internal.getEncryptor(this.objId)), "(" + ju(a(s)) + ")";
    }
  }, set: function(a) {
    s = a;
  } });
};
qs(h1, Zo);
var io = function s() {
  Zo.call(this);
  var l = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return l;
  }, set: function(Q) {
    if (isNaN(Q)) throw new Error('Invalid value "' + Q + '" for attribute F supplied.');
    l = Q;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(l, 3);
  }, set: function(Q) {
    Q ? this.F = Gr(l, 3) : this.F = Hr(l, 3);
  } });
  var a = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return a;
  }, set: function(Q) {
    if (isNaN(Q)) throw new Error('Invalid value "' + Q + '" for attribute Ff supplied.');
    a = Q;
  } });
  var m = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (m.length !== 0) return m;
  }, set: function(Q) {
    m = Q !== void 0 ? Q : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[0]) ? 0 : m[0];
  }, set: function(Q) {
    m[0] = Q;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[1]) ? 0 : m[1];
  }, set: function(Q) {
    m[1] = Q;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[2]) ? 0 : m[2];
  }, set: function(Q) {
    m[2] = Q;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[3]) ? 0 : m[3];
  }, set: function(Q) {
    m[3] = Q;
  } });
  var y = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return y;
  }, set: function(Q) {
    switch (Q) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        y = Q;
        break;
      default:
        throw new Error('Invalid value "' + Q + '" for attribute FT supplied.');
    }
  } });
  var _ = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!_ || _.length < 1) {
      if (this instanceof fd) return;
      _ = "FieldObject" + s.FieldNum++;
    }
    var Q = function(fe) {
      return fe;
    };
    return this.scope && (Q = this.scope.internal.getEncryptor(this.objId)), "(" + ju(Q(_)) + ")";
  }, set: function(Q) {
    _ = Q.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return _;
  }, set: function(Q) {
    _ = Q;
  } });
  var g = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return g;
  }, set: function(Q) {
    g = Q;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(Q) {
    o = Q;
  } });
  var k = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return k;
  }, set: function(Q) {
    k = Q;
  } });
  var D = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return D === void 0 ? 50 / _f : D;
  }, set: function(Q) {
    D = Q;
  } });
  var L = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return L;
  }, set: function(Q) {
    L = Q;
  } });
  var j = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!j || this instanceof fd || this instanceof zu)) return Pp(j, this.objId, this.scope);
  }, set: function(Q) {
    Q = Q.toString(), j = Q;
  } });
  var O = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (O) return this instanceof Cn ? O : Pp(O, this.objId, this.scope);
  }, set: function(Q) {
    Q = Q.toString(), O = this instanceof Cn ? Q : Q.substr(0, 1) === "(" ? hc(Q.substr(1, Q.length - 2)) : hc(Q);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Cn ? hc(O.substr(1, O.length - 1)) : O;
  }, set: function(Q) {
    Q = Q.toString(), O = this instanceof Cn ? "/" + Q : Q;
  } });
  var z = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (z) return z;
  }, set: function(Q) {
    this.V = Q;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (z) return this instanceof Cn ? z : Pp(z, this.objId, this.scope);
  }, set: function(Q) {
    Q = Q.toString(), z = this instanceof Cn ? Q : Q.substr(0, 1) === "(" ? hc(Q.substr(1, Q.length - 2)) : hc(Q);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Cn ? hc(z.substr(1, z.length - 1)) : z;
  }, set: function(Q) {
    Q = Q.toString(), z = this instanceof Cn ? "/" + Q : Q;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var pe, oe = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return oe;
  }, set: function(Q) {
    Q = !!Q, oe = Q;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (pe) return pe;
  }, set: function(Q) {
    pe = Q;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 1);
  }, set: function(Q) {
    Q ? this.Ff = Gr(this.Ff, 1) : this.Ff = Hr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 2);
  }, set: function(Q) {
    Q ? this.Ff = Gr(this.Ff, 2) : this.Ff = Hr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 3);
  }, set: function(Q) {
    Q ? this.Ff = Gr(this.Ff, 3) : this.Ff = Hr(this.Ff, 3);
  } });
  var ae = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (ae !== null) return ae;
  }, set: function(Q) {
    if ([0, 1, 2].indexOf(Q) === -1) throw new Error('Invalid value "' + Q + '" for attribute Q supplied.');
    ae = Q;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var Q;
    switch (ae) {
      case 0:
      default:
        Q = "left";
        break;
      case 1:
        Q = "center";
        break;
      case 2:
        Q = "right";
    }
    return Q;
  }, configurable: !0, enumerable: !0, set: function(Q) {
    switch (Q) {
      case "right":
      case 2:
        ae = 2;
        break;
      case "center":
      case 1:
        ae = 1;
        break;
      case "left":
      case 0:
      default:
        ae = 0;
    }
  } });
};
qs(io, Zo);
var _c = function() {
  io.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var s = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return s;
  }, set: function(a) {
    s = a;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return s;
  }, set: function(a) {
    s = a;
  } });
  var l = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return u1(l, this.objId, this.scope);
  }, set: function(a) {
    var m, y;
    y = [], typeof (m = a) == "string" && (y = function(_, g, o) {
      o || (o = 1);
      for (var k, D = []; k = g.exec(_); ) D.push(k[o]);
      return D;
    }(m, /\((.*?)\)/g)), l = y;
  } }), this.getOptions = function() {
    return l;
  }, this.setOptions = function(a) {
    l = a, this.sort && l.sort();
  }, this.addOption = function(a) {
    a = (a = a || "").toString(), l.push(a), this.sort && l.sort();
  }, this.removeOption = function(a, m) {
    for (m = m || !1, a = (a = a || "").toString(); l.indexOf(a) !== -1 && (l.splice(l.indexOf(a), 1), m !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 18);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 18) : this.Ff = Hr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 19);
  }, set: function(a) {
    this.combo === !0 && (a ? this.Ff = Gr(this.Ff, 19) : this.Ff = Hr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 20);
  }, set: function(a) {
    a ? (this.Ff = Gr(this.Ff, 20), l.sort()) : this.Ff = Hr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 22);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 22) : this.Ff = Hr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 23);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 23) : this.Ff = Hr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 27);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 27) : this.Ff = Hr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
qs(_c, io);
var yc = function() {
  _c.call(this), this.fontName = "helvetica", this.combo = !1;
};
qs(yc, _c);
var vc = function() {
  yc.call(this), this.combo = !0;
};
qs(vc, yc);
var nd = function() {
  vc.call(this), this.edit = !0;
};
qs(nd, vc);
var Cn = function() {
  io.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 15);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 15) : this.Ff = Hr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 16);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 16) : this.Ff = Hr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 17);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 17) : this.Ff = Hr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 26);
  }, set: function(a) {
    a ? this.Ff = Gr(this.Ff, 26) : this.Ff = Hr(this.Ff, 26);
  } });
  var s, l = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var a = function(_) {
      return _;
    };
    if (this.scope && (a = this.scope.internal.getEncryptor(this.objId)), Object.keys(l).length !== 0) {
      var m, y = [];
      for (m in y.push("<<"), l) y.push("/" + m + " (" + ju(a(l[m])) + ")");
      return y.push(">>"), y.join(`
`);
    }
  }, set: function(a) {
    ur(a) === "object" && (l = a);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return l.CA || "";
  }, set: function(a) {
    typeof a == "string" && (l.CA = a);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return s;
  }, set: function(a) {
    s = a;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return s.substr(1, s.length - 1);
  }, set: function(a) {
    s = "/" + a;
  } });
};
qs(Cn, io);
var sd = function() {
  Cn.call(this), this.pushButton = !0;
};
qs(sd, Cn);
var bc = function() {
  Cn.call(this), this.radio = !0, this.pushButton = !1;
  var s = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return s;
  }, set: function(l) {
    s = l !== void 0 ? l : [];
  } });
};
qs(bc, Cn);
var fd = function() {
  var s, l;
  io.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return s;
  }, set: function(y) {
    s = y;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return l;
  }, set: function(y) {
    l = y;
  } });
  var a, m = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var y = function(o) {
      return o;
    };
    this.scope && (y = this.scope.internal.getEncryptor(this.objId));
    var _, g = [];
    for (_ in g.push("<<"), m) g.push("/" + _ + " (" + ju(y(m[_])) + ")");
    return g.push(">>"), g.join(`
`);
  }, set: function(y) {
    ur(y) === "object" && (m = y);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return m.CA || "";
  }, set: function(y) {
    typeof y == "string" && (m.CA = y);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return a;
  }, set: function(y) {
    a = y;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return a.substr(1, a.length - 1);
  }, set: function(y) {
    a = "/" + y;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = ti.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
qs(fd, io), bc.prototype.setAppearance = function(s) {
  if (!("createAppearanceStream" in s) || !("getCA" in s)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var l in this.Kids) if (this.Kids.hasOwnProperty(l)) {
    var a = this.Kids[l];
    a.appearanceStreamContent = s.createAppearanceStream(a.optionName), a.caption = s.getCA();
  }
}, bc.prototype.createOption = function(s) {
  var l = new fd();
  return l.Parent = this, l.optionName = s, this.Kids.push(l), rx.call(this.scope, l), l;
};
var ad = function() {
  Cn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = ti.CheckBox.createAppearanceStream();
};
qs(ad, Cn);
var zu = function() {
  io.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 13);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 13) : this.Ff = Hr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 21);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 21) : this.Ff = Hr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 23);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 23) : this.Ff = Hr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 24);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 24) : this.Ff = Hr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 25);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 25) : this.Ff = Hr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 26);
  }, set: function(l) {
    l ? this.Ff = Gr(this.Ff, 26) : this.Ff = Hr(this.Ff, 26);
  } });
  var s = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return s;
  }, set: function(l) {
    s = l;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return s;
  }, set: function(l) {
    Number.isInteger(l) && (s = l);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
qs(zu, io);
var od = function() {
  zu.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Zr(this.Ff, 14);
  }, set: function(s) {
    s ? this.Ff = Gr(this.Ff, 14) : this.Ff = Hr(this.Ff, 14);
  } }), this.password = !0;
};
qs(od, zu);
var ti = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: ti.CheckBox.YesNormal }, D: { On: ti.CheckBox.YesPushDown, Off: ti.CheckBox.OffPushDown } };
}, YesPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [], m = s.scope.internal.getFont(s.fontName, s.fontStyle).id, y = s.scope.__private__.encodeColorString(s.color), _ = sf(s, s.caption);
  return a.push("0.749023 g"), a.push("0 0 " + Pi(ti.internal.getWidth(s)) + " " + Pi(ti.internal.getHeight(s)) + " re"), a.push("f"), a.push("BMC"), a.push("q"), a.push("0 0 1 rg"), a.push("/" + m + " " + Pi(_.fontSize) + " Tf " + y), a.push("BT"), a.push(_.text), a.push("ET"), a.push("Q"), a.push("EMC"), l.stream = a.join(`
`), l;
}, YesNormal: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = s.scope.internal.getFont(s.fontName, s.fontStyle).id, m = s.scope.__private__.encodeColorString(s.color), y = [], _ = ti.internal.getHeight(s), g = ti.internal.getWidth(s), o = sf(s, s.caption);
  return y.push("1 g"), y.push("0 0 " + Pi(g) + " " + Pi(_) + " re"), y.push("f"), y.push("q"), y.push("0 0 1 rg"), y.push("0 0 " + Pi(g - 1) + " " + Pi(_ - 1) + " re"), y.push("W"), y.push("n"), y.push("0 g"), y.push("BT"), y.push("/" + a + " " + Pi(o.fontSize) + " Tf " + m), y.push(o.text), y.push("ET"), y.push("Q"), l.stream = y.join(`
`), l;
}, OffPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [];
  return a.push("0.749023 g"), a.push("0 0 " + Pi(ti.internal.getWidth(s)) + " " + Pi(ti.internal.getHeight(s)) + " re"), a.push("f"), l.stream = a.join(`
`), l;
} }, RadioButton: { Circle: { createAppearanceStream: function(s) {
  var l = { D: { Off: ti.RadioButton.Circle.OffPushDown }, N: {} };
  return l.N[s] = ti.RadioButton.Circle.YesNormal, l.D[s] = ti.RadioButton.Circle.YesPushDown, l;
}, getCA: function() {
  return "l";
}, YesNormal: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [], m = ti.internal.getWidth(s) <= ti.internal.getHeight(s) ? ti.internal.getWidth(s) / 4 : ti.internal.getHeight(s) / 4;
  m = Number((0.9 * m).toFixed(5));
  var y = ti.internal.Bezier_C, _ = Number((m * y).toFixed(5));
  return a.push("q"), a.push("1 0 0 1 " + Yl(ti.internal.getWidth(s) / 2) + " " + Yl(ti.internal.getHeight(s) / 2) + " cm"), a.push(m + " 0 m"), a.push(m + " " + _ + " " + _ + " " + m + " 0 " + m + " c"), a.push("-" + _ + " " + m + " -" + m + " " + _ + " -" + m + " 0 c"), a.push("-" + m + " -" + _ + " -" + _ + " -" + m + " 0 -" + m + " c"), a.push(_ + " -" + m + " " + m + " -" + _ + " " + m + " 0 c"), a.push("f"), a.push("Q"), l.stream = a.join(`
`), l;
}, YesPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [], m = ti.internal.getWidth(s) <= ti.internal.getHeight(s) ? ti.internal.getWidth(s) / 4 : ti.internal.getHeight(s) / 4;
  m = Number((0.9 * m).toFixed(5));
  var y = Number((2 * m).toFixed(5)), _ = Number((y * ti.internal.Bezier_C).toFixed(5)), g = Number((m * ti.internal.Bezier_C).toFixed(5));
  return a.push("0.749023 g"), a.push("q"), a.push("1 0 0 1 " + Yl(ti.internal.getWidth(s) / 2) + " " + Yl(ti.internal.getHeight(s) / 2) + " cm"), a.push(y + " 0 m"), a.push(y + " " + _ + " " + _ + " " + y + " 0 " + y + " c"), a.push("-" + _ + " " + y + " -" + y + " " + _ + " -" + y + " 0 c"), a.push("-" + y + " -" + _ + " -" + _ + " -" + y + " 0 -" + y + " c"), a.push(_ + " -" + y + " " + y + " -" + _ + " " + y + " 0 c"), a.push("f"), a.push("Q"), a.push("0 g"), a.push("q"), a.push("1 0 0 1 " + Yl(ti.internal.getWidth(s) / 2) + " " + Yl(ti.internal.getHeight(s) / 2) + " cm"), a.push(m + " 0 m"), a.push(m + " " + g + " " + g + " " + m + " 0 " + m + " c"), a.push("-" + g + " " + m + " -" + m + " " + g + " -" + m + " 0 c"), a.push("-" + m + " -" + g + " -" + g + " -" + m + " 0 -" + m + " c"), a.push(g + " -" + m + " " + m + " -" + g + " " + m + " 0 c"), a.push("f"), a.push("Q"), l.stream = a.join(`
`), l;
}, OffPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [], m = ti.internal.getWidth(s) <= ti.internal.getHeight(s) ? ti.internal.getWidth(s) / 4 : ti.internal.getHeight(s) / 4;
  m = Number((0.9 * m).toFixed(5));
  var y = Number((2 * m).toFixed(5)), _ = Number((y * ti.internal.Bezier_C).toFixed(5));
  return a.push("0.749023 g"), a.push("q"), a.push("1 0 0 1 " + Yl(ti.internal.getWidth(s) / 2) + " " + Yl(ti.internal.getHeight(s) / 2) + " cm"), a.push(y + " 0 m"), a.push(y + " " + _ + " " + _ + " " + y + " 0 " + y + " c"), a.push("-" + _ + " " + y + " -" + y + " " + _ + " -" + y + " 0 c"), a.push("-" + y + " -" + _ + " -" + _ + " -" + y + " 0 -" + y + " c"), a.push(_ + " -" + y + " " + y + " -" + _ + " " + y + " 0 c"), a.push("f"), a.push("Q"), l.stream = a.join(`
`), l;
} }, Cross: { createAppearanceStream: function(s) {
  var l = { D: { Off: ti.RadioButton.Cross.OffPushDown }, N: {} };
  return l.N[s] = ti.RadioButton.Cross.YesNormal, l.D[s] = ti.RadioButton.Cross.YesPushDown, l;
}, getCA: function() {
  return "8";
}, YesNormal: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [], m = ti.internal.calculateCross(s);
  return a.push("q"), a.push("1 1 " + Pi(ti.internal.getWidth(s) - 2) + " " + Pi(ti.internal.getHeight(s) - 2) + " re"), a.push("W"), a.push("n"), a.push(Pi(m.x1.x) + " " + Pi(m.x1.y) + " m"), a.push(Pi(m.x2.x) + " " + Pi(m.x2.y) + " l"), a.push(Pi(m.x4.x) + " " + Pi(m.x4.y) + " m"), a.push(Pi(m.x3.x) + " " + Pi(m.x3.y) + " l"), a.push("s"), a.push("Q"), l.stream = a.join(`
`), l;
}, YesPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = ti.internal.calculateCross(s), m = [];
  return m.push("0.749023 g"), m.push("0 0 " + Pi(ti.internal.getWidth(s)) + " " + Pi(ti.internal.getHeight(s)) + " re"), m.push("f"), m.push("q"), m.push("1 1 " + Pi(ti.internal.getWidth(s) - 2) + " " + Pi(ti.internal.getHeight(s) - 2) + " re"), m.push("W"), m.push("n"), m.push(Pi(a.x1.x) + " " + Pi(a.x1.y) + " m"), m.push(Pi(a.x2.x) + " " + Pi(a.x2.y) + " l"), m.push(Pi(a.x4.x) + " " + Pi(a.x4.y) + " m"), m.push(Pi(a.x3.x) + " " + Pi(a.x3.y) + " l"), m.push("s"), m.push("Q"), l.stream = m.join(`
`), l;
}, OffPushDown: function(s) {
  var l = Vo(s);
  l.scope = s.scope;
  var a = [];
  return a.push("0.749023 g"), a.push("0 0 " + Pi(ti.internal.getWidth(s)) + " " + Pi(ti.internal.getHeight(s)) + " re"), a.push("f"), l.stream = a.join(`
`), l;
} } }, createDefaultAppearanceStream: function(s) {
  var l = s.scope.internal.getFont(s.fontName, s.fontStyle).id, a = s.scope.__private__.encodeColorString(s.color);
  return "/" + l + " " + s.fontSize + " Tf " + a;
} };
ti.internal = { Bezier_C: 0.551915024494, calculateCross: function(s) {
  var l = ti.internal.getWidth(s), a = ti.internal.getHeight(s), m = Math.min(l, a);
  return { x1: { x: (l - m) / 2, y: (a - m) / 2 + m }, x2: { x: (l - m) / 2 + m, y: (a - m) / 2 }, x3: { x: (l - m) / 2, y: (a - m) / 2 }, x4: { x: (l - m) / 2 + m, y: (a - m) / 2 + m } };
} }, ti.internal.getWidth = function(s) {
  var l = 0;
  return ur(s) === "object" && (l = Zg(s.Rect[2])), l;
}, ti.internal.getHeight = function(s) {
  var l = 0;
  return ur(s) === "object" && (l = Zg(s.Rect[3])), l;
};
var rx = Or.addField = function(s) {
  if (ix(this, s), !(s instanceof io)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var l;
  return (l = s).scope.internal.acroformPlugin.printedOut && (l.scope.internal.acroformPlugin.printedOut = !1, l.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), l.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(l), s.page = s.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Or.AcroFormChoiceField = _c, Or.AcroFormListBox = yc, Or.AcroFormComboBox = vc, Or.AcroFormEditBox = nd, Or.AcroFormButton = Cn, Or.AcroFormPushButton = sd, Or.AcroFormRadioButton = bc, Or.AcroFormCheckBox = ad, Or.AcroFormTextField = zu, Or.AcroFormPasswordField = od, Or.AcroFormAppearance = ti, Or.AcroForm = { ChoiceField: _c, ListBox: yc, ComboBox: vc, EditBox: nd, Button: Cn, PushButton: sd, RadioButton: bc, CheckBox: ad, TextField: zu, PasswordField: od, Appearance: ti }, wi.AcroForm = { ChoiceField: _c, ListBox: yc, ComboBox: vc, EditBox: nd, Button: Cn, PushButton: sd, RadioButton: bc, CheckBox: ad, TextField: zu, PasswordField: od, Appearance: ti };
function d1(s) {
  return s.reduce(function(l, a, m) {
    return l[a] = m, l;
  }, {});
}
(function(s) {
  s.__addimage__ = {};
  var l = "UNKNOWN", a = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, m = s.__addimage__.getImageFileTypeByImageData = function(X, re) {
    var xe, ye, Ve, He, Ze, qe = l;
    if ((re = re || l) === "RGBA" || X.data !== void 0 && X.data instanceof Uint8ClampedArray && "height" in X && "width" in X) return "RGBA";
    if (Qe(X)) for (Ze in a) for (Ve = a[Ze], xe = 0; xe < Ve.length; xe += 1) {
      for (He = !0, ye = 0; ye < Ve[xe].length; ye += 1) if (Ve[xe][ye] !== void 0 && Ve[xe][ye] !== X[ye]) {
        He = !1;
        break;
      }
      if (He === !0) {
        qe = Ze;
        break;
      }
    }
    else for (Ze in a) for (Ve = a[Ze], xe = 0; xe < Ve.length; xe += 1) {
      for (He = !0, ye = 0; ye < Ve[xe].length; ye += 1) if (Ve[xe][ye] !== void 0 && Ve[xe][ye] !== X.charCodeAt(ye)) {
        He = !1;
        break;
      }
      if (He === !0) {
        qe = Ze;
        break;
      }
    }
    return qe === l && re !== l && (qe = re), qe;
  }, y = function X(re) {
    for (var xe = this.internal.write, ye = this.internal.putStream, Ve = (0, this.internal.getFilters)(); Ve.indexOf("FlateEncode") !== -1; ) Ve.splice(Ve.indexOf("FlateEncode"), 1);
    re.objectId = this.internal.newObject();
    var He = [];
    if (He.push({ key: "Type", value: "/XObject" }), He.push({ key: "Subtype", value: "/Image" }), He.push({ key: "Width", value: re.width }), He.push({ key: "Height", value: re.height }), re.colorSpace === ae.INDEXED ? He.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (re.palette.length / 3 - 1) + " " + ("sMask" in re && re.sMask !== void 0 ? re.objectId + 2 : re.objectId + 1) + " 0 R]" }) : (He.push({ key: "ColorSpace", value: "/" + re.colorSpace }), re.colorSpace === ae.DEVICE_CMYK && He.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), He.push({ key: "BitsPerComponent", value: re.bitsPerComponent }), "decodeParameters" in re && re.decodeParameters !== void 0 && He.push({ key: "DecodeParms", value: "<<" + re.decodeParameters + ">>" }), "transparency" in re && Array.isArray(re.transparency)) {
      for (var Ze = "", qe = 0, Je = re.transparency.length; qe < Je; qe++) Ze += re.transparency[qe] + " " + re.transparency[qe] + " ";
      He.push({ key: "Mask", value: "[" + Ze + "]" });
    }
    re.sMask !== void 0 && He.push({ key: "SMask", value: re.objectId + 1 + " 0 R" });
    var et = re.filter !== void 0 ? ["/" + re.filter] : void 0;
    if (ye({ data: re.data, additionalKeyValues: He, alreadyAppliedFilters: et, objectId: re.objectId }), xe("endobj"), "sMask" in re && re.sMask !== void 0) {
      var st = "/Predictor " + re.predictor + " /Colors 1 /BitsPerComponent " + re.bitsPerComponent + " /Columns " + re.width, ee = { width: re.width, height: re.height, colorSpace: "DeviceGray", bitsPerComponent: re.bitsPerComponent, decodeParameters: st, data: re.sMask };
      "filter" in re && (ee.filter = re.filter), X.call(this, ee);
    }
    if (re.colorSpace === ae.INDEXED) {
      var _e = this.internal.newObject();
      ye({ data: Ae(new Uint8Array(re.palette)), objectId: _e }), xe("endobj");
    }
  }, _ = function() {
    var X = this.internal.collections.addImage_images;
    for (var re in X) y.call(this, X[re]);
  }, g = function() {
    var X, re = this.internal.collections.addImage_images, xe = this.internal.write;
    for (var ye in re) xe("/I" + (X = re[ye]).index, X.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", _), this.internal.events.subscribe("putXobjectDict", g));
  }, k = function() {
    var X = this.internal.collections.addImage_images;
    return o.call(this), X;
  }, D = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, L = function(X) {
    return typeof s["process" + X.toUpperCase()] == "function";
  }, j = function(X) {
    return ur(X) === "object" && X.nodeType === 1;
  }, O = function(X, re) {
    if (X.nodeName === "IMG" && X.hasAttribute("src")) {
      var xe = "" + X.getAttribute("src");
      if (xe.indexOf("data:image/") === 0) return ph(unescape(xe).split("base64,").pop());
      var ye = s.loadFile(xe, !0);
      if (ye !== void 0) return ye;
    }
    if (X.nodeName === "CANVAS") {
      if (X.width === 0 || X.height === 0) throw new Error("Given canvas must have data. Canvas width: " + X.width + ", height: " + X.height);
      var Ve;
      switch (re) {
        case "PNG":
          Ve = "image/png";
          break;
        case "WEBP":
          Ve = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Ve = "image/jpeg";
      }
      return ph(X.toDataURL(Ve, 1).split("base64,").pop());
    }
  }, z = function(X) {
    var re = this.internal.collections.addImage_images;
    if (re) {
      for (var xe in re) if (X === re[xe].alias) return re[xe];
    }
  }, pe = function(X, re, xe) {
    return X || re || (X = -96, re = -96), X < 0 && (X = -1 * xe.width * 72 / X / this.internal.scaleFactor), re < 0 && (re = -1 * xe.height * 72 / re / this.internal.scaleFactor), X === 0 && (X = re * xe.width / xe.height), re === 0 && (re = X * xe.height / xe.width), [X, re];
  }, oe = function(X, re, xe, ye, Ve, He) {
    var Ze = pe.call(this, xe, ye, Ve), qe = this.internal.getCoordinateString, Je = this.internal.getVerticalCoordinateString, et = k.call(this);
    if (xe = Ze[0], ye = Ze[1], et[Ve.index] = Ve, He) {
      He *= Math.PI / 180;
      var st = Math.cos(He), ee = Math.sin(He), _e = function(Te) {
        return Te.toFixed(4);
      }, be = [_e(st), _e(ee), _e(-1 * ee), _e(st), 0, 0, "cm"];
    }
    this.internal.write("q"), He ? (this.internal.write([1, "0", "0", 1, qe(X), Je(re + ye), "cm"].join(" ")), this.internal.write(be.join(" ")), this.internal.write([qe(xe), "0", "0", qe(ye), "0", "0", "cm"].join(" "))) : this.internal.write([qe(xe), "0", "0", qe(ye), qe(X), Je(re + ye), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Ve.index + " Do"), this.internal.write("Q");
  }, ae = s.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  s.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var Q = s.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, fe = s.__addimage__.sHashCode = function(X) {
    var re, xe, ye = 0;
    if (typeof X == "string") for (xe = X.length, re = 0; re < xe; re++) ye = (ye << 5) - ye + X.charCodeAt(re), ye |= 0;
    else if (Qe(X)) for (xe = X.byteLength / 2, re = 0; re < xe; re++) ye = (ye << 5) - ye + X[re], ye |= 0;
    return ye;
  }, Ce = s.__addimage__.validateStringAsBase64 = function(X) {
    (X = X || "").toString().trim();
    var re = !0;
    return X.length === 0 && (re = !1), X.length % 4 != 0 && (re = !1), /^[A-Za-z0-9+/]+$/.test(X.substr(0, X.length - 2)) === !1 && (re = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(X.substr(-2)) === !1 && (re = !1), re;
  }, ze = s.__addimage__.extractImageFromDataUrl = function(X) {
    var re = (X = X || "").split("base64,"), xe = null;
    if (re.length === 2) {
      var ye = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(re[0]);
      Array.isArray(ye) && (xe = { mimeType: ye[1], charset: ye[2], data: re[1] });
    }
    return xe;
  }, je = s.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  s.__addimage__.isArrayBuffer = function(X) {
    return je() && X instanceof ArrayBuffer;
  };
  var Qe = s.__addimage__.isArrayBufferView = function(X) {
    return je() && typeof Uint32Array < "u" && (X instanceof Int8Array || X instanceof Uint8Array || typeof Uint8ClampedArray < "u" && X instanceof Uint8ClampedArray || X instanceof Int16Array || X instanceof Uint16Array || X instanceof Int32Array || X instanceof Uint32Array || X instanceof Float32Array || X instanceof Float64Array);
  }, ke = s.__addimage__.binaryStringToUint8Array = function(X) {
    for (var re = X.length, xe = new Uint8Array(re), ye = 0; ye < re; ye++) xe[ye] = X.charCodeAt(ye);
    return xe;
  }, Ae = s.__addimage__.arrayBufferToBinaryString = function(X) {
    for (var re = "", xe = Qe(X) ? X : new Uint8Array(X), ye = 0; ye < xe.length; ye += 8192) re += String.fromCharCode.apply(null, xe.subarray(ye, ye + 8192));
    return re;
  };
  s.addImage = function() {
    var X, re, xe, ye, Ve, He, Ze, qe, Je;
    if (typeof arguments[1] == "number" ? (re = l, xe = arguments[1], ye = arguments[2], Ve = arguments[3], He = arguments[4], Ze = arguments[5], qe = arguments[6], Je = arguments[7]) : (re = arguments[1], xe = arguments[2], ye = arguments[3], Ve = arguments[4], He = arguments[5], Ze = arguments[6], qe = arguments[7], Je = arguments[8]), ur(X = arguments[0]) === "object" && !j(X) && "imageData" in X) {
      var et = X;
      X = et.imageData, re = et.format || re || l, xe = et.x || xe || 0, ye = et.y || ye || 0, Ve = et.w || et.width || Ve, He = et.h || et.height || He, Ze = et.alias || Ze, qe = et.compression || qe, Je = et.rotation || et.angle || Je;
    }
    var st = this.internal.getFilters();
    if (qe === void 0 && st.indexOf("FlateEncode") !== -1 && (qe = "SLOW"), isNaN(xe) || isNaN(ye)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var ee = me.call(this, X, re, Ze, qe);
    return oe.call(this, xe, ye, Ve, He, ee, Je), this;
  };
  var me = function(X, re, xe, ye) {
    var Ve, He, Ze;
    if (typeof X == "string" && m(X) === l) {
      X = unescape(X);
      var qe = ve(X, !1);
      (qe !== "" || (qe = s.loadFile(X, !0)) !== void 0) && (X = qe);
    }
    if (j(X) && (X = O(X, re)), re = m(X, re), !L(re)) throw new Error("addImage does not support files of type '" + re + "', please ensure that a plugin for '" + re + "' support is added.");
    if (((Ze = xe) == null || Ze.length === 0) && (xe = function(Je) {
      return typeof Je == "string" || Qe(Je) ? fe(Je) : Qe(Je.data) ? fe(Je.data) : null;
    }(X)), (Ve = z.call(this, xe)) || (je() && (X instanceof Uint8Array || re === "RGBA" || (He = X, X = ke(X))), Ve = this["process" + re.toUpperCase()](X, D.call(this), xe, function(Je) {
      return Je && typeof Je == "string" && (Je = Je.toUpperCase()), Je in s.image_compression ? Je : Q.NONE;
    }(ye), He)), !Ve) throw new Error("An unknown error occurred whilst processing the image.");
    return Ve;
  }, ve = s.__addimage__.convertBase64ToBinaryString = function(X, re) {
    var xe;
    re = typeof re != "boolean" || re;
    var ye, Ve = "";
    if (typeof X == "string") {
      ye = (xe = ze(X)) !== null ? xe.data : X;
      try {
        Ve = ph(ye);
      } catch (He) {
        if (re) throw Ce(ye) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + He.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Ve;
  };
  s.getImageProperties = function(X) {
    var re, xe, ye = "";
    if (j(X) && (X = O(X)), typeof X == "string" && m(X) === l && ((ye = ve(X, !1)) === "" && (ye = s.loadFile(X) || ""), X = ye), xe = m(X), !L(xe)) throw new Error("addImage does not support files of type '" + xe + "', please ensure that a plugin for '" + xe + "' support is added.");
    if (!je() || X instanceof Uint8Array || (X = ke(X)), !(re = this["process" + xe.toUpperCase()](X))) throw new Error("An unknown error occurred whilst processing the image");
    return re.fileType = xe, re;
  };
})(wi.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = function(a) {
    if (a !== void 0 && a != "") return !0;
  };
  wi.API.events.push(["addPage", function(a) {
    this.internal.getPageInfo(a.pageNumber).pageContext.annotations = [];
  }]), s.events.push(["putPage", function(a) {
    for (var m, y, _, g = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, k = this.internal.getPageInfoByObjId(a.objId), D = a.pageContext.annotations, L = !1, j = 0; j < D.length && !L; j++) switch ((m = D[j]).type) {
      case "link":
        (l(m.options.url) || l(m.options.pageNumber)) && (L = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        L = !0;
    }
    if (L != 0) {
      this.internal.write("/Annots [");
      for (var O = 0; O < D.length; O++) {
        m = D[O];
        var z = this.internal.pdfEscape, pe = this.internal.getEncryptor(a.objId);
        switch (m.type) {
          case "reference":
            this.internal.write(" " + m.object.objId + " 0 R ");
            break;
          case "text":
            var oe = this.internal.newAdditionalObject(), ae = this.internal.newAdditionalObject(), Q = this.internal.getEncryptor(oe.objId), fe = m.title || "Note";
            _ = "<</Type /Annot /Subtype /Text " + (y = "/Rect [" + g(m.bounds.x) + " " + o(m.bounds.y + m.bounds.h) + " " + g(m.bounds.x + m.bounds.w) + " " + o(m.bounds.y) + "] ") + "/Contents (" + z(Q(m.contents)) + ")", _ += " /Popup " + ae.objId + " 0 R", _ += " /P " + k.objId + " 0 R", _ += " /T (" + z(Q(fe)) + ") >>", oe.content = _;
            var Ce = oe.objId + " 0 R";
            _ = "<</Type /Annot /Subtype /Popup " + (y = "/Rect [" + g(m.bounds.x + 30) + " " + o(m.bounds.y + m.bounds.h) + " " + g(m.bounds.x + m.bounds.w + 30) + " " + o(m.bounds.y) + "] ") + " /Parent " + Ce, m.open && (_ += " /Open true"), _ += " >>", ae.content = _, this.internal.write(oe.objId, "0 R", ae.objId, "0 R");
            break;
          case "freetext":
            y = "/Rect [" + g(m.bounds.x) + " " + o(m.bounds.y) + " " + g(m.bounds.x + m.bounds.w) + " " + o(m.bounds.y + m.bounds.h) + "] ";
            var ze = m.color || "#000000";
            _ = "<</Type /Annot /Subtype /FreeText " + y + "/Contents (" + z(pe(m.contents)) + ")", _ += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + ze + ")", _ += " /Border [0 0 0]", _ += " >>", this.internal.write(_);
            break;
          case "link":
            if (m.options.name) {
              var je = this.annotations._nameMap[m.options.name];
              m.options.pageNumber = je.page, m.options.top = je.y;
            } else m.options.top || (m.options.top = 0);
            if (y = "/Rect [" + m.finalBounds.x + " " + m.finalBounds.y + " " + m.finalBounds.w + " " + m.finalBounds.h + "] ", _ = "", m.options.url) _ = "<</Type /Annot /Subtype /Link " + y + "/Border [0 0 0] /A <</S /URI /URI (" + z(pe(m.options.url)) + ") >>";
            else if (m.options.pageNumber)
              switch (_ = "<</Type /Annot /Subtype /Link " + y + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(m.options.pageNumber).objId + " 0 R", m.options.magFactor = m.options.magFactor || "XYZ", m.options.magFactor) {
                case "Fit":
                  _ += " /Fit]";
                  break;
                case "FitH":
                  _ += " /FitH " + m.options.top + "]";
                  break;
                case "FitV":
                  m.options.left = m.options.left || 0, _ += " /FitV " + m.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var Qe = o(m.options.top);
                  m.options.left = m.options.left || 0, m.options.zoom === void 0 && (m.options.zoom = 0), _ += " /XYZ " + m.options.left + " " + Qe + " " + m.options.zoom + "]";
              }
            _ != "" && (_ += " >>", this.internal.write(_));
        }
      }
      this.internal.write("]");
    }
  }]), s.createAnnotation = function(a) {
    var m = this.internal.getCurrentPageInfo();
    switch (a.type) {
      case "link":
        this.link(a.bounds.x, a.bounds.y, a.bounds.w, a.bounds.h, a);
        break;
      case "text":
      case "freetext":
        m.pageContext.annotations.push(a);
    }
  }, s.link = function(a, m, y, _, g) {
    var o = this.internal.getCurrentPageInfo(), k = this.internal.getCoordinateString, D = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: k(a), y: D(m), w: k(a + y), h: D(m + _) }, options: g, type: "link" });
  }, s.textWithLink = function(a, m, y, _) {
    var g, o, k = this.getTextWidth(a), D = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (_.maxWidth !== void 0) {
      o = _.maxWidth;
      var L = this.splitTextToSize(a, o).length;
      g = Math.ceil(D * L);
    } else o = k, g = D;
    return this.text(a, m, y, _), y += 0.2 * D, _.align === "center" && (m -= k / 2), _.align === "right" && (m -= k), this.link(m, y - D, o, g, _), k;
  }, s.getTextWidth = function(a) {
    var m = this.internal.getFontSize();
    return this.getStringUnitWidth(a) * m / this.internal.scaleFactor;
  };
}(wi.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, a = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, m = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, y = [1570, 1571, 1573, 1575];
  s.__arabicParser__ = {};
  var _ = s.__arabicParser__.isInArabicSubstitutionA = function(oe) {
    return l[oe.charCodeAt(0)] !== void 0;
  }, g = s.__arabicParser__.isArabicLetter = function(oe) {
    return typeof oe == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(oe);
  }, o = s.__arabicParser__.isArabicEndLetter = function(oe) {
    return g(oe) && _(oe) && l[oe.charCodeAt(0)].length <= 2;
  }, k = s.__arabicParser__.isArabicAlfLetter = function(oe) {
    return g(oe) && y.indexOf(oe.charCodeAt(0)) >= 0;
  };
  s.__arabicParser__.arabicLetterHasIsolatedForm = function(oe) {
    return g(oe) && _(oe) && l[oe.charCodeAt(0)].length >= 1;
  };
  var D = s.__arabicParser__.arabicLetterHasFinalForm = function(oe) {
    return g(oe) && _(oe) && l[oe.charCodeAt(0)].length >= 2;
  };
  s.__arabicParser__.arabicLetterHasInitialForm = function(oe) {
    return g(oe) && _(oe) && l[oe.charCodeAt(0)].length >= 3;
  };
  var L = s.__arabicParser__.arabicLetterHasMedialForm = function(oe) {
    return g(oe) && _(oe) && l[oe.charCodeAt(0)].length == 4;
  }, j = s.__arabicParser__.resolveLigatures = function(oe) {
    var ae = 0, Q = a, fe = "", Ce = 0;
    for (ae = 0; ae < oe.length; ae += 1) Q[oe.charCodeAt(ae)] !== void 0 ? (Ce++, typeof (Q = Q[oe.charCodeAt(ae)]) == "number" && (fe += String.fromCharCode(Q), Q = a, Ce = 0), ae === oe.length - 1 && (Q = a, fe += oe.charAt(ae - (Ce - 1)), ae -= Ce - 1, Ce = 0)) : (Q = a, fe += oe.charAt(ae - Ce), ae -= Ce, Ce = 0);
    return fe;
  };
  s.__arabicParser__.isArabicDiacritic = function(oe) {
    return oe !== void 0 && m[oe.charCodeAt(0)] !== void 0;
  };
  var O = s.__arabicParser__.getCorrectForm = function(oe, ae, Q) {
    return g(oe) ? _(oe) === !1 ? -1 : !D(oe) || !g(ae) && !g(Q) || !g(Q) && o(ae) || o(oe) && !g(ae) || o(oe) && k(ae) || o(oe) && o(ae) ? 0 : L(oe) && g(ae) && !o(ae) && g(Q) && D(Q) ? 3 : o(oe) || !g(Q) ? 1 : 2 : -1;
  }, z = function(oe) {
    var ae = 0, Q = 0, fe = 0, Ce = "", ze = "", je = "", Qe = (oe = oe || "").split("\\s+"), ke = [];
    for (ae = 0; ae < Qe.length; ae += 1) {
      for (ke.push(""), Q = 0; Q < Qe[ae].length; Q += 1) Ce = Qe[ae][Q], ze = Qe[ae][Q - 1], je = Qe[ae][Q + 1], g(Ce) ? (fe = O(Ce, ze, je), ke[ae] += fe !== -1 ? String.fromCharCode(l[Ce.charCodeAt(0)][fe]) : Ce) : ke[ae] += Ce;
      ke[ae] = j(ke[ae]);
    }
    return ke.join(" ");
  }, pe = s.__arabicParser__.processArabic = s.processArabic = function() {
    var oe, ae = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, Q = [];
    if (Array.isArray(ae)) {
      var fe = 0;
      for (Q = [], fe = 0; fe < ae.length; fe += 1) Array.isArray(ae[fe]) ? Q.push([z(ae[fe][0]), ae[fe][1], ae[fe][2]]) : Q.push([z(ae[fe])]);
      oe = Q;
    } else oe = z(ae);
    return typeof arguments[0] == "string" ? oe : (arguments[0].text = oe, arguments[0]);
  };
  s.events.push(["preProcessText", pe]);
}(wi.API), wi.API.autoPrint = function(s) {
  var l;
  switch ((s = s || {}).variant = s.variant || "non-conform", s.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        l = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + l + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = function() {
    var a = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return a;
    }, set: function(o) {
      a = o;
    } });
    var m = 150;
    Object.defineProperty(this, "width", { get: function() {
      return m;
    }, set: function(o) {
      m = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = m + 1);
    } });
    var y = 300;
    Object.defineProperty(this, "height", { get: function() {
      return y;
    }, set: function(o) {
      y = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = y + 1);
    } });
    var _ = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return _;
    }, set: function(o) {
      _ = o;
    } });
    var g = {};
    Object.defineProperty(this, "style", { get: function() {
      return g;
    }, set: function(o) {
      g = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  l.prototype.getContext = function(a, m) {
    var y;
    if ((a = a || "2d") !== "2d") return null;
    for (y in m) this.pdf.context2d.hasOwnProperty(y) && (this.pdf.context2d[y] = m[y]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, l.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, s.events.push(["initialized", function() {
    this.canvas = new l(), this.canvas.pdf = this;
  }]);
}(wi.API), function(s) {
  var l = { left: 0, top: 0, bottom: 0, right: 0 }, a = !1, m = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, l), this.internal.__cell__.margins.width = this.getPageWidth(), y.call(this));
  }, y = function() {
    this.internal.__cell__.lastCell = new _(), this.internal.__cell__.pages = 1;
  }, _ = function() {
    var k = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return k;
    }, set: function(oe) {
      k = oe;
    } });
    var D = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return D;
    }, set: function(oe) {
      D = oe;
    } });
    var L = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return L;
    }, set: function(oe) {
      L = oe;
    } });
    var j = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return j;
    }, set: function(oe) {
      j = oe;
    } });
    var O = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return O;
    }, set: function(oe) {
      O = oe;
    } });
    var z = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return z;
    }, set: function(oe) {
      z = oe;
    } });
    var pe = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return pe;
    }, set: function(oe) {
      pe = oe;
    } }), this;
  };
  _.prototype.clone = function() {
    return new _(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, _.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, s.setHeaderFunction = function(k) {
    return m.call(this), this.internal.__cell__.headerFunction = typeof k == "function" ? k : void 0, this;
  }, s.getTextDimensions = function(k, D) {
    m.call(this);
    var L = (D = D || {}).fontSize || this.getFontSize(), j = D.font || this.getFont(), O = D.scaleFactor || this.internal.scaleFactor, z = 0, pe = 0, oe = 0, ae = this;
    if (!Array.isArray(k) && typeof k != "string") {
      if (typeof k != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      k = String(k);
    }
    var Q = D.maxWidth;
    Q > 0 ? typeof k == "string" ? k = this.splitTextToSize(k, Q) : Object.prototype.toString.call(k) === "[object Array]" && (k = k.reduce(function(Ce, ze) {
      return Ce.concat(ae.splitTextToSize(ze, Q));
    }, [])) : k = Array.isArray(k) ? k : [k];
    for (var fe = 0; fe < k.length; fe++) z < (oe = this.getStringUnitWidth(k[fe], { font: j }) * L) && (z = oe);
    return z !== 0 && (pe = k.length), { w: z /= O, h: Math.max((pe * L * this.getLineHeightFactor() - L * (this.getLineHeightFactor() - 1)) / O, 0) };
  }, s.cellAddPage = function() {
    m.call(this), this.addPage();
    var k = this.internal.__cell__.margins || l;
    return this.internal.__cell__.lastCell = new _(k.left, k.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var g = s.cell = function() {
    var k;
    k = arguments[0] instanceof _ ? arguments[0] : new _(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), m.call(this);
    var D = this.internal.__cell__.lastCell, L = this.internal.__cell__.padding, j = this.internal.__cell__.margins || l, O = this.internal.__cell__.tableHeaderRow, z = this.internal.__cell__.printHeaders;
    return D.lineNumber !== void 0 && (D.lineNumber === k.lineNumber ? (k.x = (D.x || 0) + (D.width || 0), k.y = D.y || 0) : D.y + D.height + k.height + j.bottom > this.getPageHeight() ? (this.cellAddPage(), k.y = j.top, z && O && (this.printHeaderRow(k.lineNumber, !0), k.y += O[0].height)) : k.y = D.y + D.height || k.y), k.text[0] !== void 0 && (this.rect(k.x, k.y, k.width, k.height, a === !0 ? "FD" : void 0), k.align === "right" ? this.text(k.text, k.x + k.width - L, k.y + L, { align: "right", baseline: "top" }) : k.align === "center" ? this.text(k.text, k.x + k.width / 2, k.y + L, { align: "center", baseline: "top", maxWidth: k.width - L - L }) : this.text(k.text, k.x + L, k.y + L, { align: "left", baseline: "top", maxWidth: k.width - L - L })), this.internal.__cell__.lastCell = k, this;
  };
  s.table = function(k, D, L, j, O) {
    if (m.call(this), !L) throw new Error("No data for PDF table.");
    var z, pe, oe, ae, Q = [], fe = [], Ce = [], ze = {}, je = {}, Qe = [], ke = [], Ae = (O = O || {}).autoSize || !1, me = O.printHeaders !== !1, ve = O.css && O.css["font-size"] !== void 0 ? 16 * O.css["font-size"] : O.fontSize || 12, X = O.margins || Object.assign({ width: this.getPageWidth() }, l), re = typeof O.padding == "number" ? O.padding : 3, xe = O.headerBackgroundColor || "#c8c8c8", ye = O.headerTextColor || "#000";
    if (y.call(this), this.internal.__cell__.printHeaders = me, this.internal.__cell__.margins = X, this.internal.__cell__.table_font_size = ve, this.internal.__cell__.padding = re, this.internal.__cell__.headerBackgroundColor = xe, this.internal.__cell__.headerTextColor = ye, this.setFontSize(ve), j == null) fe = Q = Object.keys(L[0]), Ce = Q.map(function() {
      return "left";
    });
    else if (Array.isArray(j) && ur(j[0]) === "object") for (Q = j.map(function(et) {
      return et.name;
    }), fe = j.map(function(et) {
      return et.prompt || et.name || "";
    }), Ce = j.map(function(et) {
      return et.align || "left";
    }), z = 0; z < j.length; z += 1) je[j[z].name] = j[z].width * (19.049976 / 25.4);
    else Array.isArray(j) && typeof j[0] == "string" && (fe = Q = j, Ce = Q.map(function() {
      return "left";
    }));
    if (Ae || Array.isArray(j) && typeof j[0] == "string") for (z = 0; z < Q.length; z += 1) {
      for (ze[ae = Q[z]] = L.map(function(et) {
        return et[ae];
      }), this.setFont(void 0, "bold"), Qe.push(this.getTextDimensions(fe[z], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), pe = ze[ae], this.setFont(void 0, "normal"), oe = 0; oe < pe.length; oe += 1) Qe.push(this.getTextDimensions(pe[oe], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      je[ae] = Math.max.apply(null, Qe) + re + re, Qe = [];
    }
    if (me) {
      var Ve = {};
      for (z = 0; z < Q.length; z += 1) Ve[Q[z]] = {}, Ve[Q[z]].text = fe[z], Ve[Q[z]].align = Ce[z];
      var He = o.call(this, Ve, je);
      ke = Q.map(function(et) {
        return new _(k, D, je[et], He, Ve[et].text, void 0, Ve[et].align);
      }), this.setTableHeaderRow(ke), this.printHeaderRow(1, !1);
    }
    var Ze = j.reduce(function(et, st) {
      return et[st.name] = st.align, et;
    }, {});
    for (z = 0; z < L.length; z += 1) {
      "rowStart" in O && O.rowStart instanceof Function && O.rowStart({ row: z, data: L[z] }, this);
      var qe = o.call(this, L[z], je);
      for (oe = 0; oe < Q.length; oe += 1) {
        var Je = L[z][Q[oe]];
        "cellStart" in O && O.cellStart instanceof Function && O.cellStart({ row: z, col: oe, data: Je }, this), g.call(this, new _(k, D, je[Q[oe]], qe, Je, z + 2, Ze[Q[oe]]));
      }
    }
    return this.internal.__cell__.table_x = k, this.internal.__cell__.table_y = D, this;
  };
  var o = function(k, D) {
    var L = this.internal.__cell__.padding, j = this.internal.__cell__.table_font_size, O = this.internal.scaleFactor;
    return Object.keys(k).map(function(z) {
      var pe = k[z];
      return this.splitTextToSize(pe.hasOwnProperty("text") ? pe.text : pe, D[z] - L - L);
    }, this).map(function(z) {
      return this.getLineHeightFactor() * z.length * j / O + L + L;
    }, this).reduce(function(z, pe) {
      return Math.max(z, pe);
    }, 0);
  };
  s.setTableHeaderRow = function(k) {
    m.call(this), this.internal.__cell__.tableHeaderRow = k;
  }, s.printHeaderRow = function(k, D) {
    if (m.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var L;
    if (a = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var j = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new _(j[0], j[1], j[2], j[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var O = [], z = 0; z < this.internal.__cell__.tableHeaderRow.length; z += 1) {
      L = this.internal.__cell__.tableHeaderRow[z].clone(), D && (L.y = this.internal.__cell__.margins.top || 0, O.push(L)), L.lineNumber = k;
      var pe = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), g.call(this, L), this.setTextColor(pe);
    }
    O.length > 0 && this.setTableHeaderRow(O), this.setFont(void 0, "normal"), a = !1;
  };
}(wi.API);
var p1 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, f1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], af = d1(f1), m1 = [100, 200, 300, 400, 500, 600, 700, 800, 900], nx = d1(m1);
function of(s) {
  var l = s.family.replace(/"|'/g, "").toLowerCase(), a = function(_) {
    return p1[_ = _ || "normal"] ? _ : "normal";
  }(s.style), m = function(_) {
    if (!_) return 400;
    if (typeof _ == "number") return _ >= 100 && _ <= 900 && _ % 100 == 0 ? _ : 400;
    if (/^\d00$/.test(_)) return parseInt(_);
    switch (_) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(s.weight), y = function(_) {
    return typeof af[_ = _ || "normal"] == "number" ? _ : "normal";
  }(s.stretch);
  return { family: l, style: a, weight: m, stretch: y, src: s.src || [], ref: s.ref || { name: l, style: [y, a, m].join(" ") } };
}
function Gg(s, l, a, m) {
  var y;
  for (y = a; y >= 0 && y < l.length; y += m) if (s[l[y]]) return s[l[y]];
  for (y = a; y >= 0 && y < l.length; y -= m) if (s[l[y]]) return s[l[y]];
}
var sx = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Hg = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Wg(s) {
  return [s.stretch, s.style, s.weight, s.family].join(" ");
}
function ax(s, l, a) {
  for (var m = (a = a || {}).defaultFontFamily || "times", y = Object.assign({}, sx, a.genericFontFamilies || {}), _ = null, g = null, o = 0; o < l.length; ++o) if (y[(_ = of(l[o])).family] && (_.family = y[_.family]), s.hasOwnProperty(_.family)) {
    g = s[_.family];
    break;
  }
  if (!(g = g || s[m])) throw new Error("Could not find a font-family for the rule '" + Wg(_) + "' and default family '" + m + "'.");
  if (g = function(k, D) {
    if (D[k]) return D[k];
    var L = af[k], j = L <= af.normal ? -1 : 1, O = Gg(D, f1, L, j);
    if (!O) throw new Error("Could not find a matching font-stretch value for " + k);
    return O;
  }(_.stretch, g), g = function(k, D) {
    if (D[k]) return D[k];
    for (var L = p1[k], j = 0; j < L.length; ++j) if (D[L[j]]) return D[L[j]];
    throw new Error("Could not find a matching font-style for " + k);
  }(_.style, g), !(g = function(k, D) {
    if (D[k]) return D[k];
    if (k === 400 && D[500]) return D[500];
    if (k === 500 && D[400]) return D[400];
    var L = nx[k], j = Gg(D, m1, L, k < 400 ? -1 : 1);
    if (!j) throw new Error("Could not find a matching font-weight for value " + k);
    return j;
  }(_.weight, g))) throw new Error("Failed to resolve a font for the rule '" + Wg(_) + "'.");
  return g;
}
function Xg(s) {
  return s.trimLeft();
}
function ox(s, l) {
  for (var a = 0; a < s.length; ) {
    if (s.charAt(a) === l) return [s.substring(0, a), s.substring(a + 1)];
    a += 1;
  }
  return null;
}
function lx(s) {
  var l = s.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return l === null ? null : [l[0], s.substring(l[0].length)];
}
var ed, Yg, Jg, Kg = ["times"];
(function(s) {
  var l, a, m, y, _, g, o, k, D, L = function(ee) {
    return ee = ee || {}, this.isStrokeTransparent = ee.isStrokeTransparent || !1, this.strokeOpacity = ee.strokeOpacity || 1, this.strokeStyle = ee.strokeStyle || "#000000", this.fillStyle = ee.fillStyle || "#000000", this.isFillTransparent = ee.isFillTransparent || !1, this.fillOpacity = ee.fillOpacity || 1, this.font = ee.font || "10px sans-serif", this.textBaseline = ee.textBaseline || "alphabetic", this.textAlign = ee.textAlign || "left", this.lineWidth = ee.lineWidth || 1, this.lineJoin = ee.lineJoin || "miter", this.lineCap = ee.lineCap || "butt", this.path = ee.path || [], this.transform = ee.transform !== void 0 ? ee.transform.clone() : new k(), this.globalCompositeOperation = ee.globalCompositeOperation || "normal", this.globalAlpha = ee.globalAlpha || 1, this.clip_path = ee.clip_path || [], this.currentPoint = ee.currentPoint || new g(), this.miterLimit = ee.miterLimit || 10, this.lastPoint = ee.lastPoint || new g(), this.lineDashOffset = ee.lineDashOffset || 0, this.lineDash = ee.lineDash || [], this.margin = ee.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = ee.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof ee.ignoreClearRect != "boolean" || ee.ignoreClearRect, this;
  };
  s.events.push(["initialized", function() {
    this.context2d = new j(this), l = this.internal.f2, a = this.internal.getCoordinateString, m = this.internal.getVerticalCoordinateString, y = this.internal.getHorizontalCoordinate, _ = this.internal.getVerticalCoordinate, g = this.internal.Point, o = this.internal.Rectangle, k = this.internal.Matrix, D = new L();
  }]);
  var j = function(ee) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var _e = ee;
    Object.defineProperty(this, "pdf", { get: function() {
      return _e;
    } });
    var be = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return be;
    }, set: function(rt) {
      be = !!rt;
    } });
    var Te = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Te;
    }, set: function(rt) {
      Te = !!rt;
    } });
    var Oe = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return Oe;
    }, set: function(rt) {
      isNaN(rt) || (Oe = rt);
    } });
    var $e = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return $e;
    }, set: function(rt) {
      isNaN(rt) || ($e = rt);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return D.margin;
    }, set: function(rt) {
      var Y;
      typeof rt == "number" ? Y = [rt, rt, rt, rt] : ((Y = new Array(4))[0] = rt[0], Y[1] = rt.length >= 2 ? rt[1] : Y[0], Y[2] = rt.length >= 3 ? rt[2] : Y[0], Y[3] = rt.length >= 4 ? rt[3] : Y[1]), D.margin = Y;
    } });
    var Ue = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Ue;
    }, set: function(rt) {
      Ue = rt;
    } });
    var Ke = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ke;
    }, set: function(rt) {
      Ke = rt;
    } });
    var nt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return nt;
    }, set: function(rt) {
      nt = rt;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return D;
    }, set: function(rt) {
      rt instanceof L && (D = rt);
    } }), Object.defineProperty(this, "path", { get: function() {
      return D.path;
    }, set: function(rt) {
      D.path = rt;
    } });
    var ot = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return ot;
    }, set: function(rt) {
      ot = rt;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(rt) {
      var Y;
      Y = O(rt), this.ctx.fillStyle = Y.style, this.ctx.isFillTransparent = Y.a === 0, this.ctx.fillOpacity = Y.a, this.pdf.setFillColor(Y.r, Y.g, Y.b, { a: Y.a }), this.pdf.setTextColor(Y.r, Y.g, Y.b, { a: Y.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(rt) {
      var Y = O(rt);
      this.ctx.strokeStyle = Y.style, this.ctx.isStrokeTransparent = Y.a === 0, this.ctx.strokeOpacity = Y.a, Y.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Y.a, this.pdf.setDrawColor(Y.r, Y.g, Y.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(rt) {
      ["butt", "round", "square"].indexOf(rt) !== -1 && (this.ctx.lineCap = rt, this.pdf.setLineCap(rt));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(rt) {
      isNaN(rt) || (this.ctx.lineWidth = rt, this.pdf.setLineWidth(rt));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(rt) {
      ["bevel", "round", "miter"].indexOf(rt) !== -1 && (this.ctx.lineJoin = rt, this.pdf.setLineJoin(rt));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(rt) {
      isNaN(rt) || (this.ctx.miterLimit = rt, this.pdf.setMiterLimit(rt));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(rt) {
      this.ctx.textBaseline = rt;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(rt) {
      ["right", "end", "center", "left", "start"].indexOf(rt) !== -1 && (this.ctx.textAlign = rt);
    } });
    var vt = null;
    function mt(rt, Y) {
      if (vt === null) {
        var Kt = function(Rt) {
          var lt = [];
          return Object.keys(Rt).forEach(function(xt) {
            Rt[xt].forEach(function(At) {
              var Et = null;
              switch (At) {
                case "bold":
                  Et = { family: xt, weight: "bold" };
                  break;
                case "italic":
                  Et = { family: xt, style: "italic" };
                  break;
                case "bolditalic":
                  Et = { family: xt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Et = { family: xt };
              }
              Et !== null && (Et.ref = { name: xt, style: At }, lt.push(Et));
            });
          }), lt;
        }(rt.getFontList());
        vt = function(Rt) {
          for (var lt = {}, xt = 0; xt < Rt.length; ++xt) {
            var At = of(Rt[xt]), Et = At.family, jt = At.stretch, ni = At.style, ii = At.weight;
            lt[Et] = lt[Et] || {}, lt[Et][jt] = lt[Et][jt] || {}, lt[Et][jt][ni] = lt[Et][jt][ni] || {}, lt[Et][jt][ni][ii] = At;
          }
          return lt;
        }(Kt.concat(Y));
      }
      return vt;
    }
    var Pt = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Pt;
    }, set: function(rt) {
      vt = null, Pt = rt;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(rt) {
      var Y;
      if (this.ctx.font = rt, (Y = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(rt)) !== null) {
        var Kt = Y[1], Rt = (Y[2], Y[3]), lt = Y[4], xt = (Y[5], Y[6]), At = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(lt)[2];
        lt = Math.floor(At === "px" ? parseFloat(lt) * this.pdf.internal.scaleFactor : At === "em" ? parseFloat(lt) * this.pdf.getFontSize() : parseFloat(lt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(lt);
        var Et = function(Jt) {
          var si, It, Zi = [], ft = Jt.trim();
          if (ft === "") return Kg;
          if (ft in Hg) return [Hg[ft]];
          for (; ft !== ""; ) {
            switch (It = null, si = (ft = Xg(ft)).charAt(0)) {
              case '"':
              case "'":
                It = ox(ft.substring(1), si);
                break;
              default:
                It = lx(ft);
            }
            if (It === null || (Zi.push(It[0]), (ft = Xg(It[1])) !== "" && ft.charAt(0) !== ",")) return Kg;
            ft = ft.replace(/^,/, "");
          }
          return Zi;
        }(xt);
        if (this.fontFaces) {
          var jt = ax(mt(this.pdf, this.fontFaces), Et.map(function(Jt) {
            return { family: Jt, stretch: "normal", weight: Rt, style: Kt };
          }));
          this.pdf.setFont(jt.ref.name, jt.ref.style);
        } else {
          var ni = "";
          (Rt === "bold" || parseInt(Rt, 10) >= 700 || Kt === "bold") && (ni = "bold"), Kt === "italic" && (ni += "italic"), ni.length === 0 && (ni = "normal");
          for (var ii = "", yi = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, xi = 0; xi < Et.length; xi++) {
            if (this.pdf.internal.getFont(Et[xi], ni, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ii = Et[xi];
              break;
            }
            if (ni === "bolditalic" && this.pdf.internal.getFont(Et[xi], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) ii = Et[xi], ni = "bold";
            else if (this.pdf.internal.getFont(Et[xi], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ii = Et[xi], ni = "normal";
              break;
            }
          }
          if (ii === "") {
            for (var pt = 0; pt < Et.length; pt++) if (yi[Et[pt]]) {
              ii = yi[Et[pt]];
              break;
            }
          }
          ii = ii === "" ? "Times" : ii, this.pdf.setFont(ii, ni);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(rt) {
      this.ctx.globalCompositeOperation = rt;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(rt) {
      this.ctx.globalAlpha = rt;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(rt) {
      this.ctx.lineDashOffset = rt, st.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(rt) {
      this.ctx.lineDash = rt, st.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(rt) {
      this.ctx.ignoreClearRect = !!rt;
    } });
  };
  j.prototype.setLineDash = function(ee) {
    this.lineDash = ee;
  }, j.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, j.prototype.fill = function() {
    ze.call(this, "fill", !1);
  }, j.prototype.stroke = function() {
    ze.call(this, "stroke", !1);
  }, j.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, j.prototype.moveTo = function(ee, _e) {
    if (isNaN(ee) || isNaN(_e)) throw vr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var be = this.ctx.transform.applyToPoint(new g(ee, _e));
    this.path.push({ type: "mt", x: be.x, y: be.y }), this.ctx.lastPoint = new g(ee, _e);
  }, j.prototype.closePath = function() {
    var ee = new g(0, 0), _e = 0;
    for (_e = this.path.length - 1; _e !== -1; _e--) if (this.path[_e].type === "begin" && ur(this.path[_e + 1]) === "object" && typeof this.path[_e + 1].x == "number") {
      ee = new g(this.path[_e + 1].x, this.path[_e + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new g(ee.x, ee.y);
  }, j.prototype.lineTo = function(ee, _e) {
    if (isNaN(ee) || isNaN(_e)) throw vr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var be = this.ctx.transform.applyToPoint(new g(ee, _e));
    this.path.push({ type: "lt", x: be.x, y: be.y }), this.ctx.lastPoint = new g(be.x, be.y);
  }, j.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), ze.call(this, null, !0);
  }, j.prototype.quadraticCurveTo = function(ee, _e, be, Te) {
    if (isNaN(be) || isNaN(Te) || isNaN(ee) || isNaN(_e)) throw vr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var Oe = this.ctx.transform.applyToPoint(new g(be, Te)), $e = this.ctx.transform.applyToPoint(new g(ee, _e));
    this.path.push({ type: "qct", x1: $e.x, y1: $e.y, x: Oe.x, y: Oe.y }), this.ctx.lastPoint = new g(Oe.x, Oe.y);
  }, j.prototype.bezierCurveTo = function(ee, _e, be, Te, Oe, $e) {
    if (isNaN(Oe) || isNaN($e) || isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te)) throw vr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Ue = this.ctx.transform.applyToPoint(new g(Oe, $e)), Ke = this.ctx.transform.applyToPoint(new g(ee, _e)), nt = this.ctx.transform.applyToPoint(new g(be, Te));
    this.path.push({ type: "bct", x1: Ke.x, y1: Ke.y, x2: nt.x, y2: nt.y, x: Ue.x, y: Ue.y }), this.ctx.lastPoint = new g(Ue.x, Ue.y);
  }, j.prototype.arc = function(ee, _e, be, Te, Oe, $e) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te) || isNaN(Oe)) throw vr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if ($e = !!$e, !this.ctx.transform.isIdentity) {
      var Ue = this.ctx.transform.applyToPoint(new g(ee, _e));
      ee = Ue.x, _e = Ue.y;
      var Ke = this.ctx.transform.applyToPoint(new g(0, be)), nt = this.ctx.transform.applyToPoint(new g(0, 0));
      be = Math.sqrt(Math.pow(Ke.x - nt.x, 2) + Math.pow(Ke.y - nt.y, 2));
    }
    Math.abs(Oe - Te) >= 2 * Math.PI && (Te = 0, Oe = 2 * Math.PI), this.path.push({ type: "arc", x: ee, y: _e, radius: be, startAngle: Te, endAngle: Oe, counterclockwise: $e });
  }, j.prototype.arcTo = function(ee, _e, be, Te, Oe) {
    throw new Error("arcTo not implemented.");
  }, j.prototype.rect = function(ee, _e, be, Te) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te)) throw vr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(ee, _e), this.lineTo(ee + be, _e), this.lineTo(ee + be, _e + Te), this.lineTo(ee, _e + Te), this.lineTo(ee, _e), this.lineTo(ee + be, _e), this.lineTo(ee, _e);
  }, j.prototype.fillRect = function(ee, _e, be, Te) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te)) throw vr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!z.call(this)) {
      var Oe = {};
      this.lineCap !== "butt" && (Oe.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Oe.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(ee, _e, be, Te), this.fill(), Oe.hasOwnProperty("lineCap") && (this.lineCap = Oe.lineCap), Oe.hasOwnProperty("lineJoin") && (this.lineJoin = Oe.lineJoin);
    }
  }, j.prototype.strokeRect = function(ee, _e, be, Te) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te)) throw vr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    pe.call(this) || (this.beginPath(), this.rect(ee, _e, be, Te), this.stroke());
  }, j.prototype.clearRect = function(ee, _e, be, Te) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te)) throw vr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(ee, _e, be, Te));
  }, j.prototype.save = function(ee) {
    ee = typeof ee != "boolean" || ee;
    for (var _e = this.pdf.internal.getCurrentPageInfo().pageNumber, be = 0; be < this.pdf.internal.getNumberOfPages(); be++) this.pdf.setPage(be + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(_e), ee) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Te = new L(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Te;
    }
  }, j.prototype.restore = function(ee) {
    ee = typeof ee != "boolean" || ee;
    for (var _e = this.pdf.internal.getCurrentPageInfo().pageNumber, be = 0; be < this.pdf.internal.getNumberOfPages(); be++) this.pdf.setPage(be + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(_e), ee && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, j.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var O = function(ee) {
    var _e, be, Te, Oe;
    if (ee.isCanvasGradient === !0 && (ee = ee.getColor()), !ee) return { r: 0, g: 0, b: 0, a: 0, style: ee };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(ee)) _e = 0, be = 0, Te = 0, Oe = 0;
    else {
      var $e = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(ee);
      if ($e !== null) _e = parseInt($e[1]), be = parseInt($e[2]), Te = parseInt($e[3]), Oe = 1;
      else if (($e = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(ee)) !== null) _e = parseInt($e[1]), be = parseInt($e[2]), Te = parseInt($e[3]), Oe = parseFloat($e[4]);
      else {
        if (Oe = 1, typeof ee == "string" && ee.charAt(0) !== "#") {
          var Ue = new a1(ee);
          ee = Ue.ok ? Ue.toHex() : "#000000";
        }
        ee.length === 4 ? (_e = ee.substring(1, 2), _e += _e, be = ee.substring(2, 3), be += be, Te = ee.substring(3, 4), Te += Te) : (_e = ee.substring(1, 3), be = ee.substring(3, 5), Te = ee.substring(5, 7)), _e = parseInt(_e, 16), be = parseInt(be, 16), Te = parseInt(Te, 16);
      }
    }
    return { r: _e, g: be, b: Te, a: Oe, style: ee };
  }, z = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, pe = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  j.prototype.fillText = function(ee, _e, be, Te) {
    if (isNaN(_e) || isNaN(be) || typeof ee != "string") throw vr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Te = isNaN(Te) ? void 0 : Te, !z.call(this)) {
      var Oe = qe(this.ctx.transform.rotation), $e = this.ctx.transform.scaleX;
      re.call(this, { text: ee, x: _e, y: be, scale: $e, angle: Oe, align: this.textAlign, maxWidth: Te });
    }
  }, j.prototype.strokeText = function(ee, _e, be, Te) {
    if (isNaN(_e) || isNaN(be) || typeof ee != "string") throw vr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!pe.call(this)) {
      Te = isNaN(Te) ? void 0 : Te;
      var Oe = qe(this.ctx.transform.rotation), $e = this.ctx.transform.scaleX;
      re.call(this, { text: ee, x: _e, y: be, scale: $e, renderingMode: "stroke", angle: Oe, align: this.textAlign, maxWidth: Te });
    }
  }, j.prototype.measureText = function(ee) {
    if (typeof ee != "string") throw vr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var _e = this.pdf, be = this.pdf.internal.scaleFactor, Te = _e.internal.getFontSize(), Oe = _e.getStringUnitWidth(ee) * Te / _e.internal.scaleFactor, $e = function(Ue) {
      var Ke = (Ue = Ue || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ke;
      } }), this;
    };
    return new $e({ width: Oe *= Math.round(96 * be / 72 * 1e4) / 1e4 });
  }, j.prototype.scale = function(ee, _e) {
    if (isNaN(ee) || isNaN(_e)) throw vr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var be = new k(ee, 0, 0, _e, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(be);
  }, j.prototype.rotate = function(ee) {
    if (isNaN(ee)) throw vr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var _e = new k(Math.cos(ee), Math.sin(ee), -Math.sin(ee), Math.cos(ee), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(_e);
  }, j.prototype.translate = function(ee, _e) {
    if (isNaN(ee) || isNaN(_e)) throw vr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var be = new k(1, 0, 0, 1, ee, _e);
    this.ctx.transform = this.ctx.transform.multiply(be);
  }, j.prototype.transform = function(ee, _e, be, Te, Oe, $e) {
    if (isNaN(ee) || isNaN(_e) || isNaN(be) || isNaN(Te) || isNaN(Oe) || isNaN($e)) throw vr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Ue = new k(ee, _e, be, Te, Oe, $e);
    this.ctx.transform = this.ctx.transform.multiply(Ue);
  }, j.prototype.setTransform = function(ee, _e, be, Te, Oe, $e) {
    ee = isNaN(ee) ? 1 : ee, _e = isNaN(_e) ? 0 : _e, be = isNaN(be) ? 0 : be, Te = isNaN(Te) ? 1 : Te, Oe = isNaN(Oe) ? 0 : Oe, $e = isNaN($e) ? 0 : $e, this.ctx.transform = new k(ee, _e, be, Te, Oe, $e);
  };
  var oe = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  j.prototype.drawImage = function(ee, _e, be, Te, Oe, $e, Ue, Ke, nt) {
    var ot = this.pdf.getImageProperties(ee), vt = 1, mt = 1, Pt = 1, rt = 1;
    Te !== void 0 && Ke !== void 0 && (Pt = Ke / Te, rt = nt / Oe, vt = ot.width / Te * Ke / Te, mt = ot.height / Oe * nt / Oe), $e === void 0 && ($e = _e, Ue = be, _e = 0, be = 0), Te !== void 0 && Ke === void 0 && (Ke = Te, nt = Oe), Te === void 0 && Ke === void 0 && (Ke = ot.width, nt = ot.height);
    for (var Y, Kt = this.ctx.transform.decompose(), Rt = qe(Kt.rotate.shx), lt = new k(), xt = (lt = (lt = (lt = lt.multiply(Kt.translate)).multiply(Kt.skew)).multiply(Kt.scale)).applyToRectangle(new o($e - _e * Pt, Ue - be * rt, Te * vt, Oe * mt)), At = ae.call(this, xt), Et = [], jt = 0; jt < At.length; jt += 1) Et.indexOf(At[jt]) === -1 && Et.push(At[jt]);
    if (Ce(Et), this.autoPaging) for (var ni = Et[0], ii = Et[Et.length - 1], yi = ni; yi < ii + 1; yi++) {
      this.pdf.setPage(yi);
      var xi = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], pt = yi === 1 ? this.posY + this.margin[0] : this.margin[0], Jt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], si = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], It = yi === 1 ? 0 : Jt + (yi - 2) * si;
      if (this.ctx.clip_path.length !== 0) {
        var Zi = this.path;
        Y = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(Y, this.posX + this.margin[3], -It + pt + this.ctx.prevPageLastElemOffset), je.call(this, "fill", !0), this.path = Zi;
      }
      var ft = JSON.parse(JSON.stringify(xt));
      ft = fe([ft], this.posX + this.margin[3], -It + pt + this.ctx.prevPageLastElemOffset)[0];
      var ri = (yi > ni || yi < ii) && oe.call(this);
      ri && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], xi, si, null).clip().discardPath()), this.pdf.addImage(ee, "JPEG", ft.x, ft.y, ft.w, ft.h, null, null, Rt), ri && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(ee, "JPEG", xt.x, xt.y, xt.w, xt.h, null, null, Rt);
  };
  var ae = function(ee, _e, be) {
    var Te = [];
    _e = _e || this.pdf.internal.pageSize.width, be = be || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var Oe = this.posY + this.ctx.prevPageLastElemOffset;
    switch (ee.type) {
      default:
      case "mt":
      case "lt":
        Te.push(Math.floor((ee.y + Oe) / be) + 1);
        break;
      case "arc":
        Te.push(Math.floor((ee.y + Oe - ee.radius) / be) + 1), Te.push(Math.floor((ee.y + Oe + ee.radius) / be) + 1);
        break;
      case "qct":
        var $e = Je(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ee.x1, ee.y1, ee.x, ee.y);
        Te.push(Math.floor(($e.y + Oe) / be) + 1), Te.push(Math.floor(($e.y + $e.h + Oe) / be) + 1);
        break;
      case "bct":
        var Ue = et(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ee.x1, ee.y1, ee.x2, ee.y2, ee.x, ee.y);
        Te.push(Math.floor((Ue.y + Oe) / be) + 1), Te.push(Math.floor((Ue.y + Ue.h + Oe) / be) + 1);
        break;
      case "rect":
        Te.push(Math.floor((ee.y + Oe) / be) + 1), Te.push(Math.floor((ee.y + ee.h + Oe) / be) + 1);
    }
    for (var Ke = 0; Ke < Te.length; Ke += 1) for (; this.pdf.internal.getNumberOfPages() < Te[Ke]; ) Q.call(this);
    return Te;
  }, Q = function() {
    var ee = this.fillStyle, _e = this.strokeStyle, be = this.font, Te = this.lineCap, Oe = this.lineWidth, $e = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = ee, this.strokeStyle = _e, this.font = be, this.lineCap = Te, this.lineWidth = Oe, this.lineJoin = $e;
  }, fe = function(ee, _e, be) {
    for (var Te = 0; Te < ee.length; Te++) switch (ee[Te].type) {
      case "bct":
        ee[Te].x2 += _e, ee[Te].y2 += be;
      case "qct":
        ee[Te].x1 += _e, ee[Te].y1 += be;
      case "mt":
      case "lt":
      case "arc":
      default:
        ee[Te].x += _e, ee[Te].y += be;
    }
    return ee;
  }, Ce = function(ee) {
    return ee.sort(function(_e, be) {
      return _e - be;
    });
  }, ze = function(ee, _e) {
    for (var be, Te, Oe = this.fillStyle, $e = this.strokeStyle, Ue = this.lineCap, Ke = this.lineWidth, nt = Math.abs(Ke * this.ctx.transform.scaleX), ot = this.lineJoin, vt = JSON.parse(JSON.stringify(this.path)), mt = JSON.parse(JSON.stringify(this.path)), Pt = [], rt = 0; rt < mt.length; rt++) if (mt[rt].x !== void 0) for (var Y = ae.call(this, mt[rt]), Kt = 0; Kt < Y.length; Kt += 1) Pt.indexOf(Y[Kt]) === -1 && Pt.push(Y[Kt]);
    for (var Rt = 0; Rt < Pt.length; Rt++) for (; this.pdf.internal.getNumberOfPages() < Pt[Rt]; ) Q.call(this);
    if (Ce(Pt), this.autoPaging) for (var lt = Pt[0], xt = Pt[Pt.length - 1], At = lt; At < xt + 1; At++) {
      this.pdf.setPage(At), this.fillStyle = Oe, this.strokeStyle = $e, this.lineCap = Ue, this.lineWidth = nt, this.lineJoin = ot;
      var Et = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], jt = At === 1 ? this.posY + this.margin[0] : this.margin[0], ni = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ii = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], yi = At === 1 ? 0 : ni + (At - 2) * ii;
      if (this.ctx.clip_path.length !== 0) {
        var xi = this.path;
        be = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(be, this.posX + this.margin[3], -yi + jt + this.ctx.prevPageLastElemOffset), je.call(this, ee, !0), this.path = xi;
      }
      if (Te = JSON.parse(JSON.stringify(vt)), this.path = fe(Te, this.posX + this.margin[3], -yi + jt + this.ctx.prevPageLastElemOffset), _e === !1 || At === 0) {
        var pt = (At > lt || At < xt) && oe.call(this);
        pt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Et, ii, null).clip().discardPath()), je.call(this, ee, _e), pt && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Ke;
    }
    else this.lineWidth = nt, je.call(this, ee, _e), this.lineWidth = Ke;
    this.path = vt;
  }, je = function(ee, _e) {
    if ((ee !== "stroke" || _e || !pe.call(this)) && (ee === "stroke" || _e || !z.call(this))) {
      for (var be, Te, Oe = [], $e = this.path, Ue = 0; Ue < $e.length; Ue++) {
        var Ke = $e[Ue];
        switch (Ke.type) {
          case "begin":
            Oe.push({ begin: !0 });
            break;
          case "close":
            Oe.push({ close: !0 });
            break;
          case "mt":
            Oe.push({ start: Ke, deltas: [], abs: [] });
            break;
          case "lt":
            var nt = Oe.length;
            if ($e[Ue - 1] && !isNaN($e[Ue - 1].x) && (be = [Ke.x - $e[Ue - 1].x, Ke.y - $e[Ue - 1].y], nt > 0)) {
              for (; nt >= 0; nt--) if (Oe[nt - 1].close !== !0 && Oe[nt - 1].begin !== !0) {
                Oe[nt - 1].deltas.push(be), Oe[nt - 1].abs.push(Ke);
                break;
              }
            }
            break;
          case "bct":
            be = [Ke.x1 - $e[Ue - 1].x, Ke.y1 - $e[Ue - 1].y, Ke.x2 - $e[Ue - 1].x, Ke.y2 - $e[Ue - 1].y, Ke.x - $e[Ue - 1].x, Ke.y - $e[Ue - 1].y], Oe[Oe.length - 1].deltas.push(be);
            break;
          case "qct":
            var ot = $e[Ue - 1].x + 2 / 3 * (Ke.x1 - $e[Ue - 1].x), vt = $e[Ue - 1].y + 2 / 3 * (Ke.y1 - $e[Ue - 1].y), mt = Ke.x + 2 / 3 * (Ke.x1 - Ke.x), Pt = Ke.y + 2 / 3 * (Ke.y1 - Ke.y), rt = Ke.x, Y = Ke.y;
            be = [ot - $e[Ue - 1].x, vt - $e[Ue - 1].y, mt - $e[Ue - 1].x, Pt - $e[Ue - 1].y, rt - $e[Ue - 1].x, Y - $e[Ue - 1].y], Oe[Oe.length - 1].deltas.push(be);
            break;
          case "arc":
            Oe.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Oe[Oe.length - 1].abs) && Oe[Oe.length - 1].abs.push(Ke);
        }
      }
      Te = _e ? null : ee === "stroke" ? "stroke" : "fill";
      for (var Kt = !1, Rt = 0; Rt < Oe.length; Rt++) if (Oe[Rt].arc) for (var lt = Oe[Rt].abs, xt = 0; xt < lt.length; xt++) {
        var At = lt[xt];
        At.type === "arc" ? Ae.call(this, At.x, At.y, At.radius, At.startAngle, At.endAngle, At.counterclockwise, void 0, _e, !Kt) : xe.call(this, At.x, At.y), Kt = !0;
      }
      else if (Oe[Rt].close === !0) this.pdf.internal.out("h"), Kt = !1;
      else if (Oe[Rt].begin !== !0) {
        var Et = Oe[Rt].start.x, jt = Oe[Rt].start.y;
        ye.call(this, Oe[Rt].deltas, Et, jt), Kt = !0;
      }
      Te && me.call(this, Te), _e && ve.call(this);
    }
  }, Qe = function(ee) {
    var _e = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, be = _e * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return ee - be;
      case "top":
        return ee + _e - be;
      case "hanging":
        return ee + _e - 2 * be;
      case "middle":
        return ee + _e / 2 - be;
      case "ideographic":
        return ee;
      case "alphabetic":
      default:
        return ee;
    }
  }, ke = function(ee) {
    return ee + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  j.prototype.createLinearGradient = function() {
    var ee = function() {
    };
    return ee.colorStops = [], ee.addColorStop = function(_e, be) {
      this.colorStops.push([_e, be]);
    }, ee.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, ee.isCanvasGradient = !0, ee;
  }, j.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, j.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Ae = function(ee, _e, be, Te, Oe, $e, Ue, Ke, nt) {
    for (var ot = He.call(this, be, Te, Oe, $e), vt = 0; vt < ot.length; vt++) {
      var mt = ot[vt];
      vt === 0 && (nt ? X.call(this, mt.x1 + ee, mt.y1 + _e) : xe.call(this, mt.x1 + ee, mt.y1 + _e)), Ve.call(this, ee, _e, mt.x2, mt.y2, mt.x3, mt.y3, mt.x4, mt.y4);
    }
    Ke ? ve.call(this) : me.call(this, Ue);
  }, me = function(ee) {
    switch (ee) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ve = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, X = function(ee, _e) {
    this.pdf.internal.out(a(ee) + " " + m(_e) + " m");
  }, re = function(ee) {
    var _e;
    switch (ee.align) {
      case "right":
      case "end":
        _e = "right";
        break;
      case "center":
        _e = "center";
        break;
      case "left":
      case "start":
      default:
        _e = "left";
    }
    var be = this.pdf.getTextDimensions(ee.text), Te = Qe.call(this, ee.y), Oe = ke.call(this, Te) - be.h, $e = this.ctx.transform.applyToPoint(new g(ee.x, Te)), Ue = this.ctx.transform.decompose(), Ke = new k();
    Ke = (Ke = (Ke = Ke.multiply(Ue.translate)).multiply(Ue.skew)).multiply(Ue.scale);
    for (var nt, ot, vt, mt = this.ctx.transform.applyToRectangle(new o(ee.x, Te, be.w, be.h)), Pt = Ke.applyToRectangle(new o(ee.x, Oe, be.w, be.h)), rt = ae.call(this, Pt), Y = [], Kt = 0; Kt < rt.length; Kt += 1) Y.indexOf(rt[Kt]) === -1 && Y.push(rt[Kt]);
    if (Ce(Y), this.autoPaging) for (var Rt = Y[0], lt = Y[Y.length - 1], xt = Rt; xt < lt + 1; xt++) {
      this.pdf.setPage(xt);
      var At = xt === 1 ? this.posY + this.margin[0] : this.margin[0], Et = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], jt = this.pdf.internal.pageSize.height - this.margin[2], ni = jt - this.margin[0], ii = this.pdf.internal.pageSize.width - this.margin[1], yi = ii - this.margin[3], xi = xt === 1 ? 0 : Et + (xt - 2) * ni;
      if (this.ctx.clip_path.length !== 0) {
        var pt = this.path;
        nt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(nt, this.posX + this.margin[3], -1 * xi + At), je.call(this, "fill", !0), this.path = pt;
      }
      var Jt = fe([JSON.parse(JSON.stringify(Pt))], this.posX + this.margin[3], -xi + At + this.ctx.prevPageLastElemOffset)[0];
      ee.scale >= 0.01 && (ot = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ot * ee.scale), vt = this.lineWidth, this.lineWidth = vt * ee.scale);
      var si = this.autoPaging !== "text";
      if (si || Jt.y + Jt.h <= jt) {
        if (si || Jt.y >= At && Jt.x <= ii) {
          var It = si ? ee.text : this.pdf.splitTextToSize(ee.text, ee.maxWidth || ii - Jt.x)[0], Zi = fe([JSON.parse(JSON.stringify(mt))], this.posX + this.margin[3], -xi + At + this.ctx.prevPageLastElemOffset)[0], ft = si && (xt > Rt || xt < lt) && oe.call(this);
          ft && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], yi, ni, null).clip().discardPath()), this.pdf.text(It, Zi.x, Zi.y, { angle: ee.angle, align: _e, renderingMode: ee.renderingMode }), ft && this.pdf.restoreGraphicsState();
        }
      } else Jt.y < jt && (this.ctx.prevPageLastElemOffset += jt - Jt.y);
      ee.scale >= 0.01 && (this.pdf.setFontSize(ot), this.lineWidth = vt);
    }
    else ee.scale >= 0.01 && (ot = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ot * ee.scale), vt = this.lineWidth, this.lineWidth = vt * ee.scale), this.pdf.text(ee.text, $e.x + this.posX, $e.y + this.posY, { angle: ee.angle, align: _e, renderingMode: ee.renderingMode, maxWidth: ee.maxWidth }), ee.scale >= 0.01 && (this.pdf.setFontSize(ot), this.lineWidth = vt);
  }, xe = function(ee, _e, be, Te) {
    be = be || 0, Te = Te || 0, this.pdf.internal.out(a(ee + be) + " " + m(_e + Te) + " l");
  }, ye = function(ee, _e, be) {
    return this.pdf.lines(ee, _e, be, null, null);
  }, Ve = function(ee, _e, be, Te, Oe, $e, Ue, Ke) {
    this.pdf.internal.out([l(y(be + ee)), l(_(Te + _e)), l(y(Oe + ee)), l(_($e + _e)), l(y(Ue + ee)), l(_(Ke + _e)), "c"].join(" "));
  }, He = function(ee, _e, be, Te) {
    for (var Oe = 2 * Math.PI, $e = Math.PI / 2; _e > be; ) _e -= Oe;
    var Ue = Math.abs(be - _e);
    Ue < Oe && Te && (Ue = Oe - Ue);
    for (var Ke = [], nt = Te ? -1 : 1, ot = _e; Ue > 1e-5; ) {
      var vt = ot + nt * Math.min(Ue, $e);
      Ke.push(Ze.call(this, ee, ot, vt)), Ue -= Math.abs(vt - ot), ot = vt;
    }
    return Ke;
  }, Ze = function(ee, _e, be) {
    var Te = (be - _e) / 2, Oe = ee * Math.cos(Te), $e = ee * Math.sin(Te), Ue = Oe, Ke = -$e, nt = Ue * Ue + Ke * Ke, ot = nt + Ue * Oe + Ke * $e, vt = 4 / 3 * (Math.sqrt(2 * nt * ot) - ot) / (Ue * $e - Ke * Oe), mt = Ue - vt * Ke, Pt = Ke + vt * Ue, rt = mt, Y = -Pt, Kt = Te + _e, Rt = Math.cos(Kt), lt = Math.sin(Kt);
    return { x1: ee * Math.cos(_e), y1: ee * Math.sin(_e), x2: mt * Rt - Pt * lt, y2: mt * lt + Pt * Rt, x3: rt * Rt - Y * lt, y3: rt * lt + Y * Rt, x4: ee * Math.cos(be), y4: ee * Math.sin(be) };
  }, qe = function(ee) {
    return 180 * ee / Math.PI;
  }, Je = function(ee, _e, be, Te, Oe, $e) {
    var Ue = ee + 0.5 * (be - ee), Ke = _e + 0.5 * (Te - _e), nt = Oe + 0.5 * (be - Oe), ot = $e + 0.5 * (Te - $e), vt = Math.min(ee, Oe, Ue, nt), mt = Math.max(ee, Oe, Ue, nt), Pt = Math.min(_e, $e, Ke, ot), rt = Math.max(_e, $e, Ke, ot);
    return new o(vt, Pt, mt - vt, rt - Pt);
  }, et = function(ee, _e, be, Te, Oe, $e, Ue, Ke) {
    var nt, ot, vt, mt, Pt, rt, Y, Kt, Rt, lt, xt, At, Et, jt, ni = be - ee, ii = Te - _e, yi = Oe - be, xi = $e - Te, pt = Ue - Oe, Jt = Ke - $e;
    for (ot = 0; ot < 41; ot++) Rt = (Y = (vt = ee + (nt = ot / 40) * ni) + nt * ((Pt = be + nt * yi) - vt)) + nt * (Pt + nt * (Oe + nt * pt - Pt) - Y), lt = (Kt = (mt = _e + nt * ii) + nt * ((rt = Te + nt * xi) - mt)) + nt * (rt + nt * ($e + nt * Jt - rt) - Kt), ot == 0 ? (xt = Rt, At = lt, Et = Rt, jt = lt) : (xt = Math.min(xt, Rt), At = Math.min(At, lt), Et = Math.max(Et, Rt), jt = Math.max(jt, lt));
    return new o(Math.round(xt), Math.round(At), Math.round(Et - xt), Math.round(jt - At));
  }, st = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var ee, _e, be = (ee = this.ctx.lineDash, _e = this.ctx.lineDashOffset, JSON.stringify({ lineDash: ee, lineDashOffset: _e }));
      this.prevLineDash !== be && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = be);
    }
  };
})(wi.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = function(_) {
    var g, o, k, D, L, j, O, z, pe, oe;
    for (o = [], k = 0, D = (_ += g = "\0\0\0\0".slice(_.length % 4 || 4)).length; D > k; k += 4) (L = (_.charCodeAt(k) << 24) + (_.charCodeAt(k + 1) << 16) + (_.charCodeAt(k + 2) << 8) + _.charCodeAt(k + 3)) !== 0 ? (j = (L = ((L = ((L = ((L = (L - (oe = L % 85)) / 85) - (pe = L % 85)) / 85) - (z = L % 85)) / 85) - (O = L % 85)) / 85) % 85, o.push(j + 33, O + 33, z + 33, pe + 33, oe + 33)) : o.push(122);
    return function(ae, Q) {
      for (var fe = Q; fe > 0; fe--) ae.pop();
    }(o, g.length), String.fromCharCode.apply(String, o) + "~>";
  }, a = function(_) {
    var g, o, k, D, L, j = String, O = "length", z = 255, pe = "charCodeAt", oe = "slice", ae = "replace";
    for (_[oe](-2), _ = _[oe](0, -2)[ae](/\s/g, "")[ae]("z", "!!!!!"), k = [], D = 0, L = (_ += g = "uuuuu"[oe](_[O] % 5 || 5))[O]; L > D; D += 5) o = 52200625 * (_[pe](D) - 33) + 614125 * (_[pe](D + 1) - 33) + 7225 * (_[pe](D + 2) - 33) + 85 * (_[pe](D + 3) - 33) + (_[pe](D + 4) - 33), k.push(z & o >> 24, z & o >> 16, z & o >> 8, z & o);
    return function(Q, fe) {
      for (var Ce = fe; Ce > 0; Ce--) Q.pop();
    }(k, g[O]), j.fromCharCode.apply(j, k);
  }, m = function(_) {
    var g = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((_ = _.replace(/\s/g, "")).indexOf(">") !== -1 && (_ = _.substr(0, _.indexOf(">"))), _.length % 2 && (_ += "0"), g.test(_) === !1) return "";
    for (var o = "", k = 0; k < _.length; k += 2) o += String.fromCharCode("0x" + (_[k] + _[k + 1]));
    return o;
  }, y = function(_) {
    for (var g = new Uint8Array(_.length), o = _.length; o--; ) g[o] = _.charCodeAt(o);
    return _ = (g = ef(g)).reduce(function(k, D) {
      return k + String.fromCharCode(D);
    }, "");
  };
  s.processDataByFilters = function(_, g) {
    var o = 0, k = _ || "", D = [];
    for (typeof (g = g || []) == "string" && (g = [g]), o = 0; o < g.length; o += 1) switch (g[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        k = a(k), D.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        k = l(k), D.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        k = m(k), D.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        k = k.split("").map(function(L) {
          return ("0" + L.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", D.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        k = y(k), D.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + g[o] + '" is not implemented');
    }
    return { data: k, reverseChain: D.reverse().join(" ") };
  };
}(wi.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  s.loadFile = function(l, a, m) {
    return function(y, _, g) {
      _ = _ !== !1, g = typeof g == "function" ? g : function() {
      };
      var o = void 0;
      try {
        o = function(k, D, L) {
          var j = new XMLHttpRequest(), O = 0, z = function(pe) {
            var oe = pe.length, ae = [], Q = String.fromCharCode;
            for (O = 0; O < oe; O += 1) ae.push(Q(255 & pe.charCodeAt(O)));
            return ae.join("");
          };
          if (j.open("GET", k, !D), j.overrideMimeType("text/plain; charset=x-user-defined"), D === !1 && (j.onload = function() {
            j.status === 200 ? L(z(this.responseText)) : L(void 0);
          }), j.send(null), D && j.status === 200) return z(j.responseText);
        }(y, _, g);
      } catch {
      }
      return o;
    }(l, a, m);
  }, s.loadImageFile = s.loadFile;
}(wi.API), function(s) {
  function l() {
    return (Ai.html2canvas ? Promise.resolve(Ai.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.js")).catch(function(g) {
      return Promise.reject(new Error("Could not load html2canvas: " + g));
    }).then(function(g) {
      return g.default ? g.default : g;
    });
  }
  function a() {
    return (Ai.DOMPurify ? Promise.resolve(Ai.DOMPurify) : import("./purify.es-BwOkayRK--f1u9f-k.js")).catch(function(g) {
      return Promise.reject(new Error("Could not load dompurify: " + g));
    }).then(function(g) {
      return g.default ? g.default : g;
    });
  }
  var m = function(g) {
    var o = ur(g);
    return o === "undefined" ? "undefined" : o === "string" || g instanceof String ? "string" : o === "number" || g instanceof Number ? "number" : o === "function" || g instanceof Function ? "function" : g && g.constructor === Array ? "array" : g && g.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, y = function(g, o) {
    var k = document.createElement(g);
    for (var D in o.className && (k.className = o.className), o.innerHTML && o.dompurify && (k.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) k.style[D] = o.style[D];
    return k;
  }, _ = function g(o) {
    var k = Object.assign(g.convert(Promise.resolve()), JSON.parse(JSON.stringify(g.template))), D = g.convert(Promise.resolve(), k);
    return D = (D = D.setProgress(1, g, 1, [g])).set(o);
  };
  (_.prototype = Object.create(Promise.prototype)).constructor = _, _.convert = function(g, o) {
    return g.__proto__ = o || _.prototype, g;
  }, _.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, _.prototype.from = function(g, o) {
    return this.then(function() {
      switch (o = o || function(k) {
        switch (m(k)) {
          case "string":
            return "string";
          case "element":
            return k.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(g)) {
        case "string":
          return this.then(a).then(function(k) {
            return this.set({ src: y("div", { innerHTML: g, dompurify: k }) });
          });
        case "element":
          return this.set({ src: g });
        case "canvas":
          return this.set({ canvas: g });
        case "img":
          return this.set({ img: g });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, _.prototype.to = function(g) {
    switch (g) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, _.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var g = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function k(D, L) {
        for (var j = D.nodeType === 3 ? document.createTextNode(D.nodeValue) : D.cloneNode(!1), O = D.firstChild; O; O = O.nextSibling) L !== !0 && O.nodeType === 1 && O.nodeName === "SCRIPT" || j.appendChild(k(O, L));
        return D.nodeType === 1 && (D.nodeName === "CANVAS" ? (j.width = D.width, j.height = D.height, j.getContext("2d").drawImage(D, 0, 0)) : D.nodeName !== "TEXTAREA" && D.nodeName !== "SELECT" || (j.value = D.value), j.addEventListener("load", function() {
          j.scrollTop = D.scrollTop, j.scrollLeft = D.scrollLeft;
        }, !0)), j;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (g.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = y("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = y("div", { className: "html2pdf__container", style: g }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(y("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, _.prototype.toCanvas = function() {
    var g = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(g).then(l).then(function(o) {
      var k = Object.assign({}, this.opt.html2canvas);
      return delete k.onrendered, o(this.prop.container, k);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, _.prototype.toContext2d = function() {
    var g = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(g).then(l).then(function(o) {
      var k = this.opt.jsPDF, D = this.opt.fontFaces, L = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, j = Object.assign({ async: !0, allowTaint: !0, scale: L, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete j.onrendered, k.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, k.context2d.posX = this.opt.x, k.context2d.posY = this.opt.y, k.context2d.margin = this.opt.margin, k.context2d.fontFaces = D, D) for (var O = 0; O < D.length; ++O) {
        var z = D[O], pe = z.src.find(function(oe) {
          return oe.format === "truetype";
        });
        pe && k.addFont(pe.url, z.ref.name, z.ref.style);
      }
      return j.windowHeight = j.windowHeight || 0, j.windowHeight = j.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : j.windowHeight, k.context2d.save(!0), o(this.prop.container, j);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, _.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var g = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = g;
    });
  }, _.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, _.prototype.output = function(g, o, k) {
    return (k = k || "pdf").toLowerCase() === "img" || k.toLowerCase() === "image" ? this.outputImg(g, o) : this.outputPdf(g, o);
  }, _.prototype.outputPdf = function(g, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(g, o);
    });
  }, _.prototype.outputImg = function(g) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (g) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + g + '" is not supported.';
      }
    });
  }, _.prototype.save = function(g) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(g ? { filename: g } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, _.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, _.prototype.set = function(g) {
    if (m(g) !== "object") return this;
    var o = Object.keys(g || {}).map(function(k) {
      if (k in _.template.prop) return function() {
        this.prop[k] = g[k];
      };
      switch (k) {
        case "margin":
          return this.setMargin.bind(this, g.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = g.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, g.pageSize);
        default:
          return function() {
            this.opt[k] = g[k];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, _.prototype.get = function(g, o) {
    return this.then(function() {
      var k = g in _.template.prop ? this.prop[g] : this.opt[g];
      return o ? o(k) : k;
    });
  }, _.prototype.setMargin = function(g) {
    return this.then(function() {
      switch (m(g)) {
        case "number":
          g = [g, g, g, g];
        case "array":
          if (g.length === 2 && (g = [g[0], g[1], g[0], g[1]]), g.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = g;
    }).then(this.setPageSize);
  }, _.prototype.setPageSize = function(g) {
    function o(k, D) {
      return Math.floor(k * D / 72 * 96);
    }
    return this.then(function() {
      (g = g || wi.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (g.inner = { width: g.width - this.opt.margin[1] - this.opt.margin[3], height: g.height - this.opt.margin[0] - this.opt.margin[2] }, g.inner.px = { width: o(g.inner.width, g.k), height: o(g.inner.height, g.k) }, g.inner.ratio = g.inner.height / g.inner.width), this.prop.pageSize = g;
    });
  }, _.prototype.setProgress = function(g, o, k, D) {
    return g != null && (this.progress.val = g), o != null && (this.progress.state = o), k != null && (this.progress.n = k), D != null && (this.progress.stack = D), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, _.prototype.updateProgress = function(g, o, k, D) {
    return this.setProgress(g ? this.progress.val + g : null, o || null, k ? this.progress.n + k : null, D ? this.progress.stack.concat(D) : null);
  }, _.prototype.then = function(g, o) {
    var k = this;
    return this.thenCore(g, o, function(D, L) {
      return k.updateProgress(null, null, 1, [D]), Promise.prototype.then.call(this, function(j) {
        return k.updateProgress(null, D), j;
      }).then(D, L).then(function(j) {
        return k.updateProgress(1), j;
      });
    });
  }, _.prototype.thenCore = function(g, o, k) {
    k = k || Promise.prototype.then, g && (g = g.bind(this)), o && (o = o.bind(this));
    var D = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : _.convert(Object.assign({}, this), Promise.prototype), L = k.call(D, g, o);
    return _.convert(L, this.__proto__);
  }, _.prototype.thenExternal = function(g, o) {
    return Promise.prototype.then.call(this, g, o);
  }, _.prototype.thenList = function(g) {
    var o = this;
    return g.forEach(function(k) {
      o = o.thenCore(k);
    }), o;
  }, _.prototype.catch = function(g) {
    g && (g = g.bind(this));
    var o = Promise.prototype.catch.call(this, g);
    return _.convert(o, this);
  }, _.prototype.catchExternal = function(g) {
    return Promise.prototype.catch.call(this, g);
  }, _.prototype.error = function(g) {
    return this.then(function() {
      throw new Error(g);
    });
  }, _.prototype.using = _.prototype.set, _.prototype.saveAs = _.prototype.save, _.prototype.export = _.prototype.output, _.prototype.run = _.prototype.then, wi.getPageSize = function(g, o, k) {
    if (ur(g) === "object") {
      var D = g;
      g = D.orientation, o = D.unit || o, k = D.format || k;
    }
    o = o || "mm", k = k || "a4", g = ("" + (g || "P")).toLowerCase();
    var L, j = ("" + k).toLowerCase(), O = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        L = 1;
        break;
      case "mm":
        L = 72 / 25.4;
        break;
      case "cm":
        L = 72 / 2.54;
        break;
      case "in":
        L = 72;
        break;
      case "px":
        L = 0.75;
        break;
      case "pc":
      case "em":
        L = 12;
        break;
      case "ex":
        L = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var z, pe = 0, oe = 0;
    if (O.hasOwnProperty(j)) pe = O[j][1] / L, oe = O[j][0] / L;
    else try {
      pe = k[1], oe = k[0];
    } catch {
      throw new Error("Invalid format: " + k);
    }
    if (g === "p" || g === "portrait") g = "p", oe > pe && (z = oe, oe = pe, pe = z);
    else {
      if (g !== "l" && g !== "landscape") throw "Invalid orientation: " + g;
      g = "l", pe > oe && (z = oe, oe = pe, pe = z);
    }
    return { width: oe, height: pe, unit: o, k: L, orientation: g };
  }, s.html = function(g, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(of) : null;
    var k = new _(o);
    return o.worker ? k : k.from(g).doCallback();
  };
}(wi.API), wi.API.addJS = function(s) {
  return Jg = s, this.internal.events.subscribe("postPutResources", function() {
    ed = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (ed + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Yg = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Jg + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    ed !== void 0 && Yg !== void 0 && this.internal.out("/Names <</JavaScript " + ed + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l;
  s.events.push(["postPutResources", function() {
    var a = this, m = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var y = a.outline.render().split(/\r\n/), _ = 0; _ < y.length; _++) {
      var g = y[_], o = m.exec(g);
      if (o != null) {
        var k = o[1];
        a.internal.newObjectDeferredBegin(k, !1);
      }
      a.internal.write(g);
    }
    if (this.outline.createNamedDestinations) {
      var D = this.internal.pages.length, L = [];
      for (_ = 0; _ < D; _++) {
        var j = a.internal.newObject();
        L.push(j);
        var O = a.internal.getPageInfo(_ + 1);
        a.internal.write("<< /D[" + O.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var z = a.internal.newObject();
      for (a.internal.write("<< /Names [ "), _ = 0; _ < L.length; _++) a.internal.write("(page_" + (_ + 1) + ")" + L[_] + " 0 R");
      a.internal.write(" ] >>", "endobj"), l = a.internal.newObject(), a.internal.write("<< /Dests " + z + " 0 R"), a.internal.write(">>", "endobj");
    }
  }]), s.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + l + " 0 R"));
  }]), s.events.push(["initialized", function() {
    var a = this;
    a.outline = { createNamedDestinations: !1, root: { children: [] } }, a.outline.add = function(m, y, _) {
      var g = { title: y, options: _, children: [] };
      return m == null && (m = this.root), m.children.push(g), g;
    }, a.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = a, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, a.outline.genIds_r = function(m) {
      m.id = a.internal.newObjectDeferred();
      for (var y = 0; y < m.children.length; y++) this.genIds_r(m.children[y]);
    }, a.outline.renderRoot = function(m) {
      this.objStart(m), this.line("/Type /Outlines"), m.children.length > 0 && (this.line("/First " + this.makeRef(m.children[0])), this.line("/Last " + this.makeRef(m.children[m.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, m)), this.objEnd();
    }, a.outline.renderItems = function(m) {
      for (var y = this.ctx.pdf.internal.getVerticalCoordinateString, _ = 0; _ < m.children.length; _++) {
        var g = m.children[_];
        this.objStart(g), this.line("/Title " + this.makeString(g.title)), this.line("/Parent " + this.makeRef(m)), _ > 0 && this.line("/Prev " + this.makeRef(m.children[_ - 1])), _ < m.children.length - 1 && this.line("/Next " + this.makeRef(m.children[_ + 1])), g.children.length > 0 && (this.line("/First " + this.makeRef(g.children[0])), this.line("/Last " + this.makeRef(g.children[g.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, g);
        if (o > 0 && this.line("/Count " + o), g.options && g.options.pageNumber) {
          var k = a.internal.getPageInfo(g.options.pageNumber);
          this.line("/Dest [" + k.objId + " 0 R /XYZ 0 " + y(0) + " 0]");
        }
        this.objEnd();
      }
      for (var D = 0; D < m.children.length; D++) this.renderItems(m.children[D]);
    }, a.outline.line = function(m) {
      this.ctx.val += m + `\r
`;
    }, a.outline.makeRef = function(m) {
      return m.id + " 0 R";
    }, a.outline.makeString = function(m) {
      return "(" + a.internal.pdfEscape(m) + ")";
    }, a.outline.objStart = function(m) {
      this.ctx.val += `\r
` + m.id + ` 0 obj\r
<<\r
`;
    }, a.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, a.outline.count_r = function(m, y) {
      for (var _ = 0; _ < y.children.length; _++) m.count++, this.count_r(m, y.children[_]);
      return m.count;
    };
  }]);
}(wi.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = [192, 193, 194, 195, 196, 197, 198, 199];
  s.processJPEG = function(a, m, y, _, g, o) {
    var k, D = this.decode.DCT_DECODE, L = null;
    if (typeof a == "string" || this.__addimage__.isArrayBuffer(a) || this.__addimage__.isArrayBufferView(a)) {
      switch (a = g || a, a = this.__addimage__.isArrayBuffer(a) ? new Uint8Array(a) : a, (k = function(j) {
        for (var O, z = 256 * j.charCodeAt(4) + j.charCodeAt(5), pe = j.length, oe = { width: 0, height: 0, numcomponents: 1 }, ae = 4; ae < pe; ae += 2) {
          if (ae += z, l.indexOf(j.charCodeAt(ae + 1)) !== -1) {
            O = 256 * j.charCodeAt(ae + 5) + j.charCodeAt(ae + 6), oe = { width: 256 * j.charCodeAt(ae + 7) + j.charCodeAt(ae + 8), height: O, numcomponents: j.charCodeAt(ae + 9) };
            break;
          }
          z = 256 * j.charCodeAt(ae + 2) + j.charCodeAt(ae + 3);
        }
        return oe;
      }(a = this.__addimage__.isArrayBufferView(a) ? this.__addimage__.arrayBufferToBinaryString(a) : a)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      L = { data: a, width: k.width, height: k.height, colorSpace: o, bitsPerComponent: 8, filter: D, index: m, alias: y };
    }
    return L;
  };
}(wi.API);
var dc, td, Qg, e0, t0, ux = function() {
  var s, l, a;
  function m(_) {
    var g, o, k, D, L, j, O, z, pe, oe, ae, Q, fe, Ce;
    for (this.data = _, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, j = null; ; ) {
      switch (g = this.readUInt32(), pe = (function() {
        var ze, je;
        for (je = [], ze = 0; ze < 4; ++ze) je.push(String.fromCharCode(this.data[this.pos++]));
        return je;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(g);
          break;
        case "fcTL":
          j && this.animation.frames.push(j), this.pos += 4, j = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, L = this.readUInt16(), D = this.readUInt16() || 100, j.delay = 1e3 * L / D, j.disposeOp = this.data[this.pos++], j.blendOp = this.data[this.pos++], j.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (pe === "fdAT" && (this.pos += 4, g -= 4), _ = (j != null ? j.data : void 0) || this.imgData, Q = 0; 0 <= g ? Q < g : Q > g; 0 <= g ? ++Q : --Q) _.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (k = this.palette.length / 3, this.transparency.indexed = this.read(g), this.transparency.indexed.length > k) throw new Error("More transparent colors than palette size");
              if ((oe = k - this.transparency.indexed.length) > 0) for (fe = 0; 0 <= oe ? fe < oe : fe > oe; 0 <= oe ? ++fe : --fe) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(g)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(g);
          }
          break;
        case "tEXt":
          O = (ae = this.read(g)).indexOf(0), z = String.fromCharCode.apply(String, ae.slice(0, O)), this.text[z] = String.fromCharCode.apply(String, ae.slice(O + 1));
          break;
        case "IEND":
          return j && this.animation.frames.push(j), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (Ce = this.colorType) === 4 || Ce === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += g;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  m.prototype.read = function(_) {
    var g, o;
    for (o = [], g = 0; 0 <= _ ? g < _ : g > _; 0 <= _ ? ++g : --g) o.push(this.data[this.pos++]);
    return o;
  }, m.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, m.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, m.prototype.decodePixels = function(_) {
    var g = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * g), k = 0, D = this;
    if (_ == null && (_ = this.imgData), _.length === 0) return new Uint8Array(0);
    function L(j, O, z, pe) {
      var oe, ae, Q, fe, Ce, ze, je, Qe, ke, Ae, me, ve, X, re, xe, ye, Ve, He, Ze, qe, Je, et = Math.ceil((D.width - j) / z), st = Math.ceil((D.height - O) / pe), ee = D.width == et && D.height == st;
      for (re = g * et, ve = ee ? o : new Uint8Array(re * st), ze = _.length, X = 0, ae = 0; X < st && k < ze; ) {
        switch (_[k++]) {
          case 0:
            for (fe = Ve = 0; Ve < re; fe = Ve += 1) ve[ae++] = _[k++];
            break;
          case 1:
            for (fe = He = 0; He < re; fe = He += 1) oe = _[k++], Ce = fe < g ? 0 : ve[ae - g], ve[ae++] = (oe + Ce) % 256;
            break;
          case 2:
            for (fe = Ze = 0; Ze < re; fe = Ze += 1) oe = _[k++], Q = (fe - fe % g) / g, xe = X && ve[(X - 1) * re + Q * g + fe % g], ve[ae++] = (xe + oe) % 256;
            break;
          case 3:
            for (fe = qe = 0; qe < re; fe = qe += 1) oe = _[k++], Q = (fe - fe % g) / g, Ce = fe < g ? 0 : ve[ae - g], xe = X && ve[(X - 1) * re + Q * g + fe % g], ve[ae++] = (oe + Math.floor((Ce + xe) / 2)) % 256;
            break;
          case 4:
            for (fe = Je = 0; Je < re; fe = Je += 1) oe = _[k++], Q = (fe - fe % g) / g, Ce = fe < g ? 0 : ve[ae - g], X === 0 ? xe = ye = 0 : (xe = ve[(X - 1) * re + Q * g + fe % g], ye = Q && ve[(X - 1) * re + (Q - 1) * g + fe % g]), je = Ce + xe - ye, Qe = Math.abs(je - Ce), Ae = Math.abs(je - xe), me = Math.abs(je - ye), ke = Qe <= Ae && Qe <= me ? Ce : Ae <= me ? xe : ye, ve[ae++] = (oe + ke) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + _[k - 1]);
        }
        if (!ee) {
          var _e = ((O + X * pe) * D.width + j) * g, be = X * re;
          for (fe = 0; fe < et; fe += 1) {
            for (var Te = 0; Te < g; Te += 1) o[_e++] = ve[be++];
            _e += (z - 1) * g;
          }
        }
        X++;
      }
    }
    return _ = Vb(_), D.interlaceMethod == 1 ? (L(0, 0, 8, 8), L(4, 0, 8, 8), L(0, 4, 4, 8), L(2, 0, 4, 4), L(0, 2, 2, 4), L(1, 0, 2, 2), L(0, 1, 1, 2)) : L(0, 0, 1, 1), o;
  }, m.prototype.decodePalette = function() {
    var _, g, o, k, D, L, j, O, z;
    for (o = this.palette, L = this.transparency.indexed || [], D = new Uint8Array((L.length || 0) + o.length), k = 0, _ = 0, g = j = 0, O = o.length; j < O; g = j += 3) D[k++] = o[g], D[k++] = o[g + 1], D[k++] = o[g + 2], D[k++] = (z = L[_++]) != null ? z : 255;
    return D;
  }, m.prototype.copyToImageData = function(_, g) {
    var o, k, D, L, j, O, z, pe, oe, ae, Q;
    if (k = this.colors, oe = null, o = this.hasAlphaChannel, this.palette.length && (oe = (Q = this._decodedPalette) != null ? Q : this._decodedPalette = this.decodePalette(), k = 4, o = !0), pe = (D = _.data || _).length, j = oe || g, L = O = 0, k === 1) for (; L < pe; ) z = oe ? 4 * g[L / 4] : O, ae = j[z++], D[L++] = ae, D[L++] = ae, D[L++] = ae, D[L++] = o ? j[z++] : 255, O = z;
    else for (; L < pe; ) z = oe ? 4 * g[L / 4] : O, D[L++] = j[z++], D[L++] = j[z++], D[L++] = j[z++], D[L++] = o ? j[z++] : 255, O = z;
  }, m.prototype.decode = function() {
    var _;
    return _ = new Uint8Array(this.width * this.height * 4), this.copyToImageData(_, this.decodePixels()), _;
  };
  var y = function() {
    if (Object.prototype.toString.call(Ai) === "[object Window]") {
      try {
        l = Ai.document.createElement("canvas"), a = l.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return y(), s = function(_) {
    var g;
    if (y() === !0) return a.width = _.width, a.height = _.height, a.clearRect(0, 0, _.width, _.height), a.putImageData(_, 0, 0), (g = new Image()).src = l.toDataURL(), g;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, m.prototype.decodeFrames = function(_) {
    var g, o, k, D, L, j, O, z;
    if (this.animation) {
      for (z = [], o = L = 0, j = (O = this.animation.frames).length; L < j; o = ++L) g = O[o], k = _.createImageData(g.width, g.height), D = this.decodePixels(new Uint8Array(g.data)), this.copyToImageData(k, D), g.imageData = k, z.push(g.image = s(k));
      return z;
    }
  }, m.prototype.renderFrame = function(_, g) {
    var o, k, D;
    return o = (k = this.animation.frames)[g], D = k[g - 1], g === 0 && _.clearRect(0, 0, this.width, this.height), (D != null ? D.disposeOp : void 0) === 1 ? _.clearRect(D.xOffset, D.yOffset, D.width, D.height) : (D != null ? D.disposeOp : void 0) === 2 && _.putImageData(D.imageData, D.xOffset, D.yOffset), o.blendOp === 0 && _.clearRect(o.xOffset, o.yOffset, o.width, o.height), _.drawImage(o.image, o.xOffset, o.yOffset);
  }, m.prototype.animate = function(_) {
    var g, o, k, D, L, j, O = this;
    return o = 0, j = this.animation, D = j.numFrames, k = j.frames, L = j.numPlays, (g = function() {
      var z, pe;
      if (z = o++ % D, pe = k[z], O.renderFrame(_, z), D > 1 && o / D < L) return O.animation._timeout = setTimeout(g, pe.delay);
    })();
  }, m.prototype.stopAnimation = function() {
    var _;
    return clearTimeout((_ = this.animation) != null ? _._timeout : void 0);
  }, m.prototype.render = function(_) {
    var g, o;
    return _._png && _._png.stopAnimation(), _._png = this, _.width = this.width, _.height = this.height, g = _.getContext("2d"), this.animation ? (this.decodeFrames(g), this.animate(g)) : (o = g.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), g.putImageData(o, 0, 0));
  }, m;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function cx(s) {
  var l = 0;
  if (s[l++] !== 71 || s[l++] !== 73 || s[l++] !== 70 || s[l++] !== 56 || (s[l++] + 1 & 253) != 56 || s[l++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var a = s[l++] | s[l++] << 8, m = s[l++] | s[l++] << 8, y = s[l++], _ = y >> 7, g = 1 << (7 & y) + 1;
  s[l++], s[l++];
  var o = null, k = null;
  _ && (o = l, k = g, l += 3 * g);
  var D = !0, L = [], j = 0, O = null, z = 0, pe = null;
  for (this.width = a, this.height = m; D && l < s.length; ) switch (s[l++]) {
    case 33:
      switch (s[l++]) {
        case 255:
          if (s[l] !== 11 || s[l + 1] == 78 && s[l + 2] == 69 && s[l + 3] == 84 && s[l + 4] == 83 && s[l + 5] == 67 && s[l + 6] == 65 && s[l + 7] == 80 && s[l + 8] == 69 && s[l + 9] == 50 && s[l + 10] == 46 && s[l + 11] == 48 && s[l + 12] == 3 && s[l + 13] == 1 && s[l + 16] == 0) l += 14, pe = s[l++] | s[l++] << 8, l++;
          else for (l += 12; ; ) {
            if (!((X = s[l++]) >= 0)) throw Error("Invalid block size");
            if (X === 0) break;
            l += X;
          }
          break;
        case 249:
          if (s[l++] !== 4 || s[l + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var oe = s[l++];
          j = s[l++] | s[l++] << 8, O = s[l++], !(1 & oe) && (O = null), z = oe >> 2 & 7, l++;
          break;
        case 254:
          for (; ; ) {
            if (!((X = s[l++]) >= 0)) throw Error("Invalid block size");
            if (X === 0) break;
            l += X;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + s[l - 1].toString(16));
      }
      break;
    case 44:
      var ae = s[l++] | s[l++] << 8, Q = s[l++] | s[l++] << 8, fe = s[l++] | s[l++] << 8, Ce = s[l++] | s[l++] << 8, ze = s[l++], je = ze >> 6 & 1, Qe = 1 << (7 & ze) + 1, ke = o, Ae = k, me = !1;
      ze >> 7 && (me = !0, ke = l, Ae = Qe, l += 3 * Qe);
      var ve = l;
      for (l++; ; ) {
        var X;
        if (!((X = s[l++]) >= 0)) throw Error("Invalid block size");
        if (X === 0) break;
        l += X;
      }
      L.push({ x: ae, y: Q, width: fe, height: Ce, has_local_palette: me, palette_offset: ke, palette_size: Ae, data_offset: ve, data_length: l - ve, transparent_index: O, interlaced: !!je, delay: j, disposal: z });
      break;
    case 59:
      D = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + s[l - 1].toString(16));
  }
  this.numFrames = function() {
    return L.length;
  }, this.loopCount = function() {
    return pe;
  }, this.frameInfo = function(re) {
    if (re < 0 || re >= L.length) throw new Error("Frame index out of range.");
    return L[re];
  }, this.decodeAndBlitFrameBGRA = function(re, xe) {
    var ye = this.frameInfo(re), Ve = ye.width * ye.height, He = new Uint8Array(Ve);
    i0(s, ye.data_offset, He, Ve);
    var Ze = ye.palette_offset, qe = ye.transparent_index;
    qe === null && (qe = 256);
    var Je = ye.width, et = a - Je, st = Je, ee = 4 * (ye.y * a + ye.x), _e = 4 * ((ye.y + ye.height) * a + ye.x), be = ee, Te = 4 * et;
    ye.interlaced === !0 && (Te += 4 * a * 7);
    for (var Oe = 8, $e = 0, Ue = He.length; $e < Ue; ++$e) {
      var Ke = He[$e];
      if (st === 0 && (st = Je, (be += Te) >= _e && (Te = 4 * et + 4 * a * (Oe - 1), be = ee + (Je + et) * (Oe << 1), Oe >>= 1)), Ke === qe) be += 4;
      else {
        var nt = s[Ze + 3 * Ke], ot = s[Ze + 3 * Ke + 1], vt = s[Ze + 3 * Ke + 2];
        xe[be++] = vt, xe[be++] = ot, xe[be++] = nt, xe[be++] = 255;
      }
      --st;
    }
  }, this.decodeAndBlitFrameRGBA = function(re, xe) {
    var ye = this.frameInfo(re), Ve = ye.width * ye.height, He = new Uint8Array(Ve);
    i0(s, ye.data_offset, He, Ve);
    var Ze = ye.palette_offset, qe = ye.transparent_index;
    qe === null && (qe = 256);
    var Je = ye.width, et = a - Je, st = Je, ee = 4 * (ye.y * a + ye.x), _e = 4 * ((ye.y + ye.height) * a + ye.x), be = ee, Te = 4 * et;
    ye.interlaced === !0 && (Te += 4 * a * 7);
    for (var Oe = 8, $e = 0, Ue = He.length; $e < Ue; ++$e) {
      var Ke = He[$e];
      if (st === 0 && (st = Je, (be += Te) >= _e && (Te = 4 * et + 4 * a * (Oe - 1), be = ee + (Je + et) * (Oe << 1), Oe >>= 1)), Ke === qe) be += 4;
      else {
        var nt = s[Ze + 3 * Ke], ot = s[Ze + 3 * Ke + 1], vt = s[Ze + 3 * Ke + 2];
        xe[be++] = nt, xe[be++] = ot, xe[be++] = vt, xe[be++] = 255;
      }
      --st;
    }
  };
}
function i0(s, l, a, m) {
  for (var y = s[l++], _ = 1 << y, g = _ + 1, o = g + 1, k = y + 1, D = (1 << k) - 1, L = 0, j = 0, O = 0, z = s[l++], pe = new Int32Array(4096), oe = null; ; ) {
    for (; L < 16 && z !== 0; ) j |= s[l++] << L, L += 8, z === 1 ? z = s[l++] : --z;
    if (L < k) break;
    var ae = j & D;
    if (j >>= k, L -= k, ae !== _) {
      if (ae === g) break;
      for (var Q = ae < o ? ae : oe, fe = 0, Ce = Q; Ce > _; ) Ce = pe[Ce] >> 8, ++fe;
      var ze = Ce;
      if (O + fe + (Q !== ae ? 1 : 0) > m) return void vr.log("Warning, gif stream longer than expected.");
      a[O++] = ze;
      var je = O += fe;
      for (Q !== ae && (a[O++] = ze), Ce = Q; fe--; ) Ce = pe[Ce], a[--je] = 255 & Ce, Ce >>= 8;
      oe !== null && o < 4096 && (pe[o++] = oe << 8 | ze, o >= D + 1 && k < 12 && (++k, D = D << 1 | 1)), oe = ae;
    } else o = g + 1, D = (1 << (k = y + 1)) - 1, oe = null;
  }
  return O !== m && vr.log("Warning, gif stream shorter than expected."), a;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Lp(s) {
  var l, a, m, y, _, g = Math.floor, o = new Array(64), k = new Array(64), D = new Array(64), L = new Array(64), j = new Array(65535), O = new Array(65535), z = new Array(64), pe = new Array(64), oe = [], ae = 0, Q = 7, fe = new Array(64), Ce = new Array(64), ze = new Array(64), je = new Array(256), Qe = new Array(2048), ke = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Ae = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], me = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ve = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], X = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], re = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], xe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ye = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ve = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function He(ee, _e) {
    for (var be = 0, Te = 0, Oe = new Array(), $e = 1; $e <= 16; $e++) {
      for (var Ue = 1; Ue <= ee[$e]; Ue++) Oe[_e[Te]] = [], Oe[_e[Te]][0] = be, Oe[_e[Te]][1] = $e, Te++, be++;
      be *= 2;
    }
    return Oe;
  }
  function Ze(ee) {
    for (var _e = ee[0], be = ee[1] - 1; be >= 0; ) _e & 1 << be && (ae |= 1 << Q), be--, --Q < 0 && (ae == 255 ? (qe(255), qe(0)) : qe(ae), Q = 7, ae = 0);
  }
  function qe(ee) {
    oe.push(ee);
  }
  function Je(ee) {
    qe(ee >> 8 & 255), qe(255 & ee);
  }
  function et(ee, _e, be, Te, Oe) {
    for (var $e, Ue = Oe[0], Ke = Oe[240], nt = function(lt, xt) {
      var At, Et, jt, ni, ii, yi, xi, pt, Jt, si, It = 0;
      for (Jt = 0; Jt < 8; ++Jt) {
        At = lt[It], Et = lt[It + 1], jt = lt[It + 2], ni = lt[It + 3], ii = lt[It + 4], yi = lt[It + 5], xi = lt[It + 6];
        var Zi = At + (pt = lt[It + 7]), ft = At - pt, ri = Et + xi, Lt = Et - xi, Si = jt + yi, Gi = jt - yi, zt = ni + ii, cr = ni - ii, Ni = Zi + zt, ie = Zi - zt, ue = ri + Si, $ = ri - Si;
        lt[It] = Ni + ue, lt[It + 4] = Ni - ue;
        var B = 0.707106781 * ($ + ie);
        lt[It + 2] = ie + B, lt[It + 6] = ie - B;
        var q = 0.382683433 * ((Ni = cr + Gi) - ($ = Lt + ft)), te = 0.5411961 * Ni + q, ge = 1.306562965 * $ + q, Me = 0.707106781 * (ue = Gi + Lt), Fe = ft + Me, Ne = ft - Me;
        lt[It + 5] = Ne + te, lt[It + 3] = Ne - te, lt[It + 1] = Fe + ge, lt[It + 7] = Fe - ge, It += 8;
      }
      for (It = 0, Jt = 0; Jt < 8; ++Jt) {
        At = lt[It], Et = lt[It + 8], jt = lt[It + 16], ni = lt[It + 24], ii = lt[It + 32], yi = lt[It + 40], xi = lt[It + 48];
        var De = At + (pt = lt[It + 56]), tt = At - pt, ut = Et + xi, We = Et - xi, gt = jt + yi, Mt = jt - yi, $t = ni + ii, Qt = ni - ii, ei = De + $t, pi = De - $t, fi = ut + gt, Wi = ut - gt;
        lt[It] = ei + fi, lt[It + 32] = ei - fi;
        var Oi = 0.707106781 * (Wi + pi);
        lt[It + 16] = pi + Oi, lt[It + 48] = pi - Oi;
        var mi = 0.382683433 * ((ei = Qt + Mt) - (Wi = We + tt)), Bi = 0.5411961 * ei + mi, Hi = 1.306562965 * Wi + mi, gr = 0.707106781 * (fi = Mt + We), br = tt + gr, Pr = tt - gr;
        lt[It + 40] = Pr + Bi, lt[It + 24] = Pr - Bi, lt[It + 8] = br + Hi, lt[It + 56] = br - Hi, It++;
      }
      for (Jt = 0; Jt < 64; ++Jt) si = lt[Jt] * xt[Jt], z[Jt] = si > 0 ? si + 0.5 | 0 : si - 0.5 | 0;
      return z;
    }(ee, _e), ot = 0; ot < 64; ++ot) pe[ke[ot]] = nt[ot];
    var vt = pe[0] - be;
    be = pe[0], vt == 0 ? Ze(Te[0]) : (Ze(Te[O[$e = 32767 + vt]]), Ze(j[$e]));
    for (var mt = 63; mt > 0 && pe[mt] == 0; ) mt--;
    if (mt == 0) return Ze(Ue), be;
    for (var Pt, rt = 1; rt <= mt; ) {
      for (var Y = rt; pe[rt] == 0 && rt <= mt; ) ++rt;
      var Kt = rt - Y;
      if (Kt >= 16) {
        Pt = Kt >> 4;
        for (var Rt = 1; Rt <= Pt; ++Rt) Ze(Ke);
        Kt &= 15;
      }
      $e = 32767 + pe[rt], Ze(Oe[(Kt << 4) + O[$e]]), Ze(j[$e]), rt++;
    }
    return mt != 63 && Ze(Ue), be;
  }
  function st(ee) {
    ee = Math.min(Math.max(ee, 1), 100), _ != ee && (function(_e) {
      for (var be = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Te = 0; Te < 64; Te++) {
        var Oe = g((be[Te] * _e + 50) / 100);
        Oe = Math.min(Math.max(Oe, 1), 255), o[ke[Te]] = Oe;
      }
      for (var $e = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Ue = 0; Ue < 64; Ue++) {
        var Ke = g(($e[Ue] * _e + 50) / 100);
        Ke = Math.min(Math.max(Ke, 1), 255), k[ke[Ue]] = Ke;
      }
      for (var nt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], ot = 0, vt = 0; vt < 8; vt++) for (var mt = 0; mt < 8; mt++) D[ot] = 1 / (o[ke[ot]] * nt[vt] * nt[mt] * 8), L[ot] = 1 / (k[ke[ot]] * nt[vt] * nt[mt] * 8), ot++;
    }(ee < 50 ? Math.floor(5e3 / ee) : Math.floor(200 - 2 * ee)), _ = ee);
  }
  this.encode = function(ee, _e) {
    _e && st(_e), oe = new Array(), ae = 0, Q = 7, Je(65496), Je(65504), Je(16), qe(74), qe(70), qe(73), qe(70), qe(0), qe(1), qe(1), qe(0), Je(1), Je(1), qe(0), qe(0), function() {
      Je(65499), Je(132), qe(0);
      for (var Et = 0; Et < 64; Et++) qe(o[Et]);
      qe(1);
      for (var jt = 0; jt < 64; jt++) qe(k[jt]);
    }(), function(Et, jt) {
      Je(65472), Je(17), qe(8), Je(jt), Je(Et), qe(3), qe(1), qe(17), qe(0), qe(2), qe(17), qe(1), qe(3), qe(17), qe(1);
    }(ee.width, ee.height), function() {
      Je(65476), Je(418), qe(0);
      for (var Et = 0; Et < 16; Et++) qe(Ae[Et + 1]);
      for (var jt = 0; jt <= 11; jt++) qe(me[jt]);
      qe(16);
      for (var ni = 0; ni < 16; ni++) qe(ve[ni + 1]);
      for (var ii = 0; ii <= 161; ii++) qe(X[ii]);
      qe(1);
      for (var yi = 0; yi < 16; yi++) qe(re[yi + 1]);
      for (var xi = 0; xi <= 11; xi++) qe(xe[xi]);
      qe(17);
      for (var pt = 0; pt < 16; pt++) qe(ye[pt + 1]);
      for (var Jt = 0; Jt <= 161; Jt++) qe(Ve[Jt]);
    }(), Je(65498), Je(12), qe(3), qe(1), qe(0), qe(2), qe(17), qe(3), qe(17), qe(0), qe(63), qe(0);
    var be = 0, Te = 0, Oe = 0;
    ae = 0, Q = 7, this.encode.displayName = "_encode_";
    for (var $e, Ue, Ke, nt, ot, vt, mt, Pt, rt, Y = ee.data, Kt = ee.width, Rt = ee.height, lt = 4 * Kt, xt = 0; xt < Rt; ) {
      for ($e = 0; $e < lt; ) {
        for (ot = lt * xt + $e, mt = -1, Pt = 0, rt = 0; rt < 64; rt++) vt = ot + (Pt = rt >> 3) * lt + (mt = 4 * (7 & rt)), xt + Pt >= Rt && (vt -= lt * (xt + 1 + Pt - Rt)), $e + mt >= lt && (vt -= $e + mt - lt + 4), Ue = Y[vt++], Ke = Y[vt++], nt = Y[vt++], fe[rt] = (Qe[Ue] + Qe[Ke + 256 >> 0] + Qe[nt + 512 >> 0] >> 16) - 128, Ce[rt] = (Qe[Ue + 768 >> 0] + Qe[Ke + 1024 >> 0] + Qe[nt + 1280 >> 0] >> 16) - 128, ze[rt] = (Qe[Ue + 1280 >> 0] + Qe[Ke + 1536 >> 0] + Qe[nt + 1792 >> 0] >> 16) - 128;
        be = et(fe, D, be, l, m), Te = et(Ce, L, Te, a, y), Oe = et(ze, L, Oe, a, y), $e += 32;
      }
      xt += 8;
    }
    if (Q >= 0) {
      var At = [];
      At[1] = Q + 1, At[0] = (1 << Q + 1) - 1, Ze(At);
    }
    return Je(65497), new Uint8Array(oe);
  }, s = s || 50, function() {
    for (var ee = String.fromCharCode, _e = 0; _e < 256; _e++) je[_e] = ee(_e);
  }(), l = He(Ae, me), a = He(re, xe), m = He(ve, X), y = He(ye, Ve), function() {
    for (var ee = 1, _e = 2, be = 1; be <= 15; be++) {
      for (var Te = ee; Te < _e; Te++) O[32767 + Te] = be, j[32767 + Te] = [], j[32767 + Te][1] = be, j[32767 + Te][0] = Te;
      for (var Oe = -(_e - 1); Oe <= -ee; Oe++) O[32767 + Oe] = be, j[32767 + Oe] = [], j[32767 + Oe][1] = be, j[32767 + Oe][0] = _e - 1 + Oe;
      ee <<= 1, _e <<= 1;
    }
  }(), function() {
    for (var ee = 0; ee < 256; ee++) Qe[ee] = 19595 * ee, Qe[ee + 256 >> 0] = 38470 * ee, Qe[ee + 512 >> 0] = 7471 * ee + 32768, Qe[ee + 768 >> 0] = -11059 * ee, Qe[ee + 1024 >> 0] = -21709 * ee, Qe[ee + 1280 >> 0] = 32768 * ee + 8421375, Qe[ee + 1536 >> 0] = -27439 * ee, Qe[ee + 1792 >> 0] = -5329 * ee;
  }(), st(s);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function eo(s, l) {
  if (this.pos = 0, this.buffer = s, this.datav = new DataView(s.buffer), this.is_with_alpha = !!l, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function r0(s) {
  function l(Ae) {
    if (!Ae) throw Error("assert :P");
  }
  function a(Ae, me, ve) {
    for (var X = 0; 4 > X; X++) if (Ae[me + X] != ve.charCodeAt(X)) return !0;
    return !1;
  }
  function m(Ae, me, ve, X, re) {
    for (var xe = 0; xe < re; xe++) Ae[me + xe] = ve[X + xe];
  }
  function y(Ae, me, ve, X) {
    for (var re = 0; re < X; re++) Ae[me + re] = ve;
  }
  function _(Ae) {
    return new Int32Array(Ae);
  }
  function g(Ae, me) {
    for (var ve = [], X = 0; X < Ae; X++) ve.push(new me());
    return ve;
  }
  function o(Ae, me) {
    var ve = [];
    return function X(re, xe, ye) {
      for (var Ve = ye[xe], He = 0; He < Ve && (re.push(ye.length > xe + 1 ? [] : new me()), !(ye.length < xe + 1)); He++) X(re[He], xe + 1, ye);
    }(ve, 0, Ae), ve;
  }
  var k = function() {
    var Ae = this;
    function me(b, S) {
      for (var h = 1 << S - 1 >>> 0; b & h; ) h >>>= 1;
      return h ? (b & h - 1) + h : b;
    }
    function ve(b, S, h, e, r) {
      l(!(e % h));
      do
        b[S + (e -= h)] = r;
      while (0 < e);
    }
    function X(b, S, h, e, r) {
      if (l(2328 >= r), 512 >= r) var u = _(512);
      else if ((u = _(r)) == null) return 0;
      return function(d, p, w, A, C, P) {
        var F, N, Z = p, G = 1 << w, V = _(16), W = _(16);
        for (l(C != 0), l(A != null), l(d != null), l(0 < w), N = 0; N < C; ++N) {
          if (15 < A[N]) return 0;
          ++V[A[N]];
        }
        if (V[0] == C) return 0;
        for (W[1] = 0, F = 1; 15 > F; ++F) {
          if (V[F] > 1 << F) return 0;
          W[F + 1] = W[F] + V[F];
        }
        for (N = 0; N < C; ++N) F = A[N], 0 < A[N] && (P[W[F]++] = N);
        if (W[15] == 1) return (A = new re()).g = 0, A.value = P[0], ve(d, Z, 1, G, A), G;
        var se, le = -1, de = G - 1, ce = 0, we = 1, Le = 1, Ie = 1 << w;
        for (N = 0, F = 1, C = 2; F <= w; ++F, C <<= 1) {
          if (we += Le <<= 1, 0 > (Le -= V[F])) return 0;
          for (; 0 < V[F]; --V[F]) (A = new re()).g = F, A.value = P[N++], ve(d, Z + ce, C, Ie, A), ce = me(ce, F);
        }
        for (F = w + 1, C = 2; 15 >= F; ++F, C <<= 1) {
          if (we += Le <<= 1, 0 > (Le -= V[F])) return 0;
          for (; 0 < V[F]; --V[F]) {
            if (A = new re(), (ce & de) != le) {
              for (Z += Ie, se = 1 << (le = F) - w; 15 > le && !(0 >= (se -= V[le])); ) ++le, se <<= 1;
              G += Ie = 1 << (se = le - w), d[p + (le = ce & de)].g = se + w, d[p + le].value = Z - p - le;
            }
            A.g = F - w, A.value = P[N++], ve(d, Z + (ce >> w), C, Ie, A), ce = me(ce, F);
          }
        }
        return we != 2 * W[15] - 1 ? 0 : G;
      }(b, S, h, e, r, u);
    }
    function re() {
      this.value = this.g = 0;
    }
    function xe() {
      this.value = this.g = 0;
    }
    function ye() {
      this.G = g(5, re), this.H = _(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = g(Jr, xe);
    }
    function Ve(b, S, h, e) {
      l(b != null), l(S != null), l(2147483648 > e), b.Ca = 254, b.I = 0, b.b = -8, b.Ka = 0, b.oa = S, b.pa = h, b.Jd = S, b.Yc = h + e, b.Zc = 4 <= e ? h + e - 4 + 1 : h, $e(b);
    }
    function He(b, S) {
      for (var h = 0; 0 < S--; ) h |= Ke(b, 128) << S;
      return h;
    }
    function Ze(b, S) {
      var h = He(b, S);
      return Ue(b) ? -h : h;
    }
    function qe(b, S, h, e) {
      var r, u = 0;
      for (l(b != null), l(S != null), l(4294967288 > e), b.Sb = e, b.Ra = 0, b.u = 0, b.h = 0, 4 < e && (e = 4), r = 0; r < e; ++r) u += S[h + r] << 8 * r;
      b.Ra = u, b.bb = e, b.oa = S, b.pa = h;
    }
    function Je(b) {
      for (; 8 <= b.u && b.bb < b.Sb; ) b.Ra >>>= 8, b.Ra += b.oa[b.pa + b.bb] << qn - 8 >>> 0, ++b.bb, b.u -= 8;
      be(b) && (b.h = 1, b.u = 0);
    }
    function et(b, S) {
      if (l(0 <= S), !b.h && S <= ya) {
        var h = _e(b) & _a[S];
        return b.u += S, Je(b), h;
      }
      return b.h = 1, b.u = 0;
    }
    function st() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function ee() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function _e(b) {
      return b.Ra >>> (b.u & qn - 1) >>> 0;
    }
    function be(b) {
      return l(b.bb <= b.Sb), b.h || b.bb == b.Sb && b.u > qn;
    }
    function Te(b, S) {
      b.u = S, b.h = be(b);
    }
    function Oe(b) {
      b.u >= Xs && (l(b.u >= Xs), Je(b));
    }
    function $e(b) {
      l(b != null && b.oa != null), b.pa < b.Zc ? (b.I = (b.oa[b.pa++] | b.I << 8) >>> 0, b.b += 8) : (l(b != null && b.oa != null), b.pa < b.Yc ? (b.b += 8, b.I = b.oa[b.pa++] | b.I << 8) : b.Ka ? b.b = 0 : (b.I <<= 8, b.b += 8, b.Ka = 1));
    }
    function Ue(b) {
      return He(b, 1);
    }
    function Ke(b, S) {
      var h = b.Ca;
      0 > b.b && $e(b);
      var e = b.b, r = h * S >>> 8, u = (b.I >>> e > r) + 0;
      for (u ? (h -= r, b.I -= r + 1 << e >>> 0) : h = r + 1, e = h, r = 0; 256 <= e; ) r += 8, e >>= 8;
      return e = 7 ^ r + Fr[e], b.b -= e, b.Ca = (h << e) - 1, u;
    }
    function nt(b, S, h) {
      b[S + 0] = h >> 24 & 255, b[S + 1] = h >> 16 & 255, b[S + 2] = h >> 8 & 255, b[S + 3] = h >> 0 & 255;
    }
    function ot(b, S) {
      return b[S + 0] << 0 | b[S + 1] << 8;
    }
    function vt(b, S) {
      return ot(b, S) | b[S + 2] << 16;
    }
    function mt(b, S) {
      return ot(b, S) | ot(b, S + 2) << 16;
    }
    function Pt(b, S) {
      var h = 1 << S;
      return l(b != null), l(0 < S), b.X = _(h), b.X == null ? 0 : (b.Mb = 32 - S, b.Xa = S, 1);
    }
    function rt(b, S) {
      l(b != null), l(S != null), l(b.Xa == S.Xa), m(S.X, 0, b.X, 0, 1 << S.Xa);
    }
    function Y() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function Kt(b, S, h, e) {
      l(h != null), l(e != null);
      var r = h[0], u = e[0];
      return r == 0 && (r = (b * u + S / 2) / S), u == 0 && (u = (S * r + b / 2) / b), 0 >= r || 0 >= u ? 0 : (h[0] = r, e[0] = u, 1);
    }
    function Rt(b, S) {
      return b + (1 << S) - 1 >>> S;
    }
    function lt(b, S) {
      return ((4278255360 & b) + (4278255360 & S) >>> 0 & 4278255360) + ((16711935 & b) + (16711935 & S) >>> 0 & 16711935) >>> 0;
    }
    function xt(b, S) {
      Ae[S] = function(h, e, r, u, d, p, w) {
        var A;
        for (A = 0; A < d; ++A) {
          var C = Ae[b](p[w + A - 1], r, u + A);
          p[w + A] = lt(h[e + A], C);
        }
      };
    }
    function At() {
      this.ud = this.hd = this.jd = 0;
    }
    function Et(b, S) {
      return ((4278124286 & (b ^ S)) >>> 1) + (b & S) >>> 0;
    }
    function jt(b) {
      return 0 <= b && 256 > b ? b : 0 > b ? 0 : 255 < b ? 255 : void 0;
    }
    function ni(b, S) {
      return jt(b + (b - S + 0.5 >> 1));
    }
    function ii(b, S, h) {
      return Math.abs(S - h) - Math.abs(b - h);
    }
    function yi(b, S, h, e, r, u, d) {
      for (e = u[d - 1], h = 0; h < r; ++h) u[d + h] = e = lt(b[S + h], e);
    }
    function xi(b, S, h, e, r) {
      var u;
      for (u = 0; u < h; ++u) {
        var d = b[S + u], p = d >> 8 & 255, w = 16711935 & (w = (w = 16711935 & d) + ((p << 16) + p));
        e[r + u] = (4278255360 & d) + w >>> 0;
      }
    }
    function pt(b, S) {
      S.jd = b >> 0 & 255, S.hd = b >> 8 & 255, S.ud = b >> 16 & 255;
    }
    function Jt(b, S, h, e, r, u) {
      var d;
      for (d = 0; d < e; ++d) {
        var p = S[h + d], w = p >>> 8, A = p, C = 255 & (C = (C = p >>> 16) + ((b.jd << 24 >> 24) * (w << 24 >> 24) >>> 5));
        A = 255 & (A = (A = A + ((b.hd << 24 >> 24) * (w << 24 >> 24) >>> 5)) + ((b.ud << 24 >> 24) * (C << 24 >> 24) >>> 5)), r[u + d] = (4278255360 & p) + (C << 16) + A;
      }
    }
    function si(b, S, h, e, r) {
      Ae[S] = function(u, d, p, w, A, C, P, F, N) {
        for (w = P; w < F; ++w) for (P = 0; P < N; ++P) A[C++] = r(p[e(u[d++])]);
      }, Ae[b] = function(u, d, p, w, A, C, P) {
        var F = 8 >> u.b, N = u.Ea, Z = u.K[0], G = u.w;
        if (8 > F) for (u = (1 << u.b) - 1, G = (1 << F) - 1; d < p; ++d) {
          var V, W = 0;
          for (V = 0; V < N; ++V) V & u || (W = e(w[A++])), C[P++] = r(Z[W & G]), W >>= F;
        }
        else Ae["VP8LMapColor" + h](w, A, Z, G, C, P, d, p, N);
      };
    }
    function It(b, S, h, e, r) {
      for (h = S + h; S < h; ) {
        var u = b[S++];
        e[r++] = u >> 16 & 255, e[r++] = u >> 8 & 255, e[r++] = u >> 0 & 255;
      }
    }
    function Zi(b, S, h, e, r) {
      for (h = S + h; S < h; ) {
        var u = b[S++];
        e[r++] = u >> 16 & 255, e[r++] = u >> 8 & 255, e[r++] = u >> 0 & 255, e[r++] = u >> 24 & 255;
      }
    }
    function ft(b, S, h, e, r) {
      for (h = S + h; S < h; ) {
        var u = (d = b[S++]) >> 16 & 240 | d >> 12 & 15, d = d >> 0 & 240 | d >> 28 & 15;
        e[r++] = u, e[r++] = d;
      }
    }
    function ri(b, S, h, e, r) {
      for (h = S + h; S < h; ) {
        var u = (d = b[S++]) >> 16 & 248 | d >> 13 & 7, d = d >> 5 & 224 | d >> 3 & 31;
        e[r++] = u, e[r++] = d;
      }
    }
    function Lt(b, S, h, e, r) {
      for (h = S + h; S < h; ) {
        var u = b[S++];
        e[r++] = u >> 0 & 255, e[r++] = u >> 8 & 255, e[r++] = u >> 16 & 255;
      }
    }
    function Si(b, S, h, e, r, u) {
      if (u == 0) for (h = S + h; S < h; ) nt(e, ((u = b[S++])[0] >> 24 | u[1] >> 8 & 65280 | u[2] << 8 & 16711680 | u[3] << 24) >>> 0), r += 32;
      else m(e, r, b, S, h);
    }
    function Gi(b, S) {
      Ae[S][0] = Ae[b + "0"], Ae[S][1] = Ae[b + "1"], Ae[S][2] = Ae[b + "2"], Ae[S][3] = Ae[b + "3"], Ae[S][4] = Ae[b + "4"], Ae[S][5] = Ae[b + "5"], Ae[S][6] = Ae[b + "6"], Ae[S][7] = Ae[b + "7"], Ae[S][8] = Ae[b + "8"], Ae[S][9] = Ae[b + "9"], Ae[S][10] = Ae[b + "10"], Ae[S][11] = Ae[b + "11"], Ae[S][12] = Ae[b + "12"], Ae[S][13] = Ae[b + "13"], Ae[S][14] = Ae[b + "0"], Ae[S][15] = Ae[b + "0"];
    }
    function zt(b) {
      return b == Eo || b == Ga || b == Co || b == ul;
    }
    function cr() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Ni() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ie() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new cr(), this.f.kb = new Ni(), this.sd = null;
    }
    function ue() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function $() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function B(b) {
      return alert("todo:WebPSamplerProcessPlane"), b.T;
    }
    function q(b, S) {
      var h = b.T, e = S.ba.f.RGBA, r = e.eb, u = e.fb + b.ka * e.A, d = vi[S.ba.S], p = b.y, w = b.O, A = b.f, C = b.N, P = b.ea, F = b.W, N = S.cc, Z = S.dc, G = S.Mc, V = S.Nc, W = b.ka, se = b.ka + b.T, le = b.U, de = le + 1 >> 1;
      for (W == 0 ? d(p, w, null, null, A, C, P, F, A, C, P, F, r, u, null, null, le) : (d(S.ec, S.fc, p, w, N, Z, G, V, A, C, P, F, r, u - e.A, r, u, le), ++h); W + 2 < se; W += 2) N = A, Z = C, G = P, V = F, C += b.Rc, F += b.Rc, u += 2 * e.A, d(p, (w += 2 * b.fa) - b.fa, p, w, N, Z, G, V, A, C, P, F, r, u - e.A, r, u, le);
      return w += b.fa, b.j + se < b.o ? (m(S.ec, S.fc, p, w, le), m(S.cc, S.dc, A, C, de), m(S.Mc, S.Nc, P, F, de), h--) : 1 & se || d(p, w, null, null, A, C, P, F, A, C, P, F, r, u + e.A, null, null, le), h;
    }
    function te(b, S, h) {
      var e = b.F, r = [b.J];
      if (e != null) {
        var u = b.U, d = S.ba.S, p = d == So || d == Co;
        S = S.ba.f.RGBA;
        var w = [0], A = b.ka;
        w[0] = b.T, b.Kb && (A == 0 ? --w[0] : (--A, r[0] -= b.width), b.j + b.ka + b.T == b.o && (w[0] = b.o - b.j - A));
        var C = S.eb;
        A = S.fb + A * S.A, b = Ps(e, r[0], b.width, u, w, C, A + (p ? 0 : 3), S.A), l(h == w), b && zt(d) && Gn(C, A, p, u, w, S.A);
      }
      return 0;
    }
    function ge(b) {
      var S = b.ma, h = S.ba.S, e = 11 > h, r = h == $a || h == Za || h == So || h == ll || h == 12 || zt(h);
      if (S.memory = null, S.Ib = null, S.Jb = null, S.Nd = null, !ds(S.Oa, b, r ? 11 : 12)) return 0;
      if (r && zt(h) && Dt(), b.da) alert("todo:use_scaling");
      else {
        if (e) {
          if (S.Ib = B, b.Kb) {
            if (h = b.U + 1 >> 1, S.memory = _(b.U + 2 * h), S.memory == null) return 0;
            S.ec = S.memory, S.fc = 0, S.cc = S.ec, S.dc = S.fc + b.U, S.Mc = S.cc, S.Nc = S.dc + h, S.Ib = q, Dt();
          }
        } else alert("todo:EmitYUV");
        r && (S.Jb = te, e && Ye());
      }
      if (e && !Ji) {
        for (b = 0; 256 > b; ++b) Io[b] = 89858 * (b - 128) + Rl >> dl, Zu[b] = -22014 * (b - 128) + Rl, jl[b] = -45773 * (b - 128), Ol[b] = 113618 * (b - 128) + Rl >> dl;
        for (b = Xa; b < vu; ++b) S = 76283 * (b - 16) + Rl >> dl, pl[b - Xa] = Mi(S, 255), fl[b - Xa] = Mi(S + 8 >> 4, 15);
        Ji = 1;
      }
      return 1;
    }
    function Me(b) {
      var S = b.ma, h = b.U, e = b.T;
      return l(!(1 & b.ka)), 0 >= h || 0 >= e ? 0 : (h = S.Ib(b, S), S.Jb != null && S.Jb(b, S, h), S.Dc += h, 1);
    }
    function Fe(b) {
      b.ma.memory = null;
    }
    function Ne(b, S, h, e) {
      return et(b, 8) != 47 ? 0 : (S[0] = et(b, 14) + 1, h[0] = et(b, 14) + 1, e[0] = et(b, 1), et(b, 3) != 0 ? 0 : !b.h);
    }
    function De(b, S) {
      if (4 > b) return b + 1;
      var h = b - 2 >> 1;
      return (2 + (1 & b) << h) + et(S, h) + 1;
    }
    function tt(b, S) {
      return 120 < S ? S - 120 : 1 <= (h = ((h = Wn[S - 1]) >> 4) * b + (8 - (15 & h))) ? h : 1;
      var h;
    }
    function ut(b, S, h) {
      var e = _e(h), r = b[S += 255 & e].g - 8;
      return 0 < r && (Te(h, h.u + 8), e = _e(h), S += b[S].value, S += e & (1 << r) - 1), Te(h, h.u + b[S].g), b[S].value;
    }
    function We(b, S, h) {
      return h.g += b.g, h.value += b.value << S >>> 0, l(8 >= h.g), b.g;
    }
    function gt(b, S, h) {
      var e = b.xc;
      return l((S = e == 0 ? 0 : b.vc[b.md * (h >> e) + (S >> e)]) < b.Wb), b.Ya[S];
    }
    function Mt(b, S, h, e) {
      var r = b.ab, u = b.c * S, d = b.C;
      S = d + S;
      var p = h, w = e;
      for (e = b.Ta, h = b.Ua; 0 < r--; ) {
        var A = b.gc[r], C = d, P = S, F = p, N = w, Z = (w = e, p = h, A.Ea);
        switch (l(C < P), l(P <= A.nc), A.hc) {
          case 2:
            qa(F, N, (P - C) * Z, w, p);
            break;
          case 0:
            var G = C, V = P, W = w, se = p, le = (Ie = A).Ea;
            G == 0 && (va(F, N, null, null, 1, W, se), yi(F, N + 1, 0, 0, le - 1, W, se + 1), N += le, se += le, ++G);
            for (var de = 1 << Ie.b, ce = de - 1, we = Rt(le, Ie.b), Le = Ie.K, Ie = Ie.w + (G >> Ie.b) * we; G < V; ) {
              var it = Le, ht = Ie, _t = 1;
              for (Ys(F, N, W, se - le, 1, W, se); _t < le; ) {
                var wt = (_t & ~ce) + de;
                wt > le && (wt = le), (0, ki[it[ht++] >> 8 & 15])(F, N + +_t, W, se + _t - le, wt - _t, W, se + _t), _t = wt;
              }
              N += le, se += le, ++G & ce || (Ie += we);
            }
            P != A.nc && m(w, p - Z, w, p + (P - C - 1) * Z, Z);
            break;
          case 1:
            for (Z = F, V = N, le = (F = A.Ea) - (se = F & ~(W = (N = 1 << A.b) - 1)), G = Rt(F, A.b), de = A.K, A = A.w + (C >> A.b) * G; C < P; ) {
              for (ce = de, we = A, Le = new At(), Ie = V + se, it = V + F; V < Ie; ) pt(ce[we++], Le), cn(Le, Z, V, N, w, p), V += N, p += N;
              V < it && (pt(ce[we++], Le), cn(Le, Z, V, le, w, p), V += le, p += le), ++C & W || (A += G);
            }
            break;
          case 3:
            if (F == w && N == p && 0 < A.b) {
              for (V = w, F = Z = p + (P - C) * Z - (se = (P - C) * Rt(A.Ea, A.b)), N = w, W = p, G = [], se = (le = se) - 1; 0 <= se; --se) G[se] = N[W + se];
              for (se = le - 1; 0 <= se; --se) V[F + se] = G[se];
              Kr(A, C, P, w, Z, w, p);
            } else Kr(A, C, P, F, N, w, p);
        }
        p = e, w = h;
      }
      w != h && m(e, h, p, w, u);
    }
    function $t(b, S) {
      var h = b.V, e = b.Ba + b.c * b.C, r = S - b.C;
      if (l(S <= b.l.o), l(16 >= r), 0 < r) {
        var u = b.l, d = b.Ta, p = b.Ua, w = u.width;
        if (Mt(b, r, h, e), r = p = [p], l((h = b.C) < (e = S)), l(u.v < u.va), e > u.o && (e = u.o), h < u.j) {
          var A = u.j - h;
          h = u.j, r[0] += A * w;
        }
        if (h >= e ? h = 0 : (r[0] += 4 * u.v, u.ka = h - u.j, u.U = u.va - u.v, u.T = e - h, h = 1), h) {
          if (p = p[0], 11 > (h = b.ca).S) {
            var C = h.f.RGBA, P = (e = h.S, r = u.U, u = u.T, A = C.eb, C.A), F = u;
            for (C = C.fb + b.Ma * C.A; 0 < F--; ) {
              var N = d, Z = p, G = r, V = A, W = C;
              switch (e) {
                case Ao:
                  ps(N, Z, G, V, W);
                  break;
                case $a:
                  Js(N, Z, G, V, W);
                  break;
                case Eo:
                  Js(N, Z, G, V, W), Gn(V, W, 0, G, 1, 0);
                  break;
                case Fl:
                  Ks(N, Z, G, V, W);
                  break;
                case Za:
                  Si(N, Z, G, V, W, 1);
                  break;
                case Ga:
                  Si(N, Z, G, V, W, 1), Gn(V, W, 0, G, 1, 0);
                  break;
                case So:
                  Si(N, Z, G, V, W, 0);
                  break;
                case Co:
                  Si(N, Z, G, V, W, 0), Gn(V, W, 1, G, 1, 0);
                  break;
                case ll:
                  hn(N, Z, G, V, W);
                  break;
                case ul:
                  hn(N, Z, G, V, W), Tr(V, W, G, 1, 0);
                  break;
                case Aa:
                  Is(N, Z, G, V, W);
                  break;
                default:
                  l(0);
              }
              p += w, C += P;
            }
            b.Ma += u;
          } else alert("todo:EmitRescaledRowsYUVA");
          l(b.Ma <= h.height);
        }
      }
      b.C = S, l(b.C <= b.i);
    }
    function Qt(b) {
      var S;
      if (0 < b.ua) return 0;
      for (S = 0; S < b.Wb; ++S) {
        var h = b.Ya[S].G, e = b.Ya[S].H;
        if (0 < h[1][e[1] + 0].g || 0 < h[2][e[2] + 0].g || 0 < h[3][e[3] + 0].g) return 0;
      }
      return 1;
    }
    function ei(b, S, h, e, r, u) {
      if (b.Z != 0) {
        var d = b.qd, p = b.rd;
        for (l(Ns[b.Z] != null); S < h; ++S) Ns[b.Z](d, p, e, r, e, r, u), d = e, p = r, r += u;
        b.qd = d, b.rd = p;
      }
    }
    function pi(b, S) {
      var h = b.l.ma, e = h.Z == 0 || h.Z == 1 ? b.l.j : b.C;
      if (e = b.C < e ? e : b.C, l(S <= b.l.o), S > e) {
        var r = b.l.width, u = h.ca, d = h.tb + r * e, p = b.V, w = b.Ba + b.c * e, A = b.gc;
        l(b.ab == 1), l(A[0].hc == 3), zl(A[0], e, S, p, w, u, d), ei(h, e, S, u, d, r);
      }
      b.C = b.Ma = S;
    }
    function fi(b, S, h, e, r, u, d) {
      var p = b.$ / e, w = b.$ % e, A = b.m, C = b.s, P = h + b.$, F = P;
      r = h + e * r;
      var N = h + e * u, Z = 280 + C.ua, G = b.Pb ? p : 16777216, V = 0 < C.ua ? C.Wa : null, W = C.wc, se = P < N ? gt(C, w, p) : null;
      l(b.C < u), l(N <= r);
      var le = !1;
      e: for (; ; ) {
        for (; le || P < N; ) {
          var de = 0;
          if (p >= G) {
            var ce = P - h;
            l((G = b).Pb), G.wd = G.m, G.xd = ce, 0 < G.s.ua && rt(G.s.Wa, G.s.vb), G = p + pu;
          }
          if (w & W || (se = gt(C, w, p)), l(se != null), se.Qb && (S[P] = se.qb, le = !0), !le) if (Oe(A), se.jc) {
            de = A, ce = S;
            var we = P, Le = se.pd[_e(de) & Jr - 1];
            l(se.jc), 256 > Le.g ? (Te(de, de.u + Le.g), ce[we] = Le.value, de = 0) : (Te(de, de.u + Le.g - 256), l(256 <= Le.value), de = Le.value), de == 0 && (le = !0);
          } else de = ut(se.G[0], se.H[0], A);
          if (A.h) break;
          if (le || 256 > de) {
            if (!le) if (se.nd) S[P] = (se.qb | de << 8) >>> 0;
            else {
              if (Oe(A), le = ut(se.G[1], se.H[1], A), Oe(A), ce = ut(se.G[2], se.H[2], A), we = ut(se.G[3], se.H[3], A), A.h) break;
              S[P] = (we << 24 | le << 16 | de << 8 | ce) >>> 0;
            }
            if (le = !1, ++P, ++w >= e && (w = 0, ++p, d != null && p <= u && !(p % 16) && d(b, p), V != null)) for (; F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
          } else if (280 > de) {
            if (de = De(de - 256, A), ce = ut(se.G[4], se.H[4], A), Oe(A), ce = tt(e, ce = De(ce, A)), A.h) break;
            if (P - h < ce || r - P < de) break e;
            for (we = 0; we < de; ++we) S[P + we] = S[P + we - ce];
            for (P += de, w += de; w >= e; ) w -= e, ++p, d != null && p <= u && !(p % 16) && d(b, p);
            if (l(P <= r), w & W && (se = gt(C, w, p)), V != null) for (; F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
          } else {
            if (!(de < Z)) break e;
            for (le = de - 280, l(V != null); F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
            de = P, l(!(le >>> (ce = V).Xa)), S[de] = ce.X[le], le = !0;
          }
          le || l(A.h == be(A));
        }
        if (b.Pb && A.h && P < r) l(b.m.h), b.a = 5, b.m = b.wd, b.$ = b.xd, 0 < b.s.ua && rt(b.s.vb, b.s.Wa);
        else {
          if (A.h) break e;
          d != null && d(b, p > u ? u : p), b.a = 0, b.$ = P - h;
        }
        return 1;
      }
      return b.a = 3, 0;
    }
    function Wi(b) {
      l(b != null), b.vc = null, b.yc = null, b.Ya = null;
      var S = b.Wa;
      S != null && (S.X = null), b.vb = null, l(b != null);
    }
    function Oi() {
      var b = new ja();
      return b == null ? null : (b.a = 0, b.xb = Ha, Gi("Predictor", "VP8LPredictors"), Gi("Predictor", "VP8LPredictors_C"), Gi("PredictorAdd", "VP8LPredictorsAdd"), Gi("PredictorAdd", "VP8LPredictorsAdd_C"), qa = xi, cn = Jt, ps = It, Js = Zi, hn = ft, Is = ri, Ks = Lt, Ae.VP8LMapColor32b = Ds, Ae.VP8LMapColor8b = al, b);
    }
    function mi(b, S, h, e, r) {
      var u = 1, d = [b], p = [S], w = e.m, A = e.s, C = null, P = 0;
      e: for (; ; ) {
        if (h) for (; u && et(w, 1); ) {
          var F = d, N = p, Z = e, G = 1, V = Z.m, W = Z.gc[Z.ab], se = et(V, 2);
          if (Z.Oc & 1 << se) u = 0;
          else {
            switch (Z.Oc |= 1 << se, W.hc = se, W.Ea = F[0], W.nc = N[0], W.K = [null], ++Z.ab, l(4 >= Z.ab), se) {
              case 0:
              case 1:
                W.b = et(V, 3) + 2, G = mi(Rt(W.Ea, W.b), Rt(W.nc, W.b), 0, Z, W.K), W.K = W.K[0];
                break;
              case 3:
                var le, de = et(V, 8) + 1, ce = 16 < de ? 0 : 4 < de ? 1 : 2 < de ? 2 : 3;
                if (F[0] = Rt(W.Ea, ce), W.b = ce, le = G = mi(de, 1, 0, Z, W.K)) {
                  var we, Le = de, Ie = W, it = 1 << (8 >> Ie.b), ht = _(it);
                  if (ht == null) le = 0;
                  else {
                    var _t = Ie.K[0], wt = Ie.w;
                    for (ht[0] = Ie.K[0][0], we = 1; we < 1 * Le; ++we) ht[we] = lt(_t[wt + we], ht[we - 1]);
                    for (; we < 4 * it; ++we) ht[we] = 0;
                    Ie.K[0] = null, Ie.K[0] = ht, le = 1;
                  }
                }
                G = le;
                break;
              case 2:
                break;
              default:
                l(0);
            }
            u = G;
          }
        }
        if (d = d[0], p = p[0], u && et(w, 1) && !(u = 1 <= (P = et(w, 4)) && 11 >= P)) {
          e.a = 3;
          break e;
        }
        var bt;
        if (bt = u) t: {
          var yt, St, Zt, Tt = e, kt = d, Wt = p, di = P, ci = h, gi = Tt.m, Ei = Tt.s, qi = [null], sr = 1, Fi = 0, yr = Ls[di];
          i: for (; ; ) {
            if (ci && et(gi, 1)) {
              var Ui = et(gi, 3) + 2, pr = Rt(kt, Ui), kr = Rt(Wt, Ui), pn = pr * kr;
              if (!mi(pr, kr, 0, Tt, qi)) break i;
              for (qi = qi[0], Ei.xc = Ui, yt = 0; yt < pn; ++yt) {
                var Mn = qi[yt] >> 8 & 65535;
                qi[yt] = Mn, Mn >= sr && (sr = Mn + 1);
              }
            }
            if (gi.h) break i;
            for (St = 0; 5 > St; ++St) {
              var ar = cl[St];
              !St && 0 < di && (ar += 1 << di), Fi < ar && (Fi = ar);
            }
            var Ea = g(sr * yr, re), Nn = sr, gl = g(Nn, ye);
            if (gl == null) var Po = null;
            else l(65536 >= Nn), Po = gl;
            var en = _(Fi);
            if (Po == null || en == null || Ea == null) {
              Tt.a = 1;
              break i;
            }
            var fn = Ea;
            for (yt = Zt = 0; yt < sr; ++yt) {
              var Rr = Po[yt], tn = Rr.G, Ar = Rr.H, Vr = 0, rn = 1, Li = 0;
              for (St = 0; 5 > St; ++St) {
                ar = cl[St], tn[St] = fn, Ar[St] = Zt, !St && 0 < di && (ar += 1 << di);
                n: {
                  var zs, Ca = ar, ea = Tt, Lo = en, Pc = fn, Gu = Zt, Fs = 0, ta = ea.m, ql = et(ta, 1);
                  if (y(Lo, 0, 0, Ca), ql) {
                    var _l = et(ta, 1) + 1, Ul = et(ta, 1), yl = et(ta, Ul == 0 ? 1 : 8);
                    Lo[yl] = 1, _l == 2 && (Lo[yl = et(ta, 8)] = 1);
                    var ia = 1;
                  } else {
                    var Mo = _(19), bu = et(ta, 4) + 4;
                    if (19 < bu) {
                      ea.a = 3;
                      var xu = 0;
                      break n;
                    }
                    for (zs = 0; zs < bu; ++zs) Mo[qu[zs]] = et(ta, 3);
                    var Hu = void 0, wu = void 0, Wu = ea, Au = Mo, Ya = Ca, Ta = Lo, ys = 0, zn = Wu.m, Lc = 8, No = g(128, re);
                    r: for (; X(No, 0, 7, Au, 19); ) {
                      if (et(zn, 1)) {
                        var Cd = 2 + 2 * et(zn, 3);
                        if ((Hu = 2 + et(zn, Cd)) > Ya) break r;
                      } else Hu = Ya;
                      for (wu = 0; wu < Ya && Hu--; ) {
                        Oe(zn);
                        var Mc = No[0 + (127 & _e(zn))];
                        Te(zn, zn.u + Mc.g);
                        var or = Mc.value;
                        if (16 > or) Ta[wu++] = or, or != 0 && (Lc = or);
                        else {
                          var Nc = or == 16, zc = or - 16, vl = du[zc], zo = et(zn, hu[zc]) + vl;
                          if (wu + zo > Ya) break r;
                          for (var Xu = Nc ? Lc : 0; 0 < zo--; ) Ta[wu++] = Xu;
                        }
                      }
                      ys = 1;
                      break r;
                    }
                    ys || (Wu.a = 3), ia = ys;
                  }
                  (ia = ia && !ta.h) && (Fs = X(Pc, Gu, 8, Lo, Ca)), ia && Fs != 0 ? xu = Fs : (ea.a = 3, xu = 0);
                }
                if (xu == 0) break i;
                if (rn && To[St] == 1 && (rn = fn[Zt].g == 0), Vr += fn[Zt].g, Zt += xu, 3 >= St) {
                  var bl, Yu = en[0];
                  for (bl = 1; bl < ar; ++bl) en[bl] > Yu && (Yu = en[bl]);
                  Li += Yu;
                }
              }
              if (Rr.nd = rn, Rr.Qb = 0, rn && (Rr.qb = (tn[3][Ar[3] + 0].value << 24 | tn[1][Ar[1] + 0].value << 16 | tn[2][Ar[2] + 0].value) >>> 0, Vr == 0 && 256 > tn[0][Ar[0] + 0].value && (Rr.Qb = 1, Rr.qb += tn[0][Ar[0] + 0].value << 8)), Rr.jc = !Rr.Qb && 6 > Li, Rr.jc) {
                var Ju, ka = Rr;
                for (Ju = 0; Ju < Jr; ++Ju) {
                  var Fo = Ju, Da = ka.pd[Fo], Ku = ka.G[0][ka.H[0] + Fo];
                  256 <= Ku.value ? (Da.g = Ku.g + 256, Da.value = Ku.value) : (Da.g = 0, Da.value = 0, Fo >>= We(Ku, 8, Da), Fo >>= We(ka.G[1][ka.H[1] + Fo], 16, Da), Fo >>= We(ka.G[2][ka.H[2] + Fo], 0, Da), We(ka.G[3][ka.H[3] + Fo], 24, Da));
                }
              }
            }
            Ei.vc = qi, Ei.Wb = sr, Ei.Ya = Po, Ei.yc = Ea, bt = 1;
            break t;
          }
          bt = 0;
        }
        if (!(u = bt)) {
          e.a = 3;
          break e;
        }
        if (0 < P) {
          if (A.ua = 1 << P, !Pt(A.Wa, P)) {
            e.a = 1, u = 0;
            break e;
          }
        } else A.ua = 0;
        var Su = e, Fc = d, kh = p, Bo = Su.s, Bc = Bo.xc;
        if (Su.c = Fc, Su.i = kh, Bo.md = Rt(Fc, Bc), Bo.wc = Bc == 0 ? -1 : (1 << Bc) - 1, h) {
          e.xb = Do;
          break e;
        }
        if ((C = _(d * p)) == null) {
          e.a = 1, u = 0;
          break e;
        }
        u = (u = fi(e, C, 0, d, p, p, null)) && !w.h;
        break e;
      }
      return u ? (r != null ? r[0] = C : (l(C == null), l(h)), e.$ = 0, h || Wi(A)) : Wi(A), u;
    }
    function Bi(b, S) {
      var h = b.c * b.i, e = h + S + 16 * S;
      return l(b.c <= S), b.V = _(e), b.V == null ? (b.Ta = null, b.Ua = 0, b.a = 1, 0) : (b.Ta = b.V, b.Ua = b.Ba + h + S, 1);
    }
    function Hi(b, S) {
      var h = b.C, e = S - h, r = b.V, u = b.Ba + b.c * h;
      for (l(S <= b.l.o); 0 < e; ) {
        var d = 16 < e ? 16 : e, p = b.l.ma, w = b.l.width, A = w * d, C = p.ca, P = p.tb + w * h, F = b.Ta, N = b.Ua;
        Mt(b, d, r, u), uu(F, N, C, P, A), ei(p, h, h + d, C, P, w), e -= d, r += d * b.c, h += d;
      }
      l(h == S), b.C = b.Ma = S;
    }
    function gr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function br() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Pr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = _(4), this.Lb = _(4);
    }
    function Vs() {
      this.Yb = function() {
        var b = [];
        return function S(h, e, r) {
          for (var u = r[e], d = 0; d < u && (h.push(r.length > e + 1 ? [] : 0), !(r.length < e + 1)); d++) S(h[d], e + 1, r);
        }(b, 0, [3, 11]), b;
      }();
    }
    function ji() {
      this.jb = _(3), this.Wc = o([4, 8], Vs), this.Xc = o([4, 17], Vs);
    }
    function Yo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new _(4), this.od = new _(4);
    }
    function ca() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Wr() {
      this.Na = this.la = 0;
    }
    function on() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Jo() {
      this.ad = _(384), this.Za = 0, this.Ob = _(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function gn() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new ca()), this.Y = 0, this.ya = Array(new Jo()), this.aa = 0, this.l = new On();
    }
    function Xr() {
      this.y = _(16), this.f = _(8), this.ea = _(8);
    }
    function ha() {
      this.cb = this.a = 0, this.sc = "", this.m = new st(), this.Od = new gr(), this.Kc = new br(), this.ed = new Yo(), this.Qa = new Pr(), this.Ic = this.$c = this.Aa = 0, this.D = new gn(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = g(8, st), this.ia = 0, this.pb = g(4, on), this.Pa = new ji(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Xr()), this.Hd = 0, this.rb = Array(new Wr()), this.sb = 0, this.wa = Array(new ca()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Jo()), this.L = this.aa = 0, this.gd = o([4, 2], ca), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function On() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function xr() {
      var b = new ha();
      return b != null && (b.a = 0, b.sc = "OK", b.cb = 0, b.Xb = 0, hl || (hl = Na)), b;
    }
    function rr(b, S, h) {
      return b.a == 0 && (b.a = S, b.sc = h, b.cb = 0), 0;
    }
    function _n(b, S, h) {
      return 3 <= h && b[S + 0] == 157 && b[S + 1] == 1 && b[S + 2] == 42;
    }
    function hr(b, S) {
      if (b == null) return 0;
      if (b.a = 0, b.sc = "OK", S == null) return rr(b, 2, "null VP8Io passed to VP8GetHeaders()");
      var h = S.data, e = S.w, r = S.ha;
      if (4 > r) return rr(b, 7, "Truncated header.");
      var u = h[e + 0] | h[e + 1] << 8 | h[e + 2] << 16, d = b.Od;
      if (d.Rb = !(1 & u), d.td = u >> 1 & 7, d.yd = u >> 4 & 1, d.ub = u >> 5, 3 < d.td) return rr(b, 3, "Incorrect keyframe parameters.");
      if (!d.yd) return rr(b, 4, "Frame not displayable.");
      e += 3, r -= 3;
      var p = b.Kc;
      if (d.Rb) {
        if (7 > r) return rr(b, 7, "cannot parse picture header");
        if (!_n(h, e, r)) return rr(b, 3, "Bad code word");
        p.c = 16383 & (h[e + 4] << 8 | h[e + 3]), p.Td = h[e + 4] >> 6, p.i = 16383 & (h[e + 6] << 8 | h[e + 5]), p.Ud = h[e + 6] >> 6, e += 7, r -= 7, b.za = p.c + 15 >> 4, b.Ub = p.i + 15 >> 4, S.width = p.c, S.height = p.i, S.Da = 0, S.j = 0, S.v = 0, S.va = S.width, S.o = S.height, S.da = 0, S.ib = S.width, S.hb = S.height, S.U = S.width, S.T = S.height, y((u = b.Pa).jb, 0, 255, u.jb.length), l((u = b.Qa) != null), u.Cb = 0, u.Bb = 0, u.Fb = 1, y(u.Zb, 0, 0, u.Zb.length), y(u.Lb, 0, 0, u.Lb);
      }
      if (d.ub > r) return rr(b, 7, "bad partition length");
      Ve(u = b.m, h, e, d.ub), e += d.ub, r -= d.ub, d.Rb && (p.Ld = Ue(u), p.Kd = Ue(u)), p = b.Qa;
      var w, A = b.Pa;
      if (l(u != null), l(p != null), p.Cb = Ue(u), p.Cb) {
        if (p.Bb = Ue(u), Ue(u)) {
          for (p.Fb = Ue(u), w = 0; 4 > w; ++w) p.Zb[w] = Ue(u) ? Ze(u, 7) : 0;
          for (w = 0; 4 > w; ++w) p.Lb[w] = Ue(u) ? Ze(u, 6) : 0;
        }
        if (p.Bb) for (w = 0; 3 > w; ++w) A.jb[w] = Ue(u) ? He(u, 8) : 255;
      } else p.Bb = 0;
      if (u.Ka) return rr(b, 3, "cannot parse segment header");
      if ((p = b.ed).zd = Ue(u), p.Tb = He(u, 6), p.wb = He(u, 3), p.Pc = Ue(u), p.Pc && Ue(u)) {
        for (A = 0; 4 > A; ++A) Ue(u) && (p.vd[A] = Ze(u, 6));
        for (A = 0; 4 > A; ++A) Ue(u) && (p.od[A] = Ze(u, 6));
      }
      if (b.L = p.Tb == 0 ? 0 : p.zd ? 1 : 2, u.Ka) return rr(b, 3, "cannot parse filter header");
      var C = r;
      if (r = w = e, e = w + C, p = C, b.Xb = (1 << He(b.m, 2)) - 1, C < 3 * (A = b.Xb)) h = 7;
      else {
        for (w += 3 * A, p -= 3 * A, C = 0; C < A; ++C) {
          var P = h[r + 0] | h[r + 1] << 8 | h[r + 2] << 16;
          P > p && (P = p), Ve(b.Jc[+C], h, w, P), w += P, p -= P, r += 3;
        }
        Ve(b.Jc[+A], h, w, p), h = w < e ? 0 : 5;
      }
      if (h != 0) return rr(b, h, "cannot parse partitions");
      for (h = He(w = b.m, 7), r = Ue(w) ? Ze(w, 4) : 0, e = Ue(w) ? Ze(w, 4) : 0, p = Ue(w) ? Ze(w, 4) : 0, A = Ue(w) ? Ze(w, 4) : 0, w = Ue(w) ? Ze(w, 4) : 0, C = b.Qa, P = 0; 4 > P; ++P) {
        if (C.Cb) {
          var F = C.Zb[P];
          C.Fb || (F += h);
        } else {
          if (0 < P) {
            b.pb[P] = b.pb[0];
            continue;
          }
          F = h;
        }
        var N = b.pb[P];
        N.Sc[0] = In[Mi(F + r, 127)], N.Sc[1] = Qs[Mi(F + 0, 127)], N.Eb[0] = 2 * In[Mi(F + e, 127)], N.Eb[1] = 101581 * Qs[Mi(F + p, 127)] >> 16, 8 > N.Eb[1] && (N.Eb[1] = 8), N.Qc[0] = In[Mi(F + A, 117)], N.Qc[1] = Qs[Mi(F + w, 127)], N.lc = F + w;
      }
      if (!d.Rb) return rr(b, 4, "Not a key frame.");
      for (Ue(u), d = b.Pa, h = 0; 4 > h; ++h) {
        for (r = 0; 8 > r; ++r) for (e = 0; 3 > e; ++e) for (p = 0; 11 > p; ++p) A = Ke(u, Xn[h][r][e][p]) ? He(u, 8) : mu[h][r][e][p], d.Wc[h][r].Yb[e][p] = A;
        for (r = 0; 17 > r; ++r) d.Xc[h][r] = d.Wc[h][Ot[r]];
      }
      return b.kc = Ue(u), b.kc && (b.Bd = He(u, 8)), b.cb = 1;
    }
    function Na(b, S, h, e, r, u, d) {
      var p = S[r].Yb[h];
      for (h = 0; 16 > r; ++r) {
        if (!Ke(b, p[h + 0])) return r;
        for (; !Ke(b, p[h + 1]); ) if (p = S[++r].Yb[0], h = 0, r == 16) return 16;
        var w = S[r + 1].Yb;
        if (Ke(b, p[h + 2])) {
          var A = b, C = 0;
          if (Ke(A, (F = p)[(P = h) + 3])) if (Ke(A, F[P + 6])) {
            for (p = 0, P = 2 * (C = Ke(A, F[P + 8])) + (F = Ke(A, F[P + 9 + C])), C = 0, F = Dc[P]; F[p]; ++p) C += C + Ke(A, F[p]);
            C += 3 + (8 << P);
          } else Ke(A, F[P + 7]) ? (C = 7 + 2 * Ke(A, 165), C += Ke(A, 145)) : C = 5 + Ke(A, 159);
          else C = Ke(A, F[P + 4]) ? 3 + Ke(A, F[P + 5]) : 2;
          p = w[2];
        } else C = 1, p = w[1];
        w = d + Uu[r], 0 > (A = b).b && $e(A);
        var P, F = A.b, N = (P = A.Ca >> 1) - (A.I >> F) >> 31;
        --A.b, A.Ca += N, A.Ca |= 1, A.I -= (P + 1 & N) << F, u[w] = ((C ^ N) - N) * e[(0 < r) + 0];
      }
      return 16;
    }
    function ln(b) {
      var S = b.rb[b.sb - 1];
      S.la = 0, S.Na = 0, y(b.zc, 0, 0, b.zc.length), b.ja = 0;
    }
    function Ko(b, S) {
      if (b == null) return 0;
      if (S == null) return rr(b, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!b.cb && !hr(b, S)) return 0;
      if (l(b.cb), S.ac == null || S.ac(S)) {
        S.ob && (b.L = 0);
        var h = Sa[b.L];
        if (b.L == 2 ? (b.yb = 0, b.zb = 0) : (b.yb = S.v - h >> 4, b.zb = S.j - h >> 4, 0 > b.yb && (b.yb = 0), 0 > b.zb && (b.zb = 0)), b.Va = S.o + 15 + h >> 4, b.Hb = S.va + 15 + h >> 4, b.Hb > b.za && (b.Hb = b.za), b.Va > b.Ub && (b.Va = b.Ub), 0 < b.L) {
          var e = b.ed;
          for (h = 0; 4 > h; ++h) {
            var r;
            if (b.Qa.Cb) {
              var u = b.Qa.Lb[h];
              b.Qa.Fb || (u += e.Tb);
            } else u = e.Tb;
            for (r = 0; 1 >= r; ++r) {
              var d = b.gd[h][r], p = u;
              if (e.Pc && (p += e.vd[0], r && (p += e.od[0])), 0 < (p = 0 > p ? 0 : 63 < p ? 63 : p)) {
                var w = p;
                0 < e.wb && (w = 4 < e.wb ? w >> 2 : w >> 1) > 9 - e.wb && (w = 9 - e.wb), 1 > w && (w = 1), d.dd = w, d.tc = 2 * p + w, d.ld = 40 <= p ? 2 : 15 <= p ? 1 : 0;
              } else d.tc = 0;
              d.La = r;
            }
          }
        }
        h = 0;
      } else rr(b, 6, "Frame setup failed"), h = b.a;
      if (h = h == 0) {
        if (h) {
          b.$c = 0, 0 < b.Aa || (b.Ic = li);
          e: {
            h = b.Ic, e = 4 * (w = b.za);
            var A = 32 * w, C = w + 1, P = 0 < b.L ? w * (0 < b.Aa ? 2 : 1) : 0, F = (b.Aa == 2 ? 2 : 1) * w;
            if ((d = e + 832 + (r = 3 * (16 * h + Sa[b.L]) / 2 * A) + (u = b.Fa != null && 0 < b.Fa.length ? b.Kc.c * b.Kc.i : 0)) != d) h = 0;
            else {
              if (d > b.Vb) {
                if (b.Vb = 0, b.Ec = _(d), b.Fc = 0, b.Ec == null) {
                  h = rr(b, 1, "no memory during frame initialization.");
                  break e;
                }
                b.Vb = d;
              }
              d = b.Ec, p = b.Fc, b.Ac = d, b.Bc = p, p += e, b.Gd = g(A, Xr), b.Hd = 0, b.rb = g(C + 1, Wr), b.sb = 1, b.wa = P ? g(P, ca) : null, b.Y = 0, b.D.Nb = 0, b.D.wa = b.wa, b.D.Y = b.Y, 0 < b.Aa && (b.D.Y += w), l(!0), b.oc = d, b.pc = p, p += 832, b.ya = g(F, Jo), b.aa = 0, b.D.ya = b.ya, b.D.aa = b.aa, b.Aa == 2 && (b.D.aa += w), b.R = 16 * w, b.B = 8 * w, w = (A = Sa[b.L]) * b.R, A = A / 2 * b.B, b.sa = d, b.ta = p + w, b.qa = b.sa, b.ra = b.ta + 16 * h * b.R + A, b.Ha = b.qa, b.Ia = b.ra + 8 * h * b.B + A, b.$c = 0, p += r, b.mb = u ? d : null, b.nb = u ? p : null, l(p + u <= b.Fc + b.Vb), ln(b), y(b.Ac, b.Bc, 0, e), h = 1;
            }
          }
          if (h) {
            if (S.ka = 0, S.y = b.sa, S.O = b.ta, S.f = b.qa, S.N = b.ra, S.ea = b.Ha, S.Vd = b.Ia, S.fa = b.R, S.Rc = b.B, S.F = null, S.J = 0, !wo) {
              for (h = -255; 255 >= h; ++h) cu[255 + h] = 0 > h ? -h : h;
              for (h = -1020; 1020 >= h; ++h) _r[1020 + h] = -128 > h ? -128 : 127 < h ? 127 : h;
              for (h = -112; 112 >= h; ++h) Hn[112 + h] = -16 > h ? -16 : 15 < h ? 15 : h;
              for (h = -255; 510 >= h; ++h) bn[255 + h] = 0 > h ? 0 : 255 < h ? 255 : h;
              wo = 1;
            }
            Un = el, Ua = Ri, fs = so, Qr = Qo, vn = $s, ba = os, Vn = go, xa = Oa, $n = Nl, Zn = _o, wa = Ml, dn = fa, ms = yo, tr = il, Yi = us, dr = Di, Cr = cs, Dn = lu, Pn[0] = Tn, Pn[1] = za, Pn[2] = lo, Pn[3] = uo, Pn[4] = tl, Pn[5] = co, Pn[6] = Zs, Pn[7] = ho, Pn[8] = au, Pn[9] = Pl, gs[0] = Il, gs[1] = pa, gs[2] = As, gs[3] = oo, gs[4] = wr, gs[5] = Ba, gs[6] = qr, Ms[0] = Ss, Ms[1] = ao, Ms[2] = ou, Ms[3] = po, Ms[4] = Gs, Ms[5] = fo, Ms[6] = Ra, h = 1;
          } else h = 0;
        }
        h && (h = function(N, Z) {
          for (N.M = 0; N.M < N.Va; ++N.M) {
            var G, V = N.Jc[N.M & N.Xb], W = N.m, se = N;
            for (G = 0; G < se.za; ++G) {
              var le = W, de = se, ce = de.Ac, we = de.Bc + 4 * G, Le = de.zc, Ie = de.ya[de.aa + G];
              if (de.Qa.Bb ? Ie.$b = Ke(le, de.Pa.jb[0]) ? 2 + Ke(le, de.Pa.jb[2]) : Ke(le, de.Pa.jb[1]) : Ie.$b = 0, de.kc && (Ie.Ad = Ke(le, de.Bd)), Ie.Za = !Ke(le, 145) + 0, Ie.Za) {
                var it = Ie.Ob, ht = 0;
                for (de = 0; 4 > de; ++de) {
                  var _t, wt = Le[0 + de];
                  for (_t = 0; 4 > _t; ++_t) {
                    wt = ko[ce[we + _t]][wt];
                    for (var bt = fu[Ke(le, wt[0])]; 0 < bt; ) bt = fu[2 * bt + Ke(le, wt[bt])];
                    wt = -bt, ce[we + _t] = wt;
                  }
                  m(it, ht, ce, we, 4), ht += 4, Le[0 + de] = wt;
                }
              } else wt = Ke(le, 156) ? Ke(le, 128) ? 1 : 3 : Ke(le, 163) ? 2 : 0, Ie.Ob[0] = wt, y(ce, we, wt, 4), y(Le, 0, wt, 4);
              Ie.Dd = Ke(le, 142) ? Ke(le, 114) ? Ke(le, 183) ? 1 : 3 : 2 : 0;
            }
            if (se.m.Ka) return rr(N, 7, "Premature end-of-partition0 encountered.");
            for (; N.ja < N.za; ++N.ja) {
              if (se = V, le = (W = N).rb[W.sb - 1], ce = W.rb[W.sb + W.ja], G = W.ya[W.aa + W.ja], we = W.kc ? G.Ad : 0) le.la = ce.la = 0, G.Za || (le.Na = ce.Na = 0), G.Hc = 0, G.Gc = 0, G.ia = 0;
              else {
                var yt, St;
                if (le = ce, ce = se, we = W.Pa.Xc, Le = W.ya[W.aa + W.ja], Ie = W.pb[Le.$b], de = Le.ad, it = 0, ht = W.rb[W.sb - 1], wt = _t = 0, y(de, it, 0, 384), Le.Za) var Zt = 0, Tt = we[3];
                else {
                  bt = _(16);
                  var kt = le.Na + ht.Na;
                  if (kt = hl(ce, we[1], kt, Ie.Eb, 0, bt, 0), le.Na = ht.Na = (0 < kt) + 0, 1 < kt) Un(bt, 0, de, it);
                  else {
                    var Wt = bt[0] + 3 >> 3;
                    for (bt = 0; 256 > bt; bt += 16) de[it + bt] = Wt;
                  }
                  Zt = 1, Tt = we[0];
                }
                var di = 15 & le.la, ci = 15 & ht.la;
                for (bt = 0; 4 > bt; ++bt) {
                  var gi = 1 & ci;
                  for (Wt = St = 0; 4 > Wt; ++Wt) di = di >> 1 | (gi = (kt = hl(ce, Tt, kt = gi + (1 & di), Ie.Sc, Zt, de, it)) > Zt) << 7, St = St << 2 | (3 < kt ? 3 : 1 < kt ? 2 : de[it + 0] != 0), it += 16;
                  di >>= 4, ci = ci >> 1 | gi << 7, _t = (_t << 8 | St) >>> 0;
                }
                for (Tt = di, Zt = ci >> 4, yt = 0; 4 > yt; yt += 2) {
                  for (St = 0, di = le.la >> 4 + yt, ci = ht.la >> 4 + yt, bt = 0; 2 > bt; ++bt) {
                    for (gi = 1 & ci, Wt = 0; 2 > Wt; ++Wt) kt = gi + (1 & di), di = di >> 1 | (gi = 0 < (kt = hl(ce, we[2], kt, Ie.Qc, 0, de, it))) << 3, St = St << 2 | (3 < kt ? 3 : 1 < kt ? 2 : de[it + 0] != 0), it += 16;
                    di >>= 2, ci = ci >> 1 | gi << 5;
                  }
                  wt |= St << 4 * yt, Tt |= di << 4 << yt, Zt |= (240 & ci) << yt;
                }
                le.la = Tt, ht.la = Zt, Le.Hc = _t, Le.Gc = wt, Le.ia = 43690 & wt ? 0 : Ie.ia, we = !(_t | wt);
              }
              if (0 < W.L && (W.wa[W.Y + W.ja] = W.gd[G.$b][G.Za], W.wa[W.Y + W.ja].La |= !we), se.Ka) return rr(N, 7, "Premature end-of-file encountered.");
            }
            if (ln(N), W = Z, se = 1, G = (V = N).D, le = 0 < V.L && V.M >= V.zb && V.M <= V.Va, V.Aa == 0) e: {
              if (G.M = V.M, G.uc = le, Ws(V, G), se = 1, G = (St = V.D).Nb, le = (wt = Sa[V.L]) * V.R, ce = wt / 2 * V.B, bt = 16 * G * V.R, Wt = 8 * G * V.B, we = V.sa, Le = V.ta - le + bt, Ie = V.qa, de = V.ra - ce + Wt, it = V.Ha, ht = V.Ia - ce + Wt, ci = (di = St.M) == 0, _t = di >= V.Va - 1, V.Aa == 2 && Ws(V, St), St.uc) for (gi = (kt = V).D.M, l(kt.D.uc), St = kt.yb; St < kt.Hb; ++St) {
                Zt = St, Tt = gi;
                var Ei = (qi = (ar = kt).D).Nb;
                yt = ar.R;
                var qi = qi.wa[qi.Y + Zt], sr = ar.sa, Fi = ar.ta + 16 * Ei * yt + 16 * Zt, yr = qi.dd, Ui = qi.tc;
                if (Ui != 0) if (l(3 <= Ui), ar.L == 1) 0 < Zt && dr(sr, Fi, yt, Ui + 4), qi.La && Dn(sr, Fi, yt, Ui), 0 < Tt && Yi(sr, Fi, yt, Ui + 4), qi.La && Cr(sr, Fi, yt, Ui);
                else {
                  var pr = ar.B, kr = ar.qa, pn = ar.ra + 8 * Ei * pr + 8 * Zt, Mn = ar.Ha, ar = ar.Ia + 8 * Ei * pr + 8 * Zt;
                  Ei = qi.ld, 0 < Zt && (xa(sr, Fi, yt, Ui + 4, yr, Ei), Zn(kr, pn, Mn, ar, pr, Ui + 4, yr, Ei)), qi.La && (dn(sr, Fi, yt, Ui, yr, Ei), tr(kr, pn, Mn, ar, pr, Ui, yr, Ei)), 0 < Tt && (Vn(sr, Fi, yt, Ui + 4, yr, Ei), $n(kr, pn, Mn, ar, pr, Ui + 4, yr, Ei)), qi.La && (wa(sr, Fi, yt, Ui, yr, Ei), ms(kr, pn, Mn, ar, pr, Ui, yr, Ei));
                }
              }
              if (V.ia && alert("todo:DitherRow"), W.put != null) {
                if (St = 16 * di, di = 16 * (di + 1), ci ? (W.y = V.sa, W.O = V.ta + bt, W.f = V.qa, W.N = V.ra + Wt, W.ea = V.Ha, W.W = V.Ia + Wt) : (St -= wt, W.y = we, W.O = Le, W.f = Ie, W.N = de, W.ea = it, W.W = ht), _t || (di -= wt), di > W.o && (di = W.o), W.F = null, W.J = null, V.Fa != null && 0 < V.Fa.length && St < di && (W.J = xo(V, W, St, di - St), W.F = V.mb, W.F == null && W.F.length == 0)) {
                  se = rr(V, 3, "Could not decode alpha data.");
                  break e;
                }
                St < W.j && (wt = W.j - St, St = W.j, l(!(1 & wt)), W.O += V.R * wt, W.N += V.B * (wt >> 1), W.W += V.B * (wt >> 1), W.F != null && (W.J += W.width * wt)), St < di && (W.O += W.v, W.N += W.v >> 1, W.W += W.v >> 1, W.F != null && (W.J += W.v), W.ka = St - W.j, W.U = W.va - W.v, W.T = di - St, se = W.put(W));
              }
              G + 1 != V.Ic || _t || (m(V.sa, V.ta - le, we, Le + 16 * V.R, le), m(V.qa, V.ra - ce, Ie, de + 8 * V.B, ce), m(V.Ha, V.Ia - ce, it, ht + 8 * V.B, ce));
            }
            if (!se) return rr(N, 6, "Output aborted.");
          }
          return 1;
        }(b, S)), S.bc != null && S.bc(S), h &= 1;
      }
      return h ? (b.cb = 0, h) : 0;
    }
    function Sr(b, S, h, e, r) {
      r = b[S + h + 32 * e] + (r >> 3), b[S + h + 32 * e] = -256 & r ? 0 > r ? 0 : 255 : r;
    }
    function no(b, S, h, e, r, u) {
      Sr(b, S, 0, h, e + r), Sr(b, S, 1, h, e + u), Sr(b, S, 2, h, e - u), Sr(b, S, 3, h, e - r);
    }
    function jr(b) {
      return (20091 * b >> 16) + b;
    }
    function as(b, S, h, e) {
      var r, u = 0, d = _(16);
      for (r = 0; 4 > r; ++r) {
        var p = b[S + 0] + b[S + 8], w = b[S + 0] - b[S + 8], A = (35468 * b[S + 4] >> 16) - jr(b[S + 12]), C = jr(b[S + 4]) + (35468 * b[S + 12] >> 16);
        d[u + 0] = p + C, d[u + 1] = w + A, d[u + 2] = w - A, d[u + 3] = p - C, u += 4, S++;
      }
      for (r = u = 0; 4 > r; ++r) p = (b = d[u + 0] + 4) + d[u + 8], w = b - d[u + 8], A = (35468 * d[u + 4] >> 16) - jr(d[u + 12]), Sr(h, e, 0, 0, p + (C = jr(d[u + 4]) + (35468 * d[u + 12] >> 16))), Sr(h, e, 1, 0, w + A), Sr(h, e, 2, 0, w - A), Sr(h, e, 3, 0, p - C), u++, e += 32;
    }
    function os(b, S, h, e) {
      var r = b[S + 0] + 4, u = 35468 * b[S + 4] >> 16, d = jr(b[S + 4]), p = 35468 * b[S + 1] >> 16;
      no(h, e, 0, r + d, b = jr(b[S + 1]), p), no(h, e, 1, r + u, b, p), no(h, e, 2, r - u, b, p), no(h, e, 3, r - d, b, p);
    }
    function Ri(b, S, h, e, r) {
      as(b, S, h, e), r && as(b, S + 16, h, e + 4);
    }
    function so(b, S, h, e) {
      Ua(b, S + 0, h, e, 1), Ua(b, S + 32, h, e + 128, 1);
    }
    function Qo(b, S, h, e) {
      var r;
      for (b = b[S + 0] + 4, r = 0; 4 > r; ++r) for (S = 0; 4 > S; ++S) Sr(h, e, S, r, b);
    }
    function $s(b, S, h, e) {
      b[S + 0] && Qr(b, S + 0, h, e), b[S + 16] && Qr(b, S + 16, h, e + 4), b[S + 32] && Qr(b, S + 32, h, e + 128), b[S + 48] && Qr(b, S + 48, h, e + 128 + 4);
    }
    function el(b, S, h, e) {
      var r, u = _(16);
      for (r = 0; 4 > r; ++r) {
        var d = b[S + 0 + r] + b[S + 12 + r], p = b[S + 4 + r] + b[S + 8 + r], w = b[S + 4 + r] - b[S + 8 + r], A = b[S + 0 + r] - b[S + 12 + r];
        u[0 + r] = d + p, u[8 + r] = d - p, u[4 + r] = A + w, u[12 + r] = A - w;
      }
      for (r = 0; 4 > r; ++r) d = (b = u[0 + 4 * r] + 3) + u[3 + 4 * r], p = u[1 + 4 * r] + u[2 + 4 * r], w = u[1 + 4 * r] - u[2 + 4 * r], A = b - u[3 + 4 * r], h[e + 0] = d + p >> 3, h[e + 16] = A + w >> 3, h[e + 32] = d - p >> 3, h[e + 48] = A - w >> 3, e += 64;
    }
    function da(b, S, h) {
      var e, r = S - 32, u = Br, d = 255 - b[r - 1];
      for (e = 0; e < h; ++e) {
        var p, w = u, A = d + b[S - 1];
        for (p = 0; p < h; ++p) b[S + p] = w[A + b[r + p]];
        S += 32;
      }
    }
    function za(b, S) {
      da(b, S, 4);
    }
    function ao(b, S) {
      da(b, S, 8);
    }
    function pa(b, S) {
      da(b, S, 16);
    }
    function As(b, S) {
      var h;
      for (h = 0; 16 > h; ++h) m(b, S + 32 * h, b, S - 32, 16);
    }
    function oo(b, S) {
      var h;
      for (h = 16; 0 < h; --h) y(b, S, b[S - 1], 16), S += 32;
    }
    function Fa(b, S, h) {
      var e;
      for (e = 0; 16 > e; ++e) y(S, h + 32 * e, b, 16);
    }
    function Il(b, S) {
      var h, e = 16;
      for (h = 0; 16 > h; ++h) e += b[S - 1 + 32 * h] + b[S + h - 32];
      Fa(e >> 5, b, S);
    }
    function wr(b, S) {
      var h, e = 8;
      for (h = 0; 16 > h; ++h) e += b[S - 1 + 32 * h];
      Fa(e >> 4, b, S);
    }
    function Ba(b, S) {
      var h, e = 8;
      for (h = 0; 16 > h; ++h) e += b[S + h - 32];
      Fa(e >> 4, b, S);
    }
    function qr(b, S) {
      Fa(128, b, S);
    }
    function ai(b, S, h) {
      return b + 2 * S + h + 2 >> 2;
    }
    function lo(b, S) {
      var h, e = S - 32;
      for (e = new Uint8Array([ai(b[e - 1], b[e + 0], b[e + 1]), ai(b[e + 0], b[e + 1], b[e + 2]), ai(b[e + 1], b[e + 2], b[e + 3]), ai(b[e + 2], b[e + 3], b[e + 4])]), h = 0; 4 > h; ++h) m(b, S + 32 * h, e, 0, e.length);
    }
    function uo(b, S) {
      var h = b[S - 1], e = b[S - 1 + 32], r = b[S - 1 + 64], u = b[S - 1 + 96];
      nt(b, S + 0, 16843009 * ai(b[S - 1 - 32], h, e)), nt(b, S + 32, 16843009 * ai(h, e, r)), nt(b, S + 64, 16843009 * ai(e, r, u)), nt(b, S + 96, 16843009 * ai(r, u, u));
    }
    function Tn(b, S) {
      var h, e = 4;
      for (h = 0; 4 > h; ++h) e += b[S + h - 32] + b[S - 1 + 32 * h];
      for (e >>= 3, h = 0; 4 > h; ++h) y(b, S + 32 * h, e, 4);
    }
    function tl(b, S) {
      var h = b[S - 1 + 0], e = b[S - 1 + 32], r = b[S - 1 + 64], u = b[S - 1 - 32], d = b[S + 0 - 32], p = b[S + 1 - 32], w = b[S + 2 - 32], A = b[S + 3 - 32];
      b[S + 0 + 96] = ai(e, r, b[S - 1 + 96]), b[S + 1 + 96] = b[S + 0 + 64] = ai(h, e, r), b[S + 2 + 96] = b[S + 1 + 64] = b[S + 0 + 32] = ai(u, h, e), b[S + 3 + 96] = b[S + 2 + 64] = b[S + 1 + 32] = b[S + 0 + 0] = ai(d, u, h), b[S + 3 + 64] = b[S + 2 + 32] = b[S + 1 + 0] = ai(p, d, u), b[S + 3 + 32] = b[S + 2 + 0] = ai(w, p, d), b[S + 3 + 0] = ai(A, w, p);
    }
    function Zs(b, S) {
      var h = b[S + 1 - 32], e = b[S + 2 - 32], r = b[S + 3 - 32], u = b[S + 4 - 32], d = b[S + 5 - 32], p = b[S + 6 - 32], w = b[S + 7 - 32];
      b[S + 0 + 0] = ai(b[S + 0 - 32], h, e), b[S + 1 + 0] = b[S + 0 + 32] = ai(h, e, r), b[S + 2 + 0] = b[S + 1 + 32] = b[S + 0 + 64] = ai(e, r, u), b[S + 3 + 0] = b[S + 2 + 32] = b[S + 1 + 64] = b[S + 0 + 96] = ai(r, u, d), b[S + 3 + 32] = b[S + 2 + 64] = b[S + 1 + 96] = ai(u, d, p), b[S + 3 + 64] = b[S + 2 + 96] = ai(d, p, w), b[S + 3 + 96] = ai(p, w, w);
    }
    function co(b, S) {
      var h = b[S - 1 + 0], e = b[S - 1 + 32], r = b[S - 1 + 64], u = b[S - 1 - 32], d = b[S + 0 - 32], p = b[S + 1 - 32], w = b[S + 2 - 32], A = b[S + 3 - 32];
      b[S + 0 + 0] = b[S + 1 + 64] = u + d + 1 >> 1, b[S + 1 + 0] = b[S + 2 + 64] = d + p + 1 >> 1, b[S + 2 + 0] = b[S + 3 + 64] = p + w + 1 >> 1, b[S + 3 + 0] = w + A + 1 >> 1, b[S + 0 + 96] = ai(r, e, h), b[S + 0 + 64] = ai(e, h, u), b[S + 0 + 32] = b[S + 1 + 96] = ai(h, u, d), b[S + 1 + 32] = b[S + 2 + 96] = ai(u, d, p), b[S + 2 + 32] = b[S + 3 + 96] = ai(d, p, w), b[S + 3 + 32] = ai(p, w, A);
    }
    function ho(b, S) {
      var h = b[S + 0 - 32], e = b[S + 1 - 32], r = b[S + 2 - 32], u = b[S + 3 - 32], d = b[S + 4 - 32], p = b[S + 5 - 32], w = b[S + 6 - 32], A = b[S + 7 - 32];
      b[S + 0 + 0] = h + e + 1 >> 1, b[S + 1 + 0] = b[S + 0 + 64] = e + r + 1 >> 1, b[S + 2 + 0] = b[S + 1 + 64] = r + u + 1 >> 1, b[S + 3 + 0] = b[S + 2 + 64] = u + d + 1 >> 1, b[S + 0 + 32] = ai(h, e, r), b[S + 1 + 32] = b[S + 0 + 96] = ai(e, r, u), b[S + 2 + 32] = b[S + 1 + 96] = ai(r, u, d), b[S + 3 + 32] = b[S + 2 + 96] = ai(u, d, p), b[S + 3 + 64] = ai(d, p, w), b[S + 3 + 96] = ai(p, w, A);
    }
    function Pl(b, S) {
      var h = b[S - 1 + 0], e = b[S - 1 + 32], r = b[S - 1 + 64], u = b[S - 1 + 96];
      b[S + 0 + 0] = h + e + 1 >> 1, b[S + 2 + 0] = b[S + 0 + 32] = e + r + 1 >> 1, b[S + 2 + 32] = b[S + 0 + 64] = r + u + 1 >> 1, b[S + 1 + 0] = ai(h, e, r), b[S + 3 + 0] = b[S + 1 + 32] = ai(e, r, u), b[S + 3 + 32] = b[S + 1 + 64] = ai(r, u, u), b[S + 3 + 64] = b[S + 2 + 64] = b[S + 0 + 96] = b[S + 1 + 96] = b[S + 2 + 96] = b[S + 3 + 96] = u;
    }
    function au(b, S) {
      var h = b[S - 1 + 0], e = b[S - 1 + 32], r = b[S - 1 + 64], u = b[S - 1 + 96], d = b[S - 1 - 32], p = b[S + 0 - 32], w = b[S + 1 - 32], A = b[S + 2 - 32];
      b[S + 0 + 0] = b[S + 2 + 32] = h + d + 1 >> 1, b[S + 0 + 32] = b[S + 2 + 64] = e + h + 1 >> 1, b[S + 0 + 64] = b[S + 2 + 96] = r + e + 1 >> 1, b[S + 0 + 96] = u + r + 1 >> 1, b[S + 3 + 0] = ai(p, w, A), b[S + 2 + 0] = ai(d, p, w), b[S + 1 + 0] = b[S + 3 + 32] = ai(h, d, p), b[S + 1 + 32] = b[S + 3 + 64] = ai(e, h, d), b[S + 1 + 64] = b[S + 3 + 96] = ai(r, e, h), b[S + 1 + 96] = ai(u, r, e);
    }
    function ou(b, S) {
      var h;
      for (h = 0; 8 > h; ++h) m(b, S + 32 * h, b, S - 32, 8);
    }
    function po(b, S) {
      var h;
      for (h = 0; 8 > h; ++h) y(b, S, b[S - 1], 8), S += 32;
    }
    function ls(b, S, h) {
      var e;
      for (e = 0; 8 > e; ++e) y(S, h + 32 * e, b, 8);
    }
    function Ss(b, S) {
      var h, e = 8;
      for (h = 0; 8 > h; ++h) e += b[S + h - 32] + b[S - 1 + 32 * h];
      ls(e >> 4, b, S);
    }
    function fo(b, S) {
      var h, e = 4;
      for (h = 0; 8 > h; ++h) e += b[S + h - 32];
      ls(e >> 3, b, S);
    }
    function Gs(b, S) {
      var h, e = 4;
      for (h = 0; 8 > h; ++h) e += b[S - 1 + 32 * h];
      ls(e >> 3, b, S);
    }
    function Ra(b, S) {
      ls(128, b, S);
    }
    function un(b, S, h) {
      var e = b[S - h], r = b[S + 0], u = 3 * (r - e) + ol[1020 + b[S - 2 * h] - b[S + h]], d = Va[112 + (u + 4 >> 3)];
      b[S - h] = Br[255 + e + Va[112 + (u + 3 >> 3)]], b[S + 0] = Br[255 + r - d];
    }
    function Ll(b, S, h, e) {
      var r = b[S + 0], u = b[S + h];
      return Lr[255 + b[S - 2 * h] - b[S - h]] > e || Lr[255 + u - r] > e;
    }
    function mo(b, S, h, e) {
      return 4 * Lr[255 + b[S - h] - b[S + 0]] + Lr[255 + b[S - 2 * h] - b[S + h]] <= e;
    }
    function Es(b, S, h, e, r) {
      var u = b[S - 3 * h], d = b[S - 2 * h], p = b[S - h], w = b[S + 0], A = b[S + h], C = b[S + 2 * h], P = b[S + 3 * h];
      return 4 * Lr[255 + p - w] + Lr[255 + d - A] > e ? 0 : Lr[255 + b[S - 4 * h] - u] <= r && Lr[255 + u - d] <= r && Lr[255 + d - p] <= r && Lr[255 + P - C] <= r && Lr[255 + C - A] <= r && Lr[255 + A - w] <= r;
    }
    function us(b, S, h, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) mo(b, S + e, h, r) && un(b, S + e, h);
    }
    function Di(b, S, h, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) mo(b, S + e * h, 1, r) && un(b, S + e * h, 1);
    }
    function cs(b, S, h, e) {
      var r;
      for (r = 3; 0 < r; --r) us(b, S += 4 * h, h, e);
    }
    function lu(b, S, h, e) {
      var r;
      for (r = 3; 0 < r; --r) Di(b, S += 4, h, e);
    }
    function kn(b, S, h, e, r, u, d, p) {
      for (u = 2 * u + 1; 0 < r--; ) {
        if (Es(b, S, h, u, d)) if (Ll(b, S, h, p)) un(b, S, h);
        else {
          var w = b, A = S, C = h, P = w[A - 2 * C], F = w[A - C], N = w[A + 0], Z = w[A + C], G = w[A + 2 * C], V = 27 * (se = ol[1020 + 3 * (N - F) + ol[1020 + P - Z]]) + 63 >> 7, W = 18 * se + 63 >> 7, se = 9 * se + 63 >> 7;
          w[A - 3 * C] = Br[255 + w[A - 3 * C] + se], w[A - 2 * C] = Br[255 + P + W], w[A - C] = Br[255 + F + V], w[A + 0] = Br[255 + N - V], w[A + C] = Br[255 + Z - W], w[A + 2 * C] = Br[255 + G - se];
        }
        S += e;
      }
    }
    function hs(b, S, h, e, r, u, d, p) {
      for (u = 2 * u + 1; 0 < r--; ) {
        if (Es(b, S, h, u, d)) if (Ll(b, S, h, p)) un(b, S, h);
        else {
          var w = b, A = S, C = h, P = w[A - C], F = w[A + 0], N = w[A + C], Z = Va[112 + ((G = 3 * (F - P)) + 4 >> 3)], G = Va[112 + (G + 3 >> 3)], V = Z + 1 >> 1;
          w[A - 2 * C] = Br[255 + w[A - 2 * C] + V], w[A - C] = Br[255 + P + G], w[A + 0] = Br[255 + F - Z], w[A + C] = Br[255 + N - V];
        }
        S += e;
      }
    }
    function go(b, S, h, e, r, u) {
      kn(b, S, h, 1, 16, e, r, u);
    }
    function Oa(b, S, h, e, r, u) {
      kn(b, S, 1, h, 16, e, r, u);
    }
    function Ml(b, S, h, e, r, u) {
      var d;
      for (d = 3; 0 < d; --d) hs(b, S += 4 * h, h, 1, 16, e, r, u);
    }
    function fa(b, S, h, e, r, u) {
      var d;
      for (d = 3; 0 < d; --d) hs(b, S += 4, 1, h, 16, e, r, u);
    }
    function Nl(b, S, h, e, r, u, d, p) {
      kn(b, S, r, 1, 8, u, d, p), kn(h, e, r, 1, 8, u, d, p);
    }
    function _o(b, S, h, e, r, u, d, p) {
      kn(b, S, 1, r, 8, u, d, p), kn(h, e, 1, r, 8, u, d, p);
    }
    function yo(b, S, h, e, r, u, d, p) {
      hs(b, S + 4 * r, r, 1, 8, u, d, p), hs(h, e + 4 * r, r, 1, 8, u, d, p);
    }
    function il(b, S, h, e, r, u, d, p) {
      hs(b, S + 4, 1, r, 8, u, d, p), hs(h, e + 4, 1, r, 8, u, d, p);
    }
    function jn() {
      this.ba = new ie(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new $(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function vo() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function rl() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function nl() {
      this.ua = 0, this.Wa = new Y(), this.vb = new Y(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new ye(), this.yc = new re();
    }
    function ja() {
      this.xb = this.a = 0, this.l = new On(), this.ca = new ie(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new ee(), this.Pb = 0, this.wd = new ee(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new nl(), this.ab = 0, this.gc = g(4, rl), this.Oc = 0;
    }
    function bo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new On(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Cs(b, S, h, e, r, u, d) {
      for (b = b == null ? 0 : b[S + 0], S = 0; S < d; ++S) r[u + S] = b + h[e + S] & 255, b = r[u + S];
    }
    function sl(b, S, h, e, r, u, d) {
      var p;
      if (b == null) Cs(null, null, h, e, r, u, d);
      else for (p = 0; p < d; ++p) r[u + p] = b[S + p] + h[e + p] & 255;
    }
    function ma(b, S, h, e, r, u, d) {
      if (b == null) Cs(null, null, h, e, r, u, d);
      else {
        var p, w = b[S + 0], A = w, C = w;
        for (p = 0; p < d; ++p) A = C + (w = b[S + p]) - A, C = h[e + p] + (-256 & A ? 0 > A ? 0 : 255 : A) & 255, A = w, r[u + p] = C;
      }
    }
    function xo(b, S, h, e) {
      var r = S.width, u = S.o;
      if (l(b != null && S != null), 0 > h || 0 >= e || h + e > u) return null;
      if (!b.Cc) {
        if (b.ga == null) {
          var d;
          if (b.ga = new bo(), (d = b.ga == null) || (d = S.width * S.o, l(b.Gb.length == 0), b.Gb = _(d), b.Uc = 0, b.Gb == null ? d = 0 : (b.mb = b.Gb, b.nb = b.Uc, b.rc = null, d = 1), d = !d), !d) {
            d = b.ga;
            var p = b.Fa, w = b.P, A = b.qc, C = b.mb, P = b.nb, F = w + 1, N = A - 1, Z = d.l;
            if (l(p != null && C != null && S != null), Ns[0] = null, Ns[1] = Cs, Ns[2] = sl, Ns[3] = ma, d.ca = C, d.tb = P, d.c = S.width, d.i = S.height, l(0 < d.c && 0 < d.i), 1 >= A) S = 0;
            else if (d.$a = p[w + 0] >> 0 & 3, d.Z = p[w + 0] >> 2 & 3, d.Lc = p[w + 0] >> 4 & 3, w = p[w + 0] >> 6 & 3, 0 > d.$a || 1 < d.$a || 4 <= d.Z || 1 < d.Lc || w) S = 0;
            else if (Z.put = Me, Z.ac = ge, Z.bc = Fe, Z.ma = d, Z.width = S.width, Z.height = S.height, Z.Da = S.Da, Z.v = S.v, Z.va = S.va, Z.j = S.j, Z.o = S.o, d.$a) e: {
              l(d.$a == 1), S = Oi();
              t: for (; ; ) {
                if (S == null) {
                  S = 0;
                  break e;
                }
                if (l(d != null), d.mc = S, S.c = d.c, S.i = d.i, S.l = d.l, S.l.ma = d, S.l.width = d.c, S.l.height = d.i, S.a = 0, qe(S.m, p, F, N), !mi(d.c, d.i, 1, S, null) || (S.ab == 1 && S.gc[0].hc == 3 && Qt(S.s) ? (d.ic = 1, p = S.c * S.i, S.Ta = null, S.Ua = 0, S.V = _(p), S.Ba = 0, S.V == null ? (S.a = 1, S = 0) : S = 1) : (d.ic = 0, S = Bi(S, d.c)), !S)) break t;
                S = 1;
                break e;
              }
              d.mc = null, S = 0;
            }
            else S = N >= d.c * d.i;
            d = !S;
          }
          if (d) return null;
          b.ga.Lc != 1 ? b.Ga = 0 : e = u - h;
        }
        l(b.ga != null), l(h + e <= u);
        e: {
          if (S = (p = b.ga).c, u = p.l.o, p.$a == 0) {
            if (F = b.rc, N = b.Vc, Z = b.Fa, w = b.P + 1 + h * S, A = b.mb, C = b.nb + h * S, l(w <= b.P + b.qc), p.Z != 0) for (l(Ns[p.Z] != null), d = 0; d < e; ++d) Ns[p.Z](F, N, Z, w, A, C, S), F = A, N = C, C += S, w += S;
            else for (d = 0; d < e; ++d) m(A, C, Z, w, S), F = A, N = C, C += S, w += S;
            b.rc = F, b.Vc = N;
          } else {
            if (l(p.mc != null), S = h + e, l((d = p.mc) != null), l(S <= d.i), d.C >= S) S = 1;
            else if (p.ic || Ye(), p.ic) {
              p = d.V, F = d.Ba, N = d.c;
              var G = d.i, V = (Z = 1, w = d.$ / N, A = d.$ % N, C = d.m, P = d.s, d.$), W = N * G, se = N * S, le = P.wc, de = V < se ? gt(P, A, w) : null;
              l(V <= W), l(S <= G), l(Qt(P));
              t: for (; ; ) {
                for (; !C.h && V < se; ) {
                  if (A & le || (de = gt(P, A, w)), l(de != null), Oe(C), 256 > (G = ut(de.G[0], de.H[0], C))) p[F + V] = G, ++V, ++A >= N && (A = 0, ++w <= S && !(w % 16) && pi(d, w));
                  else {
                    if (!(280 > G)) {
                      Z = 0;
                      break t;
                    }
                    G = De(G - 256, C);
                    var ce, we = ut(de.G[4], de.H[4], C);
                    if (Oe(C), !(V >= (we = tt(N, we = De(we, C))) && W - V >= G)) {
                      Z = 0;
                      break t;
                    }
                    for (ce = 0; ce < G; ++ce) p[F + V + ce] = p[F + V + ce - we];
                    for (V += G, A += G; A >= N; ) A -= N, ++w <= S && !(w % 16) && pi(d, w);
                    V < se && A & le && (de = gt(P, A, w));
                  }
                  l(C.h == be(C));
                }
                pi(d, w > S ? S : w);
                break t;
              }
              !Z || C.h && V < W ? (Z = 0, d.a = C.h ? 5 : 3) : d.$ = V, S = Z;
            } else S = fi(d, d.V, d.Ba, d.c, d.i, S, Hi);
            if (!S) {
              e = 0;
              break e;
            }
          }
          h + e >= u && (b.Cc = 1), e = 1;
        }
        if (!e) return null;
        if (b.Cc && ((e = b.ga) != null && (e.mc = null), b.ga = null, 0 < b.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return b.nb + h * r;
    }
    function I(b, S, h, e, r, u) {
      for (; 0 < r--; ) {
        var d, p = b, w = S + (h ? 1 : 0), A = b, C = S + (h ? 0 : 3);
        for (d = 0; d < e; ++d) {
          var P = A[C + 4 * d];
          P != 255 && (P *= 32897, p[w + 4 * d + 0] = p[w + 4 * d + 0] * P >> 23, p[w + 4 * d + 1] = p[w + 4 * d + 1] * P >> 23, p[w + 4 * d + 2] = p[w + 4 * d + 2] * P >> 23);
        }
        S += u;
      }
    }
    function K(b, S, h, e, r) {
      for (; 0 < e--; ) {
        var u;
        for (u = 0; u < h; ++u) {
          var d = b[S + 2 * u + 0], p = 15 & (A = b[S + 2 * u + 1]), w = 4369 * p, A = (240 & A | A >> 4) * w >> 16;
          b[S + 2 * u + 0] = (240 & d | d >> 4) * w >> 16 & 240 | (15 & d | d << 4) * w >> 16 >> 4 & 15, b[S + 2 * u + 1] = 240 & A | p;
        }
        S += r;
      }
    }
    function Ee(b, S, h, e, r, u, d, p) {
      var w, A, C = 255;
      for (A = 0; A < r; ++A) {
        for (w = 0; w < e; ++w) {
          var P = b[S + w];
          u[d + 4 * w] = P, C &= P;
        }
        S += h, d += p;
      }
      return C != 255;
    }
    function Re(b, S, h, e, r) {
      var u;
      for (u = 0; u < r; ++u) h[e + u] = b[S + u] >> 8;
    }
    function Ye() {
      Gn = I, Tr = K, Ps = Ee, uu = Re;
    }
    function ct(b, S, h) {
      Ae[b] = function(e, r, u, d, p, w, A, C, P, F, N, Z, G, V, W, se, le) {
        var de, ce = le - 1 >> 1, we = p[w + 0] | A[C + 0] << 16, Le = P[F + 0] | N[Z + 0] << 16;
        l(e != null);
        var Ie = 3 * we + Le + 131074 >> 2;
        for (S(e[r + 0], 255 & Ie, Ie >> 16, G, V), u != null && (Ie = 3 * Le + we + 131074 >> 2, S(u[d + 0], 255 & Ie, Ie >> 16, W, se)), de = 1; de <= ce; ++de) {
          var it = p[w + de] | A[C + de] << 16, ht = P[F + de] | N[Z + de] << 16, _t = we + it + Le + ht + 524296, wt = _t + 2 * (it + Le) >> 3;
          Ie = wt + we >> 1, we = (_t = _t + 2 * (we + ht) >> 3) + it >> 1, S(e[r + 2 * de - 1], 255 & Ie, Ie >> 16, G, V + (2 * de - 1) * h), S(e[r + 2 * de - 0], 255 & we, we >> 16, G, V + (2 * de - 0) * h), u != null && (Ie = _t + Le >> 1, we = wt + ht >> 1, S(u[d + 2 * de - 1], 255 & Ie, Ie >> 16, W, se + (2 * de - 1) * h), S(u[d + 2 * de + 0], 255 & we, we >> 16, W, se + (2 * de + 0) * h)), we = it, Le = ht;
        }
        1 & le || (Ie = 3 * we + Le + 131074 >> 2, S(e[r + le - 1], 255 & Ie, Ie >> 16, G, V + (le - 1) * h), u != null && (Ie = 3 * Le + we + 131074 >> 2, S(u[d + le - 1], 255 & Ie, Ie >> 16, W, se + (le - 1) * h)));
      };
    }
    function Dt() {
      vi[Ao] = gu, vi[$a] = Bl, vi[Fl] = Ic, vi[Za] = Vu, vi[So] = Wa, vi[ll] = _u, vi[Aa] = yu, vi[Eo] = Bl, vi[Ga] = Vu, vi[Co] = Wa, vi[ul] = _u;
    }
    function Ut(b) {
      return b & ~Ln ? 0 > b ? 0 : 255 : b >> $u;
    }
    function ui(b, S) {
      return Ut((19077 * b >> 8) + (26149 * S >> 8) - 14234);
    }
    function bi(b, S, h) {
      return Ut((19077 * b >> 8) - (6419 * S >> 8) - (13320 * h >> 8) + 8708);
    }
    function Ci(b, S) {
      return Ut((19077 * b >> 8) + (33050 * S >> 8) - 17685);
    }
    function Ii(b, S, h, e, r) {
      e[r + 0] = ui(b, h), e[r + 1] = bi(b, S, h), e[r + 2] = Ci(b, S);
    }
    function nr(b, S, h, e, r) {
      e[r + 0] = Ci(b, S), e[r + 1] = bi(b, S, h), e[r + 2] = ui(b, h);
    }
    function Er(b, S, h, e, r) {
      var u = bi(b, S, h);
      S = u << 3 & 224 | Ci(b, S) >> 3, e[r + 0] = 248 & ui(b, h) | u >> 5, e[r + 1] = S;
    }
    function Ti(b, S, h, e, r) {
      var u = 240 & Ci(b, S) | 15;
      e[r + 0] = 240 & ui(b, h) | bi(b, S, h) >> 4, e[r + 1] = u;
    }
    function Yr(b, S, h, e, r) {
      e[r + 0] = 255, Ii(b, S, h, e, r + 1);
    }
    function oi(b, S, h, e, r) {
      nr(b, S, h, e, r), e[r + 3] = 255;
    }
    function yn(b, S, h, e, r) {
      Ii(b, S, h, e, r), e[r + 3] = 255;
    }
    function Mi(b, S) {
      return 0 > b ? 0 : b > S ? S : b;
    }
    function zi(b, S, h) {
      Ae[b] = function(e, r, u, d, p, w, A, C, P) {
        for (var F = C + (-2 & P) * h; C != F; ) S(e[r + 0], u[d + 0], p[w + 0], A, C), S(e[r + 1], u[d + 0], p[w + 0], A, C + h), r += 2, ++d, ++w, C += 2 * h;
        1 & P && S(e[r + 0], u[d + 0], p[w + 0], A, C);
      };
    }
    function Ts(b, S, h) {
      return h == 0 ? b == 0 ? S == 0 ? 6 : 5 : S == 0 ? 4 : 0 : h;
    }
    function Hs(b, S, h, e, r) {
      switch (b >>> 30) {
        case 3:
          Ua(S, h, e, r, 0);
          break;
        case 2:
          ba(S, h, e, r);
          break;
        case 1:
          Qr(S, h, e, r);
      }
    }
    function Ws(b, S) {
      var h, e, r = S.M, u = S.Nb, d = b.oc, p = b.pc + 40, w = b.oc, A = b.pc + 584, C = b.oc, P = b.pc + 600;
      for (h = 0; 16 > h; ++h) d[p + 32 * h - 1] = 129;
      for (h = 0; 8 > h; ++h) w[A + 32 * h - 1] = 129, C[P + 32 * h - 1] = 129;
      for (0 < r ? d[p - 1 - 32] = w[A - 1 - 32] = C[P - 1 - 32] = 129 : (y(d, p - 32 - 1, 127, 21), y(w, A - 32 - 1, 127, 9), y(C, P - 32 - 1, 127, 9)), e = 0; e < b.za; ++e) {
        var F = S.ya[S.aa + e];
        if (0 < e) {
          for (h = -1; 16 > h; ++h) m(d, p + 32 * h - 4, d, p + 32 * h + 12, 4);
          for (h = -1; 8 > h; ++h) m(w, A + 32 * h - 4, w, A + 32 * h + 4, 4), m(C, P + 32 * h - 4, C, P + 32 * h + 4, 4);
        }
        var N = b.Gd, Z = b.Hd + e, G = F.ad, V = F.Hc;
        if (0 < r && (m(d, p - 32, N[Z].y, 0, 16), m(w, A - 32, N[Z].f, 0, 8), m(C, P - 32, N[Z].ea, 0, 8)), F.Za) {
          var W = d, se = p - 32 + 16;
          for (0 < r && (e >= b.za - 1 ? y(W, se, N[Z].y[15], 4) : m(W, se, N[Z + 1].y, 0, 4)), h = 0; 4 > h; h++) W[se + 128 + h] = W[se + 256 + h] = W[se + 384 + h] = W[se + 0 + h];
          for (h = 0; 16 > h; ++h, V <<= 2) W = d, se = p + _s[h], Pn[F.Ob[h]](W, se), Hs(V, G, 16 * +h, W, se);
        } else if (W = Ts(e, r, F.Ob[0]), gs[W](d, p), V != 0) for (h = 0; 16 > h; ++h, V <<= 2) Hs(V, G, 16 * +h, d, p + _s[h]);
        for (h = F.Gc, W = Ts(e, r, F.Dd), Ms[W](w, A), Ms[W](C, P), V = G, W = w, se = A, 255 & (F = h >> 0) && (170 & F ? fs(V, 256, W, se) : vn(V, 256, W, se)), F = C, V = P, 255 & (h >>= 8) && (170 & h ? fs(G, 320, F, V) : vn(G, 320, F, V)), r < b.Ub - 1 && (m(N[Z].y, 0, d, p + 480, 16), m(N[Z].f, 0, w, A + 224, 8), m(N[Z].ea, 0, C, P + 224, 8)), h = 8 * u * b.B, N = b.sa, Z = b.ta + 16 * e + 16 * u * b.R, G = b.qa, F = b.ra + 8 * e + h, V = b.Ha, W = b.Ia + 8 * e + h, h = 0; 16 > h; ++h) m(N, Z + h * b.R, d, p + 32 * h, 16);
        for (h = 0; 8 > h; ++h) m(G, F + h * b.B, w, A + 32 * h, 8), m(V, W + h * b.B, C, P + 32 * h, 8);
      }
    }
    function ga(b, S, h, e, r, u, d, p, w) {
      var A = [0], C = [0], P = 0, F = w != null ? w.kd : 0, N = w ?? new vo();
      if (b == null || 12 > h) return 7;
      N.data = b, N.w = S, N.ha = h, S = [S], h = [h], N.gb = [N.gb];
      e: {
        var Z = S, G = h, V = N.gb;
        if (l(b != null), l(G != null), l(V != null), V[0] = 0, 12 <= G[0] && !a(b, Z[0], "RIFF")) {
          if (a(b, Z[0] + 8, "WEBP")) {
            V = 3;
            break e;
          }
          var W = mt(b, Z[0] + 4);
          if (12 > W || 4294967286 < W) {
            V = 3;
            break e;
          }
          if (F && W > G[0] - 8) {
            V = 7;
            break e;
          }
          V[0] = W, Z[0] += 12, G[0] -= 12;
        }
        V = 0;
      }
      if (V != 0) return V;
      for (W = 0 < N.gb[0], h = h[0]; ; ) {
        e: {
          var se = b;
          G = S, V = h;
          var le = A, de = C, ce = Z = [0];
          if ((Ie = P = [P])[0] = 0, 8 > V[0]) V = 7;
          else {
            if (!a(se, G[0], "VP8X")) {
              if (mt(se, G[0] + 4) != 10) {
                V = 3;
                break e;
              }
              if (18 > V[0]) {
                V = 7;
                break e;
              }
              var we = mt(se, G[0] + 8), Le = 1 + vt(se, G[0] + 12);
              if (2147483648 <= Le * (se = 1 + vt(se, G[0] + 15))) {
                V = 3;
                break e;
              }
              ce != null && (ce[0] = we), le != null && (le[0] = Le), de != null && (de[0] = se), G[0] += 18, V[0] -= 18, Ie[0] = 1;
            }
            V = 0;
          }
        }
        if (P = P[0], Z = Z[0], V != 0) return V;
        if (G = !!(2 & Z), !W && P) return 3;
        if (u != null && (u[0] = !!(16 & Z)), d != null && (d[0] = G), p != null && (p[0] = 0), d = A[0], Z = C[0], P && G && w == null) {
          V = 0;
          break;
        }
        if (4 > h) {
          V = 7;
          break;
        }
        if (W && P || !W && !P && !a(b, S[0], "ALPH")) {
          h = [h], N.na = [N.na], N.P = [N.P], N.Sa = [N.Sa];
          e: {
            we = b, V = S, W = h;
            var Ie = N.gb;
            le = N.na, de = N.P, ce = N.Sa, Le = 22, l(we != null), l(W != null), se = V[0];
            var it = W[0];
            for (l(le != null), l(ce != null), le[0] = null, de[0] = null, ce[0] = 0; ; ) {
              if (V[0] = se, W[0] = it, 8 > it) {
                V = 7;
                break e;
              }
              var ht = mt(we, se + 4);
              if (4294967286 < ht) {
                V = 3;
                break e;
              }
              var _t = 8 + ht + 1 & -2;
              if (Le += _t, 0 < Ie && Le > Ie) {
                V = 3;
                break e;
              }
              if (!a(we, se, "VP8 ") || !a(we, se, "VP8L")) {
                V = 0;
                break e;
              }
              if (it[0] < _t) {
                V = 7;
                break e;
              }
              a(we, se, "ALPH") || (le[0] = we, de[0] = se + 8, ce[0] = ht), se += _t, it -= _t;
            }
          }
          if (h = h[0], N.na = N.na[0], N.P = N.P[0], N.Sa = N.Sa[0], V != 0) break;
        }
        h = [h], N.Ja = [N.Ja], N.xa = [N.xa];
        e: if (Ie = b, V = S, W = h, le = N.gb[0], de = N.Ja, ce = N.xa, we = V[0], se = !a(Ie, we, "VP8 "), Le = !a(Ie, we, "VP8L"), l(Ie != null), l(W != null), l(de != null), l(ce != null), 8 > W[0]) V = 7;
        else {
          if (se || Le) {
            if (Ie = mt(Ie, we + 4), 12 <= le && Ie > le - 12) {
              V = 3;
              break e;
            }
            if (F && Ie > W[0] - 8) {
              V = 7;
              break e;
            }
            de[0] = Ie, V[0] += 8, W[0] -= 8, ce[0] = Le;
          } else ce[0] = 5 <= W[0] && Ie[we + 0] == 47 && !(Ie[we + 4] >> 5), de[0] = W[0];
          V = 0;
        }
        if (h = h[0], N.Ja = N.Ja[0], N.xa = N.xa[0], S = S[0], V != 0) break;
        if (4294967286 < N.Ja) return 3;
        if (p == null || G || (p[0] = N.xa ? 2 : 1), d = [d], Z = [Z], N.xa) {
          if (5 > h) {
            V = 7;
            break;
          }
          p = d, F = Z, G = u, b == null || 5 > h ? b = 0 : 5 <= h && b[S + 0] == 47 && !(b[S + 4] >> 5) ? (W = [0], Ie = [0], le = [0], qe(de = new ee(), b, S, h), Ne(de, W, Ie, le) ? (p != null && (p[0] = W[0]), F != null && (F[0] = Ie[0]), G != null && (G[0] = le[0]), b = 1) : b = 0) : b = 0;
        } else {
          if (10 > h) {
            V = 7;
            break;
          }
          p = Z, b == null || 10 > h || !_n(b, S + 3, h - 3) ? b = 0 : (F = b[S + 0] | b[S + 1] << 8 | b[S + 2] << 16, G = 16383 & (b[S + 7] << 8 | b[S + 6]), b = 16383 & (b[S + 9] << 8 | b[S + 8]), 1 & F || 3 < (F >> 1 & 7) || !(F >> 4 & 1) || F >> 5 >= N.Ja || !G || !b ? b = 0 : (d && (d[0] = G), p && (p[0] = b), b = 1));
        }
        if (!b || (d = d[0], Z = Z[0], P && (A[0] != d || C[0] != Z))) return 3;
        w != null && (w[0] = N, w.offset = S - w.w, l(4294967286 > S - w.w), l(w.offset == w.ha - h));
        break;
      }
      return V == 0 || V == 7 && P && w == null ? (u != null && (u[0] |= N.na != null && 0 < N.na.length), e != null && (e[0] = d), r != null && (r[0] = Z), 0) : V;
    }
    function ds(b, S, h) {
      var e = S.width, r = S.height, u = 0, d = 0, p = e, w = r;
      if (S.Da = b != null && 0 < b.Da, S.Da && (p = b.cd, w = b.bd, u = b.v, d = b.j, 11 > h || (u &= -2, d &= -2), 0 > u || 0 > d || 0 >= p || 0 >= w || u + p > e || d + w > r)) return 0;
      if (S.v = u, S.j = d, S.va = u + p, S.o = d + w, S.U = p, S.T = w, S.da = b != null && 0 < b.da, S.da) {
        if (!Kt(p, w, h = [b.ib], u = [b.hb])) return 0;
        S.ib = h[0], S.hb = u[0];
      }
      return S.ob = b != null && b.ob, S.Kb = b == null || !b.Sd, S.da && (S.ob = S.ib < 3 * e / 4 && S.hb < 3 * r / 4, S.Kb = 0), 1;
    }
    function ks(b) {
      if (b == null) return 2;
      if (11 > b.S) {
        var S = b.f.RGBA;
        S.fb += (b.height - 1) * S.A, S.A = -S.A;
      } else S = b.f.kb, b = b.height, S.O += (b - 1) * S.fa, S.fa = -S.fa, S.N += (b - 1 >> 1) * S.Ab, S.Ab = -S.Ab, S.W += (b - 1 >> 1) * S.Db, S.Db = -S.Db, S.F != null && (S.J += (b - 1) * S.lb, S.lb = -S.lb);
      return 0;
    }
    function Ur(b, S, h, e) {
      if (e == null || 0 >= b || 0 >= S) return 2;
      if (h != null) {
        if (h.Da) {
          var r = h.cd, u = h.bd, d = -2 & h.v, p = -2 & h.j;
          if (0 > d || 0 > p || 0 >= r || 0 >= u || d + r > b || p + u > S) return 2;
          b = r, S = u;
        }
        if (h.da) {
          if (!Kt(b, S, r = [h.ib], u = [h.hb])) return 2;
          b = r[0], S = u[0];
        }
      }
      e.width = b, e.height = S;
      e: {
        var w = e.width, A = e.height;
        if (b = e.S, 0 >= w || 0 >= A || !(b >= Ao && 13 > b)) b = 2;
        else {
          if (0 >= e.Rd && e.sd == null) {
            d = u = r = S = 0;
            var C = (p = w * ml[b]) * A;
            if (11 > b || (u = (A + 1) / 2 * (S = (w + 1) / 2), b == 12 && (d = (r = w) * A)), (A = _(C + 2 * u + d)) == null) {
              b = 1;
              break e;
            }
            e.sd = A, 11 > b ? ((w = e.f.RGBA).eb = A, w.fb = 0, w.A = p, w.size = C) : ((w = e.f.kb).y = A, w.O = 0, w.fa = p, w.Fd = C, w.f = A, w.N = 0 + C, w.Ab = S, w.Cd = u, w.ea = A, w.W = 0 + C + u, w.Db = S, w.Ed = u, b == 12 && (w.F = A, w.J = 0 + C + 2 * u), w.Tc = d, w.lb = r);
          }
          if (S = 1, r = e.S, u = e.width, d = e.height, r >= Ao && 13 > r) if (11 > r) b = e.f.RGBA, S &= (p = Math.abs(b.A)) * (d - 1) + u <= b.size, S &= p >= u * ml[r], S &= b.eb != null;
          else {
            b = e.f.kb, p = (u + 1) / 2, C = (d + 1) / 2, w = Math.abs(b.fa), A = Math.abs(b.Ab);
            var P = Math.abs(b.Db), F = Math.abs(b.lb), N = F * (d - 1) + u;
            S &= w * (d - 1) + u <= b.Fd, S &= A * (C - 1) + p <= b.Cd, S = (S &= P * (C - 1) + p <= b.Ed) & w >= u & A >= p & P >= p, S &= b.y != null, S &= b.f != null, S &= b.ea != null, r == 12 && (S &= F >= u, S &= N <= b.Tc, S &= b.F != null);
          }
          else S = 0;
          b = S ? 0 : 2;
        }
      }
      return b != 0 || h != null && h.fd && (b = ks(e)), b;
    }
    var Jr = 64, _a = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], ya = 24, qn = 32, Xs = 8, Fr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    xt("Predictor0", "PredictorAdd0"), Ae.Predictor0 = function() {
      return 4278190080;
    }, Ae.Predictor1 = function(b) {
      return b;
    }, Ae.Predictor2 = function(b, S, h) {
      return S[h + 0];
    }, Ae.Predictor3 = function(b, S, h) {
      return S[h + 1];
    }, Ae.Predictor4 = function(b, S, h) {
      return S[h - 1];
    }, Ae.Predictor5 = function(b, S, h) {
      return Et(Et(b, S[h + 1]), S[h + 0]);
    }, Ae.Predictor6 = function(b, S, h) {
      return Et(b, S[h - 1]);
    }, Ae.Predictor7 = function(b, S, h) {
      return Et(b, S[h + 0]);
    }, Ae.Predictor8 = function(b, S, h) {
      return Et(S[h - 1], S[h + 0]);
    }, Ae.Predictor9 = function(b, S, h) {
      return Et(S[h + 0], S[h + 1]);
    }, Ae.Predictor10 = function(b, S, h) {
      return Et(Et(b, S[h - 1]), Et(S[h + 0], S[h + 1]));
    }, Ae.Predictor11 = function(b, S, h) {
      var e = S[h + 0];
      return 0 >= ii(e >> 24 & 255, b >> 24 & 255, (S = S[h - 1]) >> 24 & 255) + ii(e >> 16 & 255, b >> 16 & 255, S >> 16 & 255) + ii(e >> 8 & 255, b >> 8 & 255, S >> 8 & 255) + ii(255 & e, 255 & b, 255 & S) ? e : b;
    }, Ae.Predictor12 = function(b, S, h) {
      var e = S[h + 0];
      return (jt((b >> 24 & 255) + (e >> 24 & 255) - ((S = S[h - 1]) >> 24 & 255)) << 24 | jt((b >> 16 & 255) + (e >> 16 & 255) - (S >> 16 & 255)) << 16 | jt((b >> 8 & 255) + (e >> 8 & 255) - (S >> 8 & 255)) << 8 | jt((255 & b) + (255 & e) - (255 & S))) >>> 0;
    }, Ae.Predictor13 = function(b, S, h) {
      var e = S[h - 1];
      return (ni((b = Et(b, S[h + 0])) >> 24 & 255, e >> 24 & 255) << 24 | ni(b >> 16 & 255, e >> 16 & 255) << 16 | ni(b >> 8 & 255, e >> 8 & 255) << 8 | ni(b >> 0 & 255, e >> 0 & 255)) >>> 0;
    };
    var va = Ae.PredictorAdd0;
    Ae.PredictorAdd1 = yi, xt("Predictor2", "PredictorAdd2"), xt("Predictor3", "PredictorAdd3"), xt("Predictor4", "PredictorAdd4"), xt("Predictor5", "PredictorAdd5"), xt("Predictor6", "PredictorAdd6"), xt("Predictor7", "PredictorAdd7"), xt("Predictor8", "PredictorAdd8"), xt("Predictor9", "PredictorAdd9"), xt("Predictor10", "PredictorAdd10"), xt("Predictor11", "PredictorAdd11"), xt("Predictor12", "PredictorAdd12"), xt("Predictor13", "PredictorAdd13");
    var Ys = Ae.PredictorAdd2;
    si("ColorIndexInverseTransform", "MapARGB", "32b", function(b) {
      return b >> 8 & 255;
    }, function(b) {
      return b;
    }), si("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(b) {
      return b;
    }, function(b) {
      return b >> 8 & 255;
    });
    var qa, Kr = Ae.ColorIndexInverseTransform, Ds = Ae.MapARGB, zl = Ae.VP8LColorIndexInverseTransformAlpha, al = Ae.MapAlpha, ki = Ae.VP8LPredictorsAdd = [];
    ki.length = 16, (Ae.VP8LPredictors = []).length = 16, (Ae.VP8LPredictorsAdd_C = []).length = 16, (Ae.VP8LPredictors_C = []).length = 16;
    var cn, ps, Js, hn, Is, Ks, Un, Ua, ba, fs, Qr, vn, Vn, xa, $n, Zn, wa, dn, ms, tr, Yi, dr, Cr, Dn, Gn, Tr, Ps, uu, cu = _(511), _r = _(2041), Hn = _(225), bn = _(767), wo = 0, ol = _r, Va = Hn, Br = bn, Lr = cu, Ao = 0, $a = 1, Fl = 2, Za = 3, So = 4, ll = 5, Aa = 6, Eo = 7, Ga = 8, Co = 9, ul = 10, hu = [2, 3, 7], du = [3, 3, 11], cl = [280, 256, 256, 256, 40], To = [0, 1, 1, 1, 0], qu = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Wn = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Ls = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], pu = 8, In = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Qs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], hl = null, Dc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Uu = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], fu = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], mu = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ko = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Xn = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Ot = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], gs = [], Pn = [], Ms = [], Do = 1, Ha = 2, Ns = [], vi = [];
    ct("UpsampleRgbLinePair", Ii, 3), ct("UpsampleBgrLinePair", nr, 3), ct("UpsampleRgbaLinePair", yn, 4), ct("UpsampleBgraLinePair", oi, 4), ct("UpsampleArgbLinePair", Yr, 4), ct("UpsampleRgba4444LinePair", Ti, 2), ct("UpsampleRgb565LinePair", Er, 2);
    var gu = Ae.UpsampleRgbLinePair, Ic = Ae.UpsampleBgrLinePair, Bl = Ae.UpsampleRgbaLinePair, Vu = Ae.UpsampleBgraLinePair, Wa = Ae.UpsampleArgbLinePair, _u = Ae.UpsampleRgba4444LinePair, yu = Ae.UpsampleRgb565LinePair, dl = 16, Rl = 1 << dl - 1, Xa = -227, vu = 482, $u = 6, Ln = (256 << $u) - 1, Ji = 0, Io = _(256), Ol = _(256), jl = _(256), Zu = _(256), pl = _(vu - Xa), fl = _(vu - Xa);
    zi("YuvToRgbRow", Ii, 3), zi("YuvToBgrRow", nr, 3), zi("YuvToRgbaRow", yn, 4), zi("YuvToBgraRow", oi, 4), zi("YuvToArgbRow", Yr, 4), zi("YuvToRgba4444Row", Ti, 2), zi("YuvToRgb565Row", Er, 2);
    var _s = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Sa = [0, 2, 8], Gt = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], li = 1;
    this.WebPDecodeRGBA = function(b, S, h, e, r) {
      var u = $a, d = new jn(), p = new ie();
      d.ba = p, p.S = u, p.width = [p.width], p.height = [p.height];
      var w = p.width, A = p.height, C = new ue();
      if (C == null || b == null) var P = 2;
      else l(C != null), P = ga(b, S, h, C.width, C.height, C.Pd, C.Qd, C.format, null);
      if (P != 0 ? w = 0 : (w != null && (w[0] = C.width[0]), A != null && (A[0] = C.height[0]), w = 1), w) {
        p.width = p.width[0], p.height = p.height[0], e != null && (e[0] = p.width), r != null && (r[0] = p.height);
        e: {
          if (e = new On(), (r = new vo()).data = b, r.w = S, r.ha = h, r.kd = 1, S = [0], l(r != null), ((b = ga(r.data, r.w, r.ha, null, null, null, S, null, r)) == 0 || b == 7) && S[0] && (b = 4), (S = b) == 0) {
            if (l(d != null), e.data = r.data, e.w = r.w + r.offset, e.ha = r.ha - r.offset, e.put = Me, e.ac = ge, e.bc = Fe, e.ma = d, r.xa) {
              if ((b = Oi()) == null) {
                d = 1;
                break e;
              }
              if (function(F, N) {
                var Z = [0], G = [0], V = [0];
                t: for (; ; ) {
                  if (F == null) return 0;
                  if (N == null) return F.a = 2, 0;
                  if (F.l = N, F.a = 0, qe(F.m, N.data, N.w, N.ha), !Ne(F.m, Z, G, V)) {
                    F.a = 3;
                    break t;
                  }
                  if (F.xb = Ha, N.width = Z[0], N.height = G[0], !mi(Z[0], G[0], 1, F, null)) break t;
                  return 1;
                }
                return l(F.a != 0), 0;
              }(b, e)) {
                if (e = (S = Ur(e.width, e.height, d.Oa, d.ba)) == 0) {
                  t: {
                    e = b;
                    i: for (; ; ) {
                      if (e == null) {
                        e = 0;
                        break t;
                      }
                      if (l(e.s.yc != null), l(e.s.Ya != null), l(0 < e.s.Wb), l((h = e.l) != null), l((r = h.ma) != null), e.xb != 0) {
                        if (e.ca = r.ba, e.tb = r.tb, l(e.ca != null), !ds(r.Oa, h, Za)) {
                          e.a = 2;
                          break i;
                        }
                        if (!Bi(e, h.width) || h.da) break i;
                        if ((h.da || zt(e.ca.S)) && Ye(), 11 > e.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), e.ca.f.kb.F != null && Ye()), e.Pb && 0 < e.s.ua && e.s.vb.X == null && !Pt(e.s.vb, e.s.Wa.Xa)) {
                          e.a = 1;
                          break i;
                        }
                        e.xb = 0;
                      }
                      if (!fi(e, e.V, e.Ba, e.c, e.i, h.o, $t)) break i;
                      r.Dc = e.Ma, e = 1;
                      break t;
                    }
                    l(e.a != 0), e = 0;
                  }
                  e = !e;
                }
                e && (S = b.a);
              } else S = b.a;
            } else {
              if ((b = new xr()) == null) {
                d = 1;
                break e;
              }
              if (b.Fa = r.na, b.P = r.P, b.qc = r.Sa, hr(b, e)) {
                if ((S = Ur(e.width, e.height, d.Oa, d.ba)) == 0) {
                  if (b.Aa = 0, h = d.Oa, l((r = b) != null), h != null) {
                    if (0 < (w = 0 > (w = h.Md) ? 0 : 100 < w ? 255 : 255 * w / 100)) {
                      for (A = C = 0; 4 > A; ++A) 12 > (P = r.pb[A]).lc && (P.ia = w * Gt[0 > P.lc ? 0 : P.lc] >> 3), C |= P.ia;
                      C && (alert("todo:VP8InitRandom"), r.ia = 1);
                    }
                    r.Ga = h.Id, 100 < r.Ga ? r.Ga = 100 : 0 > r.Ga && (r.Ga = 0);
                  }
                  Ko(b, e) || (S = b.a);
                }
              } else S = b.a;
            }
            S == 0 && d.Oa != null && d.Oa.fd && (S = ks(d.ba));
          }
          d = S;
        }
        u = d != 0 ? null : 11 > u ? p.f.RGBA.eb : p.f.kb.y;
      } else u = null;
      return u;
    };
    var ml = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function D(Ae, me) {
    for (var ve = "", X = 0; X < 4; X++) ve += String.fromCharCode(Ae[me++]);
    return ve;
  }
  function L(Ae, me) {
    return (Ae[me + 0] << 0 | Ae[me + 1] << 8 | Ae[me + 2] << 16) >>> 0;
  }
  function j(Ae, me) {
    return (Ae[me + 0] << 0 | Ae[me + 1] << 8 | Ae[me + 2] << 16 | Ae[me + 3] << 24) >>> 0;
  }
  new k();
  var O = [0], z = [0], pe = [], oe = new k(), ae = s, Q = function(Ae, me) {
    var ve = {}, X = 0, re = !1, xe = 0, ye = 0;
    if (ve.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(_e, be, Te, Oe) {
      for (var $e = 0; $e < Oe; $e++) if (_e[be + $e] != Te.charCodeAt($e)) return !0;
      return !1;
    }(Ae, me, "RIFF", 4)) {
      var Ve, He;
      for (j(Ae, me += 4), me += 8; me < Ae.length; ) {
        var Ze = D(Ae, me), qe = j(Ae, me += 4);
        me += 4;
        var Je = qe + (1 & qe);
        switch (Ze) {
          case "VP8 ":
          case "VP8L":
            ve.frames[X] === void 0 && (ve.frames[X] = {}), (ee = ve.frames[X]).src_off = re ? ye : me - 8, ee.src_size = xe + qe + 8, X++, re && (re = !1, xe = 0, ye = 0);
            break;
          case "VP8X":
            (ee = ve.header = {}).feature_flags = Ae[me];
            var et = me + 4;
            ee.canvas_width = 1 + L(Ae, et), et += 3, ee.canvas_height = 1 + L(Ae, et), et += 3;
            break;
          case "ALPH":
            re = !0, xe = Je + 8, ye = me - 8;
            break;
          case "ANIM":
            (ee = ve.header).bgcolor = j(Ae, me), et = me + 4, ee.loop_count = (Ve = Ae)[(He = et) + 0] << 0 | Ve[He + 1] << 8, et += 2;
            break;
          case "ANMF":
            var st, ee;
            (ee = ve.frames[X] = {}).offset_x = 2 * L(Ae, me), me += 3, ee.offset_y = 2 * L(Ae, me), me += 3, ee.width = 1 + L(Ae, me), me += 3, ee.height = 1 + L(Ae, me), me += 3, ee.duration = L(Ae, me), me += 3, st = Ae[me++], ee.dispose = 1 & st, ee.blend = st >> 1 & 1;
        }
        Ze != "ANMF" && (me += Je);
      }
      return ve;
    }
  }(ae, 0);
  Q.response = ae, Q.rgbaoutput = !0, Q.dataurl = !1;
  var fe = Q.header ? Q.header : null, Ce = Q.frames ? Q.frames : null;
  if (fe) {
    fe.loop_counter = fe.loop_count, O = [fe.canvas_height], z = [fe.canvas_width];
    for (var ze = 0; ze < Ce.length && Ce[ze].blend != 0; ze++) ;
  }
  var je = Ce[0], Qe = oe.WebPDecodeRGBA(ae, je.src_off, je.src_size, z, O);
  je.rgba = Qe, je.imgwidth = z[0], je.imgheight = O[0];
  for (var ke = 0; ke < z[0] * O[0] * 4; ke++) pe[ke] = Qe[ke];
  return this.width = z, this.height = O, this.data = pe, this;
}
(function(s) {
  var l = function() {
    return typeof ef == "function";
  }, a = function(O, z, pe, oe) {
    var ae = 4, Q = g;
    switch (oe) {
      case s.image_compression.FAST:
        ae = 1, Q = _;
        break;
      case s.image_compression.MEDIUM:
        ae = 6, Q = o;
        break;
      case s.image_compression.SLOW:
        ae = 9, Q = k;
    }
    O = m(O, z, pe, Q);
    var fe = ef(O, { level: ae });
    return s.__addimage__.arrayBufferToBinaryString(fe);
  }, m = function(O, z, pe, oe) {
    for (var ae, Q, fe, Ce = O.length / z, ze = new Uint8Array(O.length + Ce), je = L(), Qe = 0; Qe < Ce; Qe += 1) {
      if (fe = Qe * z, ae = O.subarray(fe, fe + z), oe) ze.set(oe(ae, pe, Q), fe + Qe);
      else {
        for (var ke, Ae = je.length, me = []; ke < Ae; ke += 1) me[ke] = je[ke](ae, pe, Q);
        var ve = j(me.concat());
        ze.set(me[ve], fe + Qe);
      }
      Q = ae;
    }
    return ze;
  }, y = function(O) {
    var z = Array.apply([], O);
    return z.unshift(0), z;
  }, _ = function(O, z) {
    var pe, oe = [], ae = O.length;
    oe[0] = 1;
    for (var Q = 0; Q < ae; Q += 1) pe = O[Q - z] || 0, oe[Q + 1] = O[Q] - pe + 256 & 255;
    return oe;
  }, g = function(O, z, pe) {
    var oe, ae = [], Q = O.length;
    ae[0] = 2;
    for (var fe = 0; fe < Q; fe += 1) oe = pe && pe[fe] || 0, ae[fe + 1] = O[fe] - oe + 256 & 255;
    return ae;
  }, o = function(O, z, pe) {
    var oe, ae, Q = [], fe = O.length;
    Q[0] = 3;
    for (var Ce = 0; Ce < fe; Ce += 1) oe = O[Ce - z] || 0, ae = pe && pe[Ce] || 0, Q[Ce + 1] = O[Ce] + 256 - (oe + ae >>> 1) & 255;
    return Q;
  }, k = function(O, z, pe) {
    var oe, ae, Q, fe, Ce = [], ze = O.length;
    Ce[0] = 4;
    for (var je = 0; je < ze; je += 1) oe = O[je - z] || 0, ae = pe && pe[je] || 0, Q = pe && pe[je - z] || 0, fe = D(oe, ae, Q), Ce[je + 1] = O[je] - fe + 256 & 255;
    return Ce;
  }, D = function(O, z, pe) {
    if (O === z && z === pe) return O;
    var oe = Math.abs(z - pe), ae = Math.abs(O - pe), Q = Math.abs(O + z - pe - pe);
    return oe <= ae && oe <= Q ? O : ae <= Q ? z : pe;
  }, L = function() {
    return [y, _, g, o, k];
  }, j = function(O) {
    var z = O.map(function(pe) {
      return pe.reduce(function(oe, ae) {
        return oe + Math.abs(ae);
      }, 0);
    });
    return z.indexOf(Math.min.apply(null, z));
  };
  s.processPNG = function(O, z, pe, oe) {
    var ae, Q, fe, Ce, ze, je, Qe, ke, Ae, me, ve, X, re, xe, ye, Ve = this.decode.FLATE_DECODE, He = "";
    if (this.__addimage__.isArrayBuffer(O) && (O = new Uint8Array(O)), this.__addimage__.isArrayBufferView(O)) {
      if (O = (fe = new ux(O)).imgData, Q = fe.bits, ae = fe.colorSpace, ze = fe.colors, [4, 6].indexOf(fe.colorType) !== -1) {
        if (fe.bits === 8) {
          Ae = (ke = fe.pixelBitlength == 32 ? new Uint32Array(fe.decodePixels().buffer) : fe.pixelBitlength == 16 ? new Uint16Array(fe.decodePixels().buffer) : new Uint8Array(fe.decodePixels().buffer)).length, ve = new Uint8Array(Ae * fe.colors), me = new Uint8Array(Ae);
          var Ze, qe = fe.pixelBitlength - fe.bits;
          for (xe = 0, ye = 0; xe < Ae; xe++) {
            for (re = ke[xe], Ze = 0; Ze < qe; ) ve[ye++] = re >>> Ze & 255, Ze += fe.bits;
            me[xe] = re >>> Ze & 255;
          }
        }
        if (fe.bits === 16) {
          Ae = (ke = new Uint32Array(fe.decodePixels().buffer)).length, ve = new Uint8Array(Ae * (32 / fe.pixelBitlength) * fe.colors), me = new Uint8Array(Ae * (32 / fe.pixelBitlength)), X = fe.colors > 1, xe = 0, ye = 0;
          for (var Je = 0; xe < Ae; ) re = ke[xe++], ve[ye++] = re >>> 0 & 255, X && (ve[ye++] = re >>> 16 & 255, re = ke[xe++], ve[ye++] = re >>> 0 & 255), me[Je++] = re >>> 16 & 255;
          Q = 8;
        }
        oe !== s.image_compression.NONE && l() ? (O = a(ve, fe.width * fe.colors, fe.colors, oe), Qe = a(me, fe.width, 1, oe)) : (O = ve, Qe = me, Ve = void 0);
      }
      if (fe.colorType === 3 && (ae = this.color_spaces.INDEXED, je = fe.palette, fe.transparency.indexed)) {
        var et = fe.transparency.indexed, st = 0;
        for (xe = 0, Ae = et.length; xe < Ae; ++xe) st += et[xe];
        if ((st /= 255) === Ae - 1 && et.indexOf(0) !== -1) Ce = [et.indexOf(0)];
        else if (st !== Ae) {
          for (ke = fe.decodePixels(), me = new Uint8Array(ke.length), xe = 0, Ae = ke.length; xe < Ae; xe++) me[xe] = et[ke[xe]];
          Qe = a(me, fe.width, 1);
        }
      }
      var ee = function(_e) {
        var be;
        switch (_e) {
          case s.image_compression.FAST:
            be = 11;
            break;
          case s.image_compression.MEDIUM:
            be = 13;
            break;
          case s.image_compression.SLOW:
            be = 14;
            break;
          default:
            be = 12;
        }
        return be;
      }(oe);
      return Ve === this.decode.FLATE_DECODE && (He = "/Predictor " + ee + " "), He += "/Colors " + ze + " /BitsPerComponent " + Q + " /Columns " + fe.width, (this.__addimage__.isArrayBuffer(O) || this.__addimage__.isArrayBufferView(O)) && (O = this.__addimage__.arrayBufferToBinaryString(O)), (Qe && this.__addimage__.isArrayBuffer(Qe) || this.__addimage__.isArrayBufferView(Qe)) && (Qe = this.__addimage__.arrayBufferToBinaryString(Qe)), { alias: pe, data: O, index: z, filter: Ve, decodeParameters: He, transparency: Ce, palette: je, sMask: Qe, predictor: ee, width: fe.width, height: fe.height, bitsPerComponent: Q, colorSpace: ae };
    }
  };
})(wi.API), function(s) {
  s.processGIF89A = function(l, a, m, y) {
    var _ = new cx(l), g = _.width, o = _.height, k = [];
    _.decodeAndBlitFrameRGBA(0, k);
    var D = { data: k, width: g, height: o }, L = new Lp(100).encode(D, 100);
    return s.processJPEG.call(this, L, a, m, y);
  }, s.processGIF87A = s.processGIF89A;
}(wi.API), eo.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var s = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(s);
    for (var l = 0; l < s; l++) {
      var a = this.datav.getUint8(this.pos++, !0), m = this.datav.getUint8(this.pos++, !0), y = this.datav.getUint8(this.pos++, !0), _ = this.datav.getUint8(this.pos++, !0);
      this.palette[l] = { red: y, green: m, blue: a, quad: _ };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, eo.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var s = "bit" + this.bitPP, l = this.width * this.height * 4;
    this.data = new Uint8Array(l), this[s]();
  } catch (a) {
    vr.log("bit decode error:" + a);
  }
}, eo.prototype.bit1 = function() {
  var s, l = Math.ceil(this.width / 8), a = l % 4;
  for (s = this.height - 1; s >= 0; s--) {
    for (var m = this.bottom_up ? s : this.height - 1 - s, y = 0; y < l; y++) for (var _ = this.datav.getUint8(this.pos++, !0), g = m * this.width * 4 + 8 * y * 4, o = 0; o < 8 && 8 * y + o < this.width; o++) {
      var k = this.palette[_ >> 7 - o & 1];
      this.data[g + 4 * o] = k.blue, this.data[g + 4 * o + 1] = k.green, this.data[g + 4 * o + 2] = k.red, this.data[g + 4 * o + 3] = 255;
    }
    a !== 0 && (this.pos += 4 - a);
  }
}, eo.prototype.bit4 = function() {
  for (var s = Math.ceil(this.width / 2), l = s % 4, a = this.height - 1; a >= 0; a--) {
    for (var m = this.bottom_up ? a : this.height - 1 - a, y = 0; y < s; y++) {
      var _ = this.datav.getUint8(this.pos++, !0), g = m * this.width * 4 + 2 * y * 4, o = _ >> 4, k = 15 & _, D = this.palette[o];
      if (this.data[g] = D.blue, this.data[g + 1] = D.green, this.data[g + 2] = D.red, this.data[g + 3] = 255, 2 * y + 1 >= this.width) break;
      D = this.palette[k], this.data[g + 4] = D.blue, this.data[g + 4 + 1] = D.green, this.data[g + 4 + 2] = D.red, this.data[g + 4 + 3] = 255;
    }
    l !== 0 && (this.pos += 4 - l);
  }
}, eo.prototype.bit8 = function() {
  for (var s = this.width % 4, l = this.height - 1; l >= 0; l--) {
    for (var a = this.bottom_up ? l : this.height - 1 - l, m = 0; m < this.width; m++) {
      var y = this.datav.getUint8(this.pos++, !0), _ = a * this.width * 4 + 4 * m;
      if (y < this.palette.length) {
        var g = this.palette[y];
        this.data[_] = g.red, this.data[_ + 1] = g.green, this.data[_ + 2] = g.blue, this.data[_ + 3] = 255;
      } else this.data[_] = 255, this.data[_ + 1] = 255, this.data[_ + 2] = 255, this.data[_ + 3] = 255;
    }
    s !== 0 && (this.pos += 4 - s);
  }
}, eo.prototype.bit15 = function() {
  for (var s = this.width % 3, l = parseInt("11111", 2), a = this.height - 1; a >= 0; a--) {
    for (var m = this.bottom_up ? a : this.height - 1 - a, y = 0; y < this.width; y++) {
      var _ = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var g = (_ & l) / l * 255 | 0, o = (_ >> 5 & l) / l * 255 | 0, k = (_ >> 10 & l) / l * 255 | 0, D = _ >> 15 ? 255 : 0, L = m * this.width * 4 + 4 * y;
      this.data[L] = k, this.data[L + 1] = o, this.data[L + 2] = g, this.data[L + 3] = D;
    }
    this.pos += s;
  }
}, eo.prototype.bit16 = function() {
  for (var s = this.width % 3, l = parseInt("11111", 2), a = parseInt("111111", 2), m = this.height - 1; m >= 0; m--) {
    for (var y = this.bottom_up ? m : this.height - 1 - m, _ = 0; _ < this.width; _++) {
      var g = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (g & l) / l * 255 | 0, k = (g >> 5 & a) / a * 255 | 0, D = (g >> 11) / l * 255 | 0, L = y * this.width * 4 + 4 * _;
      this.data[L] = D, this.data[L + 1] = k, this.data[L + 2] = o, this.data[L + 3] = 255;
    }
    this.pos += s;
  }
}, eo.prototype.bit24 = function() {
  for (var s = this.height - 1; s >= 0; s--) {
    for (var l = this.bottom_up ? s : this.height - 1 - s, a = 0; a < this.width; a++) {
      var m = this.datav.getUint8(this.pos++, !0), y = this.datav.getUint8(this.pos++, !0), _ = this.datav.getUint8(this.pos++, !0), g = l * this.width * 4 + 4 * a;
      this.data[g] = _, this.data[g + 1] = y, this.data[g + 2] = m, this.data[g + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, eo.prototype.bit32 = function() {
  for (var s = this.height - 1; s >= 0; s--) for (var l = this.bottom_up ? s : this.height - 1 - s, a = 0; a < this.width; a++) {
    var m = this.datav.getUint8(this.pos++, !0), y = this.datav.getUint8(this.pos++, !0), _ = this.datav.getUint8(this.pos++, !0), g = this.datav.getUint8(this.pos++, !0), o = l * this.width * 4 + 4 * a;
    this.data[o] = _, this.data[o + 1] = y, this.data[o + 2] = m, this.data[o + 3] = g;
  }
}, eo.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  s.processBMP = function(l, a, m, y) {
    var _ = new eo(l, !1), g = _.width, o = _.height, k = { data: _.getData(), width: g, height: o }, D = new Lp(100).encode(k, 100);
    return s.processJPEG.call(this, D, a, m, y);
  };
}(wi.API), r0.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  s.processWEBP = function(l, a, m, y) {
    var _ = new r0(l), g = _.width, o = _.height, k = { data: _.getData(), width: g, height: o }, D = new Lp(100).encode(k, 100);
    return s.processJPEG.call(this, D, a, m, y);
  };
}(wi.API), wi.API.processRGBA = function(s, l, a) {
  for (var m = s.data, y = m.length, _ = new Uint8Array(y / 4 * 3), g = new Uint8Array(y / 4), o = 0, k = 0, D = 0; D < y; D += 4) {
    var L = m[D], j = m[D + 1], O = m[D + 2], z = m[D + 3];
    _[o++] = L, _[o++] = j, _[o++] = O, g[k++] = z;
  }
  var pe = this.__addimage__.arrayBufferToBinaryString(_);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(g), data: pe, index: l, alias: a, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: s.width, height: s.height };
}, wi.API.setLanguage = function(s) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[s] !== void 0 && (this.internal.languageSettings.languageCode = s, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, dc = wi.API, td = dc.getCharWidthsArray = function(s, l) {
  var a, m, y = (l = l || {}).font || this.internal.getFont(), _ = l.fontSize || this.internal.getFontSize(), g = l.charSpace || this.internal.getCharSpace(), o = l.widths ? l.widths : y.metadata.Unicode.widths, k = o.fof ? o.fof : 1, D = l.kerning ? l.kerning : y.metadata.Unicode.kerning, L = D.fof ? D.fof : 1, j = l.doKerning !== !1, O = 0, z = s.length, pe = 0, oe = o[0] || k, ae = [];
  for (a = 0; a < z; a++) m = s.charCodeAt(a), typeof y.metadata.widthOfString == "function" ? ae.push((y.metadata.widthOfGlyph(y.metadata.characterToGlyph(m)) + g * (1e3 / _) || 0) / 1e3) : (O = j && ur(D[m]) === "object" && !isNaN(parseInt(D[m][pe], 10)) ? D[m][pe] / L : 0, ae.push((o[m] || oe) / k + O)), pe = m;
  return ae;
}, Qg = dc.getStringUnitWidth = function(s, l) {
  var a = (l = l || {}).fontSize || this.internal.getFontSize(), m = l.font || this.internal.getFont(), y = l.charSpace || this.internal.getCharSpace();
  return dc.processArabic && (s = dc.processArabic(s)), typeof m.metadata.widthOfString == "function" ? m.metadata.widthOfString(s, a, y) / a : td.apply(this, arguments).reduce(function(_, g) {
    return _ + g;
  }, 0);
}, e0 = function(s, l, a, m) {
  for (var y = [], _ = 0, g = s.length, o = 0; _ !== g && o + l[_] < a; ) o += l[_], _++;
  y.push(s.slice(0, _));
  var k = _;
  for (o = 0; _ !== g; ) o + l[_] > m && (y.push(s.slice(k, _)), o = 0, k = _), o += l[_], _++;
  return k !== _ && y.push(s.slice(k, _)), y;
}, t0 = function(s, l, a) {
  a || (a = {});
  var m, y, _, g, o, k, D, L = [], j = [L], O = a.textIndent || 0, z = 0, pe = 0, oe = s.split(" "), ae = td.apply(this, [" ", a])[0];
  if (k = a.lineIndent === -1 ? oe[0].length + 2 : a.lineIndent || 0) {
    var Q = Array(k).join(" "), fe = [];
    oe.map(function(ze) {
      (ze = ze.split(/\s*\n/)).length > 1 ? fe = fe.concat(ze.map(function(je, Qe) {
        return (Qe && je.length ? `
` : "") + je;
      })) : fe.push(ze[0]);
    }), oe = fe, k = Qg.apply(this, [Q, a]);
  }
  for (_ = 0, g = oe.length; _ < g; _++) {
    var Ce = 0;
    if (m = oe[_], k && m[0] == `
` && (m = m.substr(1), Ce = 1), O + z + (pe = (y = td.apply(this, [m, a])).reduce(function(ze, je) {
      return ze + je;
    }, 0)) > l || Ce) {
      if (pe > l) {
        for (o = e0.apply(this, [m, y, l - (O + z), l]), L.push(o.shift()), L = [o.pop()]; o.length; ) j.push([o.shift()]);
        pe = y.slice(m.length - (L[0] ? L[0].length : 0)).reduce(function(ze, je) {
          return ze + je;
        }, 0);
      } else L = [m];
      j.push(L), O = pe + k, z = ae;
    } else L.push(m), O += z + pe, z = ae;
  }
  return D = k ? function(ze, je) {
    return (je ? Q : "") + ze.join(" ");
  } : function(ze) {
    return ze.join(" ");
  }, j.map(D);
}, dc.splitTextToSize = function(s, l, a) {
  var m, y = (a = a || {}).fontSize || this.internal.getFontSize(), _ = (function(L) {
    if (L.widths && L.kerning) return { widths: L.widths, kerning: L.kerning };
    var j = this.internal.getFont(L.fontName, L.fontStyle);
    return j.metadata.Unicode ? { widths: j.metadata.Unicode.widths || { 0: 1 }, kerning: j.metadata.Unicode.kerning || {} } : { font: j.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, a);
  m = Array.isArray(s) ? s : String(s).split(/\r?\n/);
  var g = 1 * this.internal.scaleFactor * l / y;
  _.textIndent = a.textIndent ? 1 * a.textIndent * this.internal.scaleFactor / y : 0, _.lineIndent = a.lineIndent;
  var o, k, D = [];
  for (o = 0, k = m.length; o < k; o++) D = D.concat(t0.apply(this, [m[o], g, _]));
  return D;
}, function(s) {
  s.__fontmetrics__ = s.__fontmetrics__ || {};
  for (var l = "klmnopqrstuvwxyz", a = {}, m = {}, y = 0; y < l.length; y++) a[l[y]] = "0123456789abcdef"[y], m["0123456789abcdef"[y]] = l[y];
  var _ = function(j) {
    return "0x" + parseInt(j, 10).toString(16);
  }, g = s.__fontmetrics__.compress = function(j) {
    var O, z, pe, oe, ae = ["{"];
    for (var Q in j) {
      if (O = j[Q], isNaN(parseInt(Q, 10)) ? z = "'" + Q + "'" : (Q = parseInt(Q, 10), z = (z = _(Q).slice(2)).slice(0, -1) + m[z.slice(-1)]), typeof O == "number") O < 0 ? (pe = _(O).slice(3), oe = "-") : (pe = _(O).slice(2), oe = ""), pe = oe + pe.slice(0, -1) + m[pe.slice(-1)];
      else {
        if (ur(O) !== "object") throw new Error("Don't know what to do with value type " + ur(O) + ".");
        pe = g(O);
      }
      ae.push(z + pe);
    }
    return ae.push("}"), ae.join("");
  }, o = s.__fontmetrics__.uncompress = function(j) {
    if (typeof j != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var O, z, pe, oe, ae = {}, Q = 1, fe = ae, Ce = [], ze = "", je = "", Qe = j.length - 1, ke = 1; ke < Qe; ke += 1) (oe = j[ke]) == "'" ? O ? (pe = O.join(""), O = void 0) : O = [] : O ? O.push(oe) : oe == "{" ? (Ce.push([fe, pe]), fe = {}, pe = void 0) : oe == "}" ? ((z = Ce.pop())[0][z[1]] = fe, pe = void 0, fe = z[0]) : oe == "-" ? Q = -1 : pe === void 0 ? a.hasOwnProperty(oe) ? (ze += a[oe], pe = parseInt(ze, 16) * Q, Q = 1, ze = "") : ze += oe : a.hasOwnProperty(oe) ? (je += a[oe], fe[pe] = parseInt(je, 16) * Q, Q = 1, pe = void 0, je = "") : je += oe;
    return ae;
  }, k = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, D = { Unicode: { Courier: k, "Courier-Bold": k, "Courier-BoldOblique": k, "Courier-Oblique": k, Helvetica: k, "Helvetica-Bold": k, "Helvetica-BoldOblique": k, "Helvetica-Oblique": k, "Times-Roman": k, "Times-Bold": k, "Times-BoldItalic": k, "Times-Italic": k } }, L = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  s.events.push(["addFont", function(j) {
    var O = j.font, z = L.Unicode[O.postScriptName];
    z && (O.metadata.Unicode = {}, O.metadata.Unicode.widths = z.widths, O.metadata.Unicode.kerning = z.kerning);
    var pe = D.Unicode[O.postScriptName];
    pe && (O.metadata.Unicode.encoding = pe, O.encoding = pe.codePages[0]);
  }]);
}(wi.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = function(a) {
    for (var m = a.length, y = new Uint8Array(m), _ = 0; _ < m; _++) y[_] = a.charCodeAt(_);
    return y;
  };
  s.API.events.push(["addFont", function(a) {
    var m = void 0, y = a.font, _ = a.instance;
    if (!y.isStandardFont) {
      if (_ === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + y.postScriptName + "').");
      if (typeof (m = _.existsFileInVFS(y.postScriptName) === !1 ? _.loadFile(y.postScriptName) : _.getFileFromVFS(y.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + y.postScriptName + "').");
      (function(g, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? l(o) : l(ph(o)), g.metadata = s.API.TTFFont.open(o), g.metadata.Unicode = g.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, g.metadata.glyIdsUsed = [0];
      })(y, m);
    }
  }]);
}(wi), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(s) {
  function l() {
    return (Ai.canvg ? Promise.resolve(Ai.canvg) : import("./index.es-DoMiftKY-BxzUUBAy.js")).catch(function(a) {
      return Promise.reject(new Error("Could not load canvg: " + a));
    }).then(function(a) {
      return a.default ? a.default : a;
    });
  }
  wi.API.addSvgAsImage = function(a, m, y, _, g, o, k, D) {
    if (isNaN(m) || isNaN(y)) throw vr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(_) || isNaN(g)) throw vr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var L = document.createElement("canvas");
    L.width = _, L.height = g;
    var j = L.getContext("2d");
    j.fillStyle = "#fff", j.fillRect(0, 0, L.width, L.height);
    var O = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, z = this;
    return l().then(function(pe) {
      return pe.fromString(j, a, O);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(pe) {
      return pe.render(O);
    }).then(function() {
      z.addImage(L.toDataURL("image/jpeg", 1), m, y, _, g, k, D);
    });
  };
}(), wi.API.putTotalPages = function(s) {
  var l, a = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (l = new RegExp(s, "g"), a = this.internal.getNumberOfPages()) : (l = new RegExp(this.pdfEscape16(s, this.internal.getFont()), "g"), a = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var m = 1; m <= this.internal.getNumberOfPages(); m++) for (var y = 0; y < this.internal.pages[m].length; y++) this.internal.pages[m][y] = this.internal.pages[m][y].replace(l, a);
  return this;
}, wi.API.viewerPreferences = function(s, l) {
  var a;
  s = s || {}, l = l || !1;
  var m, y, _, g = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(g), k = [], D = 0, L = 0, j = 0;
  function O(pe, oe) {
    var ae, Q = !1;
    for (ae = 0; ae < pe.length; ae += 1) pe[ae] === oe && (Q = !0);
    return Q;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(g)), this.internal.viewerpreferences.isSubscribed = !1), a = this.internal.viewerpreferences.configuration, s === "reset" || l === !0) {
    var z = o.length;
    for (j = 0; j < z; j += 1) a[o[j]].value = a[o[j]].defaultValue, a[o[j]].explicitSet = !1;
  }
  if (ur(s) === "object") {
    for (y in s) if (_ = s[y], O(o, y) && _ !== void 0) {
      if (a[y].type === "boolean" && typeof _ == "boolean") a[y].value = _;
      else if (a[y].type === "name" && O(a[y].valueSet, _)) a[y].value = _;
      else if (a[y].type === "integer" && Number.isInteger(_)) a[y].value = _;
      else if (a[y].type === "array") {
        for (D = 0; D < _.length; D += 1) if (m = !0, _[D].length === 1 && typeof _[D][0] == "number") k.push(String(_[D] - 1));
        else if (_[D].length > 1) {
          for (L = 0; L < _[D].length; L += 1) typeof _[D][L] != "number" && (m = !1);
          m === !0 && k.push([_[D][0] - 1, _[D][1] - 1].join(" "));
        }
        a[y].value = "[" + k.join(" ") + "]";
      } else a[y].value = a[y].defaultValue;
      a[y].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var pe, oe = [];
    for (pe in a) a[pe].explicitSet === !0 && (a[pe].type === "name" ? oe.push("/" + pe + " /" + a[pe].value) : oe.push("/" + pe + " " + a[pe].value));
    oe.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + oe.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = a, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(s) {
  var l = function() {
    var m = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', y = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), _ = unescape(encodeURIComponent(m)), g = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), k = unescape(encodeURIComponent("</x:xmpmeta>")), D = _.length + g.length + o.length + y.length + k.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + D + " >>"), this.internal.write("stream"), this.internal.write(y + _ + g + o + k), this.internal.write("endstream"), this.internal.write("endobj");
  }, a = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  s.addMetadata = function(m, y) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: m, namespaceuri: y || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", a), this.internal.events.subscribe("postPutResources", l)), this;
  };
}(wi.API), function(s) {
  var l = s.API, a = l.pdfEscape16 = function(_, g) {
    for (var o, k = g.metadata.Unicode.widths, D = ["", "0", "00", "000", "0000"], L = [""], j = 0, O = _.length; j < O; ++j) {
      if (o = g.metadata.characterToGlyph(_.charCodeAt(j)), g.metadata.glyIdsUsed.push(o), g.metadata.toUnicode[o] = _.charCodeAt(j), k.indexOf(o) == -1 && (k.push(o), k.push([parseInt(g.metadata.widthOfGlyph(o), 10)])), o == "0") return L.join("");
      o = o.toString(16), L.push(D[4 - o.length], o);
    }
    return L.join("");
  }, m = function(_) {
    var g, o, k, D, L, j, O;
    for (L = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, k = [], j = 0, O = (o = Object.keys(_).sort(function(z, pe) {
      return z - pe;
    })).length; j < O; j++) g = o[j], k.length >= 100 && (L += `
` + k.length + ` beginbfchar
` + k.join(`
`) + `
endbfchar`, k = []), _[g] !== void 0 && _[g] !== null && typeof _[g].toString == "function" && (D = ("0000" + _[g].toString(16)).slice(-4), g = ("0000" + (+g).toString(16)).slice(-4), k.push("<" + g + "><" + D + ">"));
    return k.length && (L += `
` + k.length + ` beginbfchar
` + k.join(`
`) + `
endbfchar
`), L += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  l.events.push(["putFont", function(_) {
    (function(g) {
      var o = g.font, k = g.out, D = g.newObject, L = g.putStream;
      if (o.metadata instanceof s.API.TTFFont && o.encoding === "Identity-H") {
        for (var j = o.metadata.Unicode.widths, O = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), z = "", pe = 0; pe < O.length; pe++) z += String.fromCharCode(O[pe]);
        var oe = D();
        L({ data: z, addLength1: !0, objectId: oe }), k("endobj");
        var ae = D();
        L({ data: m(o.metadata.toUnicode), addLength1: !0, objectId: ae }), k("endobj");
        var Q = D();
        k("<<"), k("/Type /FontDescriptor"), k("/FontName /" + fc(o.fontName)), k("/FontFile2 " + oe + " 0 R"), k("/FontBBox " + s.API.PDFObject.convert(o.metadata.bbox)), k("/Flags " + o.metadata.flags), k("/StemV " + o.metadata.stemV), k("/ItalicAngle " + o.metadata.italicAngle), k("/Ascent " + o.metadata.ascender), k("/Descent " + o.metadata.decender), k("/CapHeight " + o.metadata.capHeight), k(">>"), k("endobj");
        var fe = D();
        k("<<"), k("/Type /Font"), k("/BaseFont /" + fc(o.fontName)), k("/FontDescriptor " + Q + " 0 R"), k("/W " + s.API.PDFObject.convert(j)), k("/CIDToGIDMap /Identity"), k("/DW 1000"), k("/Subtype /CIDFontType2"), k("/CIDSystemInfo"), k("<<"), k("/Supplement 0"), k("/Registry (Adobe)"), k("/Ordering (" + o.encoding + ")"), k(">>"), k(">>"), k("endobj"), o.objectNumber = D(), k("<<"), k("/Type /Font"), k("/Subtype /Type0"), k("/ToUnicode " + ae + " 0 R"), k("/BaseFont /" + fc(o.fontName)), k("/Encoding /" + o.encoding), k("/DescendantFonts [" + fe + " 0 R]"), k(">>"), k("endobj"), o.isAlreadyPutted = !0;
      }
    })(_);
  }]), l.events.push(["putFont", function(_) {
    (function(g) {
      var o = g.font, k = g.out, D = g.newObject, L = g.putStream;
      if (o.metadata instanceof s.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var j = o.metadata.rawData, O = "", z = 0; z < j.length; z++) O += String.fromCharCode(j[z]);
        var pe = D();
        L({ data: O, addLength1: !0, objectId: pe }), k("endobj");
        var oe = D();
        L({ data: m(o.metadata.toUnicode), addLength1: !0, objectId: oe }), k("endobj");
        var ae = D();
        k("<<"), k("/Descent " + o.metadata.decender), k("/CapHeight " + o.metadata.capHeight), k("/StemV " + o.metadata.stemV), k("/Type /FontDescriptor"), k("/FontFile2 " + pe + " 0 R"), k("/Flags 96"), k("/FontBBox " + s.API.PDFObject.convert(o.metadata.bbox)), k("/FontName /" + fc(o.fontName)), k("/ItalicAngle " + o.metadata.italicAngle), k("/Ascent " + o.metadata.ascender), k(">>"), k("endobj"), o.objectNumber = D();
        for (var Q = 0; Q < o.metadata.hmtx.widths.length; Q++) o.metadata.hmtx.widths[Q] = parseInt(o.metadata.hmtx.widths[Q] * (1e3 / o.metadata.head.unitsPerEm));
        k("<</Subtype/TrueType/Type/Font/ToUnicode " + oe + " 0 R/BaseFont/" + fc(o.fontName) + "/FontDescriptor " + ae + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + s.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), k("endobj"), o.isAlreadyPutted = !0;
      }
    })(_);
  }]);
  var y = function(_) {
    var g, o = _.text || "", k = _.x, D = _.y, L = _.options || {}, j = _.mutex || {}, O = j.pdfEscape, z = j.activeFontKey, pe = j.fonts, oe = z, ae = "", Q = 0, fe = "", Ce = pe[oe].encoding;
    if (pe[oe].encoding !== "Identity-H") return { text: o, x: k, y: D, options: L, mutex: j };
    for (fe = o, oe = z, Array.isArray(o) && (fe = o[0]), Q = 0; Q < fe.length; Q += 1) pe[oe].metadata.hasOwnProperty("cmap") && (g = pe[oe].metadata.cmap.unicode.codeMap[fe[Q].charCodeAt(0)]), g || fe[Q].charCodeAt(0) < 256 && pe[oe].metadata.hasOwnProperty("Unicode") ? ae += fe[Q] : ae += "";
    var ze = "";
    return parseInt(oe.slice(1)) < 14 || Ce === "WinAnsiEncoding" ? ze = O(ae, oe).split("").map(function(je) {
      return je.charCodeAt(0).toString(16);
    }).join("") : Ce === "Identity-H" && (ze = a(ae, pe[oe])), j.isHex = !0, { text: ze, x: k, y: D, options: L, mutex: j };
  };
  l.events.push(["postProcessText", function(_) {
    var g = _.text || "", o = [], k = { text: g, x: _.x, y: _.y, options: _.options, mutex: _.mutex };
    if (Array.isArray(g)) {
      var D = 0;
      for (D = 0; D < g.length; D += 1) Array.isArray(g[D]) && g[D].length === 3 ? o.push([y(Object.assign({}, k, { text: g[D][0] })).text, g[D][1], g[D][2]]) : o.push(y(Object.assign({}, k, { text: g[D] })).text);
      _.text = o;
    } else _.text = y(Object.assign({}, k, { text: g })).text;
  }]);
}(wi), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(s) {
  var l = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  s.existsFileInVFS = function(a) {
    return l.call(this), this.internal.vFS[a] !== void 0;
  }, s.addFileToVFS = function(a, m) {
    return l.call(this), this.internal.vFS[a] = m, this;
  }, s.getFileFromVFS = function(a) {
    return l.call(this), this.internal.vFS[a] !== void 0 ? this.internal.vFS[a] : null;
  };
}(wi.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(s) {
  s.__bidiEngine__ = s.prototype.__bidiEngine__ = function(m) {
    var y, _, g, o, k, D, L, j = l, O = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], z = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], pe = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, oe = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, ae = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], Q = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), fe = !1, Ce = 0;
    this.__bidiEngine__ = {};
    var ze = function(X) {
      var re = X.charCodeAt(), xe = re >> 8, ye = oe[xe];
      return ye !== void 0 ? j[256 * ye + (255 & re)] : xe === 252 || xe === 253 ? "AL" : Q.test(xe) ? "L" : xe === 8 ? "R" : "N";
    }, je = function(X) {
      for (var re, xe = 0; xe < X.length; xe++) {
        if ((re = ze(X.charAt(xe))) === "L") return !1;
        if (re === "R") return !0;
      }
      return !1;
    }, Qe = function(X, re, xe, ye) {
      var Ve, He, Ze, qe, Je = re[ye];
      switch (Je) {
        case "L":
        case "R":
          fe = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          fe && (Je = "AN");
          break;
        case "AL":
          fe = !0, Je = "R";
          break;
        case "WS":
          Je = "N";
          break;
        case "CS":
          ye < 1 || ye + 1 >= re.length || (Ve = xe[ye - 1]) !== "EN" && Ve !== "AN" || (He = re[ye + 1]) !== "EN" && He !== "AN" ? Je = "N" : fe && (He = "AN"), Je = He === Ve ? He : "N";
          break;
        case "ES":
          Je = (Ve = ye > 0 ? xe[ye - 1] : "B") === "EN" && ye + 1 < re.length && re[ye + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (ye > 0 && xe[ye - 1] === "EN") {
            Je = "EN";
            break;
          }
          if (fe) {
            Je = "N";
            break;
          }
          for (Ze = ye + 1, qe = re.length; Ze < qe && re[Ze] === "ET"; ) Ze++;
          Je = Ze < qe && re[Ze] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (g && !o) {
            for (qe = re.length, Ze = ye + 1; Ze < qe && re[Ze] === "NSM"; ) Ze++;
            if (Ze < qe) {
              var et = X[ye], st = et >= 1425 && et <= 2303 || et === 64286;
              if (Ve = re[Ze], st && (Ve === "R" || Ve === "AL")) {
                Je = "R";
                break;
              }
            }
          }
          Je = ye < 1 || (Ve = re[ye - 1]) === "B" ? "N" : xe[ye - 1];
          break;
        case "B":
          fe = !1, y = !0, Je = Ce;
          break;
        case "S":
          _ = !0, Je = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          fe = !1;
          break;
        case "BN":
          Je = "N";
      }
      return Je;
    }, ke = function(X, re, xe) {
      var ye = X.split("");
      return xe && Ae(ye, xe, { hiLevel: Ce }), ye.reverse(), re && re.reverse(), ye.join("");
    }, Ae = function(X, re, xe) {
      var ye, Ve, He, Ze, qe, Je = -1, et = X.length, st = 0, ee = [], _e = Ce ? z : O, be = [];
      for (fe = !1, y = !1, _ = !1, Ve = 0; Ve < et; Ve++) be[Ve] = ze(X[Ve]);
      for (He = 0; He < et; He++) {
        if (qe = st, ee[He] = Qe(X, be, ee, He), ye = 240 & (st = _e[qe][pe[ee[He]]]), st &= 15, re[He] = Ze = _e[st][5], ye > 0) if (ye === 16) {
          for (Ve = Je; Ve < He; Ve++) re[Ve] = 1;
          Je = -1;
        } else Je = -1;
        if (_e[st][6]) Je === -1 && (Je = He);
        else if (Je > -1) {
          for (Ve = Je; Ve < He; Ve++) re[Ve] = Ze;
          Je = -1;
        }
        be[He] === "B" && (re[He] = 0), xe.hiLevel |= Ze;
      }
      _ && function(Te, Oe, $e) {
        for (var Ue = 0; Ue < $e; Ue++) if (Te[Ue] === "S") {
          Oe[Ue] = Ce;
          for (var Ke = Ue - 1; Ke >= 0 && Te[Ke] === "WS"; Ke--) Oe[Ke] = Ce;
        }
      }(be, re, et);
    }, me = function(X, re, xe, ye, Ve) {
      if (!(Ve.hiLevel < X)) {
        if (X === 1 && Ce === 1 && !y) return re.reverse(), void (xe && xe.reverse());
        for (var He, Ze, qe, Je, et = re.length, st = 0; st < et; ) {
          if (ye[st] >= X) {
            for (qe = st + 1; qe < et && ye[qe] >= X; ) qe++;
            for (Je = st, Ze = qe - 1; Je < Ze; Je++, Ze--) He = re[Je], re[Je] = re[Ze], re[Ze] = He, xe && (He = xe[Je], xe[Je] = xe[Ze], xe[Ze] = He);
            st = qe;
          }
          st++;
        }
      }
    }, ve = function(X, re, xe) {
      var ye = X.split(""), Ve = { hiLevel: Ce };
      return xe || (xe = []), Ae(ye, xe, Ve), function(He, Ze, qe) {
        if (qe.hiLevel !== 0 && L) for (var Je, et = 0; et < He.length; et++) Ze[et] === 1 && (Je = ae.indexOf(He[et])) >= 0 && (He[et] = ae[Je + 1]);
      }(ye, xe, Ve), me(2, ye, re, xe, Ve), me(1, ye, re, xe, Ve), ye.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(X, re, xe) {
      if (function(Ve, He) {
        if (He) for (var Ze = 0; Ze < Ve.length; Ze++) He[Ze] = Ze;
        o === void 0 && (o = je(Ve)), D === void 0 && (D = je(Ve));
      }(X, re), g || !k || D) if (g && k && o ^ D) Ce = o ? 1 : 0, X = ke(X, re, xe);
      else if (!g && k && D) Ce = o ? 1 : 0, X = ve(X, re, xe), X = ke(X, re);
      else if (!g || o || k || D) {
        if (g && !k && o ^ D) X = ke(X, re), o ? (Ce = 0, X = ve(X, re, xe)) : (Ce = 1, X = ve(X, re, xe), X = ke(X, re));
        else if (g && o && !k && D) Ce = 1, X = ve(X, re, xe), X = ke(X, re);
        else if (!g && !k && o ^ D) {
          var ye = L;
          o ? (Ce = 1, X = ve(X, re, xe), Ce = 0, L = !1, X = ve(X, re, xe), L = ye) : (Ce = 0, X = ve(X, re, xe), X = ke(X, re), Ce = 1, L = !1, X = ve(X, re, xe), L = ye, X = ke(X, re));
        }
      } else Ce = 0, X = ve(X, re, xe);
      else Ce = o ? 1 : 0, X = ve(X, re, xe);
      return X;
    }, this.__bidiEngine__.setOptions = function(X) {
      X && (g = X.isInputVisual, k = X.isOutputVisual, o = X.isInputRtl, D = X.isOutputRtl, L = X.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(m), this.__bidiEngine__;
  };
  var l = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], a = new s.__bidiEngine__({ isInputVisual: !0 });
  s.API.events.push(["postProcessText", function(m) {
    var y = m.text, _ = (m.x, m.y, m.options || {}), g = (m.mutex, _.lang, []);
    if (_.isInputVisual = typeof _.isInputVisual != "boolean" || _.isInputVisual, a.setOptions(_), Object.prototype.toString.call(y) === "[object Array]") {
      var o = 0;
      for (g = [], o = 0; o < y.length; o += 1) Object.prototype.toString.call(y[o]) === "[object Array]" ? g.push([a.doBidiReorder(y[o][0]), y[o][1], y[o][2]]) : g.push([a.doBidiReorder(y[o])]);
      m.text = g;
    } else m.text = a.doBidiReorder(y);
    a.setOptions({ isInputVisual: !0 });
  }]);
}(wi), wi.API.TTFFont = function() {
  function s(l) {
    var a;
    if (this.rawData = l, a = this.contents = new su(l), this.contents.pos = 4, a.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    a.pos = 0, this.parse(), this.subset = new Ex(this), this.registerTTF();
  }
  return s.open = function(l) {
    return new s(l);
  }, s.prototype.parse = function() {
    return this.directory = new hx(this.contents), this.head = new px(this), this.name = new yx(this), this.cmap = new g1(this), this.toUnicode = {}, this.hhea = new fx(this), this.maxp = new vx(this), this.hmtx = new bx(this), this.post = new gx(this), this.os2 = new mx(this), this.loca = new Sx(this), this.glyf = new xx(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, s.prototype.registerTTF = function() {
    var l, a, m, y, _;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var g, o, k, D;
      for (D = [], g = 0, o = (k = this.bbox).length; g < o; g++) l = k[g], D.push(Math.round(l * this.scaleFactor));
      return D;
    }).call(this), this.stemV = 0, this.post.exists ? (m = 255 & (y = this.post.italic_angle), 32768 & (a = y >> 16) && (a = -(1 + (65535 ^ a))), this.italicAngle = +(a + "." + m)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (_ = this.familyClass) === 1 || _ === 2 || _ === 3 || _ === 4 || _ === 5 || _ === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, s.prototype.characterToGlyph = function(l) {
    var a;
    return ((a = this.cmap.unicode) != null ? a.codeMap[l] : void 0) || 0;
  }, s.prototype.widthOfGlyph = function(l) {
    var a;
    return a = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(l).advance * a;
  }, s.prototype.widthOfString = function(l, a, m) {
    var y, _, g, o;
    for (g = 0, _ = 0, o = (l = "" + l).length; 0 <= o ? _ < o : _ > o; _ = 0 <= o ? ++_ : --_) y = l.charCodeAt(_), g += this.widthOfGlyph(this.characterToGlyph(y)) + m * (1e3 / a) || 0;
    return g * (a / 1e3);
  }, s.prototype.lineHeight = function(l, a) {
    var m;
    return a == null && (a = !1), m = a ? this.lineGap : 0, (this.ascender + m - this.decender) / 1e3 * l;
  }, s;
}();
var ro, su = function() {
  function s(l) {
    this.data = l ?? [], this.pos = 0, this.length = this.data.length;
  }
  return s.prototype.readByte = function() {
    return this.data[this.pos++];
  }, s.prototype.writeByte = function(l) {
    return this.data[this.pos++] = l;
  }, s.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, s.prototype.writeUInt32 = function(l) {
    return this.writeByte(l >>> 24 & 255), this.writeByte(l >> 16 & 255), this.writeByte(l >> 8 & 255), this.writeByte(255 & l);
  }, s.prototype.readInt32 = function() {
    var l;
    return (l = this.readUInt32()) >= 2147483648 ? l - 4294967296 : l;
  }, s.prototype.writeInt32 = function(l) {
    return l < 0 && (l += 4294967296), this.writeUInt32(l);
  }, s.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, s.prototype.writeUInt16 = function(l) {
    return this.writeByte(l >> 8 & 255), this.writeByte(255 & l);
  }, s.prototype.readInt16 = function() {
    var l;
    return (l = this.readUInt16()) >= 32768 ? l - 65536 : l;
  }, s.prototype.writeInt16 = function(l) {
    return l < 0 && (l += 65536), this.writeUInt16(l);
  }, s.prototype.readString = function(l) {
    var a, m;
    for (m = [], a = 0; 0 <= l ? a < l : a > l; a = 0 <= l ? ++a : --a) m[a] = String.fromCharCode(this.readByte());
    return m.join("");
  }, s.prototype.writeString = function(l) {
    var a, m, y;
    for (y = [], a = 0, m = l.length; 0 <= m ? a < m : a > m; a = 0 <= m ? ++a : --a) y.push(this.writeByte(l.charCodeAt(a)));
    return y;
  }, s.prototype.readShort = function() {
    return this.readInt16();
  }, s.prototype.writeShort = function(l) {
    return this.writeInt16(l);
  }, s.prototype.readLongLong = function() {
    var l, a, m, y, _, g, o, k;
    return l = this.readByte(), a = this.readByte(), m = this.readByte(), y = this.readByte(), _ = this.readByte(), g = this.readByte(), o = this.readByte(), k = this.readByte(), 128 & l ? -1 * (72057594037927940 * (255 ^ l) + 281474976710656 * (255 ^ a) + 1099511627776 * (255 ^ m) + 4294967296 * (255 ^ y) + 16777216 * (255 ^ _) + 65536 * (255 ^ g) + 256 * (255 ^ o) + (255 ^ k) + 1) : 72057594037927940 * l + 281474976710656 * a + 1099511627776 * m + 4294967296 * y + 16777216 * _ + 65536 * g + 256 * o + k;
  }, s.prototype.writeLongLong = function(l) {
    var a, m;
    return a = Math.floor(l / 4294967296), m = 4294967295 & l, this.writeByte(a >> 24 & 255), this.writeByte(a >> 16 & 255), this.writeByte(a >> 8 & 255), this.writeByte(255 & a), this.writeByte(m >> 24 & 255), this.writeByte(m >> 16 & 255), this.writeByte(m >> 8 & 255), this.writeByte(255 & m);
  }, s.prototype.readInt = function() {
    return this.readInt32();
  }, s.prototype.writeInt = function(l) {
    return this.writeInt32(l);
  }, s.prototype.read = function(l) {
    var a, m;
    for (a = [], m = 0; 0 <= l ? m < l : m > l; m = 0 <= l ? ++m : --m) a.push(this.readByte());
    return a;
  }, s.prototype.write = function(l) {
    var a, m, y, _;
    for (_ = [], m = 0, y = l.length; m < y; m++) a = l[m], _.push(this.writeByte(a));
    return _;
  }, s;
}(), hx = function() {
  var s;
  function l(a) {
    var m, y, _;
    for (this.scalarType = a.readInt(), this.tableCount = a.readShort(), this.searchRange = a.readShort(), this.entrySelector = a.readShort(), this.rangeShift = a.readShort(), this.tables = {}, y = 0, _ = this.tableCount; 0 <= _ ? y < _ : y > _; y = 0 <= _ ? ++y : --y) m = { tag: a.readString(4), checksum: a.readInt(), offset: a.readInt(), length: a.readInt() }, this.tables[m.tag] = m;
  }
  return l.prototype.encode = function(a) {
    var m, y, _, g, o, k, D, L, j, O, z, pe, oe;
    for (oe in z = Object.keys(a).length, k = Math.log(2), j = 16 * Math.floor(Math.log(z) / k), g = Math.floor(j / k), L = 16 * z - j, (y = new su()).writeInt(this.scalarType), y.writeShort(z), y.writeShort(j), y.writeShort(g), y.writeShort(L), _ = 16 * z, D = y.pos + _, o = null, pe = [], a) for (O = a[oe], y.writeString(oe), y.writeInt(s(O)), y.writeInt(D), y.writeInt(O.length), pe = pe.concat(O), oe === "head" && (o = D), D += O.length; D % 4; ) pe.push(0), D++;
    return y.write(pe), m = 2981146554 - s(y.data), y.pos = o + 8, y.writeUInt32(m), y.data;
  }, s = function(a) {
    var m, y, _, g;
    for (a = _1.call(a); a.length % 4; ) a.push(0);
    for (_ = new su(a), y = 0, m = 0, g = a.length; m < g; m = m += 4) y += _.readUInt32();
    return 4294967295 & y;
  }, l;
}(), dx = {}.hasOwnProperty, Xo = function(s, l) {
  for (var a in l) dx.call(l, a) && (s[a] = l[a]);
  function m() {
    this.constructor = s;
  }
  return m.prototype = l.prototype, s.prototype = new m(), s.__super__ = l.prototype, s;
};
ro = function() {
  function s(l) {
    var a;
    this.file = l, a = this.file.directory.tables[this.tag], this.exists = !!a, a && (this.offset = a.offset, this.length = a.length, this.parse(this.file.contents));
  }
  return s.prototype.parse = function() {
  }, s.prototype.encode = function() {
  }, s.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, s;
}();
var px = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "head", l.prototype.parse = function(a) {
    return a.pos = this.offset, this.version = a.readInt(), this.revision = a.readInt(), this.checkSumAdjustment = a.readInt(), this.magicNumber = a.readInt(), this.flags = a.readShort(), this.unitsPerEm = a.readShort(), this.created = a.readLongLong(), this.modified = a.readLongLong(), this.xMin = a.readShort(), this.yMin = a.readShort(), this.xMax = a.readShort(), this.yMax = a.readShort(), this.macStyle = a.readShort(), this.lowestRecPPEM = a.readShort(), this.fontDirectionHint = a.readShort(), this.indexToLocFormat = a.readShort(), this.glyphDataFormat = a.readShort();
  }, l.prototype.encode = function(a) {
    var m;
    return (m = new su()).writeInt(this.version), m.writeInt(this.revision), m.writeInt(this.checkSumAdjustment), m.writeInt(this.magicNumber), m.writeShort(this.flags), m.writeShort(this.unitsPerEm), m.writeLongLong(this.created), m.writeLongLong(this.modified), m.writeShort(this.xMin), m.writeShort(this.yMin), m.writeShort(this.xMax), m.writeShort(this.yMax), m.writeShort(this.macStyle), m.writeShort(this.lowestRecPPEM), m.writeShort(this.fontDirectionHint), m.writeShort(a), m.writeShort(this.glyphDataFormat), m.data;
  }, l;
}(), n0 = function() {
  function s(l, a) {
    var m, y, _, g, o, k, D, L, j, O, z, pe, oe, ae, Q, fe, Ce;
    switch (this.platformID = l.readUInt16(), this.encodingID = l.readShort(), this.offset = a + l.readInt(), j = l.pos, l.pos = this.offset, this.format = l.readUInt16(), this.length = l.readUInt16(), this.language = l.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (k = 0; k < 256; ++k) this.codeMap[k] = l.readByte();
        break;
      case 4:
        for (z = l.readUInt16(), O = z / 2, l.pos += 6, _ = function() {
          var ze, je;
          for (je = [], k = ze = 0; 0 <= O ? ze < O : ze > O; k = 0 <= O ? ++ze : --ze) je.push(l.readUInt16());
          return je;
        }(), l.pos += 2, oe = function() {
          var ze, je;
          for (je = [], k = ze = 0; 0 <= O ? ze < O : ze > O; k = 0 <= O ? ++ze : --ze) je.push(l.readUInt16());
          return je;
        }(), D = function() {
          var ze, je;
          for (je = [], k = ze = 0; 0 <= O ? ze < O : ze > O; k = 0 <= O ? ++ze : --ze) je.push(l.readUInt16());
          return je;
        }(), L = function() {
          var ze, je;
          for (je = [], k = ze = 0; 0 <= O ? ze < O : ze > O; k = 0 <= O ? ++ze : --ze) je.push(l.readUInt16());
          return je;
        }(), y = (this.length - l.pos + this.offset) / 2, o = function() {
          var ze, je;
          for (je = [], k = ze = 0; 0 <= y ? ze < y : ze > y; k = 0 <= y ? ++ze : --ze) je.push(l.readUInt16());
          return je;
        }(), k = Q = 0, Ce = _.length; Q < Ce; k = ++Q) for (ae = _[k], m = fe = pe = oe[k]; pe <= ae ? fe <= ae : fe >= ae; m = pe <= ae ? ++fe : --fe) L[k] === 0 ? g = m + D[k] : (g = o[L[k] / 2 + (m - pe) - (O - k)] || 0) !== 0 && (g += D[k]), this.codeMap[m] = 65535 & g;
    }
    l.pos = j;
  }
  return s.encode = function(l, a) {
    var m, y, _, g, o, k, D, L, j, O, z, pe, oe, ae, Q, fe, Ce, ze, je, Qe, ke, Ae, me, ve, X, re, xe, ye, Ve, He, Ze, qe, Je, et, st, ee, _e, be, Te, Oe, $e, Ue, Ke, nt, ot, vt;
    switch (ye = new su(), g = Object.keys(l).sort(function(mt, Pt) {
      return mt - Pt;
    }), a) {
      case "macroman":
        for (oe = 0, ae = function() {
          var mt = [];
          for (pe = 0; pe < 256; ++pe) mt.push(0);
          return mt;
        }(), fe = { 0: 0 }, _ = {}, Ve = 0, Je = g.length; Ve < Je; Ve++) fe[Ke = l[y = g[Ve]]] == null && (fe[Ke] = ++oe), _[y] = { old: l[y], new: fe[l[y]] }, ae[y] = fe[l[y]];
        return ye.writeUInt16(1), ye.writeUInt16(0), ye.writeUInt32(12), ye.writeUInt16(0), ye.writeUInt16(262), ye.writeUInt16(0), ye.write(ae), { charMap: _, subtable: ye.data, maxGlyphID: oe + 1 };
      case "unicode":
        for (re = [], j = [], Ce = 0, fe = {}, m = {}, Q = D = null, He = 0, et = g.length; He < et; He++) fe[je = l[y = g[He]]] == null && (fe[je] = ++Ce), m[y] = { old: je, new: fe[je] }, o = fe[je] - y, Q != null && o === D || (Q && j.push(Q), re.push(y), D = o), Q = y;
        for (Q && j.push(Q), j.push(65535), re.push(65535), ve = 2 * (me = re.length), Ae = 2 * Math.pow(Math.log(me) / Math.LN2, 2), O = Math.log(Ae / 2) / Math.LN2, ke = 2 * me - Ae, k = [], Qe = [], z = [], pe = Ze = 0, st = re.length; Ze < st; pe = ++Ze) {
          if (X = re[pe], L = j[pe], X === 65535) {
            k.push(0), Qe.push(0);
            break;
          }
          if (X - (xe = m[X].new) >= 32768) for (k.push(0), Qe.push(2 * (z.length + me - pe)), y = qe = X; X <= L ? qe <= L : qe >= L; y = X <= L ? ++qe : --qe) z.push(m[y].new);
          else k.push(xe - X), Qe.push(0);
        }
        for (ye.writeUInt16(3), ye.writeUInt16(1), ye.writeUInt32(12), ye.writeUInt16(4), ye.writeUInt16(16 + 8 * me + 2 * z.length), ye.writeUInt16(0), ye.writeUInt16(ve), ye.writeUInt16(Ae), ye.writeUInt16(O), ye.writeUInt16(ke), $e = 0, ee = j.length; $e < ee; $e++) y = j[$e], ye.writeUInt16(y);
        for (ye.writeUInt16(0), Ue = 0, _e = re.length; Ue < _e; Ue++) y = re[Ue], ye.writeUInt16(y);
        for (nt = 0, be = k.length; nt < be; nt++) o = k[nt], ye.writeUInt16(o);
        for (ot = 0, Te = Qe.length; ot < Te; ot++) ze = Qe[ot], ye.writeUInt16(ze);
        for (vt = 0, Oe = z.length; vt < Oe; vt++) oe = z[vt], ye.writeUInt16(oe);
        return { charMap: m, subtable: ye.data, maxGlyphID: Ce + 1 };
    }
  }, s;
}(), g1 = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "cmap", l.prototype.parse = function(a) {
    var m, y, _;
    for (a.pos = this.offset, this.version = a.readUInt16(), _ = a.readUInt16(), this.tables = [], this.unicode = null, y = 0; 0 <= _ ? y < _ : y > _; y = 0 <= _ ? ++y : --y) m = new n0(a, this.offset), this.tables.push(m), m.isUnicode && this.unicode == null && (this.unicode = m);
    return !0;
  }, l.encode = function(a, m) {
    var y, _;
    return m == null && (m = "macroman"), y = n0.encode(a, m), (_ = new su()).writeUInt16(0), _.writeUInt16(1), y.table = _.data.concat(y.subtable), y;
  }, l;
}(), fx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "hhea", l.prototype.parse = function(a) {
    return a.pos = this.offset, this.version = a.readInt(), this.ascender = a.readShort(), this.decender = a.readShort(), this.lineGap = a.readShort(), this.advanceWidthMax = a.readShort(), this.minLeftSideBearing = a.readShort(), this.minRightSideBearing = a.readShort(), this.xMaxExtent = a.readShort(), this.caretSlopeRise = a.readShort(), this.caretSlopeRun = a.readShort(), this.caretOffset = a.readShort(), a.pos += 8, this.metricDataFormat = a.readShort(), this.numberOfMetrics = a.readUInt16();
  }, l;
}(), mx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "OS/2", l.prototype.parse = function(a) {
    if (a.pos = this.offset, this.version = a.readUInt16(), this.averageCharWidth = a.readShort(), this.weightClass = a.readUInt16(), this.widthClass = a.readUInt16(), this.type = a.readShort(), this.ySubscriptXSize = a.readShort(), this.ySubscriptYSize = a.readShort(), this.ySubscriptXOffset = a.readShort(), this.ySubscriptYOffset = a.readShort(), this.ySuperscriptXSize = a.readShort(), this.ySuperscriptYSize = a.readShort(), this.ySuperscriptXOffset = a.readShort(), this.ySuperscriptYOffset = a.readShort(), this.yStrikeoutSize = a.readShort(), this.yStrikeoutPosition = a.readShort(), this.familyClass = a.readShort(), this.panose = function() {
      var m, y;
      for (y = [], m = 0; m < 10; ++m) y.push(a.readByte());
      return y;
    }(), this.charRange = function() {
      var m, y;
      for (y = [], m = 0; m < 4; ++m) y.push(a.readInt());
      return y;
    }(), this.vendorID = a.readString(4), this.selection = a.readShort(), this.firstCharIndex = a.readShort(), this.lastCharIndex = a.readShort(), this.version > 0 && (this.ascent = a.readShort(), this.descent = a.readShort(), this.lineGap = a.readShort(), this.winAscent = a.readShort(), this.winDescent = a.readShort(), this.codePageRange = function() {
      var m, y;
      for (y = [], m = 0; m < 2; m = ++m) y.push(a.readInt());
      return y;
    }(), this.version > 1)) return this.xHeight = a.readShort(), this.capHeight = a.readShort(), this.defaultChar = a.readShort(), this.breakChar = a.readShort(), this.maxContext = a.readShort();
  }, l;
}(), gx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "post", l.prototype.parse = function(a) {
    var m, y, _;
    switch (a.pos = this.offset, this.format = a.readInt(), this.italicAngle = a.readInt(), this.underlinePosition = a.readShort(), this.underlineThickness = a.readShort(), this.isFixedPitch = a.readInt(), this.minMemType42 = a.readInt(), this.maxMemType42 = a.readInt(), this.minMemType1 = a.readInt(), this.maxMemType1 = a.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var g;
        for (y = a.readUInt16(), this.glyphNameIndex = [], g = 0; 0 <= y ? g < y : g > y; g = 0 <= y ? ++g : --g) this.glyphNameIndex.push(a.readUInt16());
        for (this.names = [], _ = []; a.pos < this.offset + this.length; ) m = a.readByte(), _.push(this.names.push(a.readString(m)));
        return _;
      case 151552:
        return y = a.readUInt16(), this.offsets = a.read(y);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var o, k, D;
          for (D = [], g = o = 0, k = this.file.maxp.numGlyphs; 0 <= k ? o < k : o > k; g = 0 <= k ? ++o : --o) D.push(a.readUInt32());
          return D;
        }).call(this);
    }
  }, l;
}(), _x = function(s, l) {
  this.raw = s, this.length = s.length, this.platformID = l.platformID, this.encodingID = l.encodingID, this.languageID = l.languageID;
}, yx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "name", l.prototype.parse = function(a) {
    var m, y, _, g, o, k, D, L, j, O, z;
    for (a.pos = this.offset, a.readShort(), m = a.readShort(), k = a.readShort(), y = [], g = 0; 0 <= m ? g < m : g > m; g = 0 <= m ? ++g : --g) y.push({ platformID: a.readShort(), encodingID: a.readShort(), languageID: a.readShort(), nameID: a.readShort(), length: a.readShort(), offset: this.offset + k + a.readShort() });
    for (D = {}, g = j = 0, O = y.length; j < O; g = ++j) _ = y[g], a.pos = _.offset, L = a.readString(_.length), o = new _x(L, _), D[z = _.nameID] == null && (D[z] = []), D[_.nameID].push(o);
    this.strings = D, this.copyright = D[0], this.fontFamily = D[1], this.fontSubfamily = D[2], this.uniqueSubfamily = D[3], this.fontName = D[4], this.version = D[5];
    try {
      this.postscriptName = D[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = D[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = D[7], this.manufacturer = D[8], this.designer = D[9], this.description = D[10], this.vendorUrl = D[11], this.designerUrl = D[12], this.license = D[13], this.licenseUrl = D[14], this.preferredFamily = D[15], this.preferredSubfamily = D[17], this.compatibleFull = D[18], this.sampleText = D[19];
  }, l;
}(), vx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "maxp", l.prototype.parse = function(a) {
    return a.pos = this.offset, this.version = a.readInt(), this.numGlyphs = a.readUInt16(), this.maxPoints = a.readUInt16(), this.maxContours = a.readUInt16(), this.maxCompositePoints = a.readUInt16(), this.maxComponentContours = a.readUInt16(), this.maxZones = a.readUInt16(), this.maxTwilightPoints = a.readUInt16(), this.maxStorage = a.readUInt16(), this.maxFunctionDefs = a.readUInt16(), this.maxInstructionDefs = a.readUInt16(), this.maxStackElements = a.readUInt16(), this.maxSizeOfInstructions = a.readUInt16(), this.maxComponentElements = a.readUInt16(), this.maxComponentDepth = a.readUInt16();
  }, l;
}(), bx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "hmtx", l.prototype.parse = function(a) {
    var m, y, _, g, o, k, D;
    for (a.pos = this.offset, this.metrics = [], m = 0, k = this.file.hhea.numberOfMetrics; 0 <= k ? m < k : m > k; m = 0 <= k ? ++m : --m) this.metrics.push({ advance: a.readUInt16(), lsb: a.readInt16() });
    for (_ = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var L, j;
      for (j = [], m = L = 0; 0 <= _ ? L < _ : L > _; m = 0 <= _ ? ++L : --L) j.push(a.readInt16());
      return j;
    }(), this.widths = (function() {
      var L, j, O, z;
      for (z = [], L = 0, j = (O = this.metrics).length; L < j; L++) g = O[L], z.push(g.advance);
      return z;
    }).call(this), y = this.widths[this.widths.length - 1], D = [], m = o = 0; 0 <= _ ? o < _ : o > _; m = 0 <= _ ? ++o : --o) D.push(this.widths.push(y));
    return D;
  }, l.prototype.forGlyph = function(a) {
    return a in this.metrics ? this.metrics[a] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[a - this.metrics.length] };
  }, l;
}(), _1 = [].slice, xx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "glyf", l.prototype.parse = function() {
    return this.cache = {};
  }, l.prototype.glyphFor = function(a) {
    var m, y, _, g, o, k, D, L, j, O;
    return a in this.cache ? this.cache[a] : (g = this.file.loca, m = this.file.contents, y = g.indexOf(a), (_ = g.lengthOf(a)) === 0 ? this.cache[a] = null : (m.pos = this.offset + y, o = (k = new su(m.read(_))).readShort(), L = k.readShort(), O = k.readShort(), D = k.readShort(), j = k.readShort(), this.cache[a] = o === -1 ? new Ax(k, L, O, D, j) : new wx(k, o, L, O, D, j), this.cache[a]));
  }, l.prototype.encode = function(a, m, y) {
    var _, g, o, k, D;
    for (o = [], g = [], k = 0, D = m.length; k < D; k++) _ = a[m[k]], g.push(o.length), _ && (o = o.concat(_.encode(y)));
    return g.push(o.length), { table: o, offsets: g };
  }, l;
}(), wx = function() {
  function s(l, a, m, y, _, g) {
    this.raw = l, this.numberOfContours = a, this.xMin = m, this.yMin = y, this.xMax = _, this.yMax = g, this.compound = !1;
  }
  return s.prototype.encode = function() {
    return this.raw.data;
  }, s;
}(), Ax = function() {
  function s(l, a, m, y, _) {
    var g, o;
    for (this.raw = l, this.xMin = a, this.yMin = m, this.xMax = y, this.yMax = _, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], g = this.raw; o = g.readShort(), this.glyphOffsets.push(g.pos), this.glyphIDs.push(g.readUInt16()), 32 & o; ) g.pos += 1 & o ? 4 : 2, 128 & o ? g.pos += 8 : 64 & o ? g.pos += 4 : 8 & o && (g.pos += 2);
  }
  return s.prototype.encode = function() {
    var l, a, m;
    for (a = new su(_1.call(this.raw.data)), l = 0, m = this.glyphIDs.length; l < m; ++l) a.pos = this.glyphOffsets[l];
    return a.data;
  }, s;
}(), Sx = function(s) {
  function l() {
    return l.__super__.constructor.apply(this, arguments);
  }
  return Xo(l, ro), l.prototype.tag = "loca", l.prototype.parse = function(a) {
    var m, y;
    return a.pos = this.offset, m = this.file.head.indexToLocFormat, this.offsets = m === 0 ? (function() {
      var _, g;
      for (g = [], y = 0, _ = this.length; y < _; y += 2) g.push(2 * a.readUInt16());
      return g;
    }).call(this) : (function() {
      var _, g;
      for (g = [], y = 0, _ = this.length; y < _; y += 4) g.push(a.readUInt32());
      return g;
    }).call(this);
  }, l.prototype.indexOf = function(a) {
    return this.offsets[a];
  }, l.prototype.lengthOf = function(a) {
    return this.offsets[a + 1] - this.offsets[a];
  }, l.prototype.encode = function(a, m) {
    for (var y = new Uint32Array(this.offsets.length), _ = 0, g = 0, o = 0; o < y.length; ++o) if (y[o] = _, g < m.length && m[g] == o) {
      ++g, y[o] = _;
      var k = this.offsets[o], D = this.offsets[o + 1] - k;
      D > 0 && (_ += D);
    }
    for (var L = new Array(4 * y.length), j = 0; j < y.length; ++j) L[4 * j + 3] = 255 & y[j], L[4 * j + 2] = (65280 & y[j]) >> 8, L[4 * j + 1] = (16711680 & y[j]) >> 16, L[4 * j] = (4278190080 & y[j]) >> 24;
    return L;
  }, l;
}(), Ex = function() {
  function s(l) {
    this.font = l, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return s.prototype.generateCmap = function() {
    var l, a, m, y, _;
    for (a in y = this.font.cmap.tables[0].codeMap, l = {}, _ = this.subset) m = _[a], l[a] = y[m];
    return l;
  }, s.prototype.glyphsFor = function(l) {
    var a, m, y, _, g, o, k;
    for (y = {}, g = 0, o = l.length; g < o; g++) y[_ = l[g]] = this.font.glyf.glyphFor(_);
    for (_ in a = [], y) (m = y[_]) != null && m.compound && a.push.apply(a, m.glyphIDs);
    if (a.length > 0) for (_ in k = this.glyphsFor(a)) m = k[_], y[_] = m;
    return y;
  }, s.prototype.encode = function(l, a) {
    var m, y, _, g, o, k, D, L, j, O, z, pe, oe, ae, Q;
    for (y in m = g1.encode(this.generateCmap(), "unicode"), g = this.glyphsFor(l), z = { 0: 0 }, Q = m.charMap) z[(k = Q[y]).old] = k.new;
    for (pe in O = m.maxGlyphID, g) pe in z || (z[pe] = O++);
    return L = function(fe) {
      var Ce, ze;
      for (Ce in ze = {}, fe) ze[fe[Ce]] = Ce;
      return ze;
    }(z), j = Object.keys(L).sort(function(fe, Ce) {
      return fe - Ce;
    }), oe = function() {
      var fe, Ce, ze;
      for (ze = [], fe = 0, Ce = j.length; fe < Ce; fe++) o = j[fe], ze.push(L[o]);
      return ze;
    }(), _ = this.font.glyf.encode(g, oe, z), D = this.font.loca.encode(_.offsets, oe), ae = { cmap: this.font.cmap.raw(), glyf: _.table, loca: D, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(a) }, this.font.os2.exists && (ae["OS/2"] = this.font.os2.raw()), this.font.directory.encode(ae);
  }, s;
}();
wi.API.PDFObject = function() {
  var s;
  function l() {
  }
  return s = function(a, m) {
    return (Array(m + 1).join("0") + a).slice(-m);
  }, l.convert = function(a) {
    var m, y, _, g;
    if (Array.isArray(a)) return "[" + function() {
      var o, k, D;
      for (D = [], o = 0, k = a.length; o < k; o++) m = a[o], D.push(l.convert(m));
      return D;
    }().join(" ") + "]";
    if (typeof a == "string") return "/" + a;
    if (a != null && a.isString) return "(" + a + ")";
    if (a instanceof Date) return "(D:" + s(a.getUTCFullYear(), 4) + s(a.getUTCMonth(), 2) + s(a.getUTCDate(), 2) + s(a.getUTCHours(), 2) + s(a.getUTCMinutes(), 2) + s(a.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(a) === "[object Object]") {
      for (y in _ = ["<<"], a) g = a[y], _.push("/" + y + " " + l.convert(g));
      return _.push(">>"), _.join(`
`);
    }
    return "" + a;
  }, l;
}();
const yf = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, md = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, gd = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class Cx {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(l, a = Nu.A4, m = 300, y = Dl.PNG, _ = Ec.mm, g = "map", o = "maplibregl-marker", k = yf, D = "maplibregl-ctrl-attrib-inner", L = md, j = gd) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "dpi"), Xi(this, "format"), Xi(this, "unit"), Xi(this, "fileName"), Xi(this, "markerClassName"), Xi(this, "markerCirclePaint"), Xi(this, "attributionClassName"), Xi(this, "attributionOptions"), Xi(this, "northIconOptions"), this.map = l, this.width = a[0], this.height = a[1], this.dpi = m, this.format = y, this.unit = _, this.fileName = g, this.markerClassName = o, this.markerCirclePaint = k, this.attributionClassName = D, this.attributionOptions = L, this.northIconOptions = j;
  }
  renderMapPost(l) {
    return l;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(l) {
    const a = this.getMarkers();
    for (let m = 0; m < a.length; m++) {
      const y = a.item(m);
      if (!y) continue;
      const _ = y.getAttribute("style");
      if (!_) continue;
      const g = /translate\(([^,]+)px,\s*([^,]+)px\)/, o = _.match(g);
      if (!o) continue;
      const k = parseInt(o[1]), D = parseInt(o[2]), L = this.map.unproject([k, D]), j = `point${m}`;
      l.addSource(j, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [L.lng, L.lat]
        }
      }), l.addLayer({
        id: j,
        source: j,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return l;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const l = this;
    JsLoadingOverlay.show({
      overlayBackgroundColor: "#5D5959",
      overlayOpacity: "0.6",
      spinnerIcon: "ball-spin",
      spinnerColor: "#2400FD",
      spinnerSize: "2x",
      overlayIDName: "overlay",
      spinnerIDName: "spinner",
      offsetX: 0,
      offsetY: 0,
      containerID: null,
      lockScroll: !1,
      overlayZIndex: 9998,
      spinnerZIndex: 9999
    });
    const a = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return l.dpi / 96;
      }
    });
    const m = document.createElement("div");
    m.className = "hidden-map", document.body.appendChild(m);
    const y = document.createElement("div");
    y.style.width = this.toPixels(this.width), y.style.height = this.toPixels(this.height), m.appendChild(y);
    const _ = this.map.getStyle();
    if (_ && _.sources) {
      const o = _.sources;
      Object.keys(o).forEach((k) => {
        const D = o[k];
        Object.keys(D).forEach((L) => {
          D[L] || delete D[L];
        });
      });
    }
    let g = this.getRenderedMap(y, _);
    g.on("load", () => {
      this.addNorthIconToMap(g).then(() => {
        g.once("idle", () => {
          this.addAttributions(g) ? g.once("idle", () => {
            g = this.renderMapPost(g), this.getMarkers().length === 0 ? this.exportImage(g, m, a) : (g = this.renderMarkers(g), g.once("idle", () => {
              this.exportImage(g, m, a);
            }));
          }) : (g = this.renderMapPost(g), this.getMarkers().length === 0 ? this.exportImage(g, m, a) : (g = this.renderMarkers(g), g.once("idle", () => {
            this.exportImage(g, m, a);
          })));
        });
      });
    });
  }
  stripHtml(l) {
    const a = document.createElement("div");
    return a.innerHTML = l, a.textContent || a.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(l, a) {
    const m = l.getContainer(), y = parseInt(m.style.width.replace("px", ""));
    return parseInt(`${y * a}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(l, a, m = 0) {
    const y = l.getContainer();
    let _ = 0, g = 0;
    switch (a) {
      case "top-left":
        _ = 0 + m, g = 0 + m;
        break;
      case "top-right":
        _ = parseInt(y.style.width.replace("px", "")) - m, g = 0 + m;
        break;
      case "bottom-left":
        _ = 0 + m, g = parseInt(y.style.height.replace("px", "")) - m;
        break;
      case "bottom-right":
        _ = parseInt(y.style.width.replace("px", "")) - m, g = parseInt(y.style.height.replace("px", "")) - m;
        break;
    }
    return [_, g];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(l) {
    const a = this.getIconWidth(l, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((m) => {
      const y = new Image(a, a);
      y.onload = () => {
        this.northIconOptions.imageName && l.addImage(this.northIconOptions.imageName, y), m();
      };
      function _(g) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(g);
      }
      this.northIconOptions.image && (y.src = _(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(l) {
    let a = this.northIconOptions.visibility ?? "visible";
    return l.getZoom() < 2 && this.width > this.height && (a = "none"), new Promise((m) => {
      this.addNorthIconImage(l).then(() => {
        const y = this.getIconWidth(
          l,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, _ = this.getElementPosition(
          l,
          this.northIconOptions.position ?? "top-right",
          y
        ), g = l.unproject(_), o = this.northIconOptions.imageName ?? "gl-export-north-icon";
        l.addSource(o, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [g.lng, g.lat]
            },
            properties: {}
          }
        }), l.addLayer({
          id: o,
          source: o,
          type: "symbol",
          layout: {
            "icon-image": o,
            "icon-size": 1,
            "icon-rotate": l.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: a
          },
          paint: {}
        }), m();
      });
    });
  }
  addAttributions(l) {
    var a;
    if (!this.map.getStyle().glyphs) return !1;
    const m = l.getContainer(), y = this.attributionOptions.position ?? "bottom-right", _ = this.getElementPosition(l, y, 5), g = _[0], o = l.unproject(_), k = m.getElementsByClassName(this.attributionClassName), D = [];
    if ((k == null ? void 0 : k.length) > 0) {
      const ae = k.item(0);
      if (ae)
        for (let Q = 0; Q < ae.children.length; Q++) {
          const fe = ae.children.item(Q);
          fe && D.push(this.stripHtml(fe.outerHTML));
        }
    } else {
      const ae = this.map.getStyle().sources;
      Object.keys(ae).forEach((Q) => {
        const fe = ae[Q];
        if ("attribution" in fe) {
          const Ce = fe.attribution;
          D.push(this.stripHtml(Ce));
        }
      });
    }
    if (D.length === 0) return !1;
    const L = D.join(" | "), j = "attribution";
    l.addSource(j, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [o.lng, o.lat]
        },
        properties: {
          attribution: L
        }
      }
    });
    const O = this.map.getStyle().layers.filter(
      (ae) => ae.type === "symbol" && ae.layout && "text-font" in ae.layout
    ), z = O.length > 0 && O[0].layout ? O[0].layout["text-font"] : (a = this.attributionOptions.style) == null ? void 0 : a.fallbackTextFont;
    let pe = this.attributionOptions.visibility ?? "visible";
    l.getZoom() < 2 && this.width > this.height && (pe = "none");
    const oe = this.attributionOptions.style;
    return l.addLayer({
      id: j,
      source: j,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": z,
        "text-max-width": parseInt(`${g / oe.textSize}`),
        "text-anchor": y,
        "text-justify": ["top-right", "bottom-right"].includes(y) ? "right" : "left",
        "text-size": oe.textSize,
        "text-allow-overlap": !0,
        visibility: pe
      },
      paint: {
        "text-halo-color": oe.textHaloColor,
        "text-halo-width": oe.textHaloWidth,
        "text-color": oe.textColor
      }
    }), !0;
  }
  exportImage(l, a, m) {
    var y;
    const _ = l.getCanvas(), g = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Dl.PNG:
        this.toPNG(_, g);
        break;
      case Dl.JPEG:
        this.toJPEG(_, g);
        break;
      case Dl.PDF:
        this.toPDF(l, g);
        break;
      case Dl.SVG:
        this.toSVG(_, g);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    l.remove(), (y = a.parentNode) == null || y.removeChild(a), Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return m;
      }
    }), a.remove(), JsLoadingOverlay.hide();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(l, a) {
    const m = document.createElement("a");
    m.href = l.toDataURL(), m.download = a, m.click(), m.remove();
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toJPEG(l, a) {
    const m = l.toDataURL("image/jpeg", 0.85), y = document.createElement("a");
    y.href = m, y.download = a, y.click(), y.remove();
  }
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(l, a) {
    const m = l.getCanvas(), y = new wi({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    y.addImage(
      m.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: _, lat: g } = l.getCenter();
    y.setProperties({
      title: l.getStyle().name,
      subject: `center: [${_}, ${g}], zoom: ${l.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), y.save(a);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toSVG(l, a) {
    const m = l.toDataURL("image/png"), y = Number(this.toPixels(this.width, this.dpi).replace("px", "")), _ = Number(this.toPixels(this.height, this.dpi).replace("px", "")), g = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${y}" 
      height="${_}" 
      viewBox="0 0 ${y} ${_}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${m}" width="${y}" height="${_}"></image>
    </svg>`, o = document.createElement("a");
    o.href = `data:application/xml,${encodeURIComponent(g)}`, o.download = a, o.click(), o.remove();
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(l, a = 96) {
    return this.unit === Ec.mm && (a /= 25.4), `${a * l}px`;
  }
}
class Tx extends Cx {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(l, a = Nu.A4, m = 300, y = Dl.PNG, _ = Ec.mm, g = "map", o = yf, k = md, D = gd) {
    super(
      l,
      a,
      m,
      y,
      _,
      g,
      "maplibregl-marker",
      o,
      "maplibregl-ctrl-attrib-inner",
      k,
      D
    );
  }
  getRenderedMap(l, a) {
    const m = new Ru.Map({
      container: l,
      style: a,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (m.setMaxPitch(85), m.setPitch(this.map.getPitch()));
    const y = (this.map.style.imageManager || {}).images || [];
    return Object.keys(y).forEach((_) => {
      y[_].data && m.addImage(_, y[_].data);
    }), m;
  }
  renderMapPost(l) {
    const a = this.map.getTerrain();
    return a && l.setTerrain({
      source: a.source,
      exaggeration: a.exaggeration
    }), l;
  }
}
class kx {
  constructor(l) {
    Xi(this, "controlContainer"), Xi(this, "exportContainer"), Xi(this, "crosshair"), Xi(this, "printableArea"), Xi(this, "map"), Xi(this, "exportButton"), Xi(this, "options", {
      PageSize: Nu.A4,
      PageOrientation: lh.Landscape,
      Format: Dl.PDF,
      DPI: Wp[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(Nu),
      Filename: "map",
      markerCirclePaint: yf,
      attributionOptions: md,
      northIconOptions: gd
    }), Xi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), l && (l.attributionOptions = Object.assign(
      md,
      l.attributionOptions
    ), l.northIconOptions = Object.assign(gd, l.northIconOptions), this.options = Object.assign(this.options, l)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const l = this.options.Local ?? "en";
    return Db(l);
  }
  onAdd(l) {
    var a;
    this.map = l, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const m = document.createElement("TABLE");
    m.className = "print-table";
    const y = {};
    (a = this.options.AllowedSizes) == null || a.forEach((L) => {
      Nu[L] && (y[L] = Nu[L]);
    });
    const _ = this.createSelection(
      y,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      (L, j) => JSON.stringify(L[j])
    );
    m.appendChild(_);
    const g = this.createSelection(
      lh,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      (L, j) => L[j]
    );
    m.appendChild(g);
    const o = this.createSelection(
      Dl,
      this.getTranslation().Format,
      "format-type",
      this.options.Format,
      (L, j) => L[j]
    );
    m.appendChild(o);
    const k = this.createSelection(
      Wp,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      (L, j) => L[j]
    );
    m.appendChild(k), this.exportContainer.appendChild(m);
    const D = document.createElement("button");
    return D.type = "button", D.textContent = this.getTranslation().Generate, D.classList.add("generate-button"), D.addEventListener("click", () => {
      const L = document.getElementById("mapbox-gl-export-page-size"), j = document.getElementById("mapbox-gl-export-page-orientation"), O = document.getElementById("mapbox-gl-export-format-type"), z = document.getElementById("mapbox-gl-export-dpi-type"), pe = j.value;
      let oe = JSON.parse(L.value);
      pe === lh.Portrait && (oe = oe.reverse()), this.generateMap(
        l,
        oe,
        Number(z.value),
        O.value,
        Ec.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(D), this.controlContainer;
  }
  generateMap(l, a, m, y, _, g) {
    new Tx(
      l,
      a,
      m,
      y,
      _,
      g,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(l, a, m, y, _) {
    const g = document.createElement("label");
    g.textContent = a;
    const o = document.createElement("select");
    o.setAttribute("id", `mapbox-gl-export-${m}`), o.style.width = "100%", Object.keys(l).forEach((j) => {
      const O = document.createElement("option");
      O.setAttribute("value", _(l, j)), O.appendChild(document.createTextNode(j)), O.setAttribute("name", m), y === l[j] && (O.selected = !0), o.appendChild(O);
    }), o.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const k = document.createElement("TR"), D = document.createElement("TD"), L = document.createElement("TD");
    return D.appendChild(g), L.appendChild(o), k.appendChild(D), k.appendChild(L), k;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(l) {
    this.controlContainer && !this.controlContainer.contains(l.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(l) {
    this.options.Crosshair === !0 && (l === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new fb(this.map), this.crosshair.create()));
  }
  togglePrintableArea(l) {
    this.options.PrintableArea === !0 && (l === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new mb(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const l = document.getElementById("mapbox-gl-export-page-size"), a = document.getElementById("mapbox-gl-export-page-orientation").value;
    let m = JSON.parse(l.value);
    a === lh.Portrait && (m = m.reverse()), this.printableArea.updateArea(m[0], m[1]);
  }
}
var y1 = { exports: {} }, nh = {}, Cl = {}, ku = {}, s0;
function Ad() {
  if (s0) return ku;
  s0 = 1;
  function s(_, g, o) {
    if (o === void 0 && (o = Array.prototype), _ && typeof o.find == "function")
      return o.find.call(_, g);
    for (var k = 0; k < _.length; k++)
      if (Object.prototype.hasOwnProperty.call(_, k)) {
        var D = _[k];
        if (g.call(void 0, D, k, _))
          return D;
      }
  }
  function l(_, g) {
    return g === void 0 && (g = Object), g && typeof g.freeze == "function" ? g.freeze(_) : _;
  }
  function a(_, g) {
    if (_ === null || typeof _ != "object")
      throw new TypeError("target is not an object");
    for (var o in g)
      Object.prototype.hasOwnProperty.call(g, o) && (_[o] = g[o]);
    return _;
  }
  var m = l({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(_) {
      return _ === m.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), y = l({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(_) {
      return _ === y.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return ku.assign = a, ku.find = s, ku.freeze = l, ku.MIME_TYPE = m, ku.NAMESPACE = y, ku;
}
var a0;
function v1() {
  if (a0) return Cl;
  a0 = 1;
  var s = Ad(), l = s.find, a = s.NAMESPACE;
  function m(ie) {
    return ie !== "";
  }
  function y(ie) {
    return ie ? ie.split(/[\t\n\f\r ]+/).filter(m) : [];
  }
  function _(ie, ue) {
    return ie.hasOwnProperty(ue) || (ie[ue] = !0), ie;
  }
  function g(ie) {
    if (!ie) return [];
    var ue = y(ie);
    return Object.keys(ue.reduce(_, {}));
  }
  function o(ie) {
    return function(ue) {
      return ie && ie.indexOf(ue) !== -1;
    };
  }
  function k(ie, ue) {
    for (var $ in ie)
      Object.prototype.hasOwnProperty.call(ie, $) && (ue[$] = ie[$]);
  }
  function D(ie, ue) {
    var $ = ie.prototype;
    if (!($ instanceof ue)) {
      let B = function() {
      };
      B.prototype = ue.prototype, B = new B(), k($, B), ie.prototype = $ = B;
    }
    $.constructor != ie && (typeof ie != "function" && console.error("unknown Class:" + ie), $.constructor = ie);
  }
  var L = {}, j = L.ELEMENT_NODE = 1, O = L.ATTRIBUTE_NODE = 2, z = L.TEXT_NODE = 3, pe = L.CDATA_SECTION_NODE = 4, oe = L.ENTITY_REFERENCE_NODE = 5, ae = L.ENTITY_NODE = 6, Q = L.PROCESSING_INSTRUCTION_NODE = 7, fe = L.COMMENT_NODE = 8, Ce = L.DOCUMENT_NODE = 9, ze = L.DOCUMENT_TYPE_NODE = 10, je = L.DOCUMENT_FRAGMENT_NODE = 11, Qe = L.NOTATION_NODE = 12, ke = {}, Ae = {};
  ke.INDEX_SIZE_ERR = (Ae[1] = "Index size error", 1), ke.DOMSTRING_SIZE_ERR = (Ae[2] = "DOMString size error", 2);
  var me = ke.HIERARCHY_REQUEST_ERR = (Ae[3] = "Hierarchy request error", 3);
  ke.WRONG_DOCUMENT_ERR = (Ae[4] = "Wrong document", 4), ke.INVALID_CHARACTER_ERR = (Ae[5] = "Invalid character", 5), ke.NO_DATA_ALLOWED_ERR = (Ae[6] = "No data allowed", 6), ke.NO_MODIFICATION_ALLOWED_ERR = (Ae[7] = "No modification allowed", 7);
  var ve = ke.NOT_FOUND_ERR = (Ae[8] = "Not found", 8);
  ke.NOT_SUPPORTED_ERR = (Ae[9] = "Not supported", 9);
  var X = ke.INUSE_ATTRIBUTE_ERR = (Ae[10] = "Attribute in use", 10);
  ke.INVALID_STATE_ERR = (Ae[11] = "Invalid state", 11), ke.SYNTAX_ERR = (Ae[12] = "Syntax error", 12), ke.INVALID_MODIFICATION_ERR = (Ae[13] = "Invalid modification", 13), ke.NAMESPACE_ERR = (Ae[14] = "Invalid namespace", 14), ke.INVALID_ACCESS_ERR = (Ae[15] = "Invalid access", 15);
  function re(ie, ue) {
    if (ue instanceof Error)
      var $ = ue;
    else
      $ = this, Error.call(this, Ae[ie]), this.message = Ae[ie], Error.captureStackTrace && Error.captureStackTrace(this, re);
    return $.code = ie, ue && (this.message = this.message + ": " + ue), $;
  }
  re.prototype = Error.prototype, k(ke, re);
  function xe() {
  }
  xe.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(ie) {
      return ie >= 0 && ie < this.length ? this[ie] : null;
    },
    toString: function(ie, ue) {
      for (var $ = [], B = 0; B < this.length; B++)
        Gi(this[B], $, ie, ue);
      return $.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(ie) {
      return Array.prototype.filter.call(this, ie);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(ie) {
      return Array.prototype.indexOf.call(this, ie);
    }
  };
  function ye(ie, ue) {
    this._node = ie, this._refresh = ue, Ve(this);
  }
  function Ve(ie) {
    var ue = ie._node._inc || ie._node.ownerDocument._inc;
    if (ie._inc !== ue) {
      var $ = ie._refresh(ie._node);
      if (Ni(ie, "length", $.length), !ie.$$length || $.length < ie.$$length)
        for (var B = $.length; B in ie; B++)
          Object.prototype.hasOwnProperty.call(ie, B) && delete ie[B];
      k($, ie), ie._inc = ue;
    }
  }
  ye.prototype.item = function(ie) {
    return Ve(this), this[ie] || null;
  }, D(ye, xe);
  function He() {
  }
  function Ze(ie, ue) {
    for (var $ = ie.length; $--; )
      if (ie[$] === ue)
        return $;
  }
  function qe(ie, ue, $, B) {
    if (B ? ue[Ze(ue, B)] = $ : ue[ue.length++] = $, ie) {
      $.ownerElement = ie;
      var q = ie.ownerDocument;
      q && (B && Oe(q, ie, B), Te(q, ie, $));
    }
  }
  function Je(ie, ue, $) {
    var B = Ze(ue, $);
    if (B >= 0) {
      for (var q = ue.length - 1; B < q; )
        ue[B] = ue[++B];
      if (ue.length = q, ie) {
        var te = ie.ownerDocument;
        te && (Oe(te, ie, $), $.ownerElement = null);
      }
    } else
      throw new re(ve, new Error(ie.tagName + "@" + $));
  }
  He.prototype = {
    length: 0,
    item: xe.prototype.item,
    getNamedItem: function(ie) {
      for (var ue = this.length; ue--; ) {
        var $ = this[ue];
        if ($.nodeName == ie)
          return $;
      }
    },
    setNamedItem: function(ie) {
      var ue = ie.ownerElement;
      if (ue && ue != this._ownerElement)
        throw new re(X);
      var $ = this.getNamedItem(ie.nodeName);
      return qe(this._ownerElement, this, ie, $), $;
    },
    /* returns Node */
    setNamedItemNS: function(ie) {
      var ue = ie.ownerElement, $;
      if (ue && ue != this._ownerElement)
        throw new re(X);
      return $ = this.getNamedItemNS(ie.namespaceURI, ie.localName), qe(this._ownerElement, this, ie, $), $;
    },
    /* returns Node */
    removeNamedItem: function(ie) {
      var ue = this.getNamedItem(ie);
      return Je(this._ownerElement, this, ue), ue;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(ie, ue) {
      var $ = this.getNamedItemNS(ie, ue);
      return Je(this._ownerElement, this, $), $;
    },
    getNamedItemNS: function(ie, ue) {
      for (var $ = this.length; $--; ) {
        var B = this[$];
        if (B.localName == ue && B.namespaceURI == ie)
          return B;
      }
      return null;
    }
  };
  function et() {
  }
  et.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(ie, ue) {
      return !0;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(ie, ue, $) {
      var B = new be();
      if (B.implementation = this, B.childNodes = new xe(), B.doctype = $ || null, $ && B.appendChild($), ue) {
        var q = B.createElementNS(ie, ue);
        B.appendChild(q);
      }
      return B;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(ie, ue, $) {
      var B = new xi();
      return B.name = ie, B.nodeName = ie, B.publicId = ue || "", B.systemId = $ || "", B;
    }
  };
  function st() {
  }
  st.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(ie, ue) {
      return lt(this, ie, ue);
    },
    replaceChild: function(ie, ue) {
      lt(this, ie, ue, Rt), ue && this.removeChild(ue);
    },
    removeChild: function(ie) {
      return Ue(this, ie);
    },
    appendChild: function(ie) {
      return this.insertBefore(ie, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(ie) {
      return cr(this.ownerDocument || this, this, ie);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      for (var ie = this.firstChild; ie; ) {
        var ue = ie.nextSibling;
        ue && ue.nodeType == z && ie.nodeType == z ? (this.removeChild(ue), ie.appendData(ue.data)) : (ie.normalize(), ie = ue);
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(ie, ue) {
      return this.ownerDocument.implementation.hasFeature(ie, ue);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(ie) {
      for (var ue = this; ue; ) {
        var $ = ue._nsMap;
        if ($) {
          for (var B in $)
            if (Object.prototype.hasOwnProperty.call($, B) && $[B] === ie)
              return B;
        }
        ue = ue.nodeType == O ? ue.ownerDocument : ue.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(ie) {
      for (var ue = this; ue; ) {
        var $ = ue._nsMap;
        if ($ && Object.prototype.hasOwnProperty.call($, ie))
          return $[ie];
        ue = ue.nodeType == O ? ue.ownerDocument : ue.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(ie) {
      var ue = this.lookupPrefix(ie);
      return ue == null;
    }
  };
  function ee(ie) {
    return ie == "<" && "&lt;" || ie == ">" && "&gt;" || ie == "&" && "&amp;" || ie == '"' && "&quot;" || "&#" + ie.charCodeAt() + ";";
  }
  k(L, st), k(L, st.prototype);
  function _e(ie, ue) {
    if (ue(ie))
      return !0;
    if (ie = ie.firstChild)
      do
        if (_e(ie, ue))
          return !0;
      while (ie = ie.nextSibling);
  }
  function be() {
    this.ownerDocument = this;
  }
  function Te(ie, ue, $) {
    ie && ie._inc++;
    var B = $.namespaceURI;
    B === a.XMLNS && (ue._nsMap[$.prefix ? $.localName : ""] = $.value);
  }
  function Oe(ie, ue, $, B) {
    ie && ie._inc++;
    var q = $.namespaceURI;
    q === a.XMLNS && delete ue._nsMap[$.prefix ? $.localName : ""];
  }
  function $e(ie, ue, $) {
    if (ie && ie._inc) {
      ie._inc++;
      var B = ue.childNodes;
      if ($)
        B[B.length++] = $;
      else {
        for (var q = ue.firstChild, te = 0; q; )
          B[te++] = q, q = q.nextSibling;
        B.length = te, delete B[B.length];
      }
    }
  }
  function Ue(ie, ue) {
    var $ = ue.previousSibling, B = ue.nextSibling;
    return $ ? $.nextSibling = B : ie.firstChild = B, B ? B.previousSibling = $ : ie.lastChild = $, ue.parentNode = null, ue.previousSibling = null, ue.nextSibling = null, $e(ie.ownerDocument, ie), ue;
  }
  function Ke(ie) {
    return ie && (ie.nodeType === st.DOCUMENT_NODE || ie.nodeType === st.DOCUMENT_FRAGMENT_NODE || ie.nodeType === st.ELEMENT_NODE);
  }
  function nt(ie) {
    return ie && (vt(ie) || mt(ie) || ot(ie) || ie.nodeType === st.DOCUMENT_FRAGMENT_NODE || ie.nodeType === st.COMMENT_NODE || ie.nodeType === st.PROCESSING_INSTRUCTION_NODE);
  }
  function ot(ie) {
    return ie && ie.nodeType === st.DOCUMENT_TYPE_NODE;
  }
  function vt(ie) {
    return ie && ie.nodeType === st.ELEMENT_NODE;
  }
  function mt(ie) {
    return ie && ie.nodeType === st.TEXT_NODE;
  }
  function Pt(ie, ue) {
    var $ = ie.childNodes || [];
    if (l($, vt) || ot(ue))
      return !1;
    var B = l($, ot);
    return !(ue && B && $.indexOf(B) > $.indexOf(ue));
  }
  function rt(ie, ue) {
    var $ = ie.childNodes || [];
    function B(te) {
      return vt(te) && te !== ue;
    }
    if (l($, B))
      return !1;
    var q = l($, ot);
    return !(ue && q && $.indexOf(q) > $.indexOf(ue));
  }
  function Y(ie, ue, $) {
    if (!Ke(ie))
      throw new re(me, "Unexpected parent node type " + ie.nodeType);
    if ($ && $.parentNode !== ie)
      throw new re(ve, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !nt(ue) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      ot(ue) && ie.nodeType !== st.DOCUMENT_NODE
    )
      throw new re(
        me,
        "Unexpected node type " + ue.nodeType + " for parent node type " + ie.nodeType
      );
  }
  function Kt(ie, ue, $) {
    var B = ie.childNodes || [], q = ue.childNodes || [];
    if (ue.nodeType === st.DOCUMENT_FRAGMENT_NODE) {
      var te = q.filter(vt);
      if (te.length > 1 || l(q, mt))
        throw new re(me, "More than one element or text in fragment");
      if (te.length === 1 && !Pt(ie, $))
        throw new re(me, "Element in fragment can not be inserted before doctype");
    }
    if (vt(ue) && !Pt(ie, $))
      throw new re(me, "Only one element can be added and only after doctype");
    if (ot(ue)) {
      if (l(B, ot))
        throw new re(me, "Only one doctype is allowed");
      var ge = l(B, vt);
      if ($ && B.indexOf(ge) < B.indexOf($))
        throw new re(me, "Doctype can only be inserted before an element");
      if (!$ && ge)
        throw new re(me, "Doctype can not be appended since element is present");
    }
  }
  function Rt(ie, ue, $) {
    var B = ie.childNodes || [], q = ue.childNodes || [];
    if (ue.nodeType === st.DOCUMENT_FRAGMENT_NODE) {
      var te = q.filter(vt);
      if (te.length > 1 || l(q, mt))
        throw new re(me, "More than one element or text in fragment");
      if (te.length === 1 && !rt(ie, $))
        throw new re(me, "Element in fragment can not be inserted before doctype");
    }
    if (vt(ue) && !rt(ie, $))
      throw new re(me, "Only one element can be added and only after doctype");
    if (ot(ue)) {
      if (l(B, function(Fe) {
        return ot(Fe) && Fe !== $;
      }))
        throw new re(me, "Only one doctype is allowed");
      var ge = l(B, vt);
      if ($ && B.indexOf(ge) < B.indexOf($))
        throw new re(me, "Doctype can only be inserted before an element");
    }
  }
  function lt(ie, ue, $, B) {
    Y(ie, ue, $), ie.nodeType === st.DOCUMENT_NODE && (B || Kt)(ie, ue, $);
    var q = ue.parentNode;
    if (q && q.removeChild(ue), ue.nodeType === je) {
      var te = ue.firstChild;
      if (te == null)
        return ue;
      var ge = ue.lastChild;
    } else
      te = ge = ue;
    var Me = $ ? $.previousSibling : ie.lastChild;
    te.previousSibling = Me, ge.nextSibling = $, Me ? Me.nextSibling = te : ie.firstChild = te, $ == null ? ie.lastChild = ge : $.previousSibling = ge;
    do
      te.parentNode = ie;
    while (te !== ge && (te = te.nextSibling));
    return $e(ie.ownerDocument || ie, ie), ue.nodeType == je && (ue.firstChild = ue.lastChild = null), ue;
  }
  function xt(ie, ue) {
    return ue.parentNode && ue.parentNode.removeChild(ue), ue.parentNode = ie, ue.previousSibling = ie.lastChild, ue.nextSibling = null, ue.previousSibling ? ue.previousSibling.nextSibling = ue : ie.firstChild = ue, ie.lastChild = ue, $e(ie.ownerDocument, ie, ue), ue;
  }
  be.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: Ce,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(ie, ue) {
      if (ie.nodeType == je) {
        for (var $ = ie.firstChild; $; ) {
          var B = $.nextSibling;
          this.insertBefore($, ue), $ = B;
        }
        return ie;
      }
      return lt(this, ie, ue), ie.ownerDocument = this, this.documentElement === null && ie.nodeType === j && (this.documentElement = ie), ie;
    },
    removeChild: function(ie) {
      return this.documentElement == ie && (this.documentElement = null), Ue(this, ie);
    },
    replaceChild: function(ie, ue) {
      lt(this, ie, ue, Rt), ie.ownerDocument = this, ue && this.removeChild(ue), vt(ie) && (this.documentElement = ie);
    },
    // Introduced in DOM Level 2:
    importNode: function(ie, ue) {
      return zt(this, ie, ue);
    },
    // Introduced in DOM Level 2:
    getElementById: function(ie) {
      var ue = null;
      return _e(this.documentElement, function($) {
        if ($.nodeType == j && $.getAttribute("id") == ie)
          return ue = $, !0;
      }), ue;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(ie) {
      var ue = g(ie);
      return new ye(this, function($) {
        var B = [];
        return ue.length > 0 && _e($.documentElement, function(q) {
          if (q !== $ && q.nodeType === j) {
            var te = q.getAttribute("class");
            if (te) {
              var ge = ie === te;
              if (!ge) {
                var Me = g(te);
                ge = ue.every(o(Me));
              }
              ge && B.push(q);
            }
          }
        }), B;
      });
    },
    //document factory method:
    createElement: function(ie) {
      var ue = new At();
      ue.ownerDocument = this, ue.nodeName = ie, ue.tagName = ie, ue.localName = ie, ue.childNodes = new xe();
      var $ = ue.attributes = new He();
      return $._ownerElement = ue, ue;
    },
    createDocumentFragment: function() {
      var ie = new It();
      return ie.ownerDocument = this, ie.childNodes = new xe(), ie;
    },
    createTextNode: function(ie) {
      var ue = new ni();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createComment: function(ie) {
      var ue = new ii();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createCDATASection: function(ie) {
      var ue = new yi();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createProcessingInstruction: function(ie, ue) {
      var $ = new Zi();
      return $.ownerDocument = this, $.tagName = $.nodeName = $.target = ie, $.nodeValue = $.data = ue, $;
    },
    createAttribute: function(ie) {
      var ue = new Et();
      return ue.ownerDocument = this, ue.name = ie, ue.nodeName = ie, ue.localName = ie, ue.specified = !0, ue;
    },
    createEntityReference: function(ie) {
      var ue = new si();
      return ue.ownerDocument = this, ue.nodeName = ie, ue;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(ie, ue) {
      var $ = new At(), B = ue.split(":"), q = $.attributes = new He();
      return $.childNodes = new xe(), $.ownerDocument = this, $.nodeName = ue, $.tagName = ue, $.namespaceURI = ie, B.length == 2 ? ($.prefix = B[0], $.localName = B[1]) : $.localName = ue, q._ownerElement = $, $;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(ie, ue) {
      var $ = new Et(), B = ue.split(":");
      return $.ownerDocument = this, $.nodeName = ue, $.name = ue, $.namespaceURI = ie, $.specified = !0, B.length == 2 ? ($.prefix = B[0], $.localName = B[1]) : $.localName = ue, $;
    }
  }, D(be, st);
  function At() {
    this._nsMap = {};
  }
  At.prototype = {
    nodeType: j,
    hasAttribute: function(ie) {
      return this.getAttributeNode(ie) != null;
    },
    getAttribute: function(ie) {
      var ue = this.getAttributeNode(ie);
      return ue && ue.value || "";
    },
    getAttributeNode: function(ie) {
      return this.attributes.getNamedItem(ie);
    },
    setAttribute: function(ie, ue) {
      var $ = this.ownerDocument.createAttribute(ie);
      $.value = $.nodeValue = "" + ue, this.setAttributeNode($);
    },
    removeAttribute: function(ie) {
      var ue = this.getAttributeNode(ie);
      ue && this.removeAttributeNode(ue);
    },
    //four real opeartion method
    appendChild: function(ie) {
      return ie.nodeType === je ? this.insertBefore(ie, null) : xt(this, ie);
    },
    setAttributeNode: function(ie) {
      return this.attributes.setNamedItem(ie);
    },
    setAttributeNodeNS: function(ie) {
      return this.attributes.setNamedItemNS(ie);
    },
    removeAttributeNode: function(ie) {
      return this.attributes.removeNamedItem(ie.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(ie, ue) {
      var $ = this.getAttributeNodeNS(ie, ue);
      $ && this.removeAttributeNode($);
    },
    hasAttributeNS: function(ie, ue) {
      return this.getAttributeNodeNS(ie, ue) != null;
    },
    getAttributeNS: function(ie, ue) {
      var $ = this.getAttributeNodeNS(ie, ue);
      return $ && $.value || "";
    },
    setAttributeNS: function(ie, ue, $) {
      var B = this.ownerDocument.createAttributeNS(ie, ue);
      B.value = B.nodeValue = "" + $, this.setAttributeNode(B);
    },
    getAttributeNodeNS: function(ie, ue) {
      return this.attributes.getNamedItemNS(ie, ue);
    },
    getElementsByTagName: function(ie) {
      return new ye(this, function(ue) {
        var $ = [];
        return _e(ue, function(B) {
          B !== ue && B.nodeType == j && (ie === "*" || B.tagName == ie) && $.push(B);
        }), $;
      });
    },
    getElementsByTagNameNS: function(ie, ue) {
      return new ye(this, function($) {
        var B = [];
        return _e($, function(q) {
          q !== $ && q.nodeType === j && (ie === "*" || q.namespaceURI === ie) && (ue === "*" || q.localName == ue) && B.push(q);
        }), B;
      });
    }
  }, be.prototype.getElementsByTagName = At.prototype.getElementsByTagName, be.prototype.getElementsByTagNameNS = At.prototype.getElementsByTagNameNS, D(At, st);
  function Et() {
  }
  Et.prototype.nodeType = O, D(Et, st);
  function jt() {
  }
  jt.prototype = {
    data: "",
    substringData: function(ie, ue) {
      return this.data.substring(ie, ie + ue);
    },
    appendData: function(ie) {
      ie = this.data + ie, this.nodeValue = this.data = ie, this.length = ie.length;
    },
    insertData: function(ie, ue) {
      this.replaceData(ie, 0, ue);
    },
    appendChild: function(ie) {
      throw new Error(Ae[me]);
    },
    deleteData: function(ie, ue) {
      this.replaceData(ie, ue, "");
    },
    replaceData: function(ie, ue, $) {
      var B = this.data.substring(0, ie), q = this.data.substring(ie + ue);
      $ = B + $ + q, this.nodeValue = this.data = $, this.length = $.length;
    }
  }, D(jt, st);
  function ni() {
  }
  ni.prototype = {
    nodeName: "#text",
    nodeType: z,
    splitText: function(ie) {
      var ue = this.data, $ = ue.substring(ie);
      ue = ue.substring(0, ie), this.data = this.nodeValue = ue, this.length = ue.length;
      var B = this.ownerDocument.createTextNode($);
      return this.parentNode && this.parentNode.insertBefore(B, this.nextSibling), B;
    }
  }, D(ni, jt);
  function ii() {
  }
  ii.prototype = {
    nodeName: "#comment",
    nodeType: fe
  }, D(ii, jt);
  function yi() {
  }
  yi.prototype = {
    nodeName: "#cdata-section",
    nodeType: pe
  }, D(yi, jt);
  function xi() {
  }
  xi.prototype.nodeType = ze, D(xi, st);
  function pt() {
  }
  pt.prototype.nodeType = Qe, D(pt, st);
  function Jt() {
  }
  Jt.prototype.nodeType = ae, D(Jt, st);
  function si() {
  }
  si.prototype.nodeType = oe, D(si, st);
  function It() {
  }
  It.prototype.nodeName = "#document-fragment", It.prototype.nodeType = je, D(It, st);
  function Zi() {
  }
  Zi.prototype.nodeType = Q, D(Zi, st);
  function ft() {
  }
  ft.prototype.serializeToString = function(ie, ue, $) {
    return ri.call(ie, ue, $);
  }, st.prototype.toString = ri;
  function ri(ie, ue) {
    var $ = [], B = this.nodeType == 9 && this.documentElement || this, q = B.prefix, te = B.namespaceURI;
    if (te && q == null) {
      var q = B.lookupPrefix(te);
      if (q == null)
        var ge = [
          { namespace: te, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return Gi(this, $, ie, ue, ge), $.join("");
  }
  function Lt(ie, ue, $) {
    var B = ie.prefix || "", q = ie.namespaceURI;
    if (!q || B === "xml" && q === a.XML || q === a.XMLNS)
      return !1;
    for (var te = $.length; te--; ) {
      var ge = $[te];
      if (ge.prefix === B)
        return ge.namespace !== q;
    }
    return !0;
  }
  function Si(ie, ue, $) {
    ie.push(" ", ue, '="', $.replace(/[<>&"\t\n\r]/g, ee), '"');
  }
  function Gi(ie, ue, $, B, q) {
    if (q || (q = []), B)
      if (ie = B(ie), ie) {
        if (typeof ie == "string") {
          ue.push(ie);
          return;
        }
      } else
        return;
    switch (ie.nodeType) {
      case j:
        var te = ie.attributes, ge = te.length, Qt = ie.firstChild, Me = ie.tagName;
        $ = a.isHTML(ie.namespaceURI) || $;
        var Fe = Me;
        if (!$ && !ie.prefix && ie.namespaceURI) {
          for (var Ne, De = 0; De < te.length; De++)
            if (te.item(De).name === "xmlns") {
              Ne = te.item(De).value;
              break;
            }
          if (!Ne)
            for (var tt = q.length - 1; tt >= 0; tt--) {
              var ut = q[tt];
              if (ut.prefix === "" && ut.namespace === ie.namespaceURI) {
                Ne = ut.namespace;
                break;
              }
            }
          if (Ne !== ie.namespaceURI)
            for (var tt = q.length - 1; tt >= 0; tt--) {
              var ut = q[tt];
              if (ut.namespace === ie.namespaceURI) {
                ut.prefix && (Fe = ut.prefix + ":" + Me);
                break;
              }
            }
        }
        ue.push("<", Fe);
        for (var We = 0; We < ge; We++) {
          var gt = te.item(We);
          gt.prefix == "xmlns" ? q.push({ prefix: gt.localName, namespace: gt.value }) : gt.nodeName == "xmlns" && q.push({ prefix: "", namespace: gt.value });
        }
        for (var We = 0; We < ge; We++) {
          var gt = te.item(We);
          if (Lt(gt, $, q)) {
            var Mt = gt.prefix || "", $t = gt.namespaceURI;
            Si(ue, Mt ? "xmlns:" + Mt : "xmlns", $t), q.push({ prefix: Mt, namespace: $t });
          }
          Gi(gt, ue, $, B, q);
        }
        if (Me === Fe && Lt(ie, $, q)) {
          var Mt = ie.prefix || "", $t = ie.namespaceURI;
          Si(ue, Mt ? "xmlns:" + Mt : "xmlns", $t), q.push({ prefix: Mt, namespace: $t });
        }
        if (Qt || $ && !/^(?:meta|link|img|br|hr|input)$/i.test(Me)) {
          if (ue.push(">"), $ && /^script$/i.test(Me))
            for (; Qt; )
              Qt.data ? ue.push(Qt.data) : Gi(Qt, ue, $, B, q.slice()), Qt = Qt.nextSibling;
          else
            for (; Qt; )
              Gi(Qt, ue, $, B, q.slice()), Qt = Qt.nextSibling;
          ue.push("</", Fe, ">");
        } else
          ue.push("/>");
        return;
      case Ce:
      case je:
        for (var Qt = ie.firstChild; Qt; )
          Gi(Qt, ue, $, B, q.slice()), Qt = Qt.nextSibling;
        return;
      case O:
        return Si(ue, ie.name, ie.value);
      case z:
        return ue.push(
          ie.data.replace(/[<&>]/g, ee)
        );
      case pe:
        return ue.push("<![CDATA[", ie.data, "]]>");
      case fe:
        return ue.push("<!--", ie.data, "-->");
      case ze:
        var ei = ie.publicId, pi = ie.systemId;
        if (ue.push("<!DOCTYPE ", ie.name), ei)
          ue.push(" PUBLIC ", ei), pi && pi != "." && ue.push(" ", pi), ue.push(">");
        else if (pi && pi != ".")
          ue.push(" SYSTEM ", pi, ">");
        else {
          var fi = ie.internalSubset;
          fi && ue.push(" [", fi, "]"), ue.push(">");
        }
        return;
      case Q:
        return ue.push("<?", ie.target, " ", ie.data, "?>");
      case oe:
        return ue.push("&", ie.nodeName, ";");
      default:
        ue.push("??", ie.nodeName);
    }
  }
  function zt(ie, ue, $) {
    var B;
    switch (ue.nodeType) {
      case j:
        B = ue.cloneNode(!1), B.ownerDocument = ie;
      case je:
        break;
      case O:
        $ = !0;
        break;
    }
    if (B || (B = ue.cloneNode(!1)), B.ownerDocument = ie, B.parentNode = null, $)
      for (var q = ue.firstChild; q; )
        B.appendChild(zt(ie, q, $)), q = q.nextSibling;
    return B;
  }
  function cr(ie, ue, $) {
    var B = new ue.constructor();
    for (var q in ue)
      if (Object.prototype.hasOwnProperty.call(ue, q)) {
        var te = ue[q];
        typeof te != "object" && te != B[q] && (B[q] = te);
      }
    switch (ue.childNodes && (B.childNodes = new xe()), B.ownerDocument = ie, B.nodeType) {
      case j:
        var ge = ue.attributes, Me = B.attributes = new He(), Fe = ge.length;
        Me._ownerElement = B;
        for (var Ne = 0; Ne < Fe; Ne++)
          B.setAttributeNode(cr(ie, ge.item(Ne), !0));
        break;
      case O:
        $ = !0;
    }
    if ($)
      for (var De = ue.firstChild; De; )
        B.appendChild(cr(ie, De, $)), De = De.nextSibling;
    return B;
  }
  function Ni(ie, ue, $) {
    ie[ue] = $;
  }
  try {
    if (Object.defineProperty) {
      let ie = function(ue) {
        switch (ue.nodeType) {
          case j:
          case je:
            var $ = [];
            for (ue = ue.firstChild; ue; )
              ue.nodeType !== 7 && ue.nodeType !== 8 && $.push(ie(ue)), ue = ue.nextSibling;
            return $.join("");
          default:
            return ue.nodeValue;
        }
      };
      Object.defineProperty(ye.prototype, "length", {
        get: function() {
          return Ve(this), this.$$length;
        }
      }), Object.defineProperty(st.prototype, "textContent", {
        get: function() {
          return ie(this);
        },
        set: function(ue) {
          switch (this.nodeType) {
            case j:
            case je:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (ue || String(ue)) && this.appendChild(this.ownerDocument.createTextNode(ue));
              break;
            default:
              this.data = ue, this.value = ue, this.nodeValue = ue;
          }
        }
      }), Ni = function(ue, $, B) {
        ue["$$" + $] = B;
      };
    }
  } catch {
  }
  return Cl.DocumentType = xi, Cl.DOMException = re, Cl.DOMImplementation = et, Cl.Element = At, Cl.Node = st, Cl.NodeList = xe, Cl.XMLSerializer = ft, Cl;
}
var sh = {}, Mp = {}, o0;
function Dx() {
  return o0 || (o0 = 1, function(s) {
    var l = Ad().freeze;
    s.XML_ENTITIES = l({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), s.HTML_ENTITIES = l({
      Aacute: "",
      aacute: "",
      Abreve: "",
      abreve: "",
      ac: "",
      acd: "",
      acE: "",
      Acirc: "",
      acirc: "",
      acute: "",
      Acy: "",
      acy: "",
      AElig: "",
      aelig: "",
      af: "",
      Afr: "",
      afr: "",
      Agrave: "",
      agrave: "",
      alefsym: "",
      aleph: "",
      Alpha: "",
      alpha: "",
      Amacr: "",
      amacr: "",
      amalg: "",
      AMP: "&",
      amp: "&",
      And: "",
      and: "",
      andand: "",
      andd: "",
      andslope: "",
      andv: "",
      ang: "",
      ange: "",
      angle: "",
      angmsd: "",
      angmsdaa: "",
      angmsdab: "",
      angmsdac: "",
      angmsdad: "",
      angmsdae: "",
      angmsdaf: "",
      angmsdag: "",
      angmsdah: "",
      angrt: "",
      angrtvb: "",
      angrtvbd: "",
      angsph: "",
      angst: "",
      angzarr: "",
      Aogon: "",
      aogon: "",
      Aopf: "",
      aopf: "",
      ap: "",
      apacir: "",
      apE: "",
      ape: "",
      apid: "",
      apos: "'",
      ApplyFunction: "",
      approx: "",
      approxeq: "",
      Aring: "",
      aring: "",
      Ascr: "",
      ascr: "",
      Assign: "",
      ast: "*",
      asymp: "",
      asympeq: "",
      Atilde: "",
      atilde: "",
      Auml: "",
      auml: "",
      awconint: "",
      awint: "",
      backcong: "",
      backepsilon: "",
      backprime: "",
      backsim: "",
      backsimeq: "",
      Backslash: "",
      Barv: "",
      barvee: "",
      Barwed: "",
      barwed: "",
      barwedge: "",
      bbrk: "",
      bbrktbrk: "",
      bcong: "",
      Bcy: "",
      bcy: "",
      bdquo: "",
      becaus: "",
      Because: "",
      because: "",
      bemptyv: "",
      bepsi: "",
      bernou: "",
      Bernoullis: "",
      Beta: "",
      beta: "",
      beth: "",
      between: "",
      Bfr: "",
      bfr: "",
      bigcap: "",
      bigcirc: "",
      bigcup: "",
      bigodot: "",
      bigoplus: "",
      bigotimes: "",
      bigsqcup: "",
      bigstar: "",
      bigtriangledown: "",
      bigtriangleup: "",
      biguplus: "",
      bigvee: "",
      bigwedge: "",
      bkarow: "",
      blacklozenge: "",
      blacksquare: "",
      blacktriangle: "",
      blacktriangledown: "",
      blacktriangleleft: "",
      blacktriangleright: "",
      blank: "",
      blk12: "",
      blk14: "",
      blk34: "",
      block: "",
      bne: "=",
      bnequiv: "",
      bNot: "",
      bnot: "",
      Bopf: "",
      bopf: "",
      bot: "",
      bottom: "",
      bowtie: "",
      boxbox: "",
      boxDL: "",
      boxDl: "",
      boxdL: "",
      boxdl: "",
      boxDR: "",
      boxDr: "",
      boxdR: "",
      boxdr: "",
      boxH: "",
      boxh: "",
      boxHD: "",
      boxHd: "",
      boxhD: "",
      boxhd: "",
      boxHU: "",
      boxHu: "",
      boxhU: "",
      boxhu: "",
      boxminus: "",
      boxplus: "",
      boxtimes: "",
      boxUL: "",
      boxUl: "",
      boxuL: "",
      boxul: "",
      boxUR: "",
      boxUr: "",
      boxuR: "",
      boxur: "",
      boxV: "",
      boxv: "",
      boxVH: "",
      boxVh: "",
      boxvH: "",
      boxvh: "",
      boxVL: "",
      boxVl: "",
      boxvL: "",
      boxvl: "",
      boxVR: "",
      boxVr: "",
      boxvR: "",
      boxvr: "",
      bprime: "",
      Breve: "",
      breve: "",
      brvbar: "",
      Bscr: "",
      bscr: "",
      bsemi: "",
      bsim: "",
      bsime: "",
      bsol: "\\",
      bsolb: "",
      bsolhsub: "",
      bull: "",
      bullet: "",
      bump: "",
      bumpE: "",
      bumpe: "",
      Bumpeq: "",
      bumpeq: "",
      Cacute: "",
      cacute: "",
      Cap: "",
      cap: "",
      capand: "",
      capbrcup: "",
      capcap: "",
      capcup: "",
      capdot: "",
      CapitalDifferentialD: "",
      caps: "",
      caret: "",
      caron: "",
      Cayleys: "",
      ccaps: "",
      Ccaron: "",
      ccaron: "",
      Ccedil: "",
      ccedil: "",
      Ccirc: "",
      ccirc: "",
      Cconint: "",
      ccups: "",
      ccupssm: "",
      Cdot: "",
      cdot: "",
      cedil: "",
      Cedilla: "",
      cemptyv: "",
      cent: "",
      CenterDot: "",
      centerdot: "",
      Cfr: "",
      cfr: "",
      CHcy: "",
      chcy: "",
      check: "",
      checkmark: "",
      Chi: "",
      chi: "",
      cir: "",
      circ: "",
      circeq: "",
      circlearrowleft: "",
      circlearrowright: "",
      circledast: "",
      circledcirc: "",
      circleddash: "",
      CircleDot: "",
      circledR: "",
      circledS: "",
      CircleMinus: "",
      CirclePlus: "",
      CircleTimes: "",
      cirE: "",
      cire: "",
      cirfnint: "",
      cirmid: "",
      cirscir: "",
      ClockwiseContourIntegral: "",
      CloseCurlyDoubleQuote: "",
      CloseCurlyQuote: "",
      clubs: "",
      clubsuit: "",
      Colon: "",
      colon: ":",
      Colone: "",
      colone: "",
      coloneq: "",
      comma: ",",
      commat: "@",
      comp: "",
      compfn: "",
      complement: "",
      complexes: "",
      cong: "",
      congdot: "",
      Congruent: "",
      Conint: "",
      conint: "",
      ContourIntegral: "",
      Copf: "",
      copf: "",
      coprod: "",
      Coproduct: "",
      COPY: "",
      copy: "",
      copysr: "",
      CounterClockwiseContourIntegral: "",
      crarr: "",
      Cross: "",
      cross: "",
      Cscr: "",
      cscr: "",
      csub: "",
      csube: "",
      csup: "",
      csupe: "",
      ctdot: "",
      cudarrl: "",
      cudarrr: "",
      cuepr: "",
      cuesc: "",
      cularr: "",
      cularrp: "",
      Cup: "",
      cup: "",
      cupbrcap: "",
      CupCap: "",
      cupcap: "",
      cupcup: "",
      cupdot: "",
      cupor: "",
      cups: "",
      curarr: "",
      curarrm: "",
      curlyeqprec: "",
      curlyeqsucc: "",
      curlyvee: "",
      curlywedge: "",
      curren: "",
      curvearrowleft: "",
      curvearrowright: "",
      cuvee: "",
      cuwed: "",
      cwconint: "",
      cwint: "",
      cylcty: "",
      Dagger: "",
      dagger: "",
      daleth: "",
      Darr: "",
      dArr: "",
      darr: "",
      dash: "",
      Dashv: "",
      dashv: "",
      dbkarow: "",
      dblac: "",
      Dcaron: "",
      dcaron: "",
      Dcy: "",
      dcy: "",
      DD: "",
      dd: "",
      ddagger: "",
      ddarr: "",
      DDotrahd: "",
      ddotseq: "",
      deg: "",
      Del: "",
      Delta: "",
      delta: "",
      demptyv: "",
      dfisht: "",
      Dfr: "",
      dfr: "",
      dHar: "",
      dharl: "",
      dharr: "",
      DiacriticalAcute: "",
      DiacriticalDot: "",
      DiacriticalDoubleAcute: "",
      DiacriticalGrave: "`",
      DiacriticalTilde: "",
      diam: "",
      Diamond: "",
      diamond: "",
      diamondsuit: "",
      diams: "",
      die: "",
      DifferentialD: "",
      digamma: "",
      disin: "",
      div: "",
      divide: "",
      divideontimes: "",
      divonx: "",
      DJcy: "",
      djcy: "",
      dlcorn: "",
      dlcrop: "",
      dollar: "$",
      Dopf: "",
      dopf: "",
      Dot: "",
      dot: "",
      DotDot: "",
      doteq: "",
      doteqdot: "",
      DotEqual: "",
      dotminus: "",
      dotplus: "",
      dotsquare: "",
      doublebarwedge: "",
      DoubleContourIntegral: "",
      DoubleDot: "",
      DoubleDownArrow: "",
      DoubleLeftArrow: "",
      DoubleLeftRightArrow: "",
      DoubleLeftTee: "",
      DoubleLongLeftArrow: "",
      DoubleLongLeftRightArrow: "",
      DoubleLongRightArrow: "",
      DoubleRightArrow: "",
      DoubleRightTee: "",
      DoubleUpArrow: "",
      DoubleUpDownArrow: "",
      DoubleVerticalBar: "",
      DownArrow: "",
      Downarrow: "",
      downarrow: "",
      DownArrowBar: "",
      DownArrowUpArrow: "",
      DownBreve: "",
      downdownarrows: "",
      downharpoonleft: "",
      downharpoonright: "",
      DownLeftRightVector: "",
      DownLeftTeeVector: "",
      DownLeftVector: "",
      DownLeftVectorBar: "",
      DownRightTeeVector: "",
      DownRightVector: "",
      DownRightVectorBar: "",
      DownTee: "",
      DownTeeArrow: "",
      drbkarow: "",
      drcorn: "",
      drcrop: "",
      Dscr: "",
      dscr: "",
      DScy: "",
      dscy: "",
      dsol: "",
      Dstrok: "",
      dstrok: "",
      dtdot: "",
      dtri: "",
      dtrif: "",
      duarr: "",
      duhar: "",
      dwangle: "",
      DZcy: "",
      dzcy: "",
      dzigrarr: "",
      Eacute: "",
      eacute: "",
      easter: "",
      Ecaron: "",
      ecaron: "",
      ecir: "",
      Ecirc: "",
      ecirc: "",
      ecolon: "",
      Ecy: "",
      ecy: "",
      eDDot: "",
      Edot: "",
      eDot: "",
      edot: "",
      ee: "",
      efDot: "",
      Efr: "",
      efr: "",
      eg: "",
      Egrave: "",
      egrave: "",
      egs: "",
      egsdot: "",
      el: "",
      Element: "",
      elinters: "",
      ell: "",
      els: "",
      elsdot: "",
      Emacr: "",
      emacr: "",
      empty: "",
      emptyset: "",
      EmptySmallSquare: "",
      emptyv: "",
      EmptyVerySmallSquare: "",
      emsp: "",
      emsp13: "",
      emsp14: "",
      ENG: "",
      eng: "",
      ensp: "",
      Eogon: "",
      eogon: "",
      Eopf: "",
      eopf: "",
      epar: "",
      eparsl: "",
      eplus: "",
      epsi: "",
      Epsilon: "",
      epsilon: "",
      epsiv: "",
      eqcirc: "",
      eqcolon: "",
      eqsim: "",
      eqslantgtr: "",
      eqslantless: "",
      Equal: "",
      equals: "=",
      EqualTilde: "",
      equest: "",
      Equilibrium: "",
      equiv: "",
      equivDD: "",
      eqvparsl: "",
      erarr: "",
      erDot: "",
      Escr: "",
      escr: "",
      esdot: "",
      Esim: "",
      esim: "",
      Eta: "",
      eta: "",
      ETH: "",
      eth: "",
      Euml: "",
      euml: "",
      euro: "",
      excl: "!",
      exist: "",
      Exists: "",
      expectation: "",
      ExponentialE: "",
      exponentiale: "",
      fallingdotseq: "",
      Fcy: "",
      fcy: "",
      female: "",
      ffilig: "",
      fflig: "",
      ffllig: "",
      Ffr: "",
      ffr: "",
      filig: "",
      FilledSmallSquare: "",
      FilledVerySmallSquare: "",
      fjlig: "fj",
      flat: "",
      fllig: "",
      fltns: "",
      fnof: "",
      Fopf: "",
      fopf: "",
      ForAll: "",
      forall: "",
      fork: "",
      forkv: "",
      Fouriertrf: "",
      fpartint: "",
      frac12: "",
      frac13: "",
      frac14: "",
      frac15: "",
      frac16: "",
      frac18: "",
      frac23: "",
      frac25: "",
      frac34: "",
      frac35: "",
      frac38: "",
      frac45: "",
      frac56: "",
      frac58: "",
      frac78: "",
      frasl: "",
      frown: "",
      Fscr: "",
      fscr: "",
      gacute: "",
      Gamma: "",
      gamma: "",
      Gammad: "",
      gammad: "",
      gap: "",
      Gbreve: "",
      gbreve: "",
      Gcedil: "",
      Gcirc: "",
      gcirc: "",
      Gcy: "",
      gcy: "",
      Gdot: "",
      gdot: "",
      gE: "",
      ge: "",
      gEl: "",
      gel: "",
      geq: "",
      geqq: "",
      geqslant: "",
      ges: "",
      gescc: "",
      gesdot: "",
      gesdoto: "",
      gesdotol: "",
      gesl: "",
      gesles: "",
      Gfr: "",
      gfr: "",
      Gg: "",
      gg: "",
      ggg: "",
      gimel: "",
      GJcy: "",
      gjcy: "",
      gl: "",
      gla: "",
      glE: "",
      glj: "",
      gnap: "",
      gnapprox: "",
      gnE: "",
      gne: "",
      gneq: "",
      gneqq: "",
      gnsim: "",
      Gopf: "",
      gopf: "",
      grave: "`",
      GreaterEqual: "",
      GreaterEqualLess: "",
      GreaterFullEqual: "",
      GreaterGreater: "",
      GreaterLess: "",
      GreaterSlantEqual: "",
      GreaterTilde: "",
      Gscr: "",
      gscr: "",
      gsim: "",
      gsime: "",
      gsiml: "",
      Gt: "",
      GT: ">",
      gt: ">",
      gtcc: "",
      gtcir: "",
      gtdot: "",
      gtlPar: "",
      gtquest: "",
      gtrapprox: "",
      gtrarr: "",
      gtrdot: "",
      gtreqless: "",
      gtreqqless: "",
      gtrless: "",
      gtrsim: "",
      gvertneqq: "",
      gvnE: "",
      Hacek: "",
      hairsp: "",
      half: "",
      hamilt: "",
      HARDcy: "",
      hardcy: "",
      hArr: "",
      harr: "",
      harrcir: "",
      harrw: "",
      Hat: "^",
      hbar: "",
      Hcirc: "",
      hcirc: "",
      hearts: "",
      heartsuit: "",
      hellip: "",
      hercon: "",
      Hfr: "",
      hfr: "",
      HilbertSpace: "",
      hksearow: "",
      hkswarow: "",
      hoarr: "",
      homtht: "",
      hookleftarrow: "",
      hookrightarrow: "",
      Hopf: "",
      hopf: "",
      horbar: "",
      HorizontalLine: "",
      Hscr: "",
      hscr: "",
      hslash: "",
      Hstrok: "",
      hstrok: "",
      HumpDownHump: "",
      HumpEqual: "",
      hybull: "",
      hyphen: "",
      Iacute: "",
      iacute: "",
      ic: "",
      Icirc: "",
      icirc: "",
      Icy: "",
      icy: "",
      Idot: "",
      IEcy: "",
      iecy: "",
      iexcl: "",
      iff: "",
      Ifr: "",
      ifr: "",
      Igrave: "",
      igrave: "",
      ii: "",
      iiiint: "",
      iiint: "",
      iinfin: "",
      iiota: "",
      IJlig: "",
      ijlig: "",
      Im: "",
      Imacr: "",
      imacr: "",
      image: "",
      ImaginaryI: "",
      imagline: "",
      imagpart: "",
      imath: "",
      imof: "",
      imped: "",
      Implies: "",
      in: "",
      incare: "",
      infin: "",
      infintie: "",
      inodot: "",
      Int: "",
      int: "",
      intcal: "",
      integers: "",
      Integral: "",
      intercal: "",
      Intersection: "",
      intlarhk: "",
      intprod: "",
      InvisibleComma: "",
      InvisibleTimes: "",
      IOcy: "",
      iocy: "",
      Iogon: "",
      iogon: "",
      Iopf: "",
      iopf: "",
      Iota: "",
      iota: "",
      iprod: "",
      iquest: "",
      Iscr: "",
      iscr: "",
      isin: "",
      isindot: "",
      isinE: "",
      isins: "",
      isinsv: "",
      isinv: "",
      it: "",
      Itilde: "",
      itilde: "",
      Iukcy: "",
      iukcy: "",
      Iuml: "",
      iuml: "",
      Jcirc: "",
      jcirc: "",
      Jcy: "",
      jcy: "",
      Jfr: "",
      jfr: "",
      jmath: "",
      Jopf: "",
      jopf: "",
      Jscr: "",
      jscr: "",
      Jsercy: "",
      jsercy: "",
      Jukcy: "",
      jukcy: "",
      Kappa: "",
      kappa: "",
      kappav: "",
      Kcedil: "",
      kcedil: "",
      Kcy: "",
      kcy: "",
      Kfr: "",
      kfr: "",
      kgreen: "",
      KHcy: "",
      khcy: "",
      KJcy: "",
      kjcy: "",
      Kopf: "",
      kopf: "",
      Kscr: "",
      kscr: "",
      lAarr: "",
      Lacute: "",
      lacute: "",
      laemptyv: "",
      lagran: "",
      Lambda: "",
      lambda: "",
      Lang: "",
      lang: "",
      langd: "",
      langle: "",
      lap: "",
      Laplacetrf: "",
      laquo: "",
      Larr: "",
      lArr: "",
      larr: "",
      larrb: "",
      larrbfs: "",
      larrfs: "",
      larrhk: "",
      larrlp: "",
      larrpl: "",
      larrsim: "",
      larrtl: "",
      lat: "",
      lAtail: "",
      latail: "",
      late: "",
      lates: "",
      lBarr: "",
      lbarr: "",
      lbbrk: "",
      lbrace: "{",
      lbrack: "[",
      lbrke: "",
      lbrksld: "",
      lbrkslu: "",
      Lcaron: "",
      lcaron: "",
      Lcedil: "",
      lcedil: "",
      lceil: "",
      lcub: "{",
      Lcy: "",
      lcy: "",
      ldca: "",
      ldquo: "",
      ldquor: "",
      ldrdhar: "",
      ldrushar: "",
      ldsh: "",
      lE: "",
      le: "",
      LeftAngleBracket: "",
      LeftArrow: "",
      Leftarrow: "",
      leftarrow: "",
      LeftArrowBar: "",
      LeftArrowRightArrow: "",
      leftarrowtail: "",
      LeftCeiling: "",
      LeftDoubleBracket: "",
      LeftDownTeeVector: "",
      LeftDownVector: "",
      LeftDownVectorBar: "",
      LeftFloor: "",
      leftharpoondown: "",
      leftharpoonup: "",
      leftleftarrows: "",
      LeftRightArrow: "",
      Leftrightarrow: "",
      leftrightarrow: "",
      leftrightarrows: "",
      leftrightharpoons: "",
      leftrightsquigarrow: "",
      LeftRightVector: "",
      LeftTee: "",
      LeftTeeArrow: "",
      LeftTeeVector: "",
      leftthreetimes: "",
      LeftTriangle: "",
      LeftTriangleBar: "",
      LeftTriangleEqual: "",
      LeftUpDownVector: "",
      LeftUpTeeVector: "",
      LeftUpVector: "",
      LeftUpVectorBar: "",
      LeftVector: "",
      LeftVectorBar: "",
      lEg: "",
      leg: "",
      leq: "",
      leqq: "",
      leqslant: "",
      les: "",
      lescc: "",
      lesdot: "",
      lesdoto: "",
      lesdotor: "",
      lesg: "",
      lesges: "",
      lessapprox: "",
      lessdot: "",
      lesseqgtr: "",
      lesseqqgtr: "",
      LessEqualGreater: "",
      LessFullEqual: "",
      LessGreater: "",
      lessgtr: "",
      LessLess: "",
      lesssim: "",
      LessSlantEqual: "",
      LessTilde: "",
      lfisht: "",
      lfloor: "",
      Lfr: "",
      lfr: "",
      lg: "",
      lgE: "",
      lHar: "",
      lhard: "",
      lharu: "",
      lharul: "",
      lhblk: "",
      LJcy: "",
      ljcy: "",
      Ll: "",
      ll: "",
      llarr: "",
      llcorner: "",
      Lleftarrow: "",
      llhard: "",
      lltri: "",
      Lmidot: "",
      lmidot: "",
      lmoust: "",
      lmoustache: "",
      lnap: "",
      lnapprox: "",
      lnE: "",
      lne: "",
      lneq: "",
      lneqq: "",
      lnsim: "",
      loang: "",
      loarr: "",
      lobrk: "",
      LongLeftArrow: "",
      Longleftarrow: "",
      longleftarrow: "",
      LongLeftRightArrow: "",
      Longleftrightarrow: "",
      longleftrightarrow: "",
      longmapsto: "",
      LongRightArrow: "",
      Longrightarrow: "",
      longrightarrow: "",
      looparrowleft: "",
      looparrowright: "",
      lopar: "",
      Lopf: "",
      lopf: "",
      loplus: "",
      lotimes: "",
      lowast: "",
      lowbar: "_",
      LowerLeftArrow: "",
      LowerRightArrow: "",
      loz: "",
      lozenge: "",
      lozf: "",
      lpar: "(",
      lparlt: "",
      lrarr: "",
      lrcorner: "",
      lrhar: "",
      lrhard: "",
      lrm: "",
      lrtri: "",
      lsaquo: "",
      Lscr: "",
      lscr: "",
      Lsh: "",
      lsh: "",
      lsim: "",
      lsime: "",
      lsimg: "",
      lsqb: "[",
      lsquo: "",
      lsquor: "",
      Lstrok: "",
      lstrok: "",
      Lt: "",
      LT: "<",
      lt: "<",
      ltcc: "",
      ltcir: "",
      ltdot: "",
      lthree: "",
      ltimes: "",
      ltlarr: "",
      ltquest: "",
      ltri: "",
      ltrie: "",
      ltrif: "",
      ltrPar: "",
      lurdshar: "",
      luruhar: "",
      lvertneqq: "",
      lvnE: "",
      macr: "",
      male: "",
      malt: "",
      maltese: "",
      Map: "",
      map: "",
      mapsto: "",
      mapstodown: "",
      mapstoleft: "",
      mapstoup: "",
      marker: "",
      mcomma: "",
      Mcy: "",
      mcy: "",
      mdash: "",
      mDDot: "",
      measuredangle: "",
      MediumSpace: "",
      Mellintrf: "",
      Mfr: "",
      mfr: "",
      mho: "",
      micro: "",
      mid: "",
      midast: "*",
      midcir: "",
      middot: "",
      minus: "",
      minusb: "",
      minusd: "",
      minusdu: "",
      MinusPlus: "",
      mlcp: "",
      mldr: "",
      mnplus: "",
      models: "",
      Mopf: "",
      mopf: "",
      mp: "",
      Mscr: "",
      mscr: "",
      mstpos: "",
      Mu: "",
      mu: "",
      multimap: "",
      mumap: "",
      nabla: "",
      Nacute: "",
      nacute: "",
      nang: "",
      nap: "",
      napE: "",
      napid: "",
      napos: "",
      napprox: "",
      natur: "",
      natural: "",
      naturals: "",
      nbsp: "",
      nbump: "",
      nbumpe: "",
      ncap: "",
      Ncaron: "",
      ncaron: "",
      Ncedil: "",
      ncedil: "",
      ncong: "",
      ncongdot: "",
      ncup: "",
      Ncy: "",
      ncy: "",
      ndash: "",
      ne: "",
      nearhk: "",
      neArr: "",
      nearr: "",
      nearrow: "",
      nedot: "",
      NegativeMediumSpace: "",
      NegativeThickSpace: "",
      NegativeThinSpace: "",
      NegativeVeryThinSpace: "",
      nequiv: "",
      nesear: "",
      nesim: "",
      NestedGreaterGreater: "",
      NestedLessLess: "",
      NewLine: `
`,
      nexist: "",
      nexists: "",
      Nfr: "",
      nfr: "",
      ngE: "",
      nge: "",
      ngeq: "",
      ngeqq: "",
      ngeqslant: "",
      nges: "",
      nGg: "",
      ngsim: "",
      nGt: "",
      ngt: "",
      ngtr: "",
      nGtv: "",
      nhArr: "",
      nharr: "",
      nhpar: "",
      ni: "",
      nis: "",
      nisd: "",
      niv: "",
      NJcy: "",
      njcy: "",
      nlArr: "",
      nlarr: "",
      nldr: "",
      nlE: "",
      nle: "",
      nLeftarrow: "",
      nleftarrow: "",
      nLeftrightarrow: "",
      nleftrightarrow: "",
      nleq: "",
      nleqq: "",
      nleqslant: "",
      nles: "",
      nless: "",
      nLl: "",
      nlsim: "",
      nLt: "",
      nlt: "",
      nltri: "",
      nltrie: "",
      nLtv: "",
      nmid: "",
      NoBreak: "",
      NonBreakingSpace: "",
      Nopf: "",
      nopf: "",
      Not: "",
      not: "",
      NotCongruent: "",
      NotCupCap: "",
      NotDoubleVerticalBar: "",
      NotElement: "",
      NotEqual: "",
      NotEqualTilde: "",
      NotExists: "",
      NotGreater: "",
      NotGreaterEqual: "",
      NotGreaterFullEqual: "",
      NotGreaterGreater: "",
      NotGreaterLess: "",
      NotGreaterSlantEqual: "",
      NotGreaterTilde: "",
      NotHumpDownHump: "",
      NotHumpEqual: "",
      notin: "",
      notindot: "",
      notinE: "",
      notinva: "",
      notinvb: "",
      notinvc: "",
      NotLeftTriangle: "",
      NotLeftTriangleBar: "",
      NotLeftTriangleEqual: "",
      NotLess: "",
      NotLessEqual: "",
      NotLessGreater: "",
      NotLessLess: "",
      NotLessSlantEqual: "",
      NotLessTilde: "",
      NotNestedGreaterGreater: "",
      NotNestedLessLess: "",
      notni: "",
      notniva: "",
      notnivb: "",
      notnivc: "",
      NotPrecedes: "",
      NotPrecedesEqual: "",
      NotPrecedesSlantEqual: "",
      NotReverseElement: "",
      NotRightTriangle: "",
      NotRightTriangleBar: "",
      NotRightTriangleEqual: "",
      NotSquareSubset: "",
      NotSquareSubsetEqual: "",
      NotSquareSuperset: "",
      NotSquareSupersetEqual: "",
      NotSubset: "",
      NotSubsetEqual: "",
      NotSucceeds: "",
      NotSucceedsEqual: "",
      NotSucceedsSlantEqual: "",
      NotSucceedsTilde: "",
      NotSuperset: "",
      NotSupersetEqual: "",
      NotTilde: "",
      NotTildeEqual: "",
      NotTildeFullEqual: "",
      NotTildeTilde: "",
      NotVerticalBar: "",
      npar: "",
      nparallel: "",
      nparsl: "",
      npart: "",
      npolint: "",
      npr: "",
      nprcue: "",
      npre: "",
      nprec: "",
      npreceq: "",
      nrArr: "",
      nrarr: "",
      nrarrc: "",
      nrarrw: "",
      nRightarrow: "",
      nrightarrow: "",
      nrtri: "",
      nrtrie: "",
      nsc: "",
      nsccue: "",
      nsce: "",
      Nscr: "",
      nscr: "",
      nshortmid: "",
      nshortparallel: "",
      nsim: "",
      nsime: "",
      nsimeq: "",
      nsmid: "",
      nspar: "",
      nsqsube: "",
      nsqsupe: "",
      nsub: "",
      nsubE: "",
      nsube: "",
      nsubset: "",
      nsubseteq: "",
      nsubseteqq: "",
      nsucc: "",
      nsucceq: "",
      nsup: "",
      nsupE: "",
      nsupe: "",
      nsupset: "",
      nsupseteq: "",
      nsupseteqq: "",
      ntgl: "",
      Ntilde: "",
      ntilde: "",
      ntlg: "",
      ntriangleleft: "",
      ntrianglelefteq: "",
      ntriangleright: "",
      ntrianglerighteq: "",
      Nu: "",
      nu: "",
      num: "#",
      numero: "",
      numsp: "",
      nvap: "",
      nVDash: "",
      nVdash: "",
      nvDash: "",
      nvdash: "",
      nvge: "",
      nvgt: ">",
      nvHarr: "",
      nvinfin: "",
      nvlArr: "",
      nvle: "",
      nvlt: "<",
      nvltrie: "",
      nvrArr: "",
      nvrtrie: "",
      nvsim: "",
      nwarhk: "",
      nwArr: "",
      nwarr: "",
      nwarrow: "",
      nwnear: "",
      Oacute: "",
      oacute: "",
      oast: "",
      ocir: "",
      Ocirc: "",
      ocirc: "",
      Ocy: "",
      ocy: "",
      odash: "",
      Odblac: "",
      odblac: "",
      odiv: "",
      odot: "",
      odsold: "",
      OElig: "",
      oelig: "",
      ofcir: "",
      Ofr: "",
      ofr: "",
      ogon: "",
      Ograve: "",
      ograve: "",
      ogt: "",
      ohbar: "",
      ohm: "",
      oint: "",
      olarr: "",
      olcir: "",
      olcross: "",
      oline: "",
      olt: "",
      Omacr: "",
      omacr: "",
      Omega: "",
      omega: "",
      Omicron: "",
      omicron: "",
      omid: "",
      ominus: "",
      Oopf: "",
      oopf: "",
      opar: "",
      OpenCurlyDoubleQuote: "",
      OpenCurlyQuote: "",
      operp: "",
      oplus: "",
      Or: "",
      or: "",
      orarr: "",
      ord: "",
      order: "",
      orderof: "",
      ordf: "",
      ordm: "",
      origof: "",
      oror: "",
      orslope: "",
      orv: "",
      oS: "",
      Oscr: "",
      oscr: "",
      Oslash: "",
      oslash: "",
      osol: "",
      Otilde: "",
      otilde: "",
      Otimes: "",
      otimes: "",
      otimesas: "",
      Ouml: "",
      ouml: "",
      ovbar: "",
      OverBar: "",
      OverBrace: "",
      OverBracket: "",
      OverParenthesis: "",
      par: "",
      para: "",
      parallel: "",
      parsim: "",
      parsl: "",
      part: "",
      PartialD: "",
      Pcy: "",
      pcy: "",
      percnt: "%",
      period: ".",
      permil: "",
      perp: "",
      pertenk: "",
      Pfr: "",
      pfr: "",
      Phi: "",
      phi: "",
      phiv: "",
      phmmat: "",
      phone: "",
      Pi: "",
      pi: "",
      pitchfork: "",
      piv: "",
      planck: "",
      planckh: "",
      plankv: "",
      plus: "+",
      plusacir: "",
      plusb: "",
      pluscir: "",
      plusdo: "",
      plusdu: "",
      pluse: "",
      PlusMinus: "",
      plusmn: "",
      plussim: "",
      plustwo: "",
      pm: "",
      Poincareplane: "",
      pointint: "",
      Popf: "",
      popf: "",
      pound: "",
      Pr: "",
      pr: "",
      prap: "",
      prcue: "",
      prE: "",
      pre: "",
      prec: "",
      precapprox: "",
      preccurlyeq: "",
      Precedes: "",
      PrecedesEqual: "",
      PrecedesSlantEqual: "",
      PrecedesTilde: "",
      preceq: "",
      precnapprox: "",
      precneqq: "",
      precnsim: "",
      precsim: "",
      Prime: "",
      prime: "",
      primes: "",
      prnap: "",
      prnE: "",
      prnsim: "",
      prod: "",
      Product: "",
      profalar: "",
      profline: "",
      profsurf: "",
      prop: "",
      Proportion: "",
      Proportional: "",
      propto: "",
      prsim: "",
      prurel: "",
      Pscr: "",
      pscr: "",
      Psi: "",
      psi: "",
      puncsp: "",
      Qfr: "",
      qfr: "",
      qint: "",
      Qopf: "",
      qopf: "",
      qprime: "",
      Qscr: "",
      qscr: "",
      quaternions: "",
      quatint: "",
      quest: "?",
      questeq: "",
      QUOT: '"',
      quot: '"',
      rAarr: "",
      race: "",
      Racute: "",
      racute: "",
      radic: "",
      raemptyv: "",
      Rang: "",
      rang: "",
      rangd: "",
      range: "",
      rangle: "",
      raquo: "",
      Rarr: "",
      rArr: "",
      rarr: "",
      rarrap: "",
      rarrb: "",
      rarrbfs: "",
      rarrc: "",
      rarrfs: "",
      rarrhk: "",
      rarrlp: "",
      rarrpl: "",
      rarrsim: "",
      Rarrtl: "",
      rarrtl: "",
      rarrw: "",
      rAtail: "",
      ratail: "",
      ratio: "",
      rationals: "",
      RBarr: "",
      rBarr: "",
      rbarr: "",
      rbbrk: "",
      rbrace: "}",
      rbrack: "]",
      rbrke: "",
      rbrksld: "",
      rbrkslu: "",
      Rcaron: "",
      rcaron: "",
      Rcedil: "",
      rcedil: "",
      rceil: "",
      rcub: "}",
      Rcy: "",
      rcy: "",
      rdca: "",
      rdldhar: "",
      rdquo: "",
      rdquor: "",
      rdsh: "",
      Re: "",
      real: "",
      realine: "",
      realpart: "",
      reals: "",
      rect: "",
      REG: "",
      reg: "",
      ReverseElement: "",
      ReverseEquilibrium: "",
      ReverseUpEquilibrium: "",
      rfisht: "",
      rfloor: "",
      Rfr: "",
      rfr: "",
      rHar: "",
      rhard: "",
      rharu: "",
      rharul: "",
      Rho: "",
      rho: "",
      rhov: "",
      RightAngleBracket: "",
      RightArrow: "",
      Rightarrow: "",
      rightarrow: "",
      RightArrowBar: "",
      RightArrowLeftArrow: "",
      rightarrowtail: "",
      RightCeiling: "",
      RightDoubleBracket: "",
      RightDownTeeVector: "",
      RightDownVector: "",
      RightDownVectorBar: "",
      RightFloor: "",
      rightharpoondown: "",
      rightharpoonup: "",
      rightleftarrows: "",
      rightleftharpoons: "",
      rightrightarrows: "",
      rightsquigarrow: "",
      RightTee: "",
      RightTeeArrow: "",
      RightTeeVector: "",
      rightthreetimes: "",
      RightTriangle: "",
      RightTriangleBar: "",
      RightTriangleEqual: "",
      RightUpDownVector: "",
      RightUpTeeVector: "",
      RightUpVector: "",
      RightUpVectorBar: "",
      RightVector: "",
      RightVectorBar: "",
      ring: "",
      risingdotseq: "",
      rlarr: "",
      rlhar: "",
      rlm: "",
      rmoust: "",
      rmoustache: "",
      rnmid: "",
      roang: "",
      roarr: "",
      robrk: "",
      ropar: "",
      Ropf: "",
      ropf: "",
      roplus: "",
      rotimes: "",
      RoundImplies: "",
      rpar: ")",
      rpargt: "",
      rppolint: "",
      rrarr: "",
      Rrightarrow: "",
      rsaquo: "",
      Rscr: "",
      rscr: "",
      Rsh: "",
      rsh: "",
      rsqb: "]",
      rsquo: "",
      rsquor: "",
      rthree: "",
      rtimes: "",
      rtri: "",
      rtrie: "",
      rtrif: "",
      rtriltri: "",
      RuleDelayed: "",
      ruluhar: "",
      rx: "",
      Sacute: "",
      sacute: "",
      sbquo: "",
      Sc: "",
      sc: "",
      scap: "",
      Scaron: "",
      scaron: "",
      sccue: "",
      scE: "",
      sce: "",
      Scedil: "",
      scedil: "",
      Scirc: "",
      scirc: "",
      scnap: "",
      scnE: "",
      scnsim: "",
      scpolint: "",
      scsim: "",
      Scy: "",
      scy: "",
      sdot: "",
      sdotb: "",
      sdote: "",
      searhk: "",
      seArr: "",
      searr: "",
      searrow: "",
      sect: "",
      semi: ";",
      seswar: "",
      setminus: "",
      setmn: "",
      sext: "",
      Sfr: "",
      sfr: "",
      sfrown: "",
      sharp: "",
      SHCHcy: "",
      shchcy: "",
      SHcy: "",
      shcy: "",
      ShortDownArrow: "",
      ShortLeftArrow: "",
      shortmid: "",
      shortparallel: "",
      ShortRightArrow: "",
      ShortUpArrow: "",
      shy: "",
      Sigma: "",
      sigma: "",
      sigmaf: "",
      sigmav: "",
      sim: "",
      simdot: "",
      sime: "",
      simeq: "",
      simg: "",
      simgE: "",
      siml: "",
      simlE: "",
      simne: "",
      simplus: "",
      simrarr: "",
      slarr: "",
      SmallCircle: "",
      smallsetminus: "",
      smashp: "",
      smeparsl: "",
      smid: "",
      smile: "",
      smt: "",
      smte: "",
      smtes: "",
      SOFTcy: "",
      softcy: "",
      sol: "/",
      solb: "",
      solbar: "",
      Sopf: "",
      sopf: "",
      spades: "",
      spadesuit: "",
      spar: "",
      sqcap: "",
      sqcaps: "",
      sqcup: "",
      sqcups: "",
      Sqrt: "",
      sqsub: "",
      sqsube: "",
      sqsubset: "",
      sqsubseteq: "",
      sqsup: "",
      sqsupe: "",
      sqsupset: "",
      sqsupseteq: "",
      squ: "",
      Square: "",
      square: "",
      SquareIntersection: "",
      SquareSubset: "",
      SquareSubsetEqual: "",
      SquareSuperset: "",
      SquareSupersetEqual: "",
      SquareUnion: "",
      squarf: "",
      squf: "",
      srarr: "",
      Sscr: "",
      sscr: "",
      ssetmn: "",
      ssmile: "",
      sstarf: "",
      Star: "",
      star: "",
      starf: "",
      straightepsilon: "",
      straightphi: "",
      strns: "",
      Sub: "",
      sub: "",
      subdot: "",
      subE: "",
      sube: "",
      subedot: "",
      submult: "",
      subnE: "",
      subne: "",
      subplus: "",
      subrarr: "",
      Subset: "",
      subset: "",
      subseteq: "",
      subseteqq: "",
      SubsetEqual: "",
      subsetneq: "",
      subsetneqq: "",
      subsim: "",
      subsub: "",
      subsup: "",
      succ: "",
      succapprox: "",
      succcurlyeq: "",
      Succeeds: "",
      SucceedsEqual: "",
      SucceedsSlantEqual: "",
      SucceedsTilde: "",
      succeq: "",
      succnapprox: "",
      succneqq: "",
      succnsim: "",
      succsim: "",
      SuchThat: "",
      Sum: "",
      sum: "",
      sung: "",
      Sup: "",
      sup: "",
      sup1: "",
      sup2: "",
      sup3: "",
      supdot: "",
      supdsub: "",
      supE: "",
      supe: "",
      supedot: "",
      Superset: "",
      SupersetEqual: "",
      suphsol: "",
      suphsub: "",
      suplarr: "",
      supmult: "",
      supnE: "",
      supne: "",
      supplus: "",
      Supset: "",
      supset: "",
      supseteq: "",
      supseteqq: "",
      supsetneq: "",
      supsetneqq: "",
      supsim: "",
      supsub: "",
      supsup: "",
      swarhk: "",
      swArr: "",
      swarr: "",
      swarrow: "",
      swnwar: "",
      szlig: "",
      Tab: "	",
      target: "",
      Tau: "",
      tau: "",
      tbrk: "",
      Tcaron: "",
      tcaron: "",
      Tcedil: "",
      tcedil: "",
      Tcy: "",
      tcy: "",
      tdot: "",
      telrec: "",
      Tfr: "",
      tfr: "",
      there4: "",
      Therefore: "",
      therefore: "",
      Theta: "",
      theta: "",
      thetasym: "",
      thetav: "",
      thickapprox: "",
      thicksim: "",
      ThickSpace: "",
      thinsp: "",
      ThinSpace: "",
      thkap: "",
      thksim: "",
      THORN: "",
      thorn: "",
      Tilde: "",
      tilde: "",
      TildeEqual: "",
      TildeFullEqual: "",
      TildeTilde: "",
      times: "",
      timesb: "",
      timesbar: "",
      timesd: "",
      tint: "",
      toea: "",
      top: "",
      topbot: "",
      topcir: "",
      Topf: "",
      topf: "",
      topfork: "",
      tosa: "",
      tprime: "",
      TRADE: "",
      trade: "",
      triangle: "",
      triangledown: "",
      triangleleft: "",
      trianglelefteq: "",
      triangleq: "",
      triangleright: "",
      trianglerighteq: "",
      tridot: "",
      trie: "",
      triminus: "",
      TripleDot: "",
      triplus: "",
      trisb: "",
      tritime: "",
      trpezium: "",
      Tscr: "",
      tscr: "",
      TScy: "",
      tscy: "",
      TSHcy: "",
      tshcy: "",
      Tstrok: "",
      tstrok: "",
      twixt: "",
      twoheadleftarrow: "",
      twoheadrightarrow: "",
      Uacute: "",
      uacute: "",
      Uarr: "",
      uArr: "",
      uarr: "",
      Uarrocir: "",
      Ubrcy: "",
      ubrcy: "",
      Ubreve: "",
      ubreve: "",
      Ucirc: "",
      ucirc: "",
      Ucy: "",
      ucy: "",
      udarr: "",
      Udblac: "",
      udblac: "",
      udhar: "",
      ufisht: "",
      Ufr: "",
      ufr: "",
      Ugrave: "",
      ugrave: "",
      uHar: "",
      uharl: "",
      uharr: "",
      uhblk: "",
      ulcorn: "",
      ulcorner: "",
      ulcrop: "",
      ultri: "",
      Umacr: "",
      umacr: "",
      uml: "",
      UnderBar: "_",
      UnderBrace: "",
      UnderBracket: "",
      UnderParenthesis: "",
      Union: "",
      UnionPlus: "",
      Uogon: "",
      uogon: "",
      Uopf: "",
      uopf: "",
      UpArrow: "",
      Uparrow: "",
      uparrow: "",
      UpArrowBar: "",
      UpArrowDownArrow: "",
      UpDownArrow: "",
      Updownarrow: "",
      updownarrow: "",
      UpEquilibrium: "",
      upharpoonleft: "",
      upharpoonright: "",
      uplus: "",
      UpperLeftArrow: "",
      UpperRightArrow: "",
      Upsi: "",
      upsi: "",
      upsih: "",
      Upsilon: "",
      upsilon: "",
      UpTee: "",
      UpTeeArrow: "",
      upuparrows: "",
      urcorn: "",
      urcorner: "",
      urcrop: "",
      Uring: "",
      uring: "",
      urtri: "",
      Uscr: "",
      uscr: "",
      utdot: "",
      Utilde: "",
      utilde: "",
      utri: "",
      utrif: "",
      uuarr: "",
      Uuml: "",
      uuml: "",
      uwangle: "",
      vangrt: "",
      varepsilon: "",
      varkappa: "",
      varnothing: "",
      varphi: "",
      varpi: "",
      varpropto: "",
      vArr: "",
      varr: "",
      varrho: "",
      varsigma: "",
      varsubsetneq: "",
      varsubsetneqq: "",
      varsupsetneq: "",
      varsupsetneqq: "",
      vartheta: "",
      vartriangleleft: "",
      vartriangleright: "",
      Vbar: "",
      vBar: "",
      vBarv: "",
      Vcy: "",
      vcy: "",
      VDash: "",
      Vdash: "",
      vDash: "",
      vdash: "",
      Vdashl: "",
      Vee: "",
      vee: "",
      veebar: "",
      veeeq: "",
      vellip: "",
      Verbar: "",
      verbar: "|",
      Vert: "",
      vert: "|",
      VerticalBar: "",
      VerticalLine: "|",
      VerticalSeparator: "",
      VerticalTilde: "",
      VeryThinSpace: "",
      Vfr: "",
      vfr: "",
      vltri: "",
      vnsub: "",
      vnsup: "",
      Vopf: "",
      vopf: "",
      vprop: "",
      vrtri: "",
      Vscr: "",
      vscr: "",
      vsubnE: "",
      vsubne: "",
      vsupnE: "",
      vsupne: "",
      Vvdash: "",
      vzigzag: "",
      Wcirc: "",
      wcirc: "",
      wedbar: "",
      Wedge: "",
      wedge: "",
      wedgeq: "",
      weierp: "",
      Wfr: "",
      wfr: "",
      Wopf: "",
      wopf: "",
      wp: "",
      wr: "",
      wreath: "",
      Wscr: "",
      wscr: "",
      xcap: "",
      xcirc: "",
      xcup: "",
      xdtri: "",
      Xfr: "",
      xfr: "",
      xhArr: "",
      xharr: "",
      Xi: "",
      xi: "",
      xlArr: "",
      xlarr: "",
      xmap: "",
      xnis: "",
      xodot: "",
      Xopf: "",
      xopf: "",
      xoplus: "",
      xotime: "",
      xrArr: "",
      xrarr: "",
      Xscr: "",
      xscr: "",
      xsqcup: "",
      xuplus: "",
      xutri: "",
      xvee: "",
      xwedge: "",
      Yacute: "",
      yacute: "",
      YAcy: "",
      yacy: "",
      Ycirc: "",
      ycirc: "",
      Ycy: "",
      ycy: "",
      yen: "",
      Yfr: "",
      yfr: "",
      YIcy: "",
      yicy: "",
      Yopf: "",
      yopf: "",
      Yscr: "",
      yscr: "",
      YUcy: "",
      yucy: "",
      Yuml: "",
      yuml: "",
      Zacute: "",
      zacute: "",
      Zcaron: "",
      zcaron: "",
      Zcy: "",
      zcy: "",
      Zdot: "",
      zdot: "",
      zeetrf: "",
      ZeroWidthSpace: "",
      Zeta: "",
      zeta: "",
      Zfr: "",
      zfr: "",
      ZHcy: "",
      zhcy: "",
      zigrarr: "",
      Zopf: "",
      zopf: "",
      Zscr: "",
      zscr: "",
      zwj: "",
      zwnj: ""
    }), s.entityMap = s.HTML_ENTITIES;
  }(Mp)), Mp;
}
var id = {}, l0;
function Ix() {
  if (l0) return id;
  l0 = 1;
  var s = Ad().NAMESPACE, l = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, a = new RegExp("[\\-\\.0-9" + l.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), m = new RegExp("^" + l.source + a.source + "*(?::" + l.source + a.source + "*)?$"), y = 0, _ = 1, g = 2, o = 3, k = 4, D = 5, L = 6, j = 7;
  function O(me, ve) {
    this.message = me, this.locator = ve, Error.captureStackTrace && Error.captureStackTrace(this, O);
  }
  O.prototype = new Error(), O.prototype.name = O.name;
  function z() {
  }
  z.prototype = {
    parse: function(me, ve, X) {
      var re = this.domBuilder;
      re.startDocument(), ze(ve, ve = {}), pe(
        me,
        ve,
        X,
        re,
        this.errorHandler
      ), re.endDocument();
    }
  };
  function pe(me, ve, X, re, xe) {
    function ye(At) {
      if (At > 65535) {
        At -= 65536;
        var Et = 55296 + (At >> 10), jt = 56320 + (At & 1023);
        return String.fromCharCode(Et, jt);
      } else
        return String.fromCharCode(At);
    }
    function Ve(At) {
      var Et = At.slice(1, -1);
      return Object.hasOwnProperty.call(X, Et) ? X[Et] : Et.charAt(0) === "#" ? ye(parseInt(Et.substr(1).replace("x", "0x"))) : (xe.error("entity not found:" + At), At);
    }
    function He(At) {
      if (At > be) {
        var Et = me.substring(be, At).replace(/&#?\w+;/g, Ve);
        st && Ze(be), re.characters(Et, 0, At - be), be = At;
      }
    }
    function Ze(At, Et) {
      for (; At >= Je && (Et = et.exec(me)); )
        qe = Et.index, Je = qe + Et[0].length, st.lineNumber++;
      st.columnNumber = At - qe + 1;
    }
    for (var qe = 0, Je = 0, et = /.*(?:\r\n?|\n)|.*$/g, st = re.locator, ee = [{ currentNSMap: ve }], _e = {}, be = 0; ; ) {
      try {
        var Te = me.indexOf("<", be);
        if (Te < 0) {
          if (!me.substr(be).match(/^\s*$/)) {
            var Oe = re.doc, $e = Oe.createTextNode(me.substr(be));
            Oe.appendChild($e), re.currentElement = $e;
          }
          return;
        }
        switch (Te > be && He(Te), me.charAt(Te + 1)) {
          case "/":
            var Y = me.indexOf(">", Te + 3), Ue = me.substring(Te + 2, Y).replace(/[ \t\n\r]+$/g, ""), Ke = ee.pop();
            Y < 0 ? (Ue = me.substring(Te + 2).replace(/[\s<].*/, ""), xe.error("end tag name: " + Ue + " is not complete:" + Ke.tagName), Y = Te + 1 + Ue.length) : Ue.match(/\s</) && (Ue = Ue.replace(/[\s<].*/, ""), xe.error("end tag name: " + Ue + " maybe not complete"), Y = Te + 1 + Ue.length);
            var nt = Ke.localNSMap, ot = Ke.tagName == Ue, vt = ot || Ke.tagName && Ke.tagName.toLowerCase() == Ue.toLowerCase();
            if (vt) {
              if (re.endElement(Ke.uri, Ke.localName, Ue), nt)
                for (var mt in nt)
                  Object.prototype.hasOwnProperty.call(nt, mt) && re.endPrefixMapping(mt);
              ot || xe.fatalError("end tag name: " + Ue + " is not match the current start tagName:" + Ke.tagName);
            } else
              ee.push(Ke);
            Y++;
            break;
          case "?":
            st && Ze(Te), Y = Qe(me, Te, re);
            break;
          case "!":
            st && Ze(Te), Y = je(me, Te, re, xe);
            break;
          default:
            st && Ze(Te);
            var Pt = new ke(), rt = ee[ee.length - 1].currentNSMap, Y = ae(me, Te, Pt, rt, Ve, xe), Kt = Pt.length;
            if (!Pt.closed && Ce(me, Y, Pt.tagName, _e) && (Pt.closed = !0, X.nbsp || xe.warning("unclosed xml attribute")), st && Kt) {
              for (var Rt = oe(st, {}), lt = 0; lt < Kt; lt++) {
                var xt = Pt[lt];
                Ze(xt.offset), xt.locator = oe(st, {});
              }
              re.locator = Rt, Q(Pt, re, rt) && ee.push(Pt), re.locator = st;
            } else
              Q(Pt, re, rt) && ee.push(Pt);
            s.isHTML(Pt.uri) && !Pt.closed ? Y = fe(me, Y, Pt.tagName, Ve, re) : Y++;
        }
      } catch (At) {
        if (At instanceof O)
          throw At;
        xe.error("element parse error: " + At), Y = -1;
      }
      Y > be ? be = Y : He(Math.max(Te, be) + 1);
    }
  }
  function oe(me, ve) {
    return ve.lineNumber = me.lineNumber, ve.columnNumber = me.columnNumber, ve;
  }
  function ae(me, ve, X, re, xe, ye) {
    function Ve(st, ee, _e) {
      X.attributeNames.hasOwnProperty(st) && ye.fatalError("Attribute " + st + " redefined"), X.addValue(
        st,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        ee.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, xe),
        _e
      );
    }
    for (var He, Ze, qe = ++ve, Je = y; ; ) {
      var et = me.charAt(qe);
      switch (et) {
        case "=":
          if (Je === _)
            He = me.slice(ve, qe), Je = o;
          else if (Je === g)
            Je = o;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (Je === o || Je === _)
            if (Je === _ && (ye.warning('attribute value must after "="'), He = me.slice(ve, qe)), ve = qe + 1, qe = me.indexOf(et, ve), qe > 0)
              Ze = me.slice(ve, qe), Ve(He, Ze, ve - 1), Je = D;
            else
              throw new Error("attribute value no end '" + et + "' match");
          else if (Je == k)
            Ze = me.slice(ve, qe), Ve(He, Ze, ve), ye.warning('attribute "' + He + '" missed start quot(' + et + ")!!"), ve = qe + 1, Je = D;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (Je) {
            case y:
              X.setTagName(me.slice(ve, qe));
            case D:
            case L:
            case j:
              Je = j, X.closed = !0;
            case k:
            case _:
              break;
            case g:
              X.closed = !0;
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return ye.error("unexpected end of input"), Je == y && X.setTagName(me.slice(ve, qe)), qe;
        case ">":
          switch (Je) {
            case y:
              X.setTagName(me.slice(ve, qe));
            case D:
            case L:
            case j:
              break;
            case k:
            case _:
              Ze = me.slice(ve, qe), Ze.slice(-1) === "/" && (X.closed = !0, Ze = Ze.slice(0, -1));
            case g:
              Je === g && (Ze = He), Je == k ? (ye.warning('attribute "' + Ze + '" missed quot(")!'), Ve(He, Ze, ve)) : ((!s.isHTML(re[""]) || !Ze.match(/^(?:disabled|checked|selected)$/i)) && ye.warning('attribute "' + Ze + '" missed value!! "' + Ze + '" instead!!'), Ve(Ze, Ze, ve));
              break;
            case o:
              throw new Error("attribute value missed!!");
          }
          return qe;
        case "":
          et = " ";
        default:
          if (et <= " ")
            switch (Je) {
              case y:
                X.setTagName(me.slice(ve, qe)), Je = L;
                break;
              case _:
                He = me.slice(ve, qe), Je = g;
                break;
              case k:
                var Ze = me.slice(ve, qe);
                ye.warning('attribute "' + Ze + '" missed quot(")!!'), Ve(He, Ze, ve);
              case D:
                Je = L;
                break;
            }
          else
            switch (Je) {
              case g:
                X.tagName, (!s.isHTML(re[""]) || !He.match(/^(?:disabled|checked|selected)$/i)) && ye.warning('attribute "' + He + '" missed value!! "' + He + '" instead2!!'), Ve(He, He, ve), ve = qe, Je = _;
                break;
              case D:
                ye.warning('attribute space is required"' + He + '"!!');
              case L:
                Je = _, ve = qe;
                break;
              case o:
                Je = k, ve = qe;
                break;
              case j:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      qe++;
    }
  }
  function Q(me, ve, X) {
    for (var re = me.tagName, xe = null, et = me.length; et--; ) {
      var ye = me[et], Ve = ye.qName, He = ye.value, st = Ve.indexOf(":");
      if (st > 0)
        var Ze = ye.prefix = Ve.slice(0, st), qe = Ve.slice(st + 1), Je = Ze === "xmlns" && qe;
      else
        qe = Ve, Ze = null, Je = Ve === "xmlns" && "";
      ye.localName = qe, Je !== !1 && (xe == null && (xe = {}, ze(X, X = {})), X[Je] = xe[Je] = He, ye.uri = s.XMLNS, ve.startPrefixMapping(Je, He));
    }
    for (var et = me.length; et--; ) {
      ye = me[et];
      var Ze = ye.prefix;
      Ze && (Ze === "xml" && (ye.uri = s.XML), Ze !== "xmlns" && (ye.uri = X[Ze || ""]));
    }
    var st = re.indexOf(":");
    st > 0 ? (Ze = me.prefix = re.slice(0, st), qe = me.localName = re.slice(st + 1)) : (Ze = null, qe = me.localName = re);
    var ee = me.uri = X[Ze || ""];
    if (ve.startElement(ee, qe, re, me), me.closed) {
      if (ve.endElement(ee, qe, re), xe)
        for (Ze in xe)
          Object.prototype.hasOwnProperty.call(xe, Ze) && ve.endPrefixMapping(Ze);
    } else
      return me.currentNSMap = X, me.localNSMap = xe, !0;
  }
  function fe(me, ve, X, re, xe) {
    if (/^(?:script|textarea)$/i.test(X)) {
      var ye = me.indexOf("</" + X + ">", ve), Ve = me.substring(ve + 1, ye);
      if (/[&<]/.test(Ve))
        return /^script$/i.test(X) ? (xe.characters(Ve, 0, Ve.length), ye) : (Ve = Ve.replace(/&#?\w+;/g, re), xe.characters(Ve, 0, Ve.length), ye);
    }
    return ve + 1;
  }
  function Ce(me, ve, X, re) {
    var xe = re[X];
    return xe == null && (xe = me.lastIndexOf("</" + X + ">"), xe < ve && (xe = me.lastIndexOf("</" + X)), re[X] = xe), xe < ve;
  }
  function ze(me, ve) {
    for (var X in me)
      Object.prototype.hasOwnProperty.call(me, X) && (ve[X] = me[X]);
  }
  function je(me, ve, X, re) {
    var xe = me.charAt(ve + 2);
    switch (xe) {
      case "-":
        if (me.charAt(ve + 3) === "-") {
          var ye = me.indexOf("-->", ve + 4);
          return ye > ve ? (X.comment(me, ve + 4, ye - ve - 4), ye + 3) : (re.error("Unclosed comment"), -1);
        } else
          return -1;
      default:
        if (me.substr(ve + 3, 6) == "CDATA[") {
          var ye = me.indexOf("]]>", ve + 9);
          return X.startCDATA(), X.characters(me, ve + 9, ye - ve - 9), X.endCDATA(), ye + 3;
        }
        var Ve = Ae(me, ve), He = Ve.length;
        if (He > 1 && /!doctype/i.test(Ve[0][0])) {
          var Ze = Ve[1][0], qe = !1, Je = !1;
          He > 3 && (/^public$/i.test(Ve[2][0]) ? (qe = Ve[3][0], Je = He > 4 && Ve[4][0]) : /^system$/i.test(Ve[2][0]) && (Je = Ve[3][0]));
          var et = Ve[He - 1];
          return X.startDTD(Ze, qe, Je), X.endDTD(), et.index + et[0].length;
        }
    }
    return -1;
  }
  function Qe(me, ve, X) {
    var re = me.indexOf("?>", ve);
    if (re) {
      var xe = me.substring(ve, re).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      return xe ? (xe[0].length, X.processingInstruction(xe[1], xe[2]), re + 2) : -1;
    }
    return -1;
  }
  function ke() {
    this.attributeNames = {};
  }
  ke.prototype = {
    setTagName: function(me) {
      if (!m.test(me))
        throw new Error("invalid tagName:" + me);
      this.tagName = me;
    },
    addValue: function(me, ve, X) {
      if (!m.test(me))
        throw new Error("invalid attribute:" + me);
      this.attributeNames[me] = this.length, this[this.length++] = { qName: me, value: ve, offset: X };
    },
    length: 0,
    getLocalName: function(me) {
      return this[me].localName;
    },
    getLocator: function(me) {
      return this[me].locator;
    },
    getQName: function(me) {
      return this[me].qName;
    },
    getURI: function(me) {
      return this[me].uri;
    },
    getValue: function(me) {
      return this[me].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function Ae(me, ve) {
    var X, re = [], xe = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    for (xe.lastIndex = ve, xe.exec(me); X = xe.exec(me); )
      if (re.push(X), X[1]) return re;
  }
  return id.XMLReader = z, id.ParseError = O, id;
}
var u0;
function Px() {
  if (u0) return sh;
  u0 = 1;
  var s = Ad(), l = v1(), a = Dx(), m = Ix(), y = l.DOMImplementation, _ = s.NAMESPACE, g = m.ParseError, o = m.XMLReader;
  function k(ae) {
    return ae.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
  }
  function D(ae) {
    this.options = ae || { locator: {} };
  }
  D.prototype.parseFromString = function(ae, Q) {
    var fe = this.options, Ce = new o(), ze = fe.domBuilder || new j(), je = fe.errorHandler, Qe = fe.locator, ke = fe.xmlns || {}, Ae = /\/x?html?$/.test(Q), me = Ae ? a.HTML_ENTITIES : a.XML_ENTITIES;
    Qe && ze.setDocumentLocator(Qe), Ce.errorHandler = L(je, ze, Qe), Ce.domBuilder = fe.domBuilder || ze, Ae && (ke[""] = _.HTML), ke.xml = ke.xml || _.XML;
    var ve = fe.normalizeLineEndings || k;
    return ae && typeof ae == "string" ? Ce.parse(
      ve(ae),
      ke,
      me
    ) : Ce.errorHandler.error("invalid doc source"), ze.doc;
  };
  function L(ae, Q, fe) {
    if (!ae) {
      if (Q instanceof j)
        return Q;
      ae = Q;
    }
    var Ce = {}, ze = ae instanceof Function;
    fe = fe || {};
    function je(Qe) {
      var ke = ae[Qe];
      !ke && ze && (ke = ae.length == 2 ? function(Ae) {
        ae(Qe, Ae);
      } : ae), Ce[Qe] = ke && function(Ae) {
        ke("[xmldom " + Qe + "]	" + Ae + z(fe));
      } || function() {
      };
    }
    return je("warning"), je("error"), je("fatalError"), Ce;
  }
  function j() {
    this.cdata = !1;
  }
  function O(ae, Q) {
    Q.lineNumber = ae.lineNumber, Q.columnNumber = ae.columnNumber;
  }
  j.prototype = {
    startDocument: function() {
      this.doc = new y().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
    },
    startElement: function(ae, Q, fe, Ce) {
      var ze = this.doc, je = ze.createElementNS(ae, fe || Q), Qe = Ce.length;
      oe(this, je), this.currentElement = je, this.locator && O(this.locator, je);
      for (var ke = 0; ke < Qe; ke++) {
        var ae = Ce.getURI(ke), Ae = Ce.getValue(ke), fe = Ce.getQName(ke), me = ze.createAttributeNS(ae, fe);
        this.locator && O(Ce.getLocator(ke), me), me.value = me.nodeValue = Ae, je.setAttributeNode(me);
      }
    },
    endElement: function(ae, Q, fe) {
      var Ce = this.currentElement;
      Ce.tagName, this.currentElement = Ce.parentNode;
    },
    startPrefixMapping: function(ae, Q) {
    },
    endPrefixMapping: function(ae) {
    },
    processingInstruction: function(ae, Q) {
      var fe = this.doc.createProcessingInstruction(ae, Q);
      this.locator && O(this.locator, fe), oe(this, fe);
    },
    ignorableWhitespace: function(ae, Q, fe) {
    },
    characters: function(ae, Q, fe) {
      if (ae = pe.apply(this, arguments), ae) {
        if (this.cdata)
          var Ce = this.doc.createCDATASection(ae);
        else
          var Ce = this.doc.createTextNode(ae);
        this.currentElement ? this.currentElement.appendChild(Ce) : /^\s*$/.test(ae) && this.doc.appendChild(Ce), this.locator && O(this.locator, Ce);
      }
    },
    skippedEntity: function(ae) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(ae) {
      (this.locator = ae) && (ae.lineNumber = 0);
    },
    //LexicalHandler
    comment: function(ae, Q, fe) {
      ae = pe.apply(this, arguments);
      var Ce = this.doc.createComment(ae);
      this.locator && O(this.locator, Ce), oe(this, Ce);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(ae, Q, fe) {
      var Ce = this.doc.implementation;
      if (Ce && Ce.createDocumentType) {
        var ze = Ce.createDocumentType(ae, Q, fe);
        this.locator && O(this.locator, ze), oe(this, ze), this.doc.doctype = ze;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(ae) {
      console.warn("[xmldom warning]	" + ae, z(this.locator));
    },
    error: function(ae) {
      console.error("[xmldom error]	" + ae, z(this.locator));
    },
    fatalError: function(ae) {
      throw new g(ae, this.locator);
    }
  };
  function z(ae) {
    if (ae)
      return `
@` + (ae.systemId || "") + "#[line:" + ae.lineNumber + ",col:" + ae.columnNumber + "]";
  }
  function pe(ae, Q, fe) {
    return typeof ae == "string" ? ae.substr(Q, fe) : ae.length >= Q + fe || Q ? new java.lang.String(ae, Q, fe) + "" : ae;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(ae) {
    j.prototype[ae] = function() {
      return null;
    };
  });
  function oe(ae, Q) {
    ae.currentElement ? ae.currentElement.appendChild(Q) : ae.doc.appendChild(Q);
  }
  return sh.__DOMHandler = j, sh.normalizeLineEndings = k, sh.DOMParser = D, sh;
}
var c0;
function Lx() {
  if (c0) return nh;
  c0 = 1;
  var s = v1();
  return nh.DOMImplementation = s.DOMImplementation, nh.XMLSerializer = s.XMLSerializer, nh.DOMParser = Px().DOMParser, nh;
}
(function(s, l) {
  var a = function() {
    var m = /\s*/g, y = /^\s*|\s*$/g, _ = /\s+/;
    function g(me) {
      if (!me || !me.length) return 0;
      for (var ve = 0, X = 0; ve < me.length; ve++)
        X = (X << 5) - X + me.charCodeAt(ve) | 0;
      return X;
    }
    function o(me, ve) {
      return me.getElementsByTagName(ve);
    }
    function k(me, ve) {
      return me.getAttribute(ve);
    }
    function D(me, ve) {
      return parseFloat(k(me, ve));
    }
    function L(me, ve) {
      var X = o(me, ve);
      return X.length ? X[0] : null;
    }
    function j(me) {
      return me.normalize && me.normalize(), me;
    }
    function O(me) {
      for (var ve = 0, X = []; ve < me.length; ve++)
        X[ve] = parseFloat(me[ve]);
      return X;
    }
    function z(me) {
      return me && j(me), me && me.textContent || "";
    }
    function pe(me, ve) {
      var X = {}, re, xe;
      for (xe = 0; xe < ve.length; xe++)
        re = L(me, ve[xe]), re && (X[ve[xe]] = z(re));
      return X;
    }
    function oe(me, ve) {
      for (var X in ve) me[X] = ve[X];
    }
    function ae(me) {
      return O(me.replace(m, "").split(","));
    }
    function Q(me) {
      for (var ve = me.replace(y, "").split(_), X = [], re = 0; re < ve.length; re++)
        X.push(ae(ve[re]));
      return X;
    }
    function fe(me) {
      var ve = [D(me, "lon"), D(me, "lat")], X = L(me, "ele"), re = L(me, "gpxtpx:hr") || L(me, "hr"), xe = L(me, "time"), ye;
      return X && (ye = parseFloat(z(X)), isNaN(ye) || ve.push(ye)), {
        coordinates: ve,
        time: xe ? z(xe) : null,
        heartRate: re ? parseFloat(z(re)) : null
      };
    }
    function Ce() {
      return {
        type: "FeatureCollection",
        features: []
      };
    }
    var ze;
    if (typeof XMLSerializer < "u")
      ze = new XMLSerializer();
    else {
      var je = typeof process == "object" && !process.browser, Qe = typeof Titanium == "object";
      if (je || Qe)
        ze = new (Lx()).XMLSerializer();
      else
        throw new Error("Unable to initialize serializer");
    }
    function ke(me) {
      return me.xml !== void 0 ? me.xml : ze.serializeToString(me);
    }
    var Ae = {
      kml: function(me) {
        for (var ve = Ce(), X = {}, re = {}, xe = {}, ye = ["Polygon", "LineString", "Point", "Track", "gx:Track"], Ve = o(me, "Placemark"), He = o(me, "Style"), Ze = o(me, "StyleMap"), qe = 0; qe < He.length; qe++) {
          var Je = g(ke(He[qe])).toString(16);
          X["#" + k(He[qe], "id")] = Je, re[Je] = He[qe];
        }
        for (var et = 0; et < Ze.length; et++) {
          X["#" + k(Ze[et], "id")] = g(ke(Ze[et])).toString(16);
          for (var st = o(Ze[et], "Pair"), ee = {}, _e = 0; _e < st.length; _e++)
            ee[z(L(st[_e], "key"))] = z(L(st[_e], "styleUrl"));
          xe["#" + k(Ze[et], "id")] = ee;
        }
        for (var be = 0; be < Ve.length; be++)
          ve.features = ve.features.concat(Ke(Ve[be]));
        function Te(nt) {
          var ot, vt;
          return nt = nt || "", nt.substr(0, 1) === "#" && (nt = nt.substr(1)), (nt.length === 6 || nt.length === 3) && (ot = nt), nt.length === 8 && (vt = parseInt(nt.substr(0, 2), 16) / 255, ot = "#" + nt.substr(6, 2) + nt.substr(4, 2) + nt.substr(2, 2)), [ot, isNaN(vt) ? void 0 : vt];
        }
        function Oe(nt) {
          return O(nt.split(" "));
        }
        function $e(nt) {
          var ot = o(nt, "coord"), vt = [], mt = [];
          ot.length === 0 && (ot = o(nt, "gx:coord"));
          for (var Pt = 0; Pt < ot.length; Pt++) vt.push(Oe(z(ot[Pt])));
          for (var rt = o(nt, "when"), Y = 0; Y < rt.length; Y++) mt.push(z(rt[Y]));
          return {
            coords: vt,
            times: mt
          };
        }
        function Ue(nt) {
          var ot, vt, mt, Pt, rt, Y = [], Kt = [];
          if (L(nt, "MultiGeometry"))
            return Ue(L(nt, "MultiGeometry"));
          if (L(nt, "MultiTrack"))
            return Ue(L(nt, "MultiTrack"));
          if (L(nt, "gx:MultiTrack"))
            return Ue(L(nt, "gx:MultiTrack"));
          for (mt = 0; mt < ye.length; mt++)
            if (vt = o(nt, ye[mt]), vt) {
              for (Pt = 0; Pt < vt.length; Pt++)
                if (ot = vt[Pt], ye[mt] === "Point")
                  Y.push({
                    type: "Point",
                    coordinates: ae(z(L(ot, "coordinates")))
                  });
                else if (ye[mt] === "LineString")
                  Y.push({
                    type: "LineString",
                    coordinates: Q(z(L(ot, "coordinates")))
                  });
                else if (ye[mt] === "Polygon") {
                  var Rt = o(ot, "LinearRing"), lt = [];
                  for (rt = 0; rt < Rt.length; rt++)
                    lt.push(Q(z(L(Rt[rt], "coordinates"))));
                  Y.push({
                    type: "Polygon",
                    coordinates: lt
                  });
                } else if (ye[mt] === "Track" || ye[mt] === "gx:Track") {
                  var xt = $e(ot);
                  Y.push({
                    type: "LineString",
                    coordinates: xt.coords
                  }), xt.times.length && Kt.push(xt.times);
                }
            }
          return {
            geoms: Y,
            coordTimes: Kt
          };
        }
        function Ke(nt) {
          var ot = Ue(nt), vt, mt = {}, Pt = z(L(nt, "name")), rt = z(L(nt, "address")), Y = z(L(nt, "styleUrl")), Kt = z(L(nt, "description")), Rt = L(nt, "TimeSpan"), lt = L(nt, "TimeStamp"), xt = L(nt, "ExtendedData"), At = L(nt, "LineStyle"), Et = L(nt, "PolyStyle"), jt = L(nt, "visibility");
          if (!ot.geoms.length) return [];
          if (Pt && (mt.name = Pt), rt && (mt.address = rt), Y) {
            Y[0] !== "#" && (Y = "#" + Y), mt.styleUrl = Y, X[Y] && (mt.styleHash = X[Y]), xe[Y] && (mt.styleMapHash = xe[Y], mt.styleHash = X[xe[Y].normal]);
            var ni = re[mt.styleHash];
            if (ni) {
              At || (At = L(ni, "LineStyle")), Et || (Et = L(ni, "PolyStyle"));
              var ii = L(ni, "IconStyle");
              if (ii) {
                var yi = L(ii, "Icon");
                if (yi) {
                  var xi = z(L(yi, "href"));
                  xi && (mt.icon = xi);
                }
              }
            }
          }
          if (Kt && (mt.description = Kt), Rt) {
            var pt = z(L(Rt, "begin")), Jt = z(L(Rt, "end"));
            mt.timespan = { begin: pt, end: Jt };
          }
          if (lt && (mt.timestamp = z(L(lt, "when"))), At) {
            var si = Te(z(L(At, "color"))), It = si[0], Zi = si[1], ft = parseFloat(z(L(At, "width")));
            It && (mt.stroke = It), isNaN(Zi) || (mt["stroke-opacity"] = Zi), isNaN(ft) || (mt["stroke-width"] = ft);
          }
          if (Et) {
            var ri = Te(z(L(Et, "color"))), Lt = ri[0], Si = ri[1], Gi = z(L(Et, "fill")), zt = z(L(Et, "outline"));
            Lt && (mt.fill = Lt), isNaN(Si) || (mt["fill-opacity"] = Si), Gi && (mt["fill-opacity"] = Gi === "1" ? mt["fill-opacity"] || 1 : 0), zt && (mt["stroke-opacity"] = zt === "1" ? mt["stroke-opacity"] || 1 : 0);
          }
          if (xt) {
            var cr = o(xt, "Data"), Ni = o(xt, "SimpleData");
            for (vt = 0; vt < cr.length; vt++)
              mt[cr[vt].getAttribute("name")] = z(L(cr[vt], "value"));
            for (vt = 0; vt < Ni.length; vt++)
              mt[Ni[vt].getAttribute("name")] = z(Ni[vt]);
          }
          jt && (mt.visibility = z(jt)), ot.coordTimes.length && (mt.coordTimes = ot.coordTimes.length === 1 ? ot.coordTimes[0] : ot.coordTimes);
          var ie = {
            type: "Feature",
            geometry: ot.geoms.length === 1 ? ot.geoms[0] : {
              type: "GeometryCollection",
              geometries: ot.geoms
            },
            properties: mt
          };
          return k(nt, "id") && (ie.id = k(nt, "id")), [ie];
        }
        return ve;
      },
      gpx: function(me) {
        var ve, X = o(me, "trk"), re = o(me, "rte"), xe = o(me, "wpt"), ye = Ce(), Ve;
        for (ve = 0; ve < X.length; ve++)
          Ve = qe(X[ve]), Ve && ye.features.push(Ve);
        for (ve = 0; ve < re.length; ve++)
          Ve = Je(re[ve]), Ve && ye.features.push(Ve);
        for (ve = 0; ve < xe.length; ve++)
          ye.features.push(et(xe[ve]));
        function He(_e, be) {
          for (var Te = 0; Te < be; Te++)
            _e.push(null);
          return _e;
        }
        function Ze(_e, be) {
          var Te = o(_e, be), Oe = [], $e = [], Ue = [], Ke = Te.length;
          if (Ke < 2) return {};
          for (var nt = 0; nt < Ke; nt++) {
            var ot = fe(Te[nt]);
            Oe.push(ot.coordinates), ot.time && $e.push(ot.time), (ot.heartRate || Ue.length) && (Ue.length || He(Ue, nt), Ue.push(ot.heartRate || null));
          }
          return {
            line: Oe,
            times: $e,
            heartRates: Ue
          };
        }
        function qe(_e) {
          for (var be = o(_e, "trkseg"), Te = [], Oe = [], $e = [], Ue, Ke = 0; Ke < be.length; Ke++)
            if (Ue = Ze(be[Ke], "trkpt"), Ue && (Ue.line && Te.push(Ue.line), Ue.times && Ue.times.length && Oe.push(Ue.times), $e.length || Ue.heartRates && Ue.heartRates.length)) {
              if (!$e.length)
                for (var nt = 0; nt < Ke; nt++)
                  $e.push(He([], Te[nt].length));
              Ue.heartRates && Ue.heartRates.length ? $e.push(Ue.heartRates) : $e.push(He([], Ue.line.length || 0));
            }
          if (Te.length !== 0) {
            var ot = ee(_e);
            return oe(ot, st(L(_e, "extensions"))), Oe.length && (ot.coordTimes = Te.length === 1 ? Oe[0] : Oe), $e.length && (ot.heartRates = Te.length === 1 ? $e[0] : $e), {
              type: "Feature",
              properties: ot,
              geometry: {
                type: Te.length === 1 ? "LineString" : "MultiLineString",
                coordinates: Te.length === 1 ? Te[0] : Te
              }
            };
          }
        }
        function Je(_e) {
          var be = Ze(_e, "rtept");
          if (be.line) {
            var Te = ee(_e);
            oe(Te, st(L(_e, "extensions")));
            var Oe = {
              type: "Feature",
              properties: Te,
              geometry: {
                type: "LineString",
                coordinates: be.line
              }
            };
            return Oe;
          }
        }
        function et(_e) {
          var be = ee(_e);
          return oe(be, pe(_e, ["sym"])), {
            type: "Feature",
            properties: be,
            geometry: {
              type: "Point",
              coordinates: fe(_e).coordinates
            }
          };
        }
        function st(_e) {
          var be = {};
          if (_e) {
            var Te = L(_e, "line");
            if (Te) {
              var Oe = z(L(Te, "color")), $e = parseFloat(z(L(Te, "opacity"))), Ue = parseFloat(z(L(Te, "width")));
              Oe && (be.stroke = Oe), isNaN($e) || (be["stroke-opacity"] = $e), isNaN(Ue) || (be["stroke-width"] = Ue * 96 / 25.4);
            }
          }
          return be;
        }
        function ee(_e) {
          var be = pe(_e, ["name", "cmt", "desc", "type", "time", "keywords"]), Te = o(_e, "link");
          Te.length && (be.links = []);
          for (var Oe = 0, $e; Oe < Te.length; Oe++)
            $e = { href: k(Te[Oe], "href") }, oe($e, pe(Te[Oe], ["text", "type"])), be.links.push($e);
          return be;
        }
        return ye;
      }
    };
    return Ae;
  }();
  s.exports = a;
})(y1);
var Mx = y1.exports;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function Np(s, l, a, m) {
  return new (a || (a = Promise))(function(y, _) {
    function g(D) {
      try {
        k(m.next(D));
      } catch (L) {
        _(L);
      }
    }
    function o(D) {
      try {
        k(m.throw(D));
      } catch (L) {
        _(L);
      }
    }
    function k(D) {
      D.done ? y(D.value) : new a(function(L) {
        L(D.value);
      }).then(g, o);
    }
    k((m = m.apply(s, l || [])).next());
  });
}
var uh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Sd(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var b1 = zx, Nx = Object.prototype.hasOwnProperty;
function zx() {
  for (var s = {}, l = 0; l < arguments.length; l++) {
    var a = arguments[l];
    for (var m in a)
      Nx.call(a, m) && (s[m] = a[m]);
  }
  return s;
}
var to = /* @__PURE__ */ Sd(b1), x1 = { exports: {} };
(function(s, l) {
  (function() {
    var a = {};
    s.exports = a, a.simpleFilter = function(m, y) {
      return y.filter(function(_) {
        return a.test(m, _);
      });
    }, a.test = function(m, y) {
      return a.match(m, y) !== null;
    }, a.match = function(m, y, _) {
      _ = _ || {};
      var g = 0, o = [], k = y.length, D = 0, L = 0, j = _.pre || "", O = _.post || "", z = _.caseSensitive && y || y.toLowerCase(), pe;
      m = _.caseSensitive && m || m.toLowerCase();
      for (var oe = 0; oe < k; oe++)
        pe = y[oe], z[oe] === m[g] ? (pe = j + pe + O, g += 1, L += 1 + L) : L = 0, D += L, o[o.length] = pe;
      return g === m.length ? (D = z === m ? 1 / 0 : D, { rendered: o.join(""), score: D }) : null;
    }, a.filter = function(m, y, _) {
      return !y || y.length === 0 ? [] : typeof m != "string" ? y : (_ = _ || {}, y.reduce(function(g, o, k, D) {
        var L = o;
        _.extract && (L = _.extract(o));
        var j = a.match(m, L, _);
        return j != null && (g[g.length] = {
          string: j.rendered,
          score: j.score,
          index: k,
          original: o
        }), g;
      }, []).sort(function(g, o) {
        var k = o.score - g.score;
        return k || g.index - o.index;
      }));
    };
  })();
})(x1);
var Fx = x1.exports, Us = function(s) {
  return this.component = s, this.items = [], this.active = s.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, s.el.parentNode.insertBefore(this.wrapper, s.el.nextSibling), this;
};
Us.prototype.show = function() {
  this.element.style.display = "block";
};
Us.prototype.hide = function() {
  this.element.style.display = "none";
};
Us.prototype.add = function(s) {
  this.items.push(s);
};
Us.prototype.clear = function() {
  this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
};
Us.prototype.isEmpty = function() {
  return !this.items.length;
};
Us.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
Us.prototype.draw = function() {
  if (this.element.innerHTML = "", this.items.length === 0) {
    this.hide();
    return;
  }
  for (var s = 0; s < this.items.length; s++)
    this.drawItem(this.items[s], this.active === s);
  this.show();
};
Us.prototype.drawItem = function(s, l) {
  var a = document.createElement("li"), m = document.createElement("a");
  l && (a.className += " active"), m.innerHTML = s.string, a.appendChild(m), this.element.appendChild(a), a.addEventListener("mousedown", (function() {
    this.selectingListItem = !0;
  }).bind(this)), a.addEventListener("mouseup", (function() {
    this.handleMouseUp.call(this, s);
  }).bind(this));
};
Us.prototype.handleMouseUp = function(s) {
  this.selectingListItem = !1, this.component.value(s.original), this.clear(), this.draw();
};
Us.prototype.move = function(s) {
  this.active = s, this.draw();
};
Us.prototype.previous = function() {
  this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
};
Us.prototype.next = function() {
  this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
};
Us.prototype.drawError = function(s) {
  var l = document.createElement("li");
  l.innerHTML = s, this.element.appendChild(l), this.show();
};
var Bx = Us, Rx = b1, Ox = Fx, jx = Bx, ss = function(s, l, a) {
  return a = a || {}, this.options = Rx({
    minLength: 2,
    limit: 5,
    filter: !0,
    hideOnBlur: !0,
    noInitialSelection: !0
  }, a), this.el = s, this.data = l || [], this.list = new jx(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(m) {
    this.handleKeyUp(m.keyCode, m);
  }).bind(this), !1), this.el.addEventListener("keydown", (function(m) {
    this.handleKeyDown(m);
  }).bind(this)), this.el.addEventListener("focus", (function() {
    this.handleFocus();
  }).bind(this)), this.el.addEventListener("blur", (function() {
    this.handleBlur();
  }).bind(this)), this.el.addEventListener("paste", (function(m) {
    this.handlePaste(m);
  }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
};
ss.prototype.handleKeyUp = function(s, l) {
  if (!(s === 40 || s === 38 || s === 27 || s === 9)) {
    if (s === 13) {
      this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), l.stopPropagation());
      return;
    }
    this.handleInputChange(this.el.value);
  }
};
ss.prototype.handleKeyDown = function(s) {
  switch (s.keyCode) {
    case 13:
      this.list.active >= 0 && (this.list.selectingListItem = !0);
      break;
    case 9:
      this.list.isEmpty() || (this.list.isVisible() && s.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
      break;
    case 27:
      this.list.isEmpty() || this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
ss.prototype.handleBlur = function() {
  !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
};
ss.prototype.handlePaste = function(s) {
  if (s.clipboardData)
    this.handleInputChange(s.clipboardData.getData("Text"));
  else {
    var l = this;
    setTimeout(function() {
      l.handleInputChange(s.target.value);
    }, 100);
  }
};
ss.prototype.handleInputChange = function(s) {
  if (this.query = this.normalize(s), this.list.clear(), this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates((function(l) {
    for (var a = 0; a < l.length && (this.list.add(l[a]), a !== this.options.limit - 1); a++)
      ;
    this.list.draw();
  }).bind(this));
};
ss.prototype.handleFocus = function() {
  this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
};
ss.prototype.update = function(s) {
  this.data = s, this.handleKeyUp();
};
ss.prototype.clear = function() {
  this.data = [], this.list.clear();
};
ss.prototype.normalize = function(s) {
  return s = s.toLowerCase(), s;
};
ss.prototype.match = function(s, l) {
  return s.indexOf(l) > -1;
};
ss.prototype.value = function(s) {
  if (this.selected = s, this.el.value = this.getItemValue(s || { place_name: this.query }), document.createEvent) {
    var l = document.createEvent("HTMLEvents");
    l.initEvent("change", !0, !1), this.el.dispatchEvent(l);
  } else
    this.el.fireEvent("onchange");
};
ss.prototype.getCandidates = function(s) {
  var l = {
    pre: "<strong>",
    post: "</strong>",
    extract: (function(m) {
      return this.getItemValue(m);
    }).bind(this)
  }, a;
  this.options.filter ? (a = Ox.filter(this.query, this.data, l), a = a.map((function(m) {
    return {
      original: m.original,
      string: this.render(m.original, m.string)
    };
  }).bind(this))) : a = this.data.map((function(m) {
    var y = this.render(m);
    return {
      original: m,
      string: y
    };
  }).bind(this)), s(a);
};
ss.prototype.getItemValue = function(s) {
  return s;
};
ss.prototype.render = function(s, l) {
  if (l)
    return l;
  for (var a = s.original ? this.getItemValue(s.original) : this.getItemValue(s), m = this.normalize(a), y = m.lastIndexOf(this.query); y > -1; ) {
    var _ = y + this.query.length;
    a = a.slice(0, y) + "<strong>" + a.slice(y, _) + "</strong>" + a.slice(_), y = m.slice(0, y).lastIndexOf(this.query);
  }
  return a;
};
ss.prototype.renderError = function(s) {
  this.list.drawError(s);
};
var qx = ss, w1 = qx, Ux = w1;
typeof window < "u" && (window.Suggestions = w1);
var Vx = /* @__PURE__ */ Sd(Ux), A1 = { exports: {} };
(function(s) {
  (function(l, a, m) {
    s.exports ? s.exports = m() : l[a] = m();
  })(uh, "subtag", function() {
    var l = "", a = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function m(k) {
      return k.match(a) || [];
    }
    function y(k) {
      return m(k).filter(function(D, L) {
        return D && L;
      });
    }
    function _(k) {
      return k = m(k), {
        language: k[1] || l,
        extlang: k[2] || l,
        script: k[3] || l,
        region: k[4] || l
      };
    }
    function g(k, D, L) {
      Object.defineProperty(k, D, {
        value: L,
        enumerable: !0
      });
    }
    function o(k, D, L) {
      function j(O) {
        return m(O)[k] || l;
      }
      g(j, "pattern", D), g(_, L, j);
    }
    return o(1, /^[a-zA-Z]{2,3}$/, "language"), o(2, /^[a-zA-Z]{3}$/, "extlang"), o(3, /^[a-zA-Z]{4}$/, "script"), o(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), g(_, "split", y), _;
  });
})(A1);
var $x = A1.exports, Zx = /* @__PURE__ */ Sd($x), Gx = "Expected a function", h0 = NaN, Hx = "[object Symbol]", Wx = /^\s+|\s+$/g, Xx = /^[-+]0x[0-9a-f]+$/i, Yx = /^0b[01]+$/i, Jx = /^0o[0-7]+$/i, Kx = parseInt, Qx = typeof uh == "object" && uh && uh.Object === Object && uh, ew = typeof self == "object" && self && self.Object === Object && self, tw = Qx || ew || Function("return this")(), iw = Object.prototype, rw = iw.toString, nw = Math.max, sw = Math.min, zp = function() {
  return tw.Date.now();
};
function aw(s, l, a) {
  var m, y, _, g, o, k, D = 0, L = !1, j = !1, O = !0;
  if (typeof s != "function")
    throw new TypeError(Gx);
  l = d0(l) || 0, lf(a) && (L = !!a.leading, j = "maxWait" in a, _ = j ? nw(d0(a.maxWait) || 0, l) : _, O = "trailing" in a ? !!a.trailing : O);
  function z(Qe) {
    var ke = m, Ae = y;
    return m = y = void 0, D = Qe, g = s.apply(Ae, ke), g;
  }
  function pe(Qe) {
    return D = Qe, o = setTimeout(Q, l), L ? z(Qe) : g;
  }
  function oe(Qe) {
    var ke = Qe - k, Ae = Qe - D, me = l - ke;
    return j ? sw(me, _ - Ae) : me;
  }
  function ae(Qe) {
    var ke = Qe - k, Ae = Qe - D;
    return k === void 0 || ke >= l || ke < 0 || j && Ae >= _;
  }
  function Q() {
    var Qe = zp();
    if (ae(Qe))
      return fe(Qe);
    o = setTimeout(Q, oe(Qe));
  }
  function fe(Qe) {
    return o = void 0, O && m ? z(Qe) : (m = y = void 0, g);
  }
  function Ce() {
    o !== void 0 && clearTimeout(o), D = 0, m = k = y = o = void 0;
  }
  function ze() {
    return o === void 0 ? g : fe(zp());
  }
  function je() {
    var Qe = zp(), ke = ae(Qe);
    if (m = arguments, y = this, k = Qe, ke) {
      if (o === void 0)
        return pe(k);
      if (j)
        return o = setTimeout(Q, l), z(k);
    }
    return o === void 0 && (o = setTimeout(Q, l)), g;
  }
  return je.cancel = Ce, je.flush = ze, je;
}
function lf(s) {
  var l = typeof s;
  return !!s && (l == "object" || l == "function");
}
function ow(s) {
  return !!s && typeof s == "object";
}
function lw(s) {
  return typeof s == "symbol" || ow(s) && rw.call(s) == Hx;
}
function d0(s) {
  if (typeof s == "number")
    return s;
  if (lw(s))
    return h0;
  if (lf(s)) {
    var l = typeof s.valueOf == "function" ? s.valueOf() : s;
    s = lf(l) ? l + "" : l;
  }
  if (typeof s != "string")
    return s === 0 ? s : +s;
  s = s.replace(Wx, "");
  var a = Yx.test(s);
  return a || Jx.test(s) ? Kx(s.slice(2), a ? 2 : 8) : Xx.test(s) ? h0 : +s;
}
var uw = aw, cw = /* @__PURE__ */ Sd(uw), vf = { exports: {} }, xc = typeof Reflect == "object" ? Reflect : null, p0 = xc && typeof xc.apply == "function" ? xc.apply : function(l, a, m) {
  return Function.prototype.apply.call(l, a, m);
}, ld;
xc && typeof xc.ownKeys == "function" ? ld = xc.ownKeys : Object.getOwnPropertySymbols ? ld = function(l) {
  return Object.getOwnPropertyNames(l).concat(Object.getOwnPropertySymbols(l));
} : ld = function(l) {
  return Object.getOwnPropertyNames(l);
};
function hw(s) {
  console && console.warn && console.warn(s);
}
var S1 = Number.isNaN || function(l) {
  return l !== l;
};
function mr() {
  mr.init.call(this);
}
vf.exports = mr;
vf.exports.once = mw;
mr.EventEmitter = mr;
mr.prototype._events = void 0;
mr.prototype._eventsCount = 0;
mr.prototype._maxListeners = void 0;
var f0 = 10;
function Ed(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(mr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return f0;
  },
  set: function(s) {
    if (typeof s != "number" || s < 0 || S1(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    f0 = s;
  }
});
mr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
mr.prototype.setMaxListeners = function(l) {
  if (typeof l != "number" || l < 0 || S1(l))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + l + ".");
  return this._maxListeners = l, this;
};
function E1(s) {
  return s._maxListeners === void 0 ? mr.defaultMaxListeners : s._maxListeners;
}
mr.prototype.getMaxListeners = function() {
  return E1(this);
};
mr.prototype.emit = function(l) {
  for (var a = [], m = 1; m < arguments.length; m++) a.push(arguments[m]);
  var y = l === "error", _ = this._events;
  if (_ !== void 0)
    y = y && _.error === void 0;
  else if (!y)
    return !1;
  if (y) {
    var g;
    if (a.length > 0 && (g = a[0]), g instanceof Error)
      throw g;
    var o = new Error("Unhandled error." + (g ? " (" + g.message + ")" : ""));
    throw o.context = g, o;
  }
  var k = _[l];
  if (k === void 0)
    return !1;
  if (typeof k == "function")
    p0(k, this, a);
  else
    for (var D = k.length, L = I1(k, D), m = 0; m < D; ++m)
      p0(L[m], this, a);
  return !0;
};
function C1(s, l, a, m) {
  var y, _, g;
  if (Ed(a), _ = s._events, _ === void 0 ? (_ = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (_.newListener !== void 0 && (s.emit(
    "newListener",
    l,
    a.listener ? a.listener : a
  ), _ = s._events), g = _[l]), g === void 0)
    g = _[l] = a, ++s._eventsCount;
  else if (typeof g == "function" ? g = _[l] = m ? [a, g] : [g, a] : m ? g.unshift(a) : g.push(a), y = E1(s), y > 0 && g.length > y && !g.warned) {
    g.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + g.length + " " + String(l) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = s, o.type = l, o.count = g.length, hw(o);
  }
  return s;
}
mr.prototype.addListener = function(l, a) {
  return C1(this, l, a, !1);
};
mr.prototype.on = mr.prototype.addListener;
mr.prototype.prependListener = function(l, a) {
  return C1(this, l, a, !0);
};
function dw() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function T1(s, l, a) {
  var m = { fired: !1, wrapFn: void 0, target: s, type: l, listener: a }, y = dw.bind(m);
  return y.listener = a, m.wrapFn = y, y;
}
mr.prototype.once = function(l, a) {
  return Ed(a), this.on(l, T1(this, l, a)), this;
};
mr.prototype.prependOnceListener = function(l, a) {
  return Ed(a), this.prependListener(l, T1(this, l, a)), this;
};
mr.prototype.removeListener = function(l, a) {
  var m, y, _, g, o;
  if (Ed(a), y = this._events, y === void 0)
    return this;
  if (m = y[l], m === void 0)
    return this;
  if (m === a || m.listener === a)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete y[l], y.removeListener && this.emit("removeListener", l, m.listener || a));
  else if (typeof m != "function") {
    for (_ = -1, g = m.length - 1; g >= 0; g--)
      if (m[g] === a || m[g].listener === a) {
        o = m[g].listener, _ = g;
        break;
      }
    if (_ < 0)
      return this;
    _ === 0 ? m.shift() : pw(m, _), m.length === 1 && (y[l] = m[0]), y.removeListener !== void 0 && this.emit("removeListener", l, o || a);
  }
  return this;
};
mr.prototype.off = mr.prototype.removeListener;
mr.prototype.removeAllListeners = function(l) {
  var a, m, y;
  if (m = this._events, m === void 0)
    return this;
  if (m.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : m[l] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete m[l]), this;
  if (arguments.length === 0) {
    var _ = Object.keys(m), g;
    for (y = 0; y < _.length; ++y)
      g = _[y], g !== "removeListener" && this.removeAllListeners(g);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (a = m[l], typeof a == "function")
    this.removeListener(l, a);
  else if (a !== void 0)
    for (y = a.length - 1; y >= 0; y--)
      this.removeListener(l, a[y]);
  return this;
};
function k1(s, l, a) {
  var m = s._events;
  if (m === void 0)
    return [];
  var y = m[l];
  return y === void 0 ? [] : typeof y == "function" ? a ? [y.listener || y] : [y] : a ? fw(y) : I1(y, y.length);
}
mr.prototype.listeners = function(l) {
  return k1(this, l, !0);
};
mr.prototype.rawListeners = function(l) {
  return k1(this, l, !1);
};
mr.listenerCount = function(s, l) {
  return typeof s.listenerCount == "function" ? s.listenerCount(l) : D1.call(s, l);
};
mr.prototype.listenerCount = D1;
function D1(s) {
  var l = this._events;
  if (l !== void 0) {
    var a = l[s];
    if (typeof a == "function")
      return 1;
    if (a !== void 0)
      return a.length;
  }
  return 0;
}
mr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ld(this._events) : [];
};
function I1(s, l) {
  for (var a = new Array(l), m = 0; m < l; ++m)
    a[m] = s[m];
  return a;
}
function pw(s, l) {
  for (; l + 1 < s.length; l++)
    s[l] = s[l + 1];
  s.pop();
}
function fw(s) {
  for (var l = new Array(s.length), a = 0; a < l.length; ++a)
    l[a] = s[a].listener || s[a];
  return l;
}
function mw(s, l) {
  return new Promise(function(a, m) {
    function y(g) {
      s.removeListener(l, _), m(g);
    }
    function _() {
      typeof s.removeListener == "function" && s.removeListener("error", y), a([].slice.call(arguments));
    }
    P1(s, l, _, { once: !0 }), l !== "error" && gw(s, y, { once: !0 });
  });
}
function gw(s, l, a) {
  typeof s.on == "function" && P1(s, "error", l, a);
}
function P1(s, l, a, m) {
  if (typeof s.on == "function")
    m.once ? s.once(l, a) : s.on(l, a);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(l, function y(_) {
      m.once && s.removeEventListener(l, y), a(_);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var _w = vf.exports;
const m0 = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, yw = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "",
  //hebrew
  ja: "",
  //japanese
  lv: "Meklt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "",
  //serbian
  zh: "",
  //chinese-simplified
  cs: "Vyhledvn",
  //czech
  hu: "Keress",
  //hungarian
  ka: "",
  // georgian
  nb: "Ske",
  //norwegian
  sk: "Vyhadvanie",
  //slovak
  th: "",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "",
  //persian(aka farsi)
  ru: ""
  //russian
}, vw = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class bw {
  constructor(l, a) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      getItemValue: (m) => m.text !== void 0 ? m.text : m.place_name,
      render: function(m) {
        if (!m.geometry) {
          const _ = m.text, g = _.toLowerCase().indexOf(this.query.toLowerCase()), o = this.query.length, k = _.substring(0, g), D = _.substring(g, g + o), L = _.substring(g + o);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + k + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + D + "</span>" + L + "</div></div></div>";
        }
        const y = m.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + y[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + y.splice(1, y.length).join(",") + "</div></div></div>";
      },
      popupRender: (m) => {
        const y = m.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + y[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + y.splice(1, y.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new _w.EventEmitter(), this.options = to({}, this.options, a), this.fresh = !0, this.lastSelected = null, this.geocoderApi = l;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(l) {
    function a(m, y) {
      if (!document.body.contains(y))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const _ = m.onAdd();
      y.appendChild(_);
    }
    if (l instanceof HTMLElement)
      a(this, l);
    else if (typeof l == "string") {
      const m = document.querySelectorAll(l);
      if (m.length === 0)
        throw new Error("Element " + l + "not found.");
      if (m.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      a(this, m[0]);
    } else if ("addControl" in l)
      l.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(l) {
    if (l && typeof l != "string" && (this._map = l), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const a = this.container = document.createElement("div");
    a.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const m = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", cw(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const y = document.createElement("div");
    y.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const _ = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(_), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), y.appendChild(this._clearEl), y.appendChild(this._loadingEl), a.appendChild(m), a.appendChild(this._inputEl), a.appendChild(y), this._typeahead = new Vx(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), a;
  }
  createIcon(l, a) {
    const m = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (m.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + l), m.setAttribute("viewBox", "0 0 18 18"), m.setAttribute("xml:space", "preserve"), m.setAttribute("width", "18"), m.setAttribute("height", "18"), "innerHTML" in m)
      m.innerHTML = a;
    else {
      const y = document.createElement("div");
      y.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>";
      const _ = y.firstChild, g = _.firstChild;
      m.appendChild(g);
    }
    return m;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(l) {
    const a = (l.clipboardData || window.clipboardData).getData("text");
    a.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(a);
  }
  _onKeyDown(l) {
    if (l.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(l), this._inputEl.blur();
    const _ = l.target && l.target.shadowRoot ? l.target.shadowRoot.activeElement : l.target;
    if (!(_ ? _.value : ""))
      return this.fresh = !0, l.keyCode !== 9 && this.clear(l), this._clearEl.style.display = "none";
    if (!(l.metaKey || [9, 27, 37, 39, 38, 40].indexOf(l.keyCode) !== -1)) {
      if (l.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(_.value);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(_.value, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      _.value.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(_.value);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(l) {
    this.options.clearOnBlur && this._clearOnBlur(l), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const l = this._typeahead.selected;
    if (l && !l.geometry)
      l.placeId ? this._geocode(l.placeId, !0, !0) : this._geocode(l.text, !0);
    else if (l && JSON.stringify(l) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let a;
        if (this._removeResultMarkers(), l.properties && m0[l.properties.short_code])
          a = to({}, this.options.flyTo), this._map && this._map.fitBounds(m0[l.properties.short_code].bbox, a);
        else if (l.bbox) {
          const m = l.bbox;
          a = to({}, this.options.flyTo), this._map && this._map.fitBounds([
            [m[0], m[1]],
            [m[2], m[3]]
          ], a);
        } else {
          const m = {
            zoom: this.options.zoom
          };
          a = to({}, m, this.options.flyTo), l.center ? a.center = l.center : l.geometry && l.geometry.type && l.geometry.type === "Point" && l.geometry.coordinates && (a.center = l.geometry.coordinates), this._map && this._map.flyTo(a);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(l), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(l), this._typeahead.selected = null, this._eventEmitter.emit("result", { result: l });
    }
  }
  _getConfigForRequest() {
    return [
      "bbox",
      "limit",
      "proximity",
      "countries",
      "types",
      "language",
      "reverseMode"
    ].reduce((m, y) => (this.options[y] && (["countries", "types", "language"].indexOf(y) > -1 ? m[y] = this.options[y].split(/[\s,]+/) : m[y] = this.options[y], y === "proximity" && this.options[y] && typeof this.options[y].longitude == "number" && typeof this.options[y].latitude == "number" && (m[y] = [
      this.options[y].longitude,
      this.options[y].latitude
    ])), m), {});
  }
  _geocode(l) {
    return Np(this, arguments, void 0, function* (a, m = !1, y = !1) {
      this._loadingEl.style.display = "block", this._eventEmitter.emit("loading", { query: a });
      const _ = this._getConfigForRequest(), g = this._createGeocodeRequest(_, a, m, y), o = this.options.localGeocoder ? this.options.localGeocoder(a) || [] : [];
      try {
        const k = yield g;
        yield this._handleGeocodeResponse(k, _, a, m, o);
      } catch (k) {
        this._handleGeocodeErrorResponse(k, o);
      }
      return g;
    });
  }
  _createGeocodeRequest(l, a, m, y) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && vw.test(a) ? this._createReverseGeocodeRequest(a, l) : (l.query = a, this.geocoderApi.getSuggestions ? m ? this.geocoderApi.searchByPlaceId && y ? this.geocoderApi.searchByPlaceId(l) : this.geocoderApi.forwardGeocode(l) : this.geocoderApi.getSuggestions(l) : this.geocoderApi.forwardGeocode(l));
  }
  _createReverseGeocodeRequest(l, a) {
    const m = l.split(/[\s(,)?]+/).map((y) => parseFloat(y)).reverse();
    return a.query = m, a.limit = 1, "proximity" in a && delete a.proximity, this.geocoderApi.reverseGeocode(a);
  }
  _handleGeocodeResponse(l, a, m, y, _) {
    return Np(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let g = {};
      l ? g = l : g = {
        type: "FeatureCollection",
        features: []
      }, g.config = a, this.fresh && (this.fresh = !1), g.features = g.features ? _.concat(g.features) : _;
      const o = this.options.externalGeocoder ? this.options.externalGeocoder(m, g.features, a) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const D = yield o;
        g.features = g.features ? D.concat(g.features) : D;
      } catch {
      }
      this.options.filter && g.features.length && (g.features = g.features.filter(this.options.filter));
      let k = [];
      "suggestions" in g ? k = g.suggestions : "place" in g ? k = [g.place] : k = g.features, k.length ? (this._clearEl.style.display = "block", this._typeahead.update(k), (!this.options.showResultsWhileTyping || y) && this.options.showResultMarkers && (g.features.length > 0 || "place" in g) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", g)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", g));
    });
  }
  _handleGeocodeErrorResponse(l, a) {
    this._loadingEl.style.display = "none", a.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(a)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", { features: a }), this._eventEmitter.emit("error", { error: l });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(l) {
    l && l.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(l) {
    this._clear(l), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(l) {
    l.relatedTarget && this._clear(l);
  }
  _onQueryResult(l) {
    if (!("features" in l) || !l.features.length)
      return;
    const a = l.features[0];
    this._typeahead.selected = a, this._inputEl.value = a.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > 9) {
        const l = this._map.getCenter().wrap();
        this.setProximity({ longitude: l.lng, latitude: l.lat });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(l) {
    return Np(this, void 0, void 0, function* () {
      const a = yield this._geocode(l);
      this._onQueryResult(a);
    });
  }
  _renderError() {
    this._renderMessage("<div class='maplibre-gl-geocoder--error'>There was an error reaching the server</div>");
  }
  _renderNoResults() {
    this._renderMessage("<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>");
  }
  _renderMessage(l) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(l);
  }
  /**
   * Get the text to use as the search bar placeholder
   *
   * If placeholder is provided in options, then use options.placeholder
   * Otherwise, if language is provided in options, then use the localized string of the first language if available
   * Otherwise use the default
   *
   * @returns the value to use as the search bar placeholder
   */
  _getPlaceholderText() {
    if (this.options.placeholder)
      return this.options.placeholder;
    if (this.options.language) {
      const l = this.options.language.split(",")[0], a = Zx.language(l), m = yw[a];
      if (m)
        return m;
    }
    return "Search";
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1)
      return;
    const l = this._typeahead.data.filter((a) => typeof a != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const m = to({}, { padding: 100 }, this.options.flyTo), y = new this._maplibregl.LngLatBounds();
      for (const _ of l)
        y.extend(_.geometry.coordinates);
      this._map.fitBounds(y, m);
    }
    return l.length > 0 && this._maplibregl && this._handleResultMarkers(l), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(l) {
    return this._inputEl.value = l, this._typeahead.selected = null, this._typeahead.clear(), l.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(l), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(l) {
    return this.options.proximity = l, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(l) {
    return l && typeof l == "function" && (this._typeahead.render = l), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(l) {
    return this.options.language = l || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(l) {
    return this.options.zoom = l, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(l) {
    return this.options.flyTo = l, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(l) {
    return this.placeholder = l || this._getPlaceholderText(), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(l) {
    return this.options.bbox = l, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(l) {
    return this.options.countries = l, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(l) {
    return this.options.types = l, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(l) {
    return this.options.minLength = l, this._typeahead && (this._typeahead.options.minLength = l), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(l) {
    return this.options.limit = l, this._typeahead && (this._typeahead.options.limit = l), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(l) {
    return this.options.filter = l, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(l) {
    return this.geocoderApi = l, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(l) {
    if (!this._map)
      return;
    this._removeMarker();
    const m = to({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(m);
    let y;
    if (this.options.popup) {
      const g = to({}, {}, this.options.popup);
      y = new this._maplibregl.Popup(g).setHTML(this.options.popupRender(l));
    }
    return l.center ? (this.mapMarker.setLngLat(l.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(y)) : l.geometry && l.geometry.type && l.geometry.type === "Point" && l.geometry.coordinates && (this.mapMarker.setLngLat(l.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(y)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(l) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let m = to({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const y of l) {
      let _;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (_ = this.options.showResultMarkers.element.cloneNode(!0), m = to(m, { element: _ }));
        const g = new this._maplibregl.Marker(to({}, m, { element: _ }));
        let o;
        if (this.options.popup) {
          const D = to({}, {}, this.options.popup);
          o = new this._maplibregl.Popup(D).setHTML(this.options.popupRender(y));
        }
        y.center ? (g.setLngLat(y.center).addTo(this._map), this.options.popup && g.setPopup(o)) : y.geometry && y.geometry.type && y.geometry.type === "Point" && y.geometry.coordinates && (g.setLngLat(y.geometry.coordinates).addTo(this._map), this.options.popup && g.setPopup(o)), this.resultMarkers.push(g);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(l) {
      l.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(l, a) {
    return this._eventEmitter.on(l, a), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(l) {
    return new Promise((a) => {
      this._eventEmitter.once(l, a);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(l, a) {
    return this._eventEmitter.removeListener(l, a), this;
  }
}
const xw = hb(Ru.addProtocol, {
  tileUrl: "https://tiles.gsj.jp/tiles/elev/mixed/{z}/{y}/{x}.png",
  maxzoom: 17,
  attribution: '<a href="https://gbank.gsj.jp/seamless/elev/"></a>'
}), Rs = new Ru.Map({
  container: "map",
  center: [139.767125, 35.681236],
  zoom: 10,
  pitch: 70,
  maplibreLogo: !0,
  style: {
    version: 8,
    sources: {
      terrain: xw,
      pale: {
        type: "raster",
        tiles: ["https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png"],
        tileSize: 256,
        attribution: "(https://maps.gsi.go.jp/development/ichiran.html)"
      },
      photo: {
        type: "raster",
        tiles: ["https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg"],
        tileSize: 256,
        attribution: "(https://maps.gsi.go.jp/development/ichiran.html)"
      }
    },
    terrain: {
      source: "terrain",
      exaggeration: 1.2
    },
    layers: [
      {
        id: "pale",
        type: "raster",
        source: "pale",
        layout: {
          visibility: "none"
        }
      },
      {
        id: "photo",
        type: "raster",
        source: "photo"
      }
    ]
  }
  // style: 'https://gsi-cyberjapan.github.io/gsivectortile-mapbox-gl-js/std.json',
});
Rs.addControl(
  new Ru.NavigationControl({
    visualizePitch: !0,
    showZoom: !0,
    showCompass: !0
  }),
  "bottom-right"
);
Rs.addControl(
  new Ru.ScaleControl()
);
Rs.addControl(
  new bw({
    forwardGeocode: async (s) => {
      const l = s.query, a = await fetch(
        `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(l)}`
      );
      return a.ok ? {
        features: (await a.json()).map(({ geometry: { coordinates: _ }, properties: g }) => ({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: _
          },
          place_name: g.title,
          center: _
        }))
      } : {};
    }
  }, {
    maplibregl: Ru.maplibregl,
    marker: !1,
    showResultsWhileTyping: !0,
    placeholder: "",
    reverseGeocode: !0
  }),
  "top-right"
);
Rs.addControl(
  new Ru.TerrainControl({
    source: "terrain",
    exaggeration: 1
  })
);
const ww = new kx({
  PageSize: Nu.A4,
  PageOrientation: lh.Landscape,
  Format: Dl.PNG,
  DPI: Wp[400],
  Crosshair: !1,
  PrintableArea: !0,
  Local: "ja",
  Filename: "terrain"
});
Rs.addControl(ww, "top-right");
Rs.on("moveend", async (s) => {
  if (document.title = "mytrack3D (" + await reverseGeocoding(Rs.getCenter().lat, Rs.getCenter().lng) + ")", "URLSearchParams" in window) {
    const a = new URL(window.location);
    a.searchParams.set("lat", Rs.getCenter().lat), a.searchParams.set("lon", Rs.getCenter().lng), history.pushState(null, "", a);
  }
  const l = Math.floor(Rs.getCenter().lat * 1e3) * 1e8 + Math.floor(Rs.getCenter().lon * 1e3);
  gtag("event", "mapmove", { event_category: "mapmove", event_label: "mapmove3d", value: l });
});
function Aw(s) {
  Array.from(s.target.files).forEach((a) => {
    console.log({ file: a });
    const m = new FileReader();
    m.onload = function(y) {
      let _ = y.target.result;
      console.log({ str: _ });
      let g;
      if (a.name.endsWith(".kml")) {
        let k = new DOMParser().parseFromString(_, "text/xml");
        console.log({ kml: k }), g = Mx.kml(k);
      } else
        g = JSON.parse(_);
      console.log({ geoJSONcontent: g });
      const o = (/* @__PURE__ */ new Date()).getTime();
      Rs.addSource("uploaded" + o, {
        type: "geojson",
        data: g
      }), Rs.addLayer({
        id: "uploaded" + o,
        type: "line",
        source: "uploaded" + o,
        layout: {
          "line-join": "round",
          "line-cap": "round"
        },
        paint: {
          "line-color": "red",
          "line-width": 3
        }
      });
    }, m.readAsText(a, "UTF-8");
  });
}
document.getElementById("file").addEventListener("change", Aw, !1);
export {
  ur as p
};
